# Test for GAP FILL in normal streaming mode (without EOWC).
# This tests the StreamGapFill executor.

statement ok
SET RW_IMPLICIT_FLUSH TO true;

statement ok
CREATE TABLE gap_normal_table (
    ts TIMESTAMP,
    value DOUBLE,
    PRIMARY KEY (ts)
);

statement ok
INSERT INTO gap_normal_table VALUES
    ('2024-05-21 10:00:00', 10.0),
    ('2024-05-21 10:02:00', 12.0),
    ('2024-05-21 10:05:00', 15.0);

# Use normal streaming syntax (without EMIT ON WINDOW CLOSE)
statement ok
CREATE MATERIALIZED VIEW gap_filled_normal AS
SELECT ts, value
FROM GAP_FILL(gap_normal_table, ts, INTERVAL '1' MINUTE);

# Insert some more data
statement ok
INSERT INTO gap_normal_table VALUES
    ('2024-05-21 10:08:00', 20.0);

# Check the result - GAP_FILL uses LOCF (Last Observation Carried Forward) by default
query TR
SELECT ts, value FROM gap_filled_normal ORDER BY ts;
----
2024-05-21 10:00:00 10
2024-05-21 10:01:00 10
2024-05-21 10:02:00 12
2024-05-21 10:03:00 12
2024-05-21 10:04:00 12
2024-05-21 10:05:00 15
2024-05-21 10:06:00 15
2024-05-21 10:07:00 15
2024-05-21 10:08:00 20

# Test inserting data IN BETWEEN a gap fill span
# This should delete the old filled rows and create new filled rows
statement ok
INSERT INTO gap_normal_table VALUES
    ('2024-05-21 10:01:00', 11.0);

# Check result - filled row at 10:01 should be replaced with original data
query TR
SELECT ts, value FROM gap_filled_normal ORDER BY ts;
----
2024-05-21 10:00:00 10
2024-05-21 10:01:00 11
2024-05-21 10:02:00 12
2024-05-21 10:03:00 12
2024-05-21 10:04:00 12
2024-05-21 10:05:00 15
2024-05-21 10:06:00 15
2024-05-21 10:07:00 15
2024-05-21 10:08:00 20

# Test inserting another data point in between with gaps
statement ok
INSERT INTO gap_normal_table VALUES
    ('2024-05-21 10:04:00', 14.0);

# Check result - gaps should be refilled with the new value
query TR
SELECT ts, value FROM gap_filled_normal ORDER BY ts;
----
2024-05-21 10:00:00 10
2024-05-21 10:01:00 11
2024-05-21 10:02:00 12
2024-05-21 10:03:00 12
2024-05-21 10:04:00 14
2024-05-21 10:05:00 15
2024-05-21 10:06:00 15
2024-05-21 10:07:00 15
2024-05-21 10:08:00 20

# Test inserting data BEFORE the earliest timestamp
# This should create a new gap before the previous earliest data point
statement ok
INSERT INTO gap_normal_table VALUES
    ('2024-05-21 09:57:00', 7.0);

# Check result - new gaps should be filled before 10:00:00
query TR
SELECT ts, value FROM gap_filled_normal ORDER BY ts;
----
2024-05-21 09:57:00 7
2024-05-21 09:58:00 7
2024-05-21 09:59:00 7
2024-05-21 10:00:00 10
2024-05-21 10:01:00 11
2024-05-21 10:02:00 12
2024-05-21 10:03:00 12
2024-05-21 10:04:00 14
2024-05-21 10:05:00 15
2024-05-21 10:06:00 15
2024-05-21 10:07:00 15
2024-05-21 10:08:00 20

# Test inserting data right before earliest without gap
statement ok
INSERT INTO gap_normal_table VALUES
    ('2024-05-21 09:56:00', 6.0);

# Check result - should have exactly one filled row between 09:56 and 09:57
query TR
SELECT ts, value FROM gap_filled_normal ORDER BY ts;
----
2024-05-21 09:56:00 6
2024-05-21 09:57:00 7
2024-05-21 09:58:00 7
2024-05-21 09:59:00 7
2024-05-21 10:00:00 10
2024-05-21 10:01:00 11
2024-05-21 10:02:00 12
2024-05-21 10:03:00 12
2024-05-21 10:04:00 14
2024-05-21 10:05:00 15
2024-05-21 10:06:00 15
2024-05-21 10:07:00 15
2024-05-21 10:08:00 20

# Test with custom fill strategies
statement ok
DROP MATERIALIZED VIEW gap_filled_normal;

statement ok
CREATE MATERIALIZED VIEW gap_filled_custom AS
SELECT ts, value
FROM GAP_FILL(gap_normal_table, ts, INTERVAL '1' MINUTE, LOCF(value));

# Should have same result with explicit LOCF strategy
query TR
SELECT ts, value FROM gap_filled_custom ORDER BY ts;
----
2024-05-21 09:56:00 6
2024-05-21 09:57:00 7
2024-05-21 09:58:00 7
2024-05-21 09:59:00 7
2024-05-21 10:00:00 10
2024-05-21 10:01:00 11
2024-05-21 10:02:00 12
2024-05-21 10:03:00 12
2024-05-21 10:04:00 14
2024-05-21 10:05:00 15
2024-05-21 10:06:00 15
2024-05-21 10:07:00 15
2024-05-21 10:08:00 20

statement ok
DROP MATERIALIZED VIEW gap_filled_custom;

# Test insert behavior with INTERPOLATE strategy
statement ok
CREATE MATERIALIZED VIEW gap_filled_interpolate AS
SELECT ts, value
FROM GAP_FILL(gap_normal_table, ts, INTERVAL '1' MINUTE, INTERPOLATE(value));

# Check interpolated values
query TR
SELECT ts, value FROM gap_filled_interpolate ORDER BY ts;
----
2024-05-21 09:56:00 6
2024-05-21 09:57:00 7
2024-05-21 09:58:00 8
2024-05-21 09:59:00 9
2024-05-21 10:00:00 10
2024-05-21 10:01:00 11
2024-05-21 10:02:00 12
2024-05-21 10:03:00 13
2024-05-21 10:04:00 14
2024-05-21 10:05:00 15
2024-05-21 10:06:00 16.666666666666668
2024-05-21 10:07:00 18.333333333333336
2024-05-21 10:08:00 20

# Test insert in between with INTERPOLATE - should recalculate interpolated values
statement ok
INSERT INTO gap_normal_table VALUES
    ('2024-05-21 10:06:00', 16.0);

# Check result - interpolated values should be recalculated
query TR
SELECT ts, value FROM gap_filled_interpolate ORDER BY ts;
----
2024-05-21 09:56:00 6
2024-05-21 09:57:00 7
2024-05-21 09:58:00 8
2024-05-21 09:59:00 9
2024-05-21 10:00:00 10
2024-05-21 10:01:00 11
2024-05-21 10:02:00 12
2024-05-21 10:03:00 13
2024-05-21 10:04:00 14
2024-05-21 10:05:00 15
2024-05-21 10:06:00 16
2024-05-21 10:07:00 18
2024-05-21 10:08:00 20

# Test insert before with INTERPOLATE
statement ok
INSERT INTO gap_normal_table VALUES
    ('2024-05-21 09:54:00', 4.0);

# Check result - new interpolated values should be created before earliest
query TR
SELECT ts, value FROM gap_filled_interpolate ORDER BY ts;
----
2024-05-21 09:54:00 4
2024-05-21 09:55:00 5
2024-05-21 09:56:00 6
2024-05-21 09:57:00 7
2024-05-21 09:58:00 8
2024-05-21 09:59:00 9
2024-05-21 10:00:00 10
2024-05-21 10:01:00 11
2024-05-21 10:02:00 12
2024-05-21 10:03:00 13
2024-05-21 10:04:00 14
2024-05-21 10:05:00 15
2024-05-21 10:06:00 16
2024-05-21 10:07:00 18
2024-05-21 10:08:00 20

statement ok
DROP MATERIALIZED VIEW gap_filled_interpolate;

statement ok
DROP TABLE gap_normal_table;

# Test mixed multi-column fill strategies
# This tests using different fill strategies for different columns in the same GAP_FILL query
statement ok
CREATE TABLE gap_multi_column_table (
    ts TIMESTAMP,
    temperature DOUBLE,
    pressure DOUBLE,
    status VARCHAR,
    PRIMARY KEY (ts)
);

statement ok
INSERT INTO gap_multi_column_table VALUES
    ('2024-05-21 10:00:00', 20.0, 100.0, 'active'),
    ('2024-05-21 10:04:00', 24.0, 120.0, 'inactive');

# Create MV with mixed strategies:
# - temperature: INTERPOLATE (linear interpolation)
# - pressure: LOCF (last observation carried forward)
# - status: KEEPNULL (keep as NULL for filled rows)
statement ok
CREATE MATERIALIZED VIEW gap_filled_mixed AS
SELECT ts, temperature, pressure, status
FROM GAP_FILL(gap_multi_column_table, ts, INTERVAL '1' MINUTE,
              INTERPOLATE(temperature), LOCF(pressure), KEEPNULL(status));

# Check result - temperature interpolated, pressure LOCF, status NULL
query TRRR
SELECT ts, temperature, pressure, status FROM gap_filled_mixed ORDER BY ts;
----
2024-05-21 10:00:00 20 100 active
2024-05-21 10:01:00 21 100 NULL
2024-05-21 10:02:00 22 100 NULL
2024-05-21 10:03:00 23 100 NULL
2024-05-21 10:04:00 24 120 inactive

# Test insert in between with mixed strategies
statement ok
INSERT INTO gap_multi_column_table VALUES
    ('2024-05-21 10:02:00', 22.0, 110.0, 'warning');

# Check result - interpolated values should be recalculated, LOCF and NULL should update
query TRRR
SELECT ts, temperature, pressure, status FROM gap_filled_mixed ORDER BY ts;
----
2024-05-21 10:00:00 20 100 active
2024-05-21 10:01:00 21 100 NULL
2024-05-21 10:02:00 22 110 warning
2024-05-21 10:03:00 23 110 NULL
2024-05-21 10:04:00 24 120 inactive

# Test delete data point with mixed strategies
statement ok
DELETE FROM gap_multi_column_table
WHERE ts = '2024-05-21 10:02:00';

# Check result - should revert to original gap filling
query TRRR
SELECT ts, temperature, pressure, status FROM gap_filled_mixed ORDER BY ts;
----
2024-05-21 10:00:00 20 100 active
2024-05-21 10:01:00 21 100 NULL
2024-05-21 10:02:00 22 100 NULL
2024-05-21 10:03:00 23 100 NULL
2024-05-21 10:04:00 24 120 inactive

# Cleanup
statement ok
DROP MATERIALIZED VIEW gap_filled_mixed;

statement ok
DROP TABLE gap_multi_column_table;