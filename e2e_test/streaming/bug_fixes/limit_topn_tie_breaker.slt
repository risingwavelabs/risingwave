# Regression test: streaming LIMIT (rewritten to TopN) should be deterministic for ties by
# appending the input stream key (PK/_row_id) as a tie-breaker.

statement ok
SET RW_IMPLICIT_FLUSH TO true;

statement ok
DROP MATERIALIZED VIEW IF EXISTS mv;

statement ok
DROP TABLE IF EXISTS t;

statement ok
CREATE TABLE t (
  pk INT PRIMARY KEY,
  v  INT
);

statement ok
INSERT INTO t VALUES
  (2, 1),
  (1, 1),
  (3, 1),
  (4, 2);

# No explicit ORDER BY. The planner will rewrite LIMIT to TopN and use the first visible column
# (v) for ordering. Rows with the same v should be deterministically ordered by the input stream key
# (here it's the table PK) as a tie-breaker, so we expect pk=1 then pk=2 for v=1.
statement ok
CREATE MATERIALIZED VIEW mv AS
SELECT v, pk FROM t LIMIT 2;

statement ok
flush;

query II rowsort
SELECT v, pk FROM mv;
----
1 1
1 2

statement ok
INSERT INTO t VALUES (0, 1);

statement ok
flush;

query II rowsort
SELECT v, pk FROM mv;
----
1 0
1 1

statement ok
DELETE FROM t WHERE pk = 0;

statement ok
flush;

query II rowsort
SELECT v, pk FROM mv;
----
1 1
1 2

statement ok
DROP MATERIALIZED VIEW mv;

statement ok
DROP TABLE t;

# Regression test: the input columns of LIMIT may be completely pruned away (0-column input) during
# streaming rewrite. This should not panic and should still produce the correct row count.

statement ok
DROP MATERIALIZED VIEW IF EXISTS mv_zero_col;

statement ok
DROP TABLE IF EXISTS t_zero_col;

statement ok
CREATE TABLE t_zero_col (v INT);

statement ok
INSERT INTO t_zero_col SELECT generate_series(1, 100);

statement ok
CREATE MATERIALIZED VIEW mv_zero_col AS
SELECT 1 c FROM (SELECT v FROM t_zero_col LIMIT 10) s;

statement ok
flush;

query I
SELECT count(*) FROM mv_zero_col;
----
10

statement ok
DELETE FROM t_zero_col WHERE v <= 50;

statement ok
flush;

query I
SELECT count(*) FROM mv_zero_col;
----
10

statement ok
DROP MATERIALIZED VIEW mv_zero_col;

statement ok
DROP TABLE t_zero_col;
