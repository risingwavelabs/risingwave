# Test DROP SECRET CASCADE functionality
# This test verifies that when dropping a secret with CASCADE,
# all dependent objects are properly removed.


# Test 1: Create source that uses the secret
statement ok
CREATE SECRET mysql_pwd WITH (
    backend = 'meta'
) AS 'mysql_password';

statement ok
CREATE SOURCE mysql_source WITH (
    connector = 'mysql-cdc',
    hostname = 'localhost',
    port = '3306',
    username = 'user',
    password = secret mysql_pwd,
    database.name = 'testdb'
);

# Test 2: Create connection that uses the secret
statement ok
CREATE SECRET conn_secret WITH (
    backend = 'meta'
) AS 'connection_string';

statement ok
CREATE CONNECTION test_connection WITH (
    connector = 'jdbc',
    url = secret conn_secret,
    properties = '{}'
);

# Test 3: Create sink that uses the secret
statement ok
CREATE SECRET sink_secret WITH (
    backend = 'meta'
) AS 'sink_auth_token';

statement ok
CREATE TABLE test_table (id int, value varchar);

statement ok
CREATE SINK test_sink FROM test_table WITH (
    connector = 'kafka',
    properties = {
        'bootstrap.servers' = 'localhost:9092',
        'topic' = 'test_topic'
    },
    auth.token = secret sink_secret
) FORMAT PLAIN ENCODE JSON;


# Test 4: Create table based on the source
statement ok
CREATE TABLE mysql_table (
    id int,
    name varchar
) FROM mysql_source TABLE 'test_table';


# Test 5: Create materialized view based on the table
statement ok
CREATE MATERIALIZED VIEW test_mv AS
SELECT id, upper(value) as upper_value
FROM test_table;

# Verify all objects exist before cascade drop
query T
SELECT secret_name FROM rw_secrets WHERE secret_name LIKE '%secret%';
----
conn_secret
mysql_pwd
sink_secret

query T
SELECT name FROM rw_sources WHERE name = 'mysql_source';
----
mysql_source

query T
SELECT name FROM rw_connections WHERE name = 'test_connection';
----
test_connection


query T
SELECT name FROM rw_sinks WHERE name = 'test_sink';
----
test_sink

query T
SELECT table_name FROM rw_tables WHERE table_name = 'mysql_table';
----
mysql_table

query T
SELECT name FROM rw_materialized_views WHERE name = 'test_mv';
----
test_mv

# Execute CASCADE drop - this should remove:
# 1. Source using the secret (mysql_source)
# 2. Connection using the secret (test_connection)
# 3. Sink using the secret (test_sink)
# 4. Table based on the source (mysql_table)
# 5. Materialized view based on the table (test_mv)


statement ok
DROP SECRET mysql_pwd CASCADE;

# Verify cascade deletion worked correctly
# The secret should be gone
query T
SELECT count(secret_name) FROM rw_secrets WHERE secret_name = 'mysql_pwd';
----
0

# The source that used the secret should be gone
query T
SELECT count(name) FROM rw_sources WHERE name = 'mysql_source';
----
0

# The table that depended on the source should be gone
query T
SELECT count(table_name) FROM rw_tables WHERE table_name = 'mysql_table';
----
0

# Other unrelated objects should still exist
query T
SELECT secret_name FROM rw_secrets WHERE secret_name IN ('conn_secret', 'sink_secret');
----
conn_secret
sink_secret

query T
SELECT name FROM rw_connections WHERE name = 'test_connection';
----
test_connection

query T
SELECT name FROM rw_sinks WHERE name = 'test_sink';
----
test_sink

query T
SELECT name FROM rw_materialized_views WHERE name = 'test_mv';
----
test_mv

# Test IF EXISTS with CASCADE
statement ok
DROP SECRET non_existent_secret CASCADE;

statement ok
DROP SECRET conn_secret CASCADE;

statement ok
DROP SECRET sink_secret CASCADE;

statement ok
DROP TABLE test_table;

statement ok
DROP MATERIALIZED VIEW test_mv;

# Final verification - all secrets should be gone
query T
SELECT secret_name FROM rw_secrets WHERE secret_name LIKE '%secret%';
----