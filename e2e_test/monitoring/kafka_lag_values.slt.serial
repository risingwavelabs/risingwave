# End-to-end check that kafka lag catalog surfaces rows for non-shared table connector
# and shared source cases.

set streaming_use_shared_source to false;

system ok
rpk topic delete kafka_lag_table || true

system ok
rpk topic create kafka_lag_table -p 1

system ok
cat <<EOF | rpk topic produce kafka_lag_table -f "%v\n"
1
2
3
EOF

statement ok
create table kafka_lag_table (v1 int)
with (
  ${RISEDEV_KAFKA_WITH_OPTIONS_COMMON},
  topic = 'kafka_lag_table',
  scan.startup.mode = 'earliest'
) FORMAT PLAIN ENCODE JSON;

sleep 3s

query I
select count(*) from kafka_lag_table;
----
3

# Should have exactly one partition row in lag view for the table job.
query I
select count(*) from rw_catalog.rw_kafka_job_lag
 where job_id = (select id from rw_tables where name = 'kafka_lag_table');
----
1

set streaming_use_shared_source to true;

system ok
rpk topic delete kafka_lag_shared || true

system ok
rpk topic create kafka_lag_shared -p 1

system ok
cat <<EOF | rpk topic produce kafka_lag_shared -f "%v\n"
10
11
EOF

statement ok
create source kafka_lag_shared (v1 int) with (
  ${RISEDEV_KAFKA_WITH_OPTIONS_COMMON},
  topic = 'kafka_lag_shared',
  scan.startup.mode = 'earliest'
) format plain encode json;

statement ok
create materialized view kafka_lag_shared_mv as select * from kafka_lag_shared;

sleep 3s

query I
select count(*) from kafka_lag_shared_mv;
----
2

query I
select is_shared from rw_sources where name = 'kafka_lag_shared';
----
t

# Lag view should surface the shared source job row.
query I
select count(*) from rw_catalog.rw_kafka_job_lag
 where job_id = (select id from rw_tables where name = 'kafka_lag_shared_mv');
----
1

set streaming_use_shared_source to default;
