# Test uint256 data type

statement ok
SET RW_IMPLICIT_FLUSH TO true;

# Drop table if exists
statement ok
DROP TABLE IF EXISTS t_uint256 CASCADE;

# Create table with uint256 column
statement ok
CREATE TABLE t_uint256 (id INT, value rw_uint256);

# Insert some uint256 values
statement ok
INSERT INTO t_uint256 VALUES
  (1, '0'::rw_uint256),
  (2, '1'::rw_uint256),
  (3, '100'::rw_uint256),
  (4, '1000000'::rw_uint256),
  (5, '18446744073709551615'::rw_uint256), -- max uint64
  (6, '340282366920938463463374607431768211455'::rw_uint256); -- max uint128

# Test basic select
query II
SELECT id, value FROM t_uint256 ORDER BY id;
----
1 0
2 1
3 100
4 1000000
5 18446744073709551615
6 340282366920938463463374607431768211455

# Test arithmetic operations
query I
SELECT value + '1'::rw_uint256 FROM t_uint256 WHERE id = 3;
----
101

query I
SELECT value - '1'::rw_uint256 FROM t_uint256 WHERE id = 3;
----
99

query I
SELECT value * '2'::rw_uint256 FROM t_uint256 WHERE id = 3;
----
200

query I
SELECT value / '2'::rw_uint256 FROM t_uint256 WHERE id = 3;
----
50

# Test aggregations
query I
SELECT COUNT(*) FROM t_uint256;
----
6

query I
SELECT SUM(value) FROM t_uint256 WHERE id <= 4;
----
1000101

query I
SELECT MIN(value) FROM t_uint256;
----
0

query I
SELECT MAX(value) FROM t_uint256;
----
340282366920938463463374607431768211455

query R
SELECT AVG(value)::DOUBLE FROM t_uint256 WHERE id <= 4;
----
250025.25

# Test comparison operators
query I
SELECT COUNT(*) FROM t_uint256 WHERE value > '100'::rw_uint256;
----
3

query I
SELECT COUNT(*) FROM t_uint256 WHERE value <= '100'::rw_uint256;
----
3

# Test materialized view with uint256
statement ok
CREATE MATERIALIZED VIEW mv_uint256 AS
SELECT
  COUNT(*) as cnt,
  SUM(value) as sum_val,
  MIN(value) as min_val,
  MAX(value) as max_val
FROM t_uint256;

query IIII
SELECT * FROM mv_uint256;
----
6 340282366920938463481821351505478763171 0 340282366920938463463374607431768211455

# Test connector-style string parsing (simulating JSON/PostgreSQL sources)
statement ok
CREATE TABLE t_connector_uint256 (
    id INT,
    json_value rw_uint256,
    pg_numeric_value rw_uint256
);

# Test string parsing that would come from JSON connectors
statement ok
INSERT INTO t_connector_uint256 VALUES
    (1, cast('123456789012345678901234567890' as rw_uint256), cast('987654321098765432109876543210' as rw_uint256));

# Test maximum value parsing
statement ok
INSERT INTO t_connector_uint256 VALUES
    (2, cast('115792089237316195423570985008687907853269984665640564039457584007913129639935' as rw_uint256), cast('115792089237316195423570985008687907853269984665640564039457584007913129639935' as rw_uint256));

query III
SELECT * FROM t_connector_uint256 ORDER BY id;
----
1 123456789012345678901234567890 987654321098765432109876543210
2 115792089237316195423570985008687907853269984665640564039457584007913129639935 115792089237316195423570985008687907853269984665640564039457584007913129639935

statement ok
DROP TABLE t_connector_uint256;

# Cleanup
statement ok
DROP MATERIALIZED VIEW mv_uint256;

statement ok
DROP TABLE t_uint256 CASCADE;