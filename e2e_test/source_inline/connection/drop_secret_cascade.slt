# Test DROP SECRET CASCADE functionality
# This test verifies that when dropping a secret with CASCADE,
# all dependent objects are properly removed.

control substitution on

# for non-shared source
statement ok
set streaming_use_shared_source to false;

# Test 1: Create source that uses the secret
statement ok
create secret source_secret with (
    backend = 'meta'
) as 'test_value';

statement ok
create source test_source (
    v1 int,
    v2 varchar
) with (
    connector = 'datagen',
    fields.v1.secret = secret source_secret
) FORMAT PLAIN ENCODE JSON;

# Test 2: Create connection that uses the secret
statement ok
create secret conn_secret with (
    backend = 'meta'
) as '${RISEDEV_KAFKA_BOOTSTRAP_SERVERS}';

statement ok
create connection test_connection with (
    type = 'kafka',
    properties.bootstrap.server = secret conn_secret,
    properties.security.protocol = 'plaintext'
);

# Test 3: Create sink that uses the secret
statement ok
CREATE SECRET sink_secret WITH (
    backend = 'meta'
) AS '${RISEDEV_KAFKA_BOOTSTRAP_SERVERS}';

statement ok
CREATE TABLE sink_table(v1 int);

statement ok
INSERT INTO sink_table SELECT * FROM generate_series(1, 1000);

statement ok
CREATE MATERIALIZED VIEW sink_mv AS SELECT * FROM sink_table;

statement ok
CREATE SINK test_sink FROM sink_mv WITH (
    connector = 'kafka',
    properties.bootstrap.server = secret sink_secret,
    topic = 'test-rw-sink-append-only'
) FORMAT PLAIN ENCODE JSON (
    force_append_only = 'true'
);

# Verify all objects exist before cascade drop
query I rowsort
SELECT name FROM rw_secrets WHERE name LIKE '%secret%';
----
conn_secret
sink_secret
source_secret

query T
SELECT count(name) FROM rw_sources WHERE name = 'test_source';
----
1

query T
SELECT count(name) FROM rw_connections WHERE name = 'test_connection';
----
1

query T
SELECT count(name) FROM rw_sinks WHERE name = 'test_sink';
----
1

query T
SELECT count(name) FROM rw_materialized_views WHERE name = 'sink_mv';
----
1

query T
SELECT count(name) FROM rw_tables WHERE name = 'sink_table';
----
1

statement error
DROP SECRET source_secret RESTRICT;

statement ok
DROP SECRET source_secret CASCADE;

# Verify cascade deletion worked correctly
# The secret should be gone
query T
SELECT count(name) FROM rw_secrets WHERE name = 'source_secret';
----
0

# The source that used the secret should be gone
query T
SELECT count(name) FROM rw_sources WHERE name = 'test_source';
----
0

# Other unrelated objects should still exist
query I rowsort
SELECT name FROM rw_secrets WHERE name LIKE '%secret%';
----
conn_secret
sink_secret

query T
SELECT count(*) FROM rw_connections WHERE name = 'test_connection';
----
1

query T
SELECT count(*) FROM rw_sinks WHERE name = 'test_sink';
----
1

statement error
DROP SECRET conn_secret RESTRICT;

statement ok
DROP SECRET conn_secret CASCADE;

query T
SELECT name FROM rw_secrets WHERE name LIKE '%secret%';
----
sink_secret

query T
SELECT count(*) FROM rw_sinks WHERE name = 'test_sink';
----
1

statement error
DROP SECRET sink_secret RESTRICT;

statement ok
DROP SECRET sink_secret CASCADE;

query T
SELECT name FROM rw_secrets WHERE name LIKE '%secret%';
----

query T
SELECT count(name) FROM rw_tables WHERE name = 'sink_table';
----
1

query T
SELECT count(name) FROM rw_materialized_views WHERE name = 'sink_mv';
----
1

statement ok
set streaming_use_shared_source to true;