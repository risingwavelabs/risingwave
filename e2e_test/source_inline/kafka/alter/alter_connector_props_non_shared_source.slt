control substitution on

statement ok
create secret s1 with ( backend = 'meta' ) as '1000000000';


statement ok
create secret s2 with ( backend = 'meta' ) as '2000000000';

# ==== test non shared source ====

statement ok
set streaming_use_shared_source to false;

system ok
rpk topic create test_alter_non_shared_source -X brokers=message_queue_sasl_1:19092 -X sasl.mechanism=PLAIN -X user=dev -X pass=rw

system ok
cat << EOF | rpk topic produce test_alter_non_shared_source -X brokers=message_queue_sasl_1:19092 -X sasl.mechanism=PLAIN -X user=dev -X pass=rw
{"x": 1}
{"x": 2}
{"x": 3}
EOF

system ok
rpk topic create test_alter_non_shared_source -X brokers=message_queue_sasl_2:19093 -X sasl.mechanism=PLAIN -X user=dev1 -X pass=rw

system ok
cat << EOF | rpk topic produce test_alter_non_shared_source -X brokers=message_queue_sasl_2:19093 -X sasl.mechanism=PLAIN -X user=dev1 -X pass=rw
{"x": 4}
{"x": 5}
{"x": 6}
EOF

statement ok
create secret s_broker with ( backend = 'meta' ) as 'message_queue_sasl_1:19092';

statement ok
create secret s_username with ( backend = 'meta' ) as 'dev';

statement ok
create source non_shared_source_1 (x int) with (
    connector = 'kafka',
    properties.receive.message.max.bytes = secret s1,
    properties.bootstrap.server = secret s_broker,
    properties.security.protocol = 'SASL_PLAINTEXT',
    properties.sasl.mechanism = 'PLAIN',
    properties.sasl.username = secret s_username,
    properties.sasl.password = 'rw',
    topic = 'test_alter_non_shared_source'
) format plain encode json;

statement ok
create materialized view non_shared_source_1_mv as select * from non_shared_source_1;

statement ok
create source non_shared_source_2 (x int) with (
    connector = 'kafka',
    properties.receive.message.max.bytes = secret s1,
    properties.bootstrap.server = secret s_broker,
    properties.security.protocol = 'SASL_PLAINTEXT',
    properties.sasl.mechanism = 'PLAIN',
    properties.sasl.username = secret s_username,
    properties.sasl.password = 'rw',
    topic = 'test_alter_non_shared_source'
) format plain encode json;

sleep 2s

# ingest from message_queue_sasl_1
query I retry 3 backoff 1s
select * from non_shared_source_1_mv order by x;
----
1
2
3


statement ok
alter secret s_broker with ( backend = 'meta' ) as 'message_queue_sasl_2:19093';

statement ok
alter secret s_username with ( backend = 'meta' ) as 'dev1';

# alter source connector also triggers re-apply secret
statement ok
alter source non_shared_source_1 connector WITH (properties.receive.message.max.bytes = secret s2);

statement ok
alter source non_shared_source_2 connector WITH (properties.receive.message.max.bytes = secret s2);

query I
select count(*)  from rw_sources where definition ILIKE '%secret s2%' and name = 'non_shared_source_1';
----
1


query I
select count(*)  from rw_sources where definition ILIKE '%secret s2%' and name = 'non_shared_source_2';
----
1


system ok
cat << EOF | rpk topic produce test_alter_non_shared_source -X brokers=message_queue_sasl_2:19093 -X sasl.mechanism=PLAIN -X user=dev1 -X pass=rw
{"x": 7}
{"x": 8}
{"x": 9}
EOF

sleep 5s

# the alter source connector applies to existing stream jobs
query I retry 3 backoff 1s
select * from non_shared_source_1_mv order by x;
----
1
2
3
7
8
9


# ==== clean up ====

statement ok
drop source non_shared_source_1 cascade;

statement ok
drop source non_shared_source_2 cascade;

system ok
rpk topic delete test_alter_non_shared_source -X brokers=message_queue_sasl_1:19092 -X sasl.mechanism=PLAIN -X user=dev -X pass=rw

system ok
rpk topic delete test_alter_non_shared_source -X brokers=message_queue_sasl_2:19093 -X sasl.mechanism=PLAIN -X user=dev1 -X pass=rw

statement ok
set streaming_use_shared_source to true;
