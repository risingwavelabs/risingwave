control substitution on

# ------------ data prepare stage ------------
system ok
sqlcmd -C -d master -Q 'create database mydb;' -b

system ok
sqlcmd -C -i e2e_test/source_inline/cdc/sql_server/sql_server_timestamp_prepare.sql -b

# ------------ Create source and table stage ------------

# Test with connect mode configuration (should handle extreme timestamps correctly)
statement ok
CREATE SOURCE mssql_timestamp_source WITH (
    connector = 'sqlserver-cdc',
    hostname = '${SQLCMDSERVER:sqlserver-server}',
    port = '${SQLCMDPORT:1433}',
    username = '${SQLCMDUSER:SA}',
    password = '${SQLCMDPASSWORD}',
    database.name = '${SQLCMDDBNAME}',
    debezium.time.precision.mode = 'connect'
);

statement ok
CREATE TABLE timestamp_test (
    id INT,
    timestamp TIMESTAMP,
    PRIMARY KEY (id)
) from mssql_timestamp_source table 'mydb.dbo.timestamp_test';

# sleep to ensure the data is consumed from Debezium message instead of backfill
sleep 10s

# ------------ add rows stage ------------
system ok
sqlcmd -C -i e2e_test/source_inline/cdc/sql_server/sql_server_timestamp_insert.sql -b

sleep 10s

# ------------ check initial data stage ------------

# Check initial data (6 rows)
query II
select id, timestamp from timestamp_test order by id;
----
1 9999-01-01 00:00:00
2 0001-01-01 00:00:00
3 1972-01-01 00:00:00
4 8000-06-01 12:00:00
5 5138-11-16 09:46:40
6 9999-12-31 23:59:59.999

# ------------ update rows stage ------------
system ok
sqlcmd -C -i e2e_test/source_inline/cdc/sql_server/sql_server_timestamp_update.sql -b

sleep 10s

# ------------ check after update stage ------------

# Check all data after update (should show updated IDs)
query II
select id, timestamp from timestamp_test order by id;
----
4 8000-06-01 12:00:00
5 5138-11-16 09:46:40
6 9999-12-31 23:59:59.999
11 9999-01-01 00:00:00
12 0001-01-01 00:00:00
13 1972-01-01 00:00:00

# ------------ drop stage ------------
statement ok
drop source mssql_timestamp_source cascade;