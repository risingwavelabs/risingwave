syntax = "proto3";

package stream_service;

option java_multiple_files = true;
option java_package = "com.risingwave.proto.streaming.streamnode";
option optimize_for = SPEED;

import "common.proto";
import "data.proto";
import "plan.proto";
import "stream_plan.proto";

// Describe the fragments which will be running on this node
message UpdateActorsRequest {
  string request_id = 1;
  repeated stream_plan.StreamActor actors = 2;
}

message UpdateActorsResponse {
  common.Status status = 1;
}

message BroadcastActorInfoTableRequest {
  repeated common.ActorInfo info = 1;
}

// Create channels and gRPC connections for a fragment
message BuildActorsRequest {
  string request_id = 1;
  repeated uint32 actor_id = 2;
}

message BuildActorsResponse {
  string request_id = 1;
  common.Status status = 2;
}

message DropActorsRequest {
  string request_id = 1;
  plan.TableRefId table_ref_id = 2;
  repeated uint32 actor_ids = 3;
}

message DropActorsResponse {
  string request_id = 1;
  common.Status status = 2;
}

message InjectBarrierRequest {
  string request_id = 1;
  data.Barrier barrier = 2;
  repeated uint32 actor_ids_to_collect = 3;
}

message InjectBarrierResponse {
  string request_id = 1;
  common.Status status = 2;
}

// Before starting streaming, the leader node broadcast the actor-host table to needed workers.
message BroadcastActorInfoTableResponse {
  common.Status status = 1;
}

service StreamService {
  rpc UpdateActors(UpdateActorsRequest) returns (UpdateActorsResponse);
  rpc BuildActors(BuildActorsRequest) returns (BuildActorsResponse);
  rpc BroadcastActorInfoTable(BroadcastActorInfoTableRequest) returns (BroadcastActorInfoTableResponse);
  rpc DropActors(DropActorsRequest) returns (DropActorsResponse);
  rpc InjectBarrier(InjectBarrierRequest) returns (InjectBarrierResponse);
}

// TODO: Lifecycle management for actors.
