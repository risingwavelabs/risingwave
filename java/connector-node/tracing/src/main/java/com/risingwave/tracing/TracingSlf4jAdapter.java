/*
 * Copyright 2023 RisingWave Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Ported from https://github.com/MrFriendly-B-V/tracing-slf4j,
// which is licensed under the Apache License, Version 2.0.

package com.risingwave.tracing;

// Import log4j's ParameterizedMessage, so that we can format the messages
// with the same interpolation as log4j (i.e. "{}" instead of "%s").
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.logging.log4j.message.ParameterizedMessage;
import org.slf4j.Marker;
import org.slf4j.event.Level;
import org.slf4j.helpers.LegacyAbstractLogger;

public class TracingSlf4jAdapter extends LegacyAbstractLogger {

    private final String name;

    public TracingSlf4jAdapter(String name) {
        this.name = name;
    }

    @Override
    public boolean isTraceEnabled() {
        return TracingSlf4jImpl.isEnabled(Level.TRACE);
    }

    @Override
    public boolean isDebugEnabled() {
        return TracingSlf4jImpl.isEnabled(Level.DEBUG);
    }

    @Override
    public boolean isInfoEnabled() {
        return TracingSlf4jImpl.isEnabled(Level.INFO);
    }

    @Override
    public boolean isWarnEnabled() {
        return TracingSlf4jImpl.isEnabled(Level.WARN);
    }

    @Override
    public boolean isErrorEnabled() {
        return TracingSlf4jImpl.isEnabled(Level.ERROR);
    }

    @Override
    protected String getFullyQualifiedCallerName() {
        return null;
    }

    @Override
    protected void handleNormalizedLoggingCall(
            Level level,
            Marker marker,
            String messagePattern,
            Object[] arguments,
            Throwable throwable) {
        // Filter out noisy Debezium warnings that occur during schema discovery.
        // These warnings are harmless and don't affect CDC functionality.
        // Performance: Most logs fail the first check (level != WARN), so overhead is minimal.
        // For filtered WARN logs, we avoid expensive message formatting and JNI calls.

        // Filter 1: PostgreSQL TypeRegistry - "Type [...] is already mapped"
        // Caused by duplicate type registrations during schema discovery.
        if (level == Level.WARN
                && name != null
                && name.equals("io.debezium.connector.postgresql.TypeRegistry")
                && messagePattern != null
                && messagePattern.contains("is already mapped")) {
            return;
        }

        // Filter 2: PostgreSQL DefaultValueConverter - "Cannot parse column default value"
        // Occurs when Debezium cannot parse function call expressions (e.g., "schema".function())
        // as constant values. The actual default values are generated by PostgreSQL during INSERT.
        if (level == Level.WARN
                && name != null
                && name.equals(
                        "io.debezium.connector.postgresql.connection.PostgresDefaultValueConverter")
                && messagePattern != null
                && messagePattern.contains("Cannot parse column default value")
                && messagePattern.contains("Expression evaluation is not supported")) {
            return;
        }

        // Filter 3: SQL Server DefaultValueConverter - "Cannot parse column default value"
        // Similar to PostgreSQL, occurs for SQL Server function expressions like sysdatetime(),
        // getdate(), CONVERT(), etc.
        if (level == Level.WARN
                && name != null
                && name.equals("io.debezium.connector.sqlserver.SqlServerDefaultValueConverter")
                && messagePattern != null
                && messagePattern.contains("Cannot parse column default value")
                && messagePattern.contains("Expression evaluation is not supported")) {
            return;
        }

        // Filter 4: SQL Server Type Mapper - "Mapper for type ... not found"
        // Occurs when Debezium doesn't have a specific type mapper, but the type is still
        // handled correctly through generic converters.
        if (level == Level.WARN
                && name != null
                && name.equals("io.debezium.connector.sqlserver.SqlServerDefaultValueConverter")
                && messagePattern != null
                && messagePattern.contains("Mapper for type")
                && messagePattern.contains("not found")) {
            return;
        }

        var pm = new ParameterizedMessage(messagePattern, arguments, throwable);
        var message = pm.getFormattedMessage();

        String stackTrace = null;
        if (throwable != null) {
            stackTrace = ExceptionUtils.getStackTrace(throwable);
        }

        TracingSlf4jImpl.event(name, level, message, stackTrace);
    }
}
