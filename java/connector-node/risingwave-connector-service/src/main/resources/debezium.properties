# Store common debezium configs shared by all connectors
topic.prefix=RW_CDC_${source.id}
topic.heartbeat.prefix=${debezium.topic.heartbeat.prefix:-RW_CDC_HeartBeat_}
# schema.history.internal=io.debezium.relational.history.MemorySchemaHistory
# schema.history.internal=io.debezium.relational.history.S3SchemaHistory
schema.history.internal=io.debezium.relational.history.FileSchemaHistory
offset.storage=com.risingwave.connector.cdc.debezium.internal.ConfigurableOffsetBackingStore
converters=datetime
datetime.type=com.risingwave.connector.cdc.debezium.converters.DatetimeTypeConverter
# use string to preserve the precision of decimal, since currently we cannot
# parse decimal in the "precise" mode
decimal.handling.mode=${debezium.decimal.handling.mode:-string}
interval.handling.mode=string
max.batch.size=${debezium.max.batch.size:-1024}
max.queue.size=${debezium.max.queue.size:-8192}
time.precision.mode=adaptive_time_microseconds
# Quoted from the debezium document:
# > Your application should always properly stop the engine to ensure graceful and complete
# > shutdown and that each source record is sent to the application exactly one time.
# In RisingWave we assume the upstream changelog may contain duplicate events and
# handle conflicts in the mview operator, thus we don't need to obey the above
# instructions. So we decrease the wait time here to reclaim jvm thread faster.
debezium.embedded.shutdown.pause.before.interrupt.ms=1
offset.flush.interval.ms=60000
