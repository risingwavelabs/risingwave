# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: explain (distsql, trace, verbose) select 1;
  explain_output: |
    Begin:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]] }

    Predicate Push Down:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]] }

    Predicate Push Down:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]] }

    Predicate Push Down:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]] }

    Prune Columns:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]] }

    Predicate Push Down:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]] }

    Project Remove:

    apply TrivialProjectToValuesRule 1 time(s)

    LogicalValues { rows: [[1:Int32]] }

    Inline Session Timezone:

    BatchValues { rows: [[1:Int32]] }

    Const eval exprs:

    BatchValues { rows: [[1:Int32]] }

    To Batch Physical Plan:

    BatchValues { rows: [[1:Int32]] }

    To Batch Local Plan:

    BatchValues { rows: [[1:Int32]] }

    {
      "root_stage_id": 0,
      "stages": {
        "0": {
          "root": {
            "plan_node_id": 10028,
            "plan_node_type": "BatchValues",
            "schema": [
              {
                "dataType": {
                  "typeName": "INT32",
                  "isNullable": true
                },
                "name": "1:Int32"
              }
            ],
            "children": [],
            "source_stage_id": null
          },
          "parallelism": 1,
          "exchange_info": {
            "mode": "SINGLE"
          }
        }
      },
      "child_edges": {
        "0": []
      },
      "parent_edges": {
        "0": []
      }
    }
- sql: |
    create table t1(v1 int);
    create table t2(v2 int);
    explain (logical) select * from t1 join t2 on v1=v2;
  explain_output: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
    ├─LogicalScan { table: t1, columns: [v1] }
    └─LogicalScan { table: t2, columns: [v2] }
- sql: |
    create table t1(v1 int);
    create table t2(v2 int);
    explain (logical, trace) select * from t1 join t2 on v1=v2;
  explain_output: |+
    Begin:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Predicate Push Down:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Predicate Push Down:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Predicate Push Down:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Push Down the Calculation of Inputs of Join's Condition:

    apply PushCalculationOfJoinRule 1 time(s)

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Prune Columns:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1] }
      └─LogicalScan { table: t2, columns: [v2] }

    Predicate Push Down:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1] }
      └─LogicalScan { table: t2, columns: [v2] }

    Project Remove:

    apply ProjectEliminateRule 1 time(s)

    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
    ├─LogicalScan { table: t1, columns: [v1] }
    └─LogicalScan { table: t2, columns: [v2] }

- sql: |
    explain (logical) create table t1(v1 int);
  explain_output: |
    LogicalSource
- sql: |
    explain create table t (v1 int, v2 varchar);
  explain_output: |
    StreamMaterialize { columns: [v1, v2, _row_id(hidden)], pk_columns: [_row_id], pk_conflict: "overwrite" }
    └─StreamExchange { dist: HashShard(_row_id) }
      └─StreamRowIdGen { row_id_index: 2 }
        └─StreamDml { columns: [v1, v2, _row_id] }
          └─StreamSource
- sql: |
    explain create table t (v1 int, v2 varchar) with ( connector = 'kafka', kafka.topic = 'kafka_3_partition_topic', kafka.brokers = '127.0.0.1:1234', kafka.scan.startup.mode='earliest'  ) row format json;
  explain_output: |
    StreamMaterialize { columns: [v1, v2, _row_id(hidden)], pk_columns: [_row_id], pk_conflict: "overwrite" }
    └─StreamExchange { dist: HashShard(_row_id) }
      └─StreamRowIdGen { row_id_index: 2 }
        └─StreamDml { columns: [v1, v2, _row_id] }
          └─StreamSource { source: "t", columns: ["v1", "v2", "_row_id"] }
