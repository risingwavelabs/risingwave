# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    /* T: updatable; Tk: Hash(k) distribution; AO: append-only; S: single distribution */
    create table T  (k int, v int, o int, s varchar);
    create index Tk on T(k) include(k, v, o, s);
    create materialized view S as select * from T order by o limit 100;
    create table AO (k int, v int, o int, s varchar) with (appendonly = true);
- id: extreme_on_single
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(s.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [max(s.v)] }
          BatchScan { table: s, columns: [s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [max(s.v)] }
        StreamGlobalSimpleAgg { aggs: [count, max(s.v)] }
          StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
- id: sum_on_single
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(sum(s.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [sum(s.v)] }
          BatchScan { table: s, columns: [s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(s.v)] }
        StreamGlobalSimpleAgg { aggs: [count, sum(s.v)] }
          StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
- id: cnt_on_single
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(count(s.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [count(s.v)] }
          BatchScan { table: s, columns: [s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [count(s.v)] }
        StreamGlobalSimpleAgg { aggs: [count, count(s.v)] }
          StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
- id: string_agg_on_single
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by v) as a1 from S;
  batch_plan: |
    BatchSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [s.s, ',':Varchar, s.v] }
          BatchScan { table: s, columns: [s.v, s.s], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))] }
        StreamGlobalSimpleAgg { aggs: [count, string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))] }
          StreamProject { exprs: [s.s, ',':Varchar, s.v, s.t._row_id] }
            StreamTableScan { table: s, columns: [s.v, s.s, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
- id: extreme_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(t.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [max(t.v)] }
          BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [max(max(t.v))] }
        StreamGlobalSimpleAgg { aggs: [sum(count), max(max(t.v))] }
          StreamExchange { dist: Single }
            StreamHashAgg { group_key: [Vnode(t._row_id)], aggs: [count, max(t.v)] }
              StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id)] }
                StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: extreme_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [max(max(ao.v))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), max(max(ao.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, max(ao.v)] }
              StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: sum_on_T
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(sum(t.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [sum(t.v)] }
          BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(sum(t.v))] }
        StreamGlobalSimpleAgg { aggs: [sum(count), sum(sum(t.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, sum(t.v)] }
              StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: sum_on_AO
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(sum(ao.v))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), sum(sum(ao.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, sum(ao.v)] }
              StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: cnt_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(count(t.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [count(t.v)] }
          BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(count(t.v))] }
        StreamGlobalSimpleAgg { aggs: [sum(count), sum(count(t.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, count(t.v)] }
              StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: cnt_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(count(ao.v))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), sum(count(ao.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, count(ao.v)] }
              StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: string_agg_on_T
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [t.s, ',':Varchar, t.o] }
          BatchScan { table: t, columns: [t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
        StreamGlobalSimpleAgg { aggs: [count, string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [t.s, ',':Varchar, t.o, t._row_id] }
              StreamTableScan { table: t, columns: [t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: string_agg_on_AO
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [count, string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [ao.s, ',':Varchar, ao.o, ao._row_id] }
              StreamTableScan { table: ao, columns: [ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: extreme_count_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(t.v)), sum(count(t.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [max(t.v), count(t.v)] }
          BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [max(max(t.v)), sum(count(t.v))] }
        StreamGlobalSimpleAgg { aggs: [sum(count), max(max(t.v)), sum(count(t.v))] }
          StreamExchange { dist: Single }
            StreamHashAgg { group_key: [Vnode(t._row_id)], aggs: [count, max(t.v), count(t.v)] }
              StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id)] }
                StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: extreme_count_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [max(max(ao.v)), sum(count(ao.v))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), max(max(ao.v)), sum(count(ao.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, max(ao.v), count(ao.v)] }
              StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: count_string_agg_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
          BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
        StreamGlobalSimpleAgg { aggs: [count, count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
              StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: count_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [count, count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
              StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: extreme_string_agg_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
          BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
        StreamGlobalSimpleAgg { aggs: [count, max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
              StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: extreme_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [count, max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
              StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: extreme_on_T_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(t.v)] }
        BatchHashAgg { group_key: [t.k], aggs: [max(t.v)] }
          BatchExchange { order: [], dist: HashShard(t.k) }
            BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
      StreamProject { exprs: [max(t.v), t.k] }
        StreamHashAgg { group_key: [t.k], aggs: [count, max(t.v)] }
          StreamExchange { dist: HashShard(t.k) }
            StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: extreme_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(tk.v)] }
        BatchSortAgg { group_key: [tk.k], aggs: [max(tk.v)] }
          BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
      StreamProject { exprs: [max(tk.v), tk.k] }
        StreamHashAgg { group_key: [tk.k], aggs: [count, max(tk.v)] }
          StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
- id: extreme_on_S_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(s.v)] }
        BatchHashAgg { group_key: [s.k], aggs: [max(s.v)] }
          BatchScan { table: s, columns: [s.k, s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
      StreamProject { exprs: [max(s.v), s.k] }
        StreamHashAgg { group_key: [s.k], aggs: [count, max(s.v)] }
          StreamExchange { dist: HashShard(s.k) }
            StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
- id: extreme_on_AO_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
      StreamProject { exprs: [max(ao.v), ao.k] }
        StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, max(ao.v)] }
          StreamExchange { dist: HashShard(ao.k) }
            StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: sum_on_T_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [sum(t.v)] }
        BatchHashAgg { group_key: [t.k], aggs: [sum(t.v)] }
          BatchExchange { order: [], dist: HashShard(t.k) }
            BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
      StreamProject { exprs: [sum(t.v), t.k] }
        StreamHashAgg { group_key: [t.k], aggs: [count, sum(t.v)] }
          StreamExchange { dist: HashShard(t.k) }
            StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: sum_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [sum(tk.v)] }
        BatchSortAgg { group_key: [tk.k], aggs: [sum(tk.v)] }
          BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
      StreamProject { exprs: [sum(tk.v), tk.k] }
        StreamHashAgg { group_key: [tk.k], aggs: [count, sum(tk.v)] }
          StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
- id: sum_on_S_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [sum(s.v)] }
        BatchHashAgg { group_key: [s.k], aggs: [sum(s.v)] }
          BatchScan { table: s, columns: [s.k, s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
      StreamProject { exprs: [sum(s.v), s.k] }
        StreamHashAgg { group_key: [s.k], aggs: [count, sum(s.v)] }
          StreamExchange { dist: HashShard(s.k) }
            StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
- id: sum_on_AO_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
      StreamProject { exprs: [sum(ao.v), ao.k] }
        StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, sum(ao.v)] }
          StreamExchange { dist: HashShard(ao.k) }
            StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: cnt_on_T_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [count(t.v)] }
        BatchHashAgg { group_key: [t.k], aggs: [count(t.v)] }
          BatchExchange { order: [], dist: HashShard(t.k) }
            BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
      StreamProject { exprs: [count(t.v), t.k] }
        StreamHashAgg { group_key: [t.k], aggs: [count, count(t.v)] }
          StreamExchange { dist: HashShard(t.k) }
            StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: cnt_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [count(tk.v)] }
        BatchSortAgg { group_key: [tk.k], aggs: [count(tk.v)] }
          BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
      StreamProject { exprs: [count(tk.v), tk.k] }
        StreamHashAgg { group_key: [tk.k], aggs: [count, count(tk.v)] }
          StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
- id: cnt_on_S_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [count(s.v)] }
        BatchHashAgg { group_key: [s.k], aggs: [count(s.v)] }
          BatchScan { table: s, columns: [s.k, s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
      StreamProject { exprs: [count(s.v), s.k] }
        StreamHashAgg { group_key: [s.k], aggs: [count, count(s.v)] }
          StreamExchange { dist: HashShard(s.k) }
            StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
- id: cnt_on_AO_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
      StreamProject { exprs: [count(ao.v), ao.k] }
        StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, count(ao.v)] }
          StreamExchange { dist: HashShard(ao.k) }
            StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
- id: string_agg_on_T_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
        BatchHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          BatchExchange { order: [], dist: HashShard(t.k) }
            BatchProject { exprs: [t.k, t.s, ',':Varchar, t.o] }
              BatchScan { table: t, columns: [t.k, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
      StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST)), t.k] }
        StreamHashAgg { group_key: [t.k], aggs: [count, string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          StreamExchange { dist: HashShard(t.k) }
            StreamProject { exprs: [t.k, t.s, ',':Varchar, t.o, t._row_id] }
              StreamTableScan { table: t, columns: [t.k, t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- id: string_agg_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST))] }
        BatchSortAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST))] }
          BatchProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o] }
            BatchScan { table: tk, columns: [tk.k, tk.o, tk.s], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
      StreamProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST)), tk.k] }
        StreamHashAgg { group_key: [tk.k], aggs: [count, string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST))] }
          StreamProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id] }
            StreamTableScan { table: tk, columns: [tk.k, tk.o, tk.s, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
- id: string_agg_on_S_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST))] }
        BatchHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST))] }
          BatchProject { exprs: [s.k, s.s, ',':Varchar, s.o] }
            BatchScan { table: s, columns: [s.k, s.o, s.s], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
      StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST)), s.k] }
        StreamHashAgg { group_key: [s.k], aggs: [count, string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST))] }
          StreamExchange { dist: HashShard(s.k) }
            StreamProject { exprs: [s.k, s.s, ',':Varchar, s.o, s.t._row_id] }
              StreamTableScan { table: s, columns: [s.k, s.o, s.s, s.t._row_id], pk: [s.t._row_id], distribution: Single }
- id: string_agg_on_AO_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
      StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST)), ao.k] }
        StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
          StreamExchange { dist: HashShard(ao.k) }
            StreamProject { exprs: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id] }
              StreamTableScan { table: ao, columns: [ao.k, ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
