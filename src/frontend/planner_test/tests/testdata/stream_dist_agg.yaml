# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    /* T: updatable; Tk: Hash(k) distribution; AO: append-only; S: single distribution */
    create table T  (k int, v int, o int, s varchar);
    create index Tk on T(k) include(k, v, o, s);
    create materialized view S as select * from T order by o limit 100;
    create table AO (k int, v int, o int, s varchar) append only;
- id: extreme_on_single
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [max(s.v)] }
      └─BatchScan { table: s, columns: [s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(s.v)] }
      └─StreamGlobalSimpleAgg { aggs: [max(s.v), count] }
        └─StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(s.v)] }
        └── StreamGlobalSimpleAgg { aggs: [max(s.v), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └── Chain { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
                ├──  Upstream
                └──  BatchPlanNode
    Table 0
    ├── columns: [ s_v, s_t__row_id ]
    ├── primary key: [ $0 DESC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 1
    ├── columns: [ max(s_v), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: sum_on_single
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [sum(s.v)] }
      └─BatchScan { table: s, columns: [s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(s.v)] }
      └─StreamGlobalSimpleAgg { aggs: [sum(s.v), count] }
        └─StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [sum(s.v)] }
        └── StreamGlobalSimpleAgg { aggs: [sum(s.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── Chain { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
                ├──  Upstream
                └──  BatchPlanNode
    Table 0
    ├── columns: [ sum(s_v), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: cnt_on_single
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [count(s.v)] }
      └─BatchScan { table: s, columns: [s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(s.v)] }
      └─StreamGlobalSimpleAgg { aggs: [count(s.v), count] }
        └─StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [count(s.v)] }
        └── StreamGlobalSimpleAgg { aggs: [count(s.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── Chain { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
                ├──  Upstream
                └──  BatchPlanNode
    Table 0
    ├── columns: [ count(s_v), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: string_agg_on_single
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by v) as a1 from S;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC))] }
      └─BatchProject { exprs: [s.s, ',':Varchar, s.v] }
        └─BatchScan { table: s, columns: [s.v, s.s], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.v ASC))] }
      └─StreamGlobalSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC)), count] }
        └─StreamProject { exprs: [s.s, ',':Varchar, s.v, s.t._row_id] }
          └─StreamTableScan { table: s, columns: [s.v, s.s, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.v ASC))] }
        └── StreamGlobalSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC)), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └── StreamProject { exprs: [s.s, ',':Varchar, s.v, s.t._row_id] }
                └── Chain { table: s, columns: [s.v, s.s, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
                    ├──  Upstream
                    └──  BatchPlanNode
    Table 0
    ├── columns: [ s_v, s_t__row_id, s_s, ',':Varchar ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 1
    ├── columns: [ string_agg(s_s, ',':Varchar order_by(s_v ASC)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: extreme_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [max(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(max(t.v))] }
      └─StreamGlobalSimpleAgg { aggs: [max(max(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamHashAgg { group_key: [$expr1], aggs: [max(t.v), count] }
            └─StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as $expr1] }
              └─StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(max(t.v))] }
        └── StreamGlobalSimpleAgg { aggs: [max(max(t.v)), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamHashAgg { group_key: [$expr1], aggs: [max(t.v), count] }
    ├── result table: 3
    ├── state tables: [ 2 ]
    ├── distinct tables: []
    └── StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as $expr1] }
        └── Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
            ├──  Upstream
            └──  BatchPlanNode
    Table 0
    ├── columns: [ max(t_v), $expr1 ]
    ├── primary key: [ $0 DESC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 1
    ├── columns: [ max(max(t_v)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 2
    ├── columns: [ $expr1, t_v, t__row_id ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 2 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0
    Table 3
    ├── columns: [ $expr1, max(t_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: []
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: extreme_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(max(ao.v))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [max(max(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [max(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(max(ao.v))] }
        └── StreamAppendOnlyGlobalSimpleAgg { aggs: [max(max(ao.v)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamStatelessLocalSimpleAgg { aggs: [max(ao.v)] }
    └── Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ max(max(ao_v)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: sum_on_T
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(sum(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [sum(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(sum(t.v))] }
      └─StreamGlobalSimpleAgg { aggs: [sum(sum(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [sum(t.v)] }
            └─StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [sum(sum(t.v))] }
        └── StreamGlobalSimpleAgg { aggs: [sum(sum(t.v)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamStatelessLocalSimpleAgg { aggs: [sum(t.v)] }
    └── Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ sum(sum(t_v)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: sum_on_AO
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(sum(ao.v))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(sum(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [sum(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [sum(sum(ao.v))] }
        └── StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(sum(ao.v)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamStatelessLocalSimpleAgg { aggs: [sum(ao.v)] }
    └── Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ sum(sum(ao_v)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: cnt_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum0(count(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum0(count(t.v))] }
      └─StreamGlobalSimpleAgg { aggs: [sum0(count(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [count(t.v)] }
            └─StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [sum0(count(t.v))] }
        └── StreamGlobalSimpleAgg { aggs: [sum0(count(t.v)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamStatelessLocalSimpleAgg { aggs: [count(t.v)] }
    └── Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ sum0(count(t_v)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: cnt_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum0(count(ao.v))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [sum0(count(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [count(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [sum0(count(ao.v))] }
        └── StreamAppendOnlyGlobalSimpleAgg { aggs: [sum0(count(ao.v)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamStatelessLocalSimpleAgg { aggs: [count(ao.v)] }
    └── Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ sum0(count(ao_v)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: string_agg_on_T
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.s, ',':Varchar, t.o] }
        └─BatchScan { table: t, columns: [t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─StreamGlobalSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
        └── StreamGlobalSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamProject { exprs: [t.s, ',':Varchar, t.o, t._row_id] }
    └── Chain { table: t, columns: [t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ t_o, t__row_id, t_s, ',':Varchar ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 1
    ├── columns: [ string_agg(t_s, ',':Varchar order_by(t_o ASC)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: string_agg_on_AO
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
        └── StreamAppendOnlyGlobalSimpleAgg { aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamProject { exprs: [ao.s, ',':Varchar, ao.o, ao._row_id] }
    └── Chain { table: ao, columns: [ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1 ]
    ├── primary key: []
    ├── value indices: [ 0 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: extreme_count_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(t.v)), sum0(count(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [max(t.v), count(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(max(t.v)), sum0(count(t.v))] }
      └─StreamGlobalSimpleAgg { aggs: [max(max(t.v)), sum0(count(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamHashAgg { group_key: [$expr1], aggs: [max(t.v), count(t.v), count] }
            └─StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as $expr1] }
              └─StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(max(t.v)), sum0(count(t.v))] }
        └── StreamGlobalSimpleAgg { aggs: [max(max(t.v)), sum0(count(t.v)), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamHashAgg { group_key: [$expr1], aggs: [max(t.v), count(t.v), count] }
    ├── result table: 3
    ├── state tables: [ 2 ]
    ├── distinct tables: []
    └── StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as $expr1] }
        └── Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
            ├──  Upstream
            └──  BatchPlanNode
    Table 0
    ├── columns: [ max(t_v), $expr1 ]
    ├── primary key: [ $0 DESC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 1
    ├── columns: [ max(max(t_v)), sum0(count(t_v)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 2
    ├── columns: [ $expr1, t_v, t__row_id ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 2 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0
    Table 3
    ├── columns: [ $expr1, max(t_v), count(t_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: []
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0
    Table 4294967294
    ├── columns: [ a1, a2 ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: extreme_count_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(max(ao.v)), sum0(count(ao.v))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [max(max(ao.v)), sum0(count(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [max(ao.v), count(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(max(ao.v)), sum0(count(ao.v))] }
        └── StreamAppendOnlyGlobalSimpleAgg { aggs: [max(max(ao.v)), sum0(count(ao.v)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamStatelessLocalSimpleAgg { aggs: [max(ao.v), count(ao.v)] }
    └── Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ max(max(ao_v)), sum0(count(ao_v)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1, a2 ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: count_string_agg_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
        └─BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─StreamGlobalSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
        └── StreamGlobalSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
    └── Chain { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ t_o, t__row_id, t_s, ',':Varchar ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 1
    ├── columns:
    │   ┌── count(t_v)
    │   ├── string_agg(t_s, ',':Varchar order_by(t_o ASC))
    │   └── count
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1, a2 ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: count_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
        └── StreamAppendOnlyGlobalSimpleAgg { aggs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
    └── Chain { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ count(ao_v), string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1, a2 ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: extreme_string_agg_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
        └─BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─StreamGlobalSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
        └── StreamGlobalSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
            ├── result table: 2
            ├── state tables: [ 0, 1 ]
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
    └── Chain { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ t_v, t__row_id ]
    ├── primary key: [ $0 DESC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 1
    ├── columns: [ t_o, t__row_id, t_s, ',':Varchar ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 2
    ├── columns: [ max(t_v), string_agg(t_s, ',':Varchar order_by(t_o ASC)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1, a2 ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: extreme_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
        └── StreamAppendOnlyGlobalSimpleAgg { aggs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Single from 1
    Fragment 1 StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
    └── Chain { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ max(ao_v), string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count ]
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
    Table 4294967294
    ├── columns: [ a1, a2 ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0
- id: extreme_on_T_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [max(t.v)] }
      └─BatchHashAgg { group_key: [t.k], aggs: [max(t.v)] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(t.v), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [max(t.v), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(t.v), t.k] }
        └── StreamHashAgg { group_key: [t.k], aggs: [max(t.v), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 Chain { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
    ├──  Upstream
    └──  BatchPlanNode
    Table 0
    ├── columns: [ t_k, t_v, t__row_id ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 1
    ├── columns: [ t_k, max(t_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, t.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: extreme_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [max(tk.v)] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [max(tk.v)] }
        └─BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(tk.v), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [max(tk.v), count] }
        └─StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(tk.v), tk.k] }
        └── StreamHashAgg { group_key: [tk.k], aggs: [max(tk.v), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └── Chain { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
                ├──  Upstream
                └──  BatchPlanNode
    Table 0
    ├── columns: [ tk_k, tk_v, tk_t__row_id ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 1
    ├── columns: [ tk_k, max(tk_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, tk.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: extreme_on_S_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [max(s.v)] }
      └─BatchHashAgg { group_key: [s.k], aggs: [max(s.v)] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchScan { table: s, columns: [s.k, s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(s.v), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [max(s.v), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(s.v), s.k] }
        └── StreamHashAgg { group_key: [s.k], aggs: [max(s.v), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 Chain { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
    ├──  Upstream
    └──  BatchPlanNode
    Table 0
    ├── columns: [ s_k, s_v, s_t__row_id ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 1
    ├── columns: [ s_k, max(s_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, s.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: extreme_on_AO_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(ao.v), ao.k] }
      └─StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [max(ao.v), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [max(ao.v), ao.k] }
        └── StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [max(ao.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 Chain { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
    ├──  Upstream
    └──  BatchPlanNode
    Table 0
    ├── columns: [ ao_k, max(ao_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, ao.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: sum_on_T_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [sum(t.v)] }
      └─BatchHashAgg { group_key: [t.k], aggs: [sum(t.v)] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(t.v), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [sum(t.v), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [sum(t.v), t.k] }
        └── StreamHashAgg { group_key: [t.k], aggs: [sum(t.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 Chain { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
    ├──  Upstream
    └──  BatchPlanNode
    Table 0
    ├── columns: [ t_k, sum(t_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, t.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: sum_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [sum(tk.v)] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [sum(tk.v)] }
        └─BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(tk.v), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [sum(tk.v), count] }
        └─StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [sum(tk.v), tk.k] }
        └── StreamHashAgg { group_key: [tk.k], aggs: [sum(tk.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── Chain { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
                ├──  Upstream
                └──  BatchPlanNode
    Table 0
    ├── columns: [ tk_k, sum(tk_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, tk.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: sum_on_S_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [sum(s.v)] }
      └─BatchHashAgg { group_key: [s.k], aggs: [sum(s.v)] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchScan { table: s, columns: [s.k, s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(s.v), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [sum(s.v), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [sum(s.v), s.k] }
        └── StreamHashAgg { group_key: [s.k], aggs: [sum(s.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 Chain { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
    ├──  Upstream
    └──  BatchPlanNode
    Table 0
    ├── columns: [ s_k, sum(s_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, s.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: sum_on_AO_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(ao.v), ao.k] }
      └─StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [sum(ao.v), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [sum(ao.v), ao.k] }
        └── StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [sum(ao.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 Chain { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
    ├──  Upstream
    └──  BatchPlanNode
    Table 0
    ├── columns: [ ao_k, sum(ao_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, ao.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: cnt_on_T_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count(t.v)] }
      └─BatchHashAgg { group_key: [t.k], aggs: [count(t.v)] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(t.v), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [count(t.v), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [count(t.v), t.k] }
        └── StreamHashAgg { group_key: [t.k], aggs: [count(t.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 Chain { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
    ├──  Upstream
    └──  BatchPlanNode
    Table 0
    ├── columns: [ t_k, count(t_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, t.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: cnt_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count(tk.v)] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [count(tk.v)] }
        └─BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(tk.v), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [count(tk.v), count] }
        └─StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [count(tk.v), tk.k] }
        └── StreamHashAgg { group_key: [tk.k], aggs: [count(tk.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── Chain { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
                ├──  Upstream
                └──  BatchPlanNode
    Table 0
    ├── columns: [ tk_k, count(tk_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, tk.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: cnt_on_S_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count(s.v)] }
      └─BatchHashAgg { group_key: [s.k], aggs: [count(s.v)] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchScan { table: s, columns: [s.k, s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(s.v), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [count(s.v), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [count(s.v), s.k] }
        └── StreamHashAgg { group_key: [s.k], aggs: [count(s.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 Chain { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
    ├──  Upstream
    └──  BatchPlanNode
    Table 0
    ├── columns: [ s_k, count(s_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, s.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: cnt_on_AO_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(ao.v), ao.k] }
      └─StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count(ao.v), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [count(ao.v), ao.k] }
        └── StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count(ao.v), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 Chain { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
    ├──  Upstream
    └──  BatchPlanNode
    Table 0
    ├── columns: [ ao_k, count(ao_v), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, ao.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: string_agg_on_T_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─BatchHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchProject { exprs: [t.k, t.s, ',':Varchar, t.o] }
            └─BatchScan { table: t, columns: [t.k, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamProject { exprs: [t.k, t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.k, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), t.k] }
        └── StreamHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 StreamProject { exprs: [t.k, t.s, ',':Varchar, t.o, t._row_id] }
    └── Chain { table: t, columns: [t.k, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ t_k, t_o, t__row_id, t_s, ',':Varchar ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 1
    ├── columns: [ t_k, string_agg(t_s, ',':Varchar order_by(t_o ASC)), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, t.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: string_agg_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC))] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC))] }
        └─BatchProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o] }
          └─BatchScan { table: tk, columns: [tk.k, tk.o, tk.s], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), count] }
        └─StreamProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id] }
          └─StreamTableScan { table: tk, columns: [tk.k, tk.o, tk.s, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), tk.k] }
        └── StreamHashAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └── StreamProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id] }
                └── Chain { table: tk, columns: [tk.k, tk.o, tk.s, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
                    ├──  Upstream
                    └──  BatchPlanNode
    Table 0
    ├── columns: [ tk_k, tk_o, tk_t__row_id, tk_s, ',':Varchar ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 1
    ├── columns: [ tk_k, string_agg(tk_s, ',':Varchar order_by(tk_o ASC)), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, tk.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: string_agg_on_S_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC))] }
      └─BatchHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC))] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchProject { exprs: [s.k, s.s, ',':Varchar, s.o] }
            └─BatchScan { table: s, columns: [s.k, s.o, s.s], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamProject { exprs: [s.k, s.s, ',':Varchar, s.o, s.t._row_id] }
            └─StreamTableScan { table: s, columns: [s.k, s.o, s.s, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), s.k] }
        └── StreamHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), count] }
            ├── result table: 1
            ├── state tables: [ 0 ]
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 StreamProject { exprs: [s.k, s.s, ',':Varchar, s.o, s.t._row_id] }
    └── Chain { table: s, columns: [s.k, s.o, s.s, s.t._row_id], pk: [s.t._row_id], dist: Single }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ s_k, s_o, s_t__row_id, s_s, ',':Varchar ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 1
    ├── columns: [ s_k, string_agg(s_s, ',':Varchar order_by(s_o ASC)), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, s.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
- id: string_agg_on_AO_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), ao.k] }
      └─StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamProject { exprs: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.k, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0 StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), ao.k] }
        └── StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └──  StreamExchange Hash([0]) from 1
    Fragment 1 StreamProject { exprs: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id] }
    └── Chain { table: ao, columns: [ao.k, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        ├──  Upstream
        └──  BatchPlanNode
    Table 0
    ├── columns: [ ao_k, string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1
    Table 4294967294
    ├── columns: [ a1, ao.k ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1
