# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v3 int, v4 int);
    create table t3 (v5 int, v6 int);
    select * from t1, t2, t3 where t1.v1 = t2.v3 and t1.v1 = t3.v5;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4, t3.v5, t3.v6] }
      LogicalFilter { predicate: (t1.v1 = t2.v3) AND (t1.v1 = t3.v5) }
        LogicalJoin { type: Inner, on: true, output: all }
          LogicalJoin { type: Inner, on: true, output: all }
            LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
            LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
          LogicalScan { table: t3, columns: [t3.v5, t3.v6, t3._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, v3, v4, v5, v6, t1._row_id(hidden), t2._row_id(hidden), t3._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id, t3._row_id] }
      StreamExchange { dist: HashShard(t1._row_id, t2._row_id, t3._row_id) }
        StreamHashJoin { type: Inner, predicate: t1.v1 = t3.v5, output: [t1.v1, t1.v2, t2.v3, t2.v4, t3.v5, t3.v6, t1._row_id, t2._row_id, t3._row_id] }
          StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v3, output: [t1.v1, t1.v2, t2.v3, t2.v4, t1._row_id, t2._row_id] }
            StreamExchange { dist: HashShard(t1.v1) }
              StreamTableScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id], pk: [t1._row_id], distribution: UpstreamHashShard(t1._row_id) }
            StreamExchange { dist: HashShard(t2.v3) }
              StreamTableScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id], pk: [t2._row_id], distribution: UpstreamHashShard(t2._row_id) }
          StreamExchange { dist: HashShard(t3.v5) }
            StreamTableScan { table: t3, columns: [t3.v5, t3.v6, t3._row_id], pk: [t3._row_id], distribution: UpstreamHashShard(t3._row_id) }
- sql: |
    /* self join */
    create table t (v1 int, v2 int);
    select t1.v1 as t1v1, t2.v1 as t2v1 from t t1 join t t2 on t1.v1 = t2.v1;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v1] }
      LogicalJoin { type: Inner, on: (t.v1 = t.v1), output: all }
        LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
        LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [t1v1, t2v1, t._row_id(hidden), t._row_id#1(hidden)], pk_columns: [t._row_id, t._row_id#1] }
      StreamExchange { dist: HashShard(t._row_id, t._row_id) }
        StreamHashJoin { type: Inner, predicate: t.v1 = t.v1, output: [t.v1, t.v1, t._row_id, t._row_id] }
          StreamExchange { dist: HashShard(t.v1) }
            StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
          StreamExchange { dist: HashShard(t.v1) }
            StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create table t3 (v1 int, v2 int);
    select t1.v1 as t1_v1, t1.v2 as t1_v2, t2.v1 as t2_v1, t2.v2 as t2_v2, t3.v1 as t3_v1, t3.v2 as t3_v2 from t1 join t2 on (t1.v1 = t2.v1) join t3 on (t2.v2 = t3.v2);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: t2.v2 = t3.v2, output: all }
        BatchExchange { order: [], dist: HashShard(t2.v2) }
          BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: all }
            BatchExchange { order: [], dist: HashShard(t1.v1) }
              BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
            BatchExchange { order: [], dist: HashShard(t2.v1) }
              BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
        BatchExchange { order: [], dist: HashShard(t3.v2) }
          BatchScan { table: t3, columns: [t3.v1, t3.v2], distribution: SomeShard }
  batch_local_plan: |
    BatchHashJoin { type: Inner, predicate: t2.v2 = t3.v2, output: all }
      BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: all }
        BatchExchange { order: [], dist: Single }
          BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
        BatchExchange { order: [], dist: Single }
          BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t3, columns: [t3.v1, t3.v2], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [t1_v1, t1_v2, t2_v1, t2_v2, t3_v1, t3_v2, t1._row_id(hidden), t2._row_id(hidden), t3._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id, t3._row_id] }
      StreamExchange { dist: HashShard(t1._row_id, t2._row_id, t3._row_id) }
        StreamHashJoin { type: Inner, predicate: t2.v2 = t3.v2, output: [t1.v1, t1.v2, t2.v1, t2.v2, t3.v1, t3.v2, t1._row_id, t2._row_id, t3._row_id] }
          StreamExchange { dist: HashShard(t2.v2) }
            StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v1, t1.v2, t2.v1, t2.v2, t1._row_id, t2._row_id] }
              StreamExchange { dist: HashShard(t1.v1) }
                StreamTableScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id], pk: [t1._row_id], distribution: UpstreamHashShard(t1._row_id) }
              StreamExchange { dist: HashShard(t2.v1) }
                StreamTableScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id], pk: [t2._row_id], distribution: UpstreamHashShard(t2._row_id) }
          StreamExchange { dist: HashShard(t3.v2) }
            StreamTableScan { table: t3, columns: [t3.v1, t3.v2, t3._row_id], pk: [t3._row_id], distribution: UpstreamHashShard(t3._row_id) }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select t1.v2 as t1_v2, t2.v2 as t2_v2 from t1 join t2 on t1.v1 = t2.v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v2, t2.v2] }
        BatchExchange { order: [], dist: HashShard(t1.v1) }
          BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
        BatchExchange { order: [], dist: HashShard(t2.v1) }
          BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
  batch_local_plan: |
    BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v2, t2.v2] }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [t1_v2, t2_v2, t1._row_id(hidden), t2._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id] }
      StreamExchange { dist: HashShard(t1._row_id, t2._row_id) }
        StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v2, t2.v2, t1._row_id, t2._row_id] }
          StreamExchange { dist: HashShard(t1.v1) }
            StreamTableScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id], pk: [t1._row_id], distribution: UpstreamHashShard(t1._row_id) }
          StreamExchange { dist: HashShard(t2.v1) }
            StreamTableScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id], pk: [t2._row_id], distribution: UpstreamHashShard(t2._row_id) }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select t1.v2 as t1_v2, t2.v2 as t2_v2 from t1 join t2 on t1.v1 > t2.v1 and t1.v2 < 10;
  batch_plan: |
    BatchNestedLoopJoin { type: Inner, predicate: (t1.v1 > t2.v1), output: [t1.v2, t2.v2] }
      BatchExchange { order: [], dist: Single }
        BatchFilter { predicate: (t1.v2 < 10:Int32) }
          BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
  batch_local_plan: |
    BatchNestedLoopJoin { type: Inner, predicate: (t1.v1 > t2.v1), output: [t1.v2, t2.v2] }
      BatchExchange { order: [], dist: Single }
        BatchFilter { predicate: (t1.v2 < 10:Int32) }
          BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v3 int);
    select * from t1 join t2 using(v1);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v1, t1.v2, t2.v3] }
        BatchExchange { order: [], dist: HashShard(t1.v1) }
          BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
        BatchExchange { order: [], dist: HashShard(t2.v1) }
          BatchScan { table: t2, columns: [t2.v1, t2.v3], distribution: SomeShard }
- sql: |
    create table ab (a int, b int);
    create table bc (b int, c int);
    create table ca (c int, a int);
    select * from ab join bc using(b) join ca using(c);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: bc.c = ca.c, output: [bc.c, ab.b, ab.a, ca.a] }
        BatchExchange { order: [], dist: HashShard(bc.c) }
          BatchHashJoin { type: Inner, predicate: ab.b = bc.b, output: [ab.a, ab.b, bc.c] }
            BatchExchange { order: [], dist: HashShard(ab.b) }
              BatchScan { table: ab, columns: [ab.a, ab.b], distribution: SomeShard }
            BatchExchange { order: [], dist: HashShard(bc.b) }
              BatchScan { table: bc, columns: [bc.b, bc.c], distribution: SomeShard }
        BatchExchange { order: [], dist: HashShard(ca.c) }
          BatchScan { table: ca, columns: [ca.c, ca.a], distribution: SomeShard }
- sql: |
    /* Only push to left */
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select * from t1 left join t2 where t1.v2 > 100;
  optimized_logical_plan: |
    LogicalJoin { type: LeftOuter, on: true, output: all }
      LogicalScan { table: t1, output_columns: [t1.v1, t1.v2], required_columns: [v1, v2], predicate: (t1.v2 > 100:Int32) }
      LogicalScan { table: t2, columns: [t2.v1, t2.v2] }
- sql: |
    /* Only push to right */
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select * from t1 right join t2 where t2.v2 > 100;
  optimized_logical_plan: |
    LogicalJoin { type: RightOuter, on: true, output: all }
      LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
      LogicalScan { table: t2, output_columns: [t2.v1, t2.v2], required_columns: [v1, v2], predicate: (t2.v2 > 100:Int32) }
- sql: |
    /* Push to left, right and on */
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select * from t1, t2 where t1.v1 > 100 and t2.v1 < 1000 and t1.v2 = t2.v2;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v2 = t2.v2), output: all }
      LogicalScan { table: t1, output_columns: [t1.v1, t1.v2], required_columns: [v1, v2], predicate: (t1.v1 > 100:Int32) }
      LogicalScan { table: t2, output_columns: [t2.v1, t2.v2], required_columns: [v1, v2], predicate: (t2.v1 < 1000:Int32) }
- sql: |
    /* Left & right has same SomeShard distribution. There should still be exchanges below hash join */
    create table t(x int);
    create index i on t(x);
    select i.x as ix, ii.x as iix from i join i as ii on i.x=ii.x;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: i.x = i.x, output: all }
        BatchExchange { order: [], dist: HashShard(i.x) }
          BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
        BatchExchange { order: [], dist: HashShard(i.x) }
          BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
  stream_plan: |
    StreamMaterialize { columns: [ix, iix, i.t._row_id(hidden), i.t._row_id#1(hidden)], pk_columns: [i.t._row_id, i.t._row_id#1] }
      StreamExchange { dist: HashShard(i.t._row_id, i.t._row_id) }
        StreamHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x, i.x, i.t._row_id, i.t._row_id] }
          StreamExchange { dist: HashShard(i.x) }
            StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], distribution: UpstreamHashShard(i.x) }
          StreamExchange { dist: HashShard(i.x) }
            StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], distribution: UpstreamHashShard(i.x) }
- sql: |
    /* Left & right has same SomeShard distribution. There should still be exchanges below hash join */
    create table t(x int);
    create index i on t(x);
    select i.x as ix, t.x as tx from i join t on i.x=t.x;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: i.x = t.x, output: all }
        BatchExchange { order: [], dist: HashShard(i.x) }
          BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
        BatchExchange { order: [], dist: HashShard(t.x) }
          BatchScan { table: t, columns: [t.x], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [ix, tx, i.t._row_id(hidden), t._row_id(hidden)], pk_columns: [i.t._row_id, t._row_id] }
      StreamExchange { dist: HashShard(i.t._row_id, t._row_id) }
        StreamHashJoin { type: Inner, predicate: i.x = t.x, output: [i.x, t.x, i.t._row_id, t._row_id] }
          StreamExchange { dist: HashShard(i.x) }
            StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], distribution: UpstreamHashShard(i.x) }
          StreamExchange { dist: HashShard(t.x) }
            StreamTableScan { table: t, columns: [t.x, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    /* Left & right has same HashShard distribution. There should be no exchange below hash join */
    create table t(x int);
    create index i on t(x);
    select * from
      (select * from i join i as ii using (x)) t1
    full join
      (select * from i join i as ii using (x)) t2
    using (x);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [Coalesce(i.x, i.x)] }
        BatchHashJoin { type: FullOuter, predicate: i.x = i.x, output: all }
          BatchHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x] }
            BatchExchange { order: [], dist: HashShard(i.x) }
              BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
            BatchExchange { order: [], dist: HashShard(i.x) }
              BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
          BatchHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x] }
            BatchExchange { order: [], dist: HashShard(i.x) }
              BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
            BatchExchange { order: [], dist: HashShard(i.x) }
              BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
  stream_plan: |
    StreamMaterialize { columns: [x, i.t._row_id(hidden), i.t._row_id#1(hidden), i.t._row_id#2(hidden), i.t._row_id#3(hidden)], pk_columns: [i.t._row_id, i.t._row_id#1, i.t._row_id#2, i.t._row_id#3] }
      StreamExchange { dist: HashShard(i.t._row_id, i.t._row_id, i.t._row_id, i.t._row_id) }
        StreamProject { exprs: [Coalesce(i.x, i.x), i.t._row_id, i.t._row_id, i.t._row_id, i.t._row_id] }
          StreamHashJoin { type: FullOuter, predicate: i.x = i.x, output: [i.x, i.x, i.t._row_id, i.t._row_id, i.t._row_id, i.t._row_id] }
            StreamHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x, i.t._row_id, i.t._row_id] }
              StreamExchange { dist: HashShard(i.x) }
                StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], distribution: UpstreamHashShard(i.x) }
              StreamExchange { dist: HashShard(i.x) }
                StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], distribution: UpstreamHashShard(i.x) }
            StreamHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x, i.t._row_id, i.t._row_id] }
              StreamExchange { dist: HashShard(i.x) }
                StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], distribution: UpstreamHashShard(i.x) }
              StreamExchange { dist: HashShard(i.x) }
                StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], distribution: UpstreamHashShard(i.x) }
- sql: |
    /* Use lookup join */
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create materialized view t3 as select v1, count(v2) as v2 from t2 group by v1;
    select * from t1 join t3 where t1.v2 = t3.v1;
  batch_local_plan: |
    BatchLookupJoin { type: Inner, predicate: t1.v2 = t3.v1, output: all }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
  with_config_map:
    QUERY_MODE: local
    RW_BATCH_ENABLE_LOOKUP_JOIN: 'true'
- sql: |
    /* Ensure correct binding of join with USING clause */
    create table t1(v1 varchar);
    create table t2(v1 varchar);
    create table t3(v2 varchar);
    select * from t3, t1 join t2 using (v1);
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t3.v2] }
      LogicalJoin { type: Inner, on: true, output: all }
        LogicalScan { table: t3, columns: [t3.v2, t3._row_id] }
        LogicalJoin { type: Inner, on: (t1.v1 = t2.v1), output: all }
          LogicalScan { table: t1, columns: [t1.v1, t1._row_id] }
          LogicalScan { table: t2, columns: [t2.v1, t2._row_id] }
- sql: |
    /* Ensure correct binding of join with ON clause */
    create table t1(v1 varchar);
    create table t2(v2 varchar);
    create table t3(v3 varchar);
    select * from t3, t1 join t2 on v1 = v2;
  logical_plan: |
    LogicalProject { exprs: [t3.v3, t1.v1, t2.v2] }
      LogicalJoin { type: Inner, on: true, output: all }
        LogicalScan { table: t3, columns: [t3.v3, t3._row_id] }
        LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: all }
          LogicalScan { table: t1, columns: [t1.v1, t1._row_id] }
          LogicalScan { table: t2, columns: [t2.v2, t2._row_id] }
- sql: |
    /* Ensure correct binding with USING clause with left outer join */
    create table t1(v1 varchar);
    create table t2(v1 varchar);
    create table t3(v2 varchar);
    select * from t3, t1 left join t2 using (v1);
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t3.v2] }
      LogicalJoin { type: Inner, on: true, output: all }
        LogicalScan { table: t3, columns: [t3.v2, t3._row_id] }
        LogicalJoin { type: LeftOuter, on: (t1.v1 = t2.v1), output: all }
          LogicalScan { table: t1, columns: [t1.v1, t1._row_id] }
          LogicalScan { table: t2, columns: [t2.v1, t2._row_id] }
- sql: |
    /* Ensure correct binding with ON clause with left outer join */
    create table t1(v1 varchar);
    create table t2(v2 varchar);
    create table t3(v3 varchar);
    select * from t3, t1 left join t2 on v1 = v2;
  logical_plan: |
    LogicalProject { exprs: [t3.v3, t1.v1, t2.v2] }
      LogicalJoin { type: Inner, on: true, output: all }
        LogicalScan { table: t3, columns: [t3.v3, t3._row_id] }
        LogicalJoin { type: LeftOuter, on: (t1.v1 = t2.v2), output: all }
          LogicalScan { table: t1, columns: [t1.v1, t1._row_id] }
          LogicalScan { table: t2, columns: [t2.v2, t2._row_id] }
- sql: |
    /* Ensure that ON clause cannot reference correlated columns */
    create table a(a1 int);
    create table b(b1 int);
    create table c(c1 int);
    select * from a, b join c on a1 + b1 = c1;
  binder_error: 'Item not found: Invalid column: a1'
- sql: |
    create table a(a1 int);
    create table b(b1 int);
    select * from a join lateral (select * from b where a1 = b1);
  binder_error: |-
    Feature is not yet implemented: lateral subqueries are not yet supported
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/3815
- sql: |
    /* Ensure that natural joins bind the correct columns */
    create table a(x int);
    create table b(x int);
    create table c(y int);
    select * from a natural join b natural join c;
  logical_plan: |
    LogicalProject { exprs: [a.x, c.y] }
      LogicalJoin { type: Inner, on: true, output: all }
        LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
          LogicalScan { table: a, columns: [a.x, a._row_id] }
          LogicalScan { table: b, columns: [b.x, b._row_id] }
        LogicalScan { table: c, columns: [c.y, c._row_id] }
- sql: |
    /* Ensure that natural joins can disambiguate columns */
    create table a(x int);
    create table b(x int);
    select x, a.x, b.x from a natural join b;
  logical_plan: |
    LogicalProject { exprs: [a.x, a.x, b.x] }
      LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
        LogicalScan { table: a, columns: [a.x, a._row_id] }
        LogicalScan { table: b, columns: [b.x, b._row_id] }
- sql: |
    /* Ensure that natural joins bind the correct columns */
    create table a(x int);
    create table b(x int);
    create table c(y int);
    select * from a natural join b natural join c;
  logical_plan: |
    LogicalProject { exprs: [a.x, c.y] }
      LogicalJoin { type: Inner, on: true, output: all }
        LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
          LogicalScan { table: a, columns: [a.x, a._row_id] }
          LogicalScan { table: b, columns: [b.x, b._row_id] }
        LogicalScan { table: c, columns: [c.y, c._row_id] }
- sql: |
    /* Ensure that natural joins can disambiguate columns */
    create table a(x int);
    create table b(x int);
    select x, a.x, b.x from a natural join b;
  logical_plan: |
    LogicalProject { exprs: [a.x, a.x, b.x] }
      LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
        LogicalScan { table: a, columns: [a.x, a._row_id] }
        LogicalScan { table: b, columns: [b.x, b._row_id] }
- sql: |
    /* Ensure that natural joins bind the correct columns */
    create table a(x int);
    create table b(x int);
    create table c(y int);
    select * from a natural join b natural join c;
  logical_plan: |
    LogicalProject { exprs: [a.x, c.y] }
      LogicalJoin { type: Inner, on: true, output: all }
        LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
          LogicalScan { table: a, columns: [a.x, a._row_id] }
          LogicalScan { table: b, columns: [b.x, b._row_id] }
        LogicalScan { table: c, columns: [c.y, c._row_id] }
- sql: |
    /* Ensure that natural joins bind the correct columns */
    create table a(x int);
    create table b(x int);
    select x from a natural join b;
  logical_plan: |
    LogicalProject { exprs: [a.x] }
      LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
        LogicalScan { table: a, columns: [a.x, a._row_id] }
        LogicalScan { table: b, columns: [b.x, b._row_id] }
- sql: |
    /* Ensure that natural joins bind the correct columns */
    create table a(x int);
    create table b(x int);
    select x from a natural left join b;
  logical_plan: |
    LogicalProject { exprs: [a.x] }
      LogicalJoin { type: LeftOuter, on: (a.x = b.x), output: all }
        LogicalScan { table: a, columns: [a.x, a._row_id] }
        LogicalScan { table: b, columns: [b.x, b._row_id] }
- sql: |
    /* Ensure that natural joins bind the correct columns */
    create table a(x int);
    create table b(x int);
    select x, a.x, b.x from a natural right join b;
  logical_plan: |
    LogicalProject { exprs: [b.x, a.x, b.x] }
      LogicalJoin { type: RightOuter, on: (a.x = b.x), output: all }
        LogicalScan { table: a, columns: [a.x, a._row_id] }
        LogicalScan { table: b, columns: [b.x, b._row_id] }
- sql: |
    /* Ensure that natural joins bind the correct columns */
    create table a(x int);
    create table b(x int);
    select x, a.x, b.x from a natural full join b;
  logical_plan: |
    LogicalProject { exprs: [Coalesce(a.x, b.x), a.x, b.x] }
      LogicalJoin { type: FullOuter, on: (a.x = b.x), output: all }
        LogicalScan { table: a, columns: [a.x, a._row_id] }
        LogicalScan { table: b, columns: [b.x, b._row_id] }
- sql: |
    /* Ensure that nested natural joins bind and disambiguate columns */
    create table a(x int, y int);
    create table b(x int, z int);
    create table c(x int, a int);
    select x, a.x, b.x, c.x from a natural join b natural join c;
  logical_plan: |
    LogicalProject { exprs: [a.x, a.x, b.x, c.x] }
      LogicalJoin { type: Inner, on: (a.x = c.x), output: all }
        LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
          LogicalScan { table: a, columns: [a.x, a.y, a._row_id] }
          LogicalScan { table: b, columns: [b.x, b.z, b._row_id] }
        LogicalScan { table: c, columns: [c.x, c.a, c._row_id] }
- sql: |
    /* Ensure that nested natural joins bind and disambiguate columns */
    create table a(x int, y int);
    create table b(x int, z int);
    create table c(x int, a int);
    select x, a.x, b.x, c.x from a natural full join b natural full join c;
  logical_plan: |
    LogicalProject { exprs: [Coalesce(a.x, b.x, c.x), a.x, b.x, c.x] }
      LogicalJoin { type: FullOuter, on: (Coalesce(a.x, b.x) = c.x), output: all }
        LogicalJoin { type: FullOuter, on: (a.x = b.x), output: all }
          LogicalScan { table: a, columns: [a.x, a.y, a._row_id] }
          LogicalScan { table: b, columns: [b.x, b.z, b._row_id] }
        LogicalScan { table: c, columns: [c.x, c.a, c._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [Coalesce(a.x, b.x, c.x), a.x, b.x, c.x] }
      LogicalJoin { type: FullOuter, on: (Coalesce(a.x, b.x) = c.x), output: [a.x, b.x, c.x] }
        LogicalProject { exprs: [a.x, b.x, Coalesce(a.x, b.x)] }
          LogicalJoin { type: FullOuter, on: (a.x = b.x), output: all }
            LogicalScan { table: a, columns: [a.x] }
            LogicalScan { table: b, columns: [b.x] }
        LogicalProject { exprs: [c.x, c.x] }
          LogicalScan { table: c, columns: [c.x] }
- sql: |
    /* Ensure that nested natural joins bind and disambiguate columns */
    create table a(a int, y int);
    create table b(x int, z int);
    create table c(x int, a int);
    select a, x, a.a, c.a, b.x, c.x from a natural full join b natural full join c;
  logical_plan: |
    LogicalProject { exprs: [Coalesce(a.a, c.a), Coalesce(b.x, c.x), a.a, c.a, b.x, c.x] }
      LogicalJoin { type: FullOuter, on: (a.a = c.a) AND (b.x = c.x), output: all }
        LogicalJoin { type: FullOuter, on: true, output: all }
          LogicalScan { table: a, columns: [a.a, a.y, a._row_id] }
          LogicalScan { table: b, columns: [b.x, b.z, b._row_id] }
        LogicalScan { table: c, columns: [c.x, c.a, c._row_id] }
- sql: |
    /* Ensure error on non-existent USING col */
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v3 int);
    select * from t1 join t2 using (v2);
  binder_error: 'Item not found: column "v2" specified in USING clause does not exist
    in right table'
- sql: |
    /* Ensure error on non-existent USING col */
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v3 int);
    select * from t1 join t2 using (v3);
  binder_error: 'Item not found: column "v3" specified in USING clause does not exist
    in left table'
- sql: |
    /* Ensure that we can correctly bind nested joins */
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    create table t3(v5 int, v6 int);
    create table t4(v7 int, v8 int);
    select * from (t1 join t2 on v1=v3) full join (t3 join t4 on v5=v7) on v2=v6 and v4=v8;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4, t3.v5, t3.v6, t4.v7, t4.v8] }
      LogicalJoin { type: FullOuter, on: (t1.v2 = t3.v6) AND (t2.v4 = t4.v8), output: all }
        LogicalJoin { type: Inner, on: (t1.v1 = t2.v3), output: all }
          LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
        LogicalJoin { type: Inner, on: (t3.v5 = t4.v7), output: all }
          LogicalScan { table: t3, columns: [t3.v5, t3.v6, t3._row_id] }
          LogicalScan { table: t4, columns: [t4.v7, t4.v8, t4._row_id] }
- sql: |
    /* Ensure that we can correctly bind nested joins with ambiguous column names */
    create table t1(x int);
    create table t2(x int);
    create table t3(x int);
    select *, x, t1.x, t2.x, t3.x from t1 full join (t2 full join t3 using (x)) using (x);
  logical_plan: |
    LogicalProject { exprs: [Coalesce(t1.x, t2.x, t3.x), Coalesce(t1.x, t2.x, t3.x), t1.x, t2.x, t3.x] }
      LogicalJoin { type: FullOuter, on: (t1.x = Coalesce(t2.x, t3.x)), output: all }
        LogicalScan { table: t1, columns: [t1.x, t1._row_id] }
        LogicalJoin { type: FullOuter, on: (t2.x = t3.x), output: all }
          LogicalScan { table: t2, columns: [t2.x, t2._row_id] }
          LogicalScan { table: t3, columns: [t3.x, t3._row_id] }
- sql: |
    /* Ensure that non-trivial ambiguous references can be resolved */
    create table a(x int);
    create table b(x int);
    select 2 * x as Y, x + x as Z from a natural full join b where 2 * x < 10 order by x + x;
  logical_plan: |
    LogicalProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))] }
      LogicalProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))] }
        LogicalFilter { predicate: ((2:Int32 * Coalesce(a.x, b.x)) < 10:Int32) }
          LogicalJoin { type: FullOuter, on: (a.x = b.x), output: all }
            LogicalScan { table: a, columns: [a.x, a._row_id] }
            LogicalScan { table: b, columns: [b.x, b._row_id] }
  batch_plan: |
    BatchProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))] }
      BatchExchange { order: [(Coalesce(a.x, b.x) + Coalesce(a.x, b.x)) ASC], dist: Single }
        BatchSort { order: [(Coalesce(a.x, b.x) + Coalesce(a.x, b.x)) ASC] }
          BatchProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))] }
            BatchFilter { predicate: ((2:Int32 * Coalesce(a.x, b.x)) < 10:Int32) }
              BatchHashJoin { type: FullOuter, predicate: a.x = b.x, output: all }
                BatchExchange { order: [], dist: HashShard(a.x) }
                  BatchScan { table: a, columns: [a.x], distribution: SomeShard }
                BatchExchange { order: [], dist: HashShard(b.x) }
                  BatchScan { table: b, columns: [b.x], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [y, z, (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))(hidden), a._row_id(hidden), b._row_id(hidden)], pk_columns: [a._row_id, b._row_id], order_descs: [(Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), a._row_id, b._row_id] }
      StreamExchange { dist: HashShard(a._row_id, b._row_id) }
        StreamProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), a._row_id, b._row_id] }
          StreamFilter { predicate: ((2:Int32 * Coalesce(a.x, b.x)) < 10:Int32) }
            StreamHashJoin { type: FullOuter, predicate: a.x = b.x, output: [a.x, b.x, a._row_id, b._row_id] }
              StreamExchange { dist: HashShard(a.x) }
                StreamTableScan { table: a, columns: [a.x, a._row_id], pk: [a._row_id], distribution: UpstreamHashShard(a._row_id) }
              StreamExchange { dist: HashShard(b.x) }
                StreamTableScan { table: b, columns: [b.x, b._row_id], pk: [b._row_id], distribution: UpstreamHashShard(b._row_id) }
- sql: |
    CREATE TABLE test (a INTEGER, b INTEGER);
    CREATE TABLE test2 (a INTEGER, c INTEGER);
    SELECT test.a, b, c FROM test, test2 WHERE test.a = test2.a AND test.b <> test2.c ORDER BY test.a;
  logical_plan: |
    LogicalProject { exprs: [test.a, test.b, test2.c] }
      LogicalProject { exprs: [test.a, test.b, test2.c, test.a] }
        LogicalFilter { predicate: (test.a = test2.a) AND (test.b <> test2.c) }
          LogicalJoin { type: Inner, on: true, output: all }
            LogicalScan { table: test, columns: [test.a, test.b, test._row_id] }
            LogicalScan { table: test2, columns: [test2.a, test2.c, test2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (test.a = test2.a) AND (test.b <> test2.c), output: [test.a, test.b, test2.c, test.a] }
      LogicalScan { table: test, columns: [test.a, test.b] }
      LogicalScan { table: test2, columns: [test2.a, test2.c] }
  batch_plan: |
    BatchProject { exprs: [test.a, test.b, test2.c] }
      BatchExchange { order: [test.a ASC], dist: Single }
        BatchSort { order: [test.a ASC] }
          BatchProject { exprs: [test.a, test.b, test2.c, test.a] }
            BatchFilter { predicate: (test.b <> test2.c) }
              BatchHashJoin { type: Inner, predicate: test.a = test2.a, output: all }
                BatchExchange { order: [], dist: HashShard(test.a) }
                  BatchScan { table: test, columns: [test.a, test.b], distribution: SomeShard }
                BatchExchange { order: [], dist: HashShard(test2.a) }
                  BatchScan { table: test2, columns: [test2.a, test2.c], distribution: SomeShard }
- sql: |
    /* Use lookup join with predicate */
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create materialized view t3 as select v1, count(v2) as v2 from t2 group by v1;
    select * from t1 join t3 where t1.v2 = t3.v1 and t3.v1 > 1;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v2 = t3.v1), output: all }
      LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
      LogicalScan { table: t3, output_columns: [t3.v1, t3.v2], required_columns: [v1, v2], predicate: (t3.v1 > 1:Int32) }
  batch_local_plan: |
    BatchLookupJoin { type: Inner, predicate: t1.v2 = t3.v1 AND (t3.v1 > 1:Int32), output: all }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
  with_config_map:
    QUERY_MODE: local
    RW_BATCH_ENABLE_LOOKUP_JOIN: 'true'
- sql: |
    /* Use project to do the calculation */
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1, t2 where t1.x + t1.y = t2.x + t2.y;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ((t1.x + t1.y) = (t2.x + t2.y)), output: [t1.x, t1.y, t2.x, t2.y] }
      LogicalProject { exprs: [t1.x, t1.y, (t1.x + t1.y)] }
        LogicalScan { table: t1, columns: [t1.x, t1.y] }
      LogicalProject { exprs: [t2.x, t2.y, (t2.x + t2.y)] }
        LogicalScan { table: t2, columns: [t2.x, t2.y] }
- sql: |
    /* Use project to align return types */
    create table t1(x int, y int);
    create table t2(x int, y decimal);
    select * from t1, t2 where t1.x = t2.y;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.x::Decimal = t2.y), output: [t1.x, t1.y, t2.x, t2.y] }
      LogicalProject { exprs: [t1.x, t1.y, t1.x::Decimal] }
        LogicalScan { table: t1, columns: [t1.x, t1.y] }
      LogicalProject { exprs: [t2.x, t2.y, t2.y] }
        LogicalScan { table: t2, columns: [t2.x, t2.y] }
