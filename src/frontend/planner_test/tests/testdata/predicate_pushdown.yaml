# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t1 (v1 int, v2 int, v3 int);
    create table t2 (v1 int, v2 int, v3 int);
    select * from t1 join t2 on t1.v1=t2.v2 and t1.v1>1 where t2.v2>2;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t1.v3, t2.v1, t2.v2, t2.v3] }
    └─LogicalFilter { predicate: (t2.v2 > 2:Int32) }
      └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) AND (t1.v1 > 1:Int32), output: all }
        ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1.v3, t1._row_id] }
        └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2.v3, t2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: all }
    ├─LogicalScan { table: t1, output_columns: [t1.v1, t1.v2, t1.v3], required_columns: [v1, v2, v3], predicate: (t1.v1 > 1:Int32) }
    └─LogicalScan { table: t2, output_columns: [t2.v1, t2.v2, t2.v3], required_columns: [v1, v2, v3], predicate: (t2.v2 > 2:Int32) }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t) where v2 > 1;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2] }
    └─LogicalFilter { predicate: (t.v2 > 1:Int32) }
      └─LogicalProject { exprs: [t.v1, t.v2] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  optimized_logical_plan: |
    LogicalScan { table: t, output_columns: [t.v1, t.v2], required_columns: [v1, v2], predicate: (t.v2 > 1:Int32) }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select v1 from (select v2, v1 from t) where v2 > 1;
  logical_plan: |
    LogicalProject { exprs: [t.v1] }
    └─LogicalFilter { predicate: (t.v2 > 1:Int32) }
      └─LogicalProject { exprs: [t.v2, t.v1] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  optimized_logical_plan: |
    LogicalScan { table: t, output_columns: [t.v1], required_columns: [v1, v2], predicate: (t.v2 > 1:Int32) }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select v1 from (select v2 as a2, v1 from t where v1 > 2) where a2 > 1;
  logical_plan: |
    LogicalProject { exprs: [t.v1] }
    └─LogicalFilter { predicate: (t.v2 > 1:Int32) }
      └─LogicalProject { exprs: [t.v2, t.v1] }
        └─LogicalFilter { predicate: (t.v1 > 2:Int32) }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  optimized_logical_plan: |
    LogicalScan { table: t, output_columns: [t.v1], required_columns: [v1, v2], predicate: (t.v2 > 1:Int32) AND (t.v1 > 2:Int32) }
- sql: |
    create table t(v1 int, v2 int, v3 int, v4 int);
    select * from (select v1, min(v2) as min from t group by v1) where v1 > 1 and min > 1 and 1 > 0 and v1 > min;
  logical_plan: |
    LogicalProject { exprs: [t.v1, min(t.v2)] }
    └─LogicalFilter { predicate: (t.v1 > 1:Int32) AND (min(t.v2) > 1:Int32) AND (1:Int32 > 0:Int32) AND (t.v1 > min(t.v2)) }
      └─LogicalProject { exprs: [t.v1, min(t.v2)] }
        └─LogicalAgg { group_key: [t.v1], aggs: [min(t.v2)] }
          └─LogicalProject { exprs: [t.v1, t.v2] }
            └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: (min(t.v2) > 1:Int32) AND (t.v1 > min(t.v2)) }
    └─LogicalAgg { group_key: [t.v1], aggs: [min(t.v2)] }
      └─LogicalScan { table: t, output_columns: [t.v1, t.v2], required_columns: [v1, v2], predicate: (t.v1 > 1:Int32) AND (1:Int32 > 0:Int32) }
- name: filter limit transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int);
    with cte as (select * from t limit 10) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
      └─LogicalLimit { limit: 10, offset: 0 }
        └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
    └─LogicalLimit { limit: 10, offset: 0 }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4] }
- name: filter topN transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int);
    with cte as (select * from t order by v1 limit 10 ) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
      └─LogicalTopN { order: "[t.v1 ASC]", limit: 10, offset: 0 }
        └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
    └─LogicalTopN { order: "[t.v1 ASC]", limit: 10, offset: 0 }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4] }
- name: filter hop transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select * from hop(t, ts, interval '1' day, interval '3' day))
    select * from cte
    where v1=10 AND v2=20 AND v3=30 AND ts >= date '1997-07-01'
    AND window_start >= date '1997-07-02' AND window_end >= date '1997-07-03'
    AND window_start >= ts + interval '1' day AND window_end > ts + interval '4' day;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, t.ts, window_start, window_end] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (t.ts >= '1997-07-01':Varchar::Date) AND (window_start >= '1997-07-02':Varchar::Date) AND (window_end >= '1997-07-03':Varchar::Date) AND (window_start >= (t.ts + '1 day':Interval)) AND (window_end > (t.ts + '4 days':Interval)) }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, t.ts, window_start, window_end] }
        └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: all }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (t.ts >= '1997-07-01':Varchar::Date) AND (window_start >= '1997-07-02':Varchar::Date) AND (window_end >= '1997-07-03':Varchar::Date) AND (window_start >= (t.ts + '1 day':Interval)) AND (window_end > (t.ts + '4 days':Interval)) }
    └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: all }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts] }
- name: filter union transpose
  sql: |
    create table t1 (v1 int, v2 int, v3 int);
    create table t2 (v1 int, v2 int, v3 int);
    with cte as (select * from t1 union all select * from t2) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t1.v3] }
    └─LogicalFilter { predicate: (t1.v1 = 10:Int32) AND (t1.v2 = 20:Int32) AND (t1.v3 = 30:Int32) }
      └─LogicalUnion { all: true }
        ├─LogicalProject { exprs: [t1.v1, t1.v2, t1.v3] }
        | └─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1.v3, t1._row_id] }
        └─LogicalProject { exprs: [t2.v1, t2.v2, t2.v3] }
          └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2.v3, t2._row_id] }
  optimized_logical_plan: |
    LogicalUnion { all: true }
    ├─LogicalScan { table: t1, output_columns: [t1.v1, t1.v2, t1.v3], required_columns: [v1, v2, v3], predicate: (t1.v1 = 10:Int32) AND (t1.v2 = 20:Int32) AND (t1.v3 = 30:Int32) }
    └─LogicalScan { table: t2, output_columns: [t2.v1, t2.v2, t2.v3], required_columns: [v1, v2, v3], predicate: (t2.v1 = 10:Int32) AND (t2.v2 = 20:Int32) AND (t2.v3 = 30:Int32) }
- name: filter project transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select v1,v2,v3,v4,v1+v2 as expr_a from t) select * from cte where expr_a>10 AND v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, (t.v1 + t.v2)] }
    └─LogicalFilter { predicate: ((t.v1 + t.v2) > 10:Int32) AND (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, (t.v1 + t.v2)] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, (t.v1 + t.v2)] }
    └─LogicalScan { table: t, output_columns: [t.v1, t.v2, t.v3, t.v4], required_columns: [v1, v2, v3, v4], predicate: ((t.v1 + t.v2) > 10:Int32) AND (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
- name: filter agg transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select v1, v2, v3, count(*) from t group by v1, v2, v3) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, count] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, count] }
        └─LogicalAgg { group_key: [t.v1, t.v2, t.v3], aggs: [count] }
          └─LogicalProject { exprs: [t.v1, t.v2, t.v3] }
            └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [t.v1, t.v2, t.v3], aggs: [count] }
    └─LogicalScan { table: t, output_columns: [t.v1, t.v2, t.v3], required_columns: [v1, v2, v3], predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
- name: filter project set transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, arr int[]);
    with cte as (select v1, v2, v3, unnest(arr) as arr_unnested from t) select * from cte where v1=10 AND v2=20 AND v3=30 AND arr_unnested=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, Unnest($3)] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (Unnest($3) = 30:Int32) }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, Unnest($3)] }
        └─LogicalProjectSet { select_list: [$0, $1, $2, Unnest($3)] }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.arr, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, Unnest($3)] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (Unnest($3) = 30:Int32) }
      └─LogicalProjectSet { select_list: [$0, $1, $2, Unnest($3)] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.arr, t._row_id] }
- name: filter inner join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
        └─LogicalJoin { type: Inner, on: true, output: all }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: true, output: all }
    ├─LogicalScan { table: t1, output_columns: [t1.v1, t1.v2], required_columns: [v1, v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalScan { table: t2, output_columns: [t2.v3, t2.v4], required_columns: [v3, v4], predicate: IsNull(t2.v3) AND IsNull(t2.v4) }
- name: filter left join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 left join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
        └─LogicalJoin { type: LeftOuter, on: true, output: all }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: IsNull(t2.v3) AND IsNull(t2.v4) }
    └─LogicalJoin { type: LeftOuter, on: true, output: all }
      ├─LogicalScan { table: t1, output_columns: [t1.v1, t1.v2], required_columns: [v1, v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
      └─LogicalScan { table: t2, columns: [t2.v3, t2.v4] }
- name: filter right join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 right join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
        └─LogicalJoin { type: RightOuter, on: true, output: all }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalJoin { type: LeftOuter, on: true, output: [t1.v1, t1.v2, t2.v3, t2.v4] }
      ├─LogicalScan { table: t2, output_columns: [t2.v3, t2.v4], required_columns: [v3, v4], predicate: IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
- name: filter full outer join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 full outer join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
        └─LogicalJoin { type: FullOuter, on: true, output: all }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
    └─LogicalJoin { type: FullOuter, on: true, output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
      └─LogicalScan { table: t2, columns: [t2.v3, t2.v4] }
- name: filter semi join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    with cte as (select * from t1 where exists (select * from t2)) select * from cte where v1 is null AND v2 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
      └─LogicalProject { exprs: [t1.v1, t1.v2] }
        └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalProject { exprs: [t2.v1, t2.v2] }
            └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: true, output: all }
    ├─LogicalScan { table: t1, output_columns: [t1.v1, t1.v2], required_columns: [v1, v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalScan { table: t2, columns: [] }
- name: filter anti join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    with cte as (select * from t1 where not exists (select * from t2)) select * from cte where v1 is null AND v2 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
      └─LogicalProject { exprs: [t1.v1, t1.v2] }
        └─LogicalApply { type: LeftAnti, on: true, correlated_id: 1 }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalProject { exprs: [t2.v1, t2.v2] }
            └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: LeftAnti, on: true, output: all }
    ├─LogicalScan { table: t1, output_columns: [t1.v1, t1.v2], required_columns: [v1, v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalScan { table: t2, columns: [] }
