# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    values (ARRAY['foo', 'bar']);
  logical_plan: |
    LogicalValues { rows: [[Array('foo':Varchar, 'bar':Varchar)]], schema: Schema { fields: [*VALUES*_0.column_0:List { datatype: Varchar }] } }
  batch_plan: |
    BatchValues { rows: [[Array('foo':Varchar, 'bar':Varchar)]] }
- sql: |
    values (ARRAY[1, 2+3, 4*5+1]);
  logical_plan: |
    LogicalValues { rows: [[Array(1:Int32, (2:Int32 + 3:Int32), ((4:Int32 * 5:Int32) + 1:Int32))]], schema: Schema { fields: [*VALUES*_0.column_0:List { datatype: Int32 }] } }
  batch_plan: |
    BatchValues { rows: [[Array(1:Int32, (2:Int32 + 3:Int32), ((4:Int32 * 5:Int32) + 1:Int32))]] }
- sql: |
    create table t (v1 int);
    select (ARRAY[1, v1]) from t;
  logical_plan: |
    LogicalProject { exprs: [Array(1:Int32, t.v1)] }
      LogicalScan { table: t, columns: [t.v1, t._row_id] }
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [Array(1:Int32, t.v1)] }
        BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    select ARRAY[null];
  logical_plan: |
    LogicalProject { exprs: [Array(null:Varchar)] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    /* PostgreSQL requires a cast from user for this. But we treat it as varchar[] here. */
    select ARRAY[];
  logical_plan: |
    LogicalProject { exprs: [Array] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select ARRAY[]::int[];
  logical_plan: |
    LogicalProject { exprs: [Array::List { datatype: Int32 }] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select array_cat(array[66], array[123]);
  logical_plan: |
    LogicalProject { exprs: [ArrayCat(Array(66:Int32), Array(123:Int32))] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |
    BatchProject { exprs: [ArrayCat(Array(66:Int32), Array(123:Int32))] }
      BatchValues { rows: [[]] }
- sql: |
    select array_cat(array[array[66]], array[233]);
  logical_plan: |
    LogicalProject { exprs: [ArrayCat(Array(Array(66:Int32)), Array(233:Int32))] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |
    BatchProject { exprs: [ArrayCat(Array(Array(66:Int32)), Array(233:Int32))] }
      BatchValues { rows: [[]] }
- sql: |
    select array_cat(array[233], array[array[66]]);
  logical_plan: |
    LogicalProject { exprs: [ArrayCat(Array(233:Int32), Array(Array(66:Int32)))] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |
    BatchProject { exprs: [ArrayCat(Array(233:Int32), Array(Array(66:Int32)))] }
      BatchValues { rows: [[]] }
- sql: |
    select array_cat(array[233], array[array[array[66]]]);
  binder_error: 'Bind error: Cannot concatenate integer[] and integer[][][]'
- sql: |
    select array_cat(array[233], 123);
  binder_error: 'Bind error: Cannot concatenate integer[] and integer'
- sql: |
    select array_cat(123, array[233]);
  binder_error: 'Bind error: Cannot concatenate integer and integer[]'
- sql: |
    select array_append(array[66], 123);
  logical_plan: |
    LogicalProject { exprs: [ArrayAppend(Array(66:Int32), 123:Int32)] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |
    BatchProject { exprs: [ArrayAppend(Array(66:Int32), 123:Int32)] }
      BatchValues { rows: [[]] }
- sql: |
    select array_append(123, 234);
  binder_error: 'Bind error: Cannot append integer to integer'
- sql: |
    select array_append(array[array[66]], array[233]);
  binder_error: 'Bind error: Cannot append integer[] to integer[][]'
- sql: |
    select array_prepend(123, array[66]);
  logical_plan: |
    LogicalProject { exprs: [ArrayPrepend(123:Int32, Array(66:Int32))] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |
    BatchProject { exprs: [ArrayPrepend(123:Int32, Array(66:Int32))] }
      BatchValues { rows: [[]] }
- sql: |
    select array_prepend(123, 234);
  binder_error: 'Bind error: Cannot prepend integer to integer'
- sql: |
    select array_prepend(array[233], array[array[66]]);
  binder_error: 'Bind error: Cannot prepend integer[] to integer[][]'
- sql: |
    /* string from/to varchar[] in implicit context */
    values (array['a', 'b']), ('{c,' || 'd}');
  binder_error: 'Bind error: types List { datatype: Varchar } and Varchar cannot be
    matched'
- sql: |
    /* string to varchar[] in assign context */
    create table t (v1 varchar[]);
    insert into t values ('{c,' || 'd}');
  binder_error: 'Bind error: cannot cast type "varchar" to "varchar[]" in Assign context'
- sql: |
    /* string to varchar[] in explicit context */
    select ('{c,' || 'd}')::varchar[];
  logical_plan: |
    LogicalProject { exprs: [ConcatOp('{c,':Varchar, 'd}':Varchar)::List { datatype: Varchar }] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    /* unknown to varchar[] in implicit context */
    values (array['a', 'b']), ('{c,d}');
  logical_plan: |
    LogicalValues { rows: [[Array('a':Varchar, 'b':Varchar)], ['{c,d}':Varchar::List { datatype: Varchar }]], schema: Schema { fields: [*VALUES*_0.column_0:List { datatype: Varchar }] } }
- sql: |
    /* unknown to varchar[] in assign context */
    create table t (v1 varchar[]);
    insert into t values ('{c,d}');
  logical_plan: |
    LogicalInsert { table: t }
      LogicalValues { rows: [['{c,d}':Varchar::List { datatype: Varchar }]], schema: Schema { fields: [*VALUES*_0.column_0:List { datatype: Varchar }] } }
- sql: |
    /* unknown to varchar[] in explicit context */
    select ('{c,d}')::varchar[];
  logical_plan: |
    LogicalProject { exprs: ['{c,d}':Varchar::List { datatype: Varchar }] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    /* varchar[] to string in assign context */
    create table t (v1 varchar);
    insert into t values (array['a', 'b']);
  logical_plan: |
    LogicalInsert { table: t }
      LogicalValues { rows: [[Array('a':Varchar, 'b':Varchar)::Varchar]], schema: Schema { fields: [*VALUES*_0.column_0:Varchar] } }
- sql: |
    /* varchar[] to string in explicit context */
    select array['a', 'b']::varchar;
  logical_plan: |
    LogicalProject { exprs: [Array('a':Varchar, 'b':Varchar)::Varchar] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
