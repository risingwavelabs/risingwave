# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    /* insert values on matching types */
    create table t (v1 int, v2 int);
    insert into t values (22, 33), (44, 55);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchInsert { table: t }
        BatchValues { rows: [[22:Int32, 33:Int32], [44:Int32, 55:Int32]] }
- sql: |
    /* insert values on assign-castable types */
    create table t (v1 real, v2 int);
    insert into t values (22.33, '33'), (44, 55.0);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchInsert { table: t }
        BatchValues { rows: [[22.33:Decimal::Float32, '33':Varchar::Int32], [44:Int32::Float32, 55.0:Decimal::Int32]] }
- sql: |
    /* insert values on non-assign-castable types */
    create table t (v1 real, v2 int);
    insert into t values (22.33, true);
  binder_error: 'Bind error: cannot cast type "boolean" to "integer" in Assign context'
- sql: |
    /* insert values mismatch columns length */
    create table t (v1 real, v2 int, v3 varchar);
    insert into t values (1, 2), (3, 4);
  binder_error: 'Bind error: INSERT has more target columns than expressions'
- sql: |
    /* insert literal null */
    create table t(v1 int);
    insert into t values(NULL);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchInsert { table: t }
        BatchValues { rows: [[null:Int32]] }
- sql: |
    /* insert values cast each expr rather than whole `VALUES` (compare with below) */
    create table t (v1 time);
    insert into t values (timestamp '2020-01-01 01:02:03'), (time '03:04:05');
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchInsert { table: t }
        BatchValues { rows: [['2020-01-01 01:02:03':Varchar::Timestamp::Time], ['03:04:05':Varchar::Time]] }
- sql: |
    /* a `VALUES` without insert context may be invalid on its own (compare with above) */
    create table t (v1 time);
    values (timestamp '2020-01-01 01:02:03'), (time '03:04:05');
  binder_error: 'Bind error: types Timestamp and Time cannot be matched'
- sql: |
    /* a `VALUES` with `limit` loses insert context (compare with 2 cases above) */
    create table t (v1 time);
    insert into t values (timestamp '2020-01-01 01:02:03'), (time '03:04:05') limit 1;
  binder_error: 'Bind error: types Timestamp and Time cannot be matched'
- sql: |
    /* null in first row without insert context */
    values (null), (1);
  batch_plan: |
    BatchValues { rows: [[null:Int32], [1:Int32]] }
- sql: |
    /* null in later rows without insert context */
    values (1), (null), (2.3);
  batch_plan: |
    BatchValues { rows: [[1:Int32::Decimal], [null:Decimal], [2.3:Decimal]] }
- sql: |
    /* rows of different number of columns */
    values (1), (2, 3);
  binder_error: 'Bind error: VALUES lists must all be the same length'
- sql: |
    /* insert into select without cast */
    create table t (v1 time);
    insert into t select v1 from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchInsert { table: t }
        BatchExchange { order: [], dist: Single }
          BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    /* insert into select with cast */
    create table t (v1 time, v2 int, v3 real);
    insert into t select timestamp '2020-01-01 01:02:03', 11, 4.5 from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchInsert { table: t }
        BatchExchange { order: [], dist: Single }
          BatchProject { exprs: ['2020-01-01 01:02:03':Varchar::Timestamp::Time, 11:Int32, 4.5:Decimal::Float32] }
            BatchScan { table: t, columns: [], distribution: SomeShard }
- sql: |
    /* insert into select with cast error */
    create table t (v1 timestamp, v2 real);
    insert into t select time '01:02:03', 4.5 from t;
  binder_error: 'Bind error: cannot cast type "time without time zone" to "timestamp
    without time zone" in Assign context'
- sql: |
    /* insert into select mismatch columns length */
    create table t (v1 int, v2 real);
    insert into t select 2, 3, 4.5 from t;
  binder_error: 'Bind error: INSERT has more expressions than target columns'
- sql: |
    /* insert with join */
    create table t1 (a int, b int);
    create table t2 (c int, d int);
    create table t3 (e int, f int);
    insert into t1 select c, e from t2 join t3 on t2.d = t3.f
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchInsert { table: t1 }
        BatchExchange { order: [], dist: Single }
          BatchHashJoin { type: Inner, predicate: t2.d = t3.f, output: [t2.c, t3.e] }
            BatchExchange { order: [], dist: HashShard(t2.d) }
              BatchScan { table: t2, columns: [t2.c, t2.d], distribution: SomeShard }
            BatchExchange { order: [], dist: HashShard(t3.f) }
              BatchScan { table: t3, columns: [t3.e, t3.f], distribution: SomeShard }
