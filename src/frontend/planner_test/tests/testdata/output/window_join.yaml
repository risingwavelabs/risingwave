# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Window join
  sql: |
    create source t1 (ts1 timestamp with time zone, a1 int, b1 int, watermark for ts1 as ts1 - INTERVAL '1' SECOND) with (
    connector = 'datagen',
    datagen.rows.per.second = '10',
    );
    create source t2 (ts2 timestamp with time zone, a2 int, b2 int, watermark for ts2 as ts2 - INTERVAL '1' SECOND) with (
    connector = 'datagen',
    datagen.rows.per.second = '10',
    );
    select * from t1, t2 where ts1 = ts2 and a1 = a2;
  stream_plan: |-
    StreamMaterialize { columns: [ts1, a1, b1, ts2, a2, b2, _row_id(hidden), _row_id#1(hidden)], stream_key: [_row_id, _row_id#1, ts1, a1], pk_columns: [_row_id, _row_id#1, ts1, a1], pk_conflict: NoCheck, watermark_columns: [ts1, ts2] }
    └─StreamHashJoin [window, append_only] { type: Inner, predicate: ts1 = ts2 AND a1 = a2, output_watermarks: [ts1, ts2], output: [ts1, a1, b1, ts2, a2, b2, _row_id, _row_id] }
      ├─StreamExchange { dist: HashShard(ts1, a1) }
      │ └─StreamRowIdGen { row_id_index: 3 }
      │   └─StreamWatermarkFilter { watermark_descs: [Desc { idx: 0, expr: (ts1 - '00:00:01':Interval) }] }
      │     └─StreamSource { source: t1, columns: [ts1, a1, b1, _row_id] }
      └─StreamExchange { dist: HashShard(ts2, a2) }
        └─StreamRowIdGen { row_id_index: 3 }
          └─StreamWatermarkFilter { watermark_descs: [Desc { idx: 0, expr: (ts2 - '00:00:01':Interval) }] }
            └─StreamSource { source: t2, columns: [ts2, a2, b2, _row_id] }
- name: Window join expression reorder
  sql: |
    create source t1 (ts1 timestamp with time zone, a1 int, b1 int, watermark for ts1 as ts1 - INTERVAL '1' SECOND) with (
    connector = 'datagen',
    datagen.rows.per.second = '10',
    );
    create source t2 (ts2 timestamp with time zone, a2 int, b2 int, watermark for ts2 as ts2 - INTERVAL '1' SECOND) with (
    connector = 'datagen',
    datagen.rows.per.second = '10',
    );
    select * from t1, t2 where a1 = a2 and ts1 = ts2;
  stream_plan: |-
    StreamMaterialize { columns: [ts1, a1, b1, ts2, a2, b2, _row_id(hidden), _row_id#1(hidden)], stream_key: [_row_id, _row_id#1, a1, ts1], pk_columns: [_row_id, _row_id#1, a1, ts1], pk_conflict: NoCheck, watermark_columns: [ts1, ts2] }
    └─StreamHashJoin [window, append_only] { type: Inner, predicate: ts1 = ts2 AND a1 = a2, output_watermarks: [ts1, ts2], output: [ts1, a1, b1, ts2, a2, b2, _row_id, _row_id] }
      ├─StreamExchange { dist: HashShard(ts1, a1) }
      │ └─StreamRowIdGen { row_id_index: 3 }
      │   └─StreamWatermarkFilter { watermark_descs: [Desc { idx: 0, expr: (ts1 - '00:00:01':Interval) }] }
      │     └─StreamSource { source: t1, columns: [ts1, a1, b1, _row_id] }
      └─StreamExchange { dist: HashShard(ts2, a2) }
        └─StreamRowIdGen { row_id_index: 3 }
          └─StreamWatermarkFilter { watermark_descs: [Desc { idx: 0, expr: (ts2 - '00:00:01':Interval) }] }
            └─StreamSource { source: t2, columns: [ts2, a2, b2, _row_id] }
