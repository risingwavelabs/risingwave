# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Window join
  sql: |
    create source t1 (ts1 timestamp with time zone, a1 int, b1 int, watermark for ts1 as ts1 - INTERVAL '1' SECOND) with (
    connector = 'datagen',
    datagen.rows.per.second = '10',
    );
    create source t2 (ts2 timestamp with time zone, a2 int, b2 int, watermark for ts2 as ts2 - INTERVAL '1' SECOND) with (
    connector = 'datagen',
    datagen.rows.per.second = '10',
    );
    select * from t1, t2 where ts1 = ts2 and a1 = a2;
  stream_plan: |-
    StreamMaterialize { columns: [ts1, a1, b1, ts2, a2, b2, _row_id(hidden), _row_id#1(hidden)], stream_key: [_row_id, _row_id#1, ts1, a1], pk_columns: [_row_id, _row_id#1, ts1, a1], pk_conflict: NoCheck, watermark_columns: [ts1, ts2] }
    └─StreamExchange { dist: HashShard(ts1, a1, _row_id, _row_id) }
      └─StreamHashJoin [window, append_only] { type: Inner, predicate: ts1 = ts2 AND a1 = a2, output_watermarks: [[ts1], [ts2]], output: [ts1, a1, b1, ts2, a2, b2, _row_id, _row_id] }
        ├─StreamExchange { dist: HashShard(ts1, a1) }
        │ └─StreamRowIdGen { row_id_index: 3 }
        │   └─StreamWatermarkFilter { watermark_descs: [Desc { column: ts1, expr: (ts1 - '00:00:01':Interval) }], output_watermarks: [[ts1]] }
        │     └─StreamSource { source: t1, columns: [ts1, a1, b1, _row_id] }
        └─StreamExchange { dist: HashShard(ts2, a2) }
          └─StreamRowIdGen { row_id_index: 3 }
            └─StreamWatermarkFilter { watermark_descs: [Desc { column: ts2, expr: (ts2 - '00:00:01':Interval) }], output_watermarks: [[ts2]] }
              └─StreamSource { source: t2, columns: [ts2, a2, b2, _row_id] }
- name: Window join expression reorder
  sql: |
    create source t1 (ts1 timestamp with time zone, a1 int, b1 int, watermark for ts1 as ts1 - INTERVAL '1' SECOND) with (
    connector = 'datagen',
    datagen.rows.per.second = '10',
    );
    create source t2 (ts2 timestamp with time zone, a2 int, b2 int, watermark for ts2 as ts2 - INTERVAL '1' SECOND) with (
    connector = 'datagen',
    datagen.rows.per.second = '10',
    );
    select * from t1, t2 where a1 = a2 and ts1 = ts2;
  stream_plan: |-
    StreamMaterialize { columns: [ts1, a1, b1, ts2, a2, b2, _row_id(hidden), _row_id#1(hidden)], stream_key: [_row_id, _row_id#1, a1, ts1], pk_columns: [_row_id, _row_id#1, a1, ts1], pk_conflict: NoCheck, watermark_columns: [ts1, ts2] }
    └─StreamExchange { dist: HashShard(ts1, a1, _row_id, _row_id) }
      └─StreamHashJoin [window, append_only] { type: Inner, predicate: ts1 = ts2 AND a1 = a2, output_watermarks: [[ts1], [ts2]], output: [ts1, a1, b1, ts2, a2, b2, _row_id, _row_id] }
        ├─StreamExchange { dist: HashShard(ts1, a1) }
        │ └─StreamRowIdGen { row_id_index: 3 }
        │   └─StreamWatermarkFilter { watermark_descs: [Desc { column: ts1, expr: (ts1 - '00:00:01':Interval) }], output_watermarks: [[ts1]] }
        │     └─StreamSource { source: t1, columns: [ts1, a1, b1, _row_id] }
        └─StreamExchange { dist: HashShard(ts2, a2) }
          └─StreamRowIdGen { row_id_index: 3 }
            └─StreamWatermarkFilter { watermark_descs: [Desc { column: ts2, expr: (ts2 - '00:00:01':Interval) }], output_watermarks: [[ts2]] }
              └─StreamSource { source: t2, columns: [ts2, a2, b2, _row_id] }
