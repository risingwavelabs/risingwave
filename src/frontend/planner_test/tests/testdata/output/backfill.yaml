# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: backfill order, no order, empty
  sql: |
    create table t1(v1 int);
    select * from t1;
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
  backfill_order_plan: |
    digraph G {
    }
- name: backfill order, auto, empty
  sql: |
    create table t1(v1 int);
    select * from t1;
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
  backfill_order_plan: |
    digraph G {
    }
- name: backfill order, auto, non-empty
  sql: |
    create table t1(v1 int);
    create table t2(v2 int);
    select * from t1 join t2 on t1.v1 = t2.v2;
  stream_plan: |-
    StreamMaterialize { columns: [v1, v2, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, v1], pk_columns: [t1._row_id, t2._row_id, v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.v1, t1._row_id, t2._row_id) }
      └─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v2, output: [t1.v1, t2.v2, t1._row_id, t2._row_id] }
        ├─StreamExchange { dist: HashShard(t1.v1) }
        │ └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard(t2.v2) }
          └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
  backfill_order_plan: |
    digraph G {
      "public.t2" -> "public.t1";
    }
- name: backfill order, fixed, non-empty
  sql: |
    create table t1(v1 int);
    create table t2(v2 int);
    select * from t1 join t2 on t1.v1 = t2.v2;
  stream_plan: |-
    StreamMaterialize { columns: [v1, v2, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, v1], pk_columns: [t1._row_id, t2._row_id, v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.v1, t1._row_id, t2._row_id) }
      └─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v2, output: [t1.v1, t2.v2, t1._row_id, t2._row_id] }
        ├─StreamExchange { dist: HashShard(t1.v1) }
        │ └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard(t2.v2) }
          └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
  backfill_order_plan: |
    digraph G {
      "public.t2" -> "public.t1";
    }
- name: backfill order, auto, bushy join
  sql: |
    create table fact1(v1 int);
    create table fact2(v1 int);
    create table fact3(v1 int);
    create table fact4(v1 int);
    create table dim1(v1 int);
    create table dim2(v1 int);
    create table dim3(v1 int);
    create table dim4(v1 int);
    with
         joined1 as (select fact1.v1 from fact1 left join dim1 on fact1.v1 = dim1.v1),
         joined2 as (select fact2.v1 from fact2 left join dim2 on fact2.v1 = dim2.v1),
         joined3 as (select fact3.v1 from fact3 left join dim3 on fact3.v1 = dim3.v1),
         joined4 as (select fact4.v1 from fact4 left join dim4 on fact4.v1 = dim4.v1),
         joined12 as (select joined1.v1 from joined1 left join joined2 on joined1.v1 = joined2.v1),
         joined34 as (select joined3.v1 from joined3 left join joined4 on joined3.v1 = joined4.v1),
         joined1234 as (select joined12.v1 from joined12 left join joined34 on joined12.v1 = joined34.v1)
    select * from joined1234;
  stream_plan: |-
    StreamMaterialize { columns: [v1, fact1._row_id(hidden), dim1._row_id(hidden), fact2._row_id(hidden), dim2._row_id(hidden), fact3._row_id(hidden), dim3._row_id(hidden), fact3.v1(hidden), fact4._row_id(hidden), dim4._row_id(hidden)], stream_key: [fact1._row_id, dim1._row_id, v1, fact2._row_id, dim2._row_id, fact3._row_id, dim3._row_id, fact4._row_id, dim4._row_id], pk_columns: [fact1._row_id, dim1._row_id, v1, fact2._row_id, dim2._row_id, fact3._row_id, dim3._row_id, fact4._row_id, dim4._row_id], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(fact1.v1, fact1._row_id, dim1._row_id, fact2._row_id, dim2._row_id, fact3._row_id, dim3._row_id, fact4._row_id, dim4._row_id) }
      └─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = fact3.v1, output: [fact1.v1, fact1._row_id, dim1._row_id, fact2._row_id, dim2._row_id, fact3._row_id, dim3._row_id, fact3.v1, fact4._row_id, dim4._row_id] }
        ├─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = fact2.v1, output: [fact1.v1, fact1._row_id, dim1._row_id, fact2._row_id, dim2._row_id, fact2.v1] }
        │ ├─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = dim1.v1, output: [fact1.v1, fact1._row_id, dim1._row_id] }
        │ │ ├─StreamExchange { dist: HashShard(fact1.v1) }
        │ │ │ └─StreamTableScan { table: fact1, columns: [fact1.v1, fact1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact1._row_id], pk: [_row_id], dist: UpstreamHashShard(fact1._row_id) }
        │ │ └─StreamExchange { dist: HashShard(dim1.v1) }
        │ │   └─StreamTableScan { table: dim1, columns: [dim1.v1, dim1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim1._row_id], pk: [_row_id], dist: UpstreamHashShard(dim1._row_id) }
        │ └─StreamHashJoin { type: LeftOuter, predicate: fact2.v1 = dim2.v1, output: [fact2.v1, fact2._row_id, dim2._row_id] }
        │   ├─StreamExchange { dist: HashShard(fact2.v1) }
        │   │ └─StreamTableScan { table: fact2, columns: [fact2.v1, fact2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact2._row_id], pk: [_row_id], dist: UpstreamHashShard(fact2._row_id) }
        │   └─StreamExchange { dist: HashShard(dim2.v1) }
        │     └─StreamTableScan { table: dim2, columns: [dim2.v1, dim2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim2._row_id], pk: [_row_id], dist: UpstreamHashShard(dim2._row_id) }
        └─StreamHashJoin { type: LeftOuter, predicate: fact3.v1 = fact4.v1, output: [fact3.v1, fact3._row_id, dim3._row_id, fact4._row_id, dim4._row_id, fact4.v1] }
          ├─StreamHashJoin { type: LeftOuter, predicate: fact3.v1 = dim3.v1, output: [fact3.v1, fact3._row_id, dim3._row_id] }
          │ ├─StreamExchange { dist: HashShard(fact3.v1) }
          │ │ └─StreamTableScan { table: fact3, columns: [fact3.v1, fact3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact3._row_id], pk: [_row_id], dist: UpstreamHashShard(fact3._row_id) }
          │ └─StreamExchange { dist: HashShard(dim3.v1) }
          │   └─StreamTableScan { table: dim3, columns: [dim3.v1, dim3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim3._row_id], pk: [_row_id], dist: UpstreamHashShard(dim3._row_id) }
          └─StreamHashJoin { type: LeftOuter, predicate: fact4.v1 = dim4.v1, output: [fact4.v1, fact4._row_id, dim4._row_id] }
            ├─StreamExchange { dist: HashShard(fact4.v1) }
            │ └─StreamTableScan { table: fact4, columns: [fact4.v1, fact4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact4._row_id], pk: [_row_id], dist: UpstreamHashShard(fact4._row_id) }
            └─StreamExchange { dist: HashShard(dim4.v1) }
              └─StreamTableScan { table: dim4, columns: [dim4.v1, dim4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim4._row_id], pk: [_row_id], dist: UpstreamHashShard(dim4._row_id) }
  backfill_order_plan: |
    digraph G {
      "public.fact3" -> "public.fact1";
      "public.fact4" -> "public.fact3";
      "public.dim4" -> "public.fact4";
      "public.dim2" -> "public.fact2";
      "public.fact2" -> "public.fact1";
      "public.dim3" -> "public.fact3";
      "public.dim1" -> "public.fact1";
    }
- name: backfill order, auto, union, empty
  sql: |
    create table t1(v1 int);
    create table t2(v2 int);
    select * from (select * from t1 union all select * from t2);
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden), $src(hidden)], stream_key: [t1._row_id, $src], pk_columns: [t1._row_id, $src], pk_conflict: NoCheck }
    └─StreamUnion { all: true }
      ├─StreamExchange { dist: HashShard(t1._row_id, 0:Int32) }
      │ └─StreamProject { exprs: [t1.v1, t1._row_id, 0:Int32] }
      │   └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: HashShard(t2._row_id, 1:Int32) }
        └─StreamProject { exprs: [t2.v2, t2._row_id, 1:Int32] }
          └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
  backfill_order_plan: |
    digraph G {
    }
- name: backfill order, auto, union with join, non-empty
  sql: |
    create table fact1(v1 int);
    create table fact2(v1 int);
    create table fact3(v1 int);
    create table fact4(v1 int);
    create table dim1(v1 int);
    create table dim2(v1 int);
    create table dim3(v1 int);
    create table dim4(v1 int);
    with
         joined1 as (select fact1.v1 from fact1 left join dim1 on fact1.v1 = dim1.v1),
         joined2 as (select fact2.v1 from fact2 left join dim2 on fact2.v1 = dim2.v1),
         joined3 as (select fact3.v1 from fact3 left join dim3 on fact3.v1 = dim3.v1),
         joined4 as (select fact4.v1 from fact4 left join dim4 on fact4.v1 = dim4.v1),
         union12 as (select joined1.v1 from joined1 union all select joined2.v1 from joined2),
         union34 as (select joined3.v1 from joined3 union all select joined4.v1 from joined4),
         joined1234 as (select union12.v1 from union12 left join union34 on union12.v1 = union34.v1)
    select * from joined1234;
  stream_plan: |-
    StreamMaterialize { columns: [v1, fact1._row_id(hidden), dim1._row_id(hidden), fact1.v1(hidden), $src(hidden), fact3._row_id(hidden), dim3._row_id(hidden), fact3.v1(hidden), $src#1(hidden)], stream_key: [fact1._row_id, dim1._row_id, fact1.v1, $src, fact3._row_id, dim3._row_id, fact3.v1, $src#1, v1], pk_columns: [fact1._row_id, dim1._row_id, fact1.v1, $src, fact3._row_id, dim3._row_id, fact3.v1, $src#1, v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(fact1.v1, fact1._row_id, dim1._row_id, fact1.v1, $src, fact3._row_id, dim3._row_id, fact3.v1, $src) }
      └─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = fact3.v1, output: [fact1.v1, fact1._row_id, dim1._row_id, fact1.v1, $src, fact3._row_id, dim3._row_id, fact3.v1, $src] }
        ├─StreamExchange { dist: HashShard(fact1.v1) }
        │ └─StreamUnion { all: true }
        │   ├─StreamExchange { dist: HashShard(fact1._row_id, dim1._row_id, fact1.v1, 0:Int32) }
        │   │ └─StreamProject { exprs: [fact1.v1, fact1.v1, fact1._row_id, dim1._row_id, 0:Int32] }
        │   │   └─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = dim1.v1, output: [fact1.v1, fact1._row_id, dim1._row_id] }
        │   │     ├─StreamExchange { dist: HashShard(fact1.v1) }
        │   │     │ └─StreamTableScan { table: fact1, columns: [fact1.v1, fact1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact1._row_id], pk: [_row_id], dist: UpstreamHashShard(fact1._row_id) }
        │   │     └─StreamExchange { dist: HashShard(dim1.v1) }
        │   │       └─StreamTableScan { table: dim1, columns: [dim1.v1, dim1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim1._row_id], pk: [_row_id], dist: UpstreamHashShard(dim1._row_id) }
        │   └─StreamExchange { dist: HashShard(fact2._row_id, dim2._row_id, fact2.v1, 1:Int32) }
        │     └─StreamProject { exprs: [fact2.v1, fact2.v1, fact2._row_id, dim2._row_id, 1:Int32] }
        │       └─StreamHashJoin { type: LeftOuter, predicate: fact2.v1 = dim2.v1, output: [fact2.v1, fact2._row_id, dim2._row_id] }
        │         ├─StreamExchange { dist: HashShard(fact2.v1) }
        │         │ └─StreamTableScan { table: fact2, columns: [fact2.v1, fact2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact2._row_id], pk: [_row_id], dist: UpstreamHashShard(fact2._row_id) }
        │         └─StreamExchange { dist: HashShard(dim2.v1) }
        │           └─StreamTableScan { table: dim2, columns: [dim2.v1, dim2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim2._row_id], pk: [_row_id], dist: UpstreamHashShard(dim2._row_id) }
        └─StreamExchange { dist: HashShard(fact3.v1) }
          └─StreamUnion { all: true }
            ├─StreamExchange { dist: HashShard(fact3._row_id, dim3._row_id, fact3.v1, 0:Int32) }
            │ └─StreamProject { exprs: [fact3.v1, fact3.v1, fact3._row_id, dim3._row_id, 0:Int32] }
            │   └─StreamHashJoin { type: LeftOuter, predicate: fact3.v1 = dim3.v1, output: [fact3.v1, fact3._row_id, dim3._row_id] }
            │     ├─StreamExchange { dist: HashShard(fact3.v1) }
            │     │ └─StreamTableScan { table: fact3, columns: [fact3.v1, fact3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact3._row_id], pk: [_row_id], dist: UpstreamHashShard(fact3._row_id) }
            │     └─StreamExchange { dist: HashShard(dim3.v1) }
            │       └─StreamTableScan { table: dim3, columns: [dim3.v1, dim3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim3._row_id], pk: [_row_id], dist: UpstreamHashShard(dim3._row_id) }
            └─StreamExchange { dist: HashShard(fact4._row_id, dim4._row_id, fact4.v1, 1:Int32) }
              └─StreamProject { exprs: [fact4.v1, fact4.v1, fact4._row_id, dim4._row_id, 1:Int32] }
                └─StreamHashJoin { type: LeftOuter, predicate: fact4.v1 = dim4.v1, output: [fact4.v1, fact4._row_id, dim4._row_id] }
                  ├─StreamExchange { dist: HashShard(fact4.v1) }
                  │ └─StreamTableScan { table: fact4, columns: [fact4.v1, fact4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact4._row_id], pk: [_row_id], dist: UpstreamHashShard(fact4._row_id) }
                  └─StreamExchange { dist: HashShard(dim4.v1) }
                    └─StreamTableScan { table: dim4, columns: [dim4.v1, dim4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim4._row_id], pk: [_row_id], dist: UpstreamHashShard(dim4._row_id) }
  backfill_order_plan: |
    digraph G {
      "public.dim2" -> "public.fact2";
      "public.dim4" -> "public.fact4";
      "public.fact4" -> "public.fact1";
      "public.fact4" -> "public.fact2";
      "public.dim1" -> "public.fact1";
      "public.fact3" -> "public.fact1";
      "public.fact3" -> "public.fact2";
      "public.dim3" -> "public.fact3";
    }
- name: backfill order, auto, union with join, test explain
  sql: |
    create table fact1(v1 int);
    create table fact2(v1 int);
    create table fact3(v1 int);
    create table fact4(v1 int);
    create table dim1(v1 int);
    create table dim2(v1 int);
    create table dim3(v1 int);
    create table dim4(v1 int);
    explain(backfill, format dot) create materialized view m1 with (backfill_order = auto)
    as with
         joined1 as (select fact1.v1 from fact1 left join dim1 on fact1.v1 = dim1.v1),
         joined2 as (select fact2.v1 from fact2 left join dim2 on fact2.v1 = dim2.v1),
         joined3 as (select fact3.v1 from fact3 left join dim3 on fact3.v1 = dim3.v1),
         joined4 as (select fact4.v1 from fact4 left join dim4 on fact4.v1 = dim4.v1),
         union12 as (select joined1.v1 from joined1 union all select joined2.v1 from joined2),
         union34 as (select joined3.v1 from joined3 union all select joined4.v1 from joined4),
         joined1234 as (select union12.v1 from union12 left join union34 on union12.v1 = union34.v1)
    select * from joined1234;
  explain_output: |
    digraph G {
      "public.dim1" -> "public.fact1";
      "public.fact4" -> "public.fact2";
      "public.fact4" -> "public.fact1";
      "public.dim2" -> "public.fact2";
      "public.dim3" -> "public.fact3";
      "public.fact3" -> "public.fact1";
      "public.fact3" -> "public.fact2";
      "public.dim4" -> "public.fact4";
    }
- name: |
    Test backfill order, auto, stream share cycle.
    For auto derived backfill order with cycle, it should not return any order plan, and return a NOTICE
    to the user.
  sql: |
    create table fact1(v1 int);
    create table fact2(v1 int);
    create table fact3(v1 int);
    create table fact4(v1 int);
    create table dim1(v1 int);
    create table dim2(v1 int);
    create table dim3(v1 int);
    create table dim4(v1 int);
    with
        joined1 as (select fact1.v1 from fact1 left join dim1 on fact1.v1 = dim1.v1),
        joined2 as (select fact2.v1 from fact2 left join dim2 on fact2.v1 = dim2.v1),
        joined3 as (select fact3.v1 from fact3 left join dim3 on fact3.v1 = dim3.v1),
        joined12 as (select joined1.v1 from joined1 left join joined2 on joined1.v1 = joined2.v1),
        joined13 as (select joined1.v1 from joined1 left join joined3 on joined1.v1 = joined3.v1),
        joined1213 as (select joined12.v1 from joined12 left join joined13 on joined12.v1 = joined13.v1)
    select * from joined1213;
  stream_plan: |-
    StreamMaterialize { columns: [v1, fact1._row_id(hidden), dim1._row_id(hidden), fact2._row_id(hidden), dim2._row_id(hidden), fact1._row_id#1(hidden), dim1._row_id#1(hidden), fact1.v1(hidden), fact3._row_id(hidden), dim3._row_id(hidden)], stream_key: [fact1._row_id, dim1._row_id, v1, fact2._row_id, dim2._row_id, fact1._row_id#1, dim1._row_id#1, fact3._row_id, dim3._row_id], pk_columns: [fact1._row_id, dim1._row_id, v1, fact2._row_id, dim2._row_id, fact1._row_id#1, dim1._row_id#1, fact3._row_id, dim3._row_id], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(fact1.v1, fact1._row_id, dim1._row_id, fact2._row_id, dim2._row_id, fact1._row_id, dim1._row_id, fact3._row_id, dim3._row_id) }
      └─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = fact1.v1, output: [fact1.v1, fact1._row_id, dim1._row_id, fact2._row_id, dim2._row_id, fact1._row_id, dim1._row_id, fact1.v1, fact3._row_id, dim3._row_id] }
        ├─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = fact2.v1, output: [fact1.v1, fact1._row_id, dim1._row_id, fact2._row_id, dim2._row_id, fact2.v1] }
        │ ├─StreamShare { id: 4 }
        │ │ └─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = dim1.v1, output: [fact1.v1, fact1._row_id, dim1._row_id] }
        │ │   ├─StreamExchange { dist: HashShard(fact1.v1) }
        │ │   │ └─StreamTableScan { table: fact1, columns: [fact1.v1, fact1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact1._row_id], pk: [_row_id], dist: UpstreamHashShard(fact1._row_id) }
        │ │   └─StreamExchange { dist: HashShard(dim1.v1) }
        │ │     └─StreamTableScan { table: dim1, columns: [dim1.v1, dim1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim1._row_id], pk: [_row_id], dist: UpstreamHashShard(dim1._row_id) }
        │ └─StreamHashJoin { type: LeftOuter, predicate: fact2.v1 = dim2.v1, output: [fact2.v1, fact2._row_id, dim2._row_id] }
        │   ├─StreamExchange { dist: HashShard(fact2.v1) }
        │   │ └─StreamTableScan { table: fact2, columns: [fact2.v1, fact2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact2._row_id], pk: [_row_id], dist: UpstreamHashShard(fact2._row_id) }
        │   └─StreamExchange { dist: HashShard(dim2.v1) }
        │     └─StreamTableScan { table: dim2, columns: [dim2.v1, dim2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim2._row_id], pk: [_row_id], dist: UpstreamHashShard(dim2._row_id) }
        └─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = fact3.v1, output: [fact1.v1, fact1._row_id, dim1._row_id, fact3._row_id, dim3._row_id, fact3.v1] }
          ├─StreamShare { id: 4 }
          │ └─StreamHashJoin { type: LeftOuter, predicate: fact1.v1 = dim1.v1, output: [fact1.v1, fact1._row_id, dim1._row_id] }
          │   ├─StreamExchange { dist: HashShard(fact1.v1) }
          │   │ └─StreamTableScan { table: fact1, columns: [fact1.v1, fact1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact1._row_id], pk: [_row_id], dist: UpstreamHashShard(fact1._row_id) }
          │   └─StreamExchange { dist: HashShard(dim1.v1) }
          │     └─StreamTableScan { table: dim1, columns: [dim1.v1, dim1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim1._row_id], pk: [_row_id], dist: UpstreamHashShard(dim1._row_id) }
          └─StreamHashJoin { type: LeftOuter, predicate: fact3.v1 = dim3.v1, output: [fact3.v1, fact3._row_id, dim3._row_id] }
            ├─StreamExchange { dist: HashShard(fact3.v1) }
            │ └─StreamTableScan { table: fact3, columns: [fact3.v1, fact3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [fact3._row_id], pk: [_row_id], dist: UpstreamHashShard(fact3._row_id) }
            └─StreamExchange { dist: HashShard(dim3.v1) }
              └─StreamTableScan { table: dim3, columns: [dim3.v1, dim3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [dim3._row_id], pk: [_row_id], dist: UpstreamHashShard(dim3._row_id) }
  backfill_order_plan: |
    digraph G {
    }
