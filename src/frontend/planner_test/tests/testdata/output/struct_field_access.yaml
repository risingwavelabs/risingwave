# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t(c STRUCT<x INTEGER, y INTEGER>);
    select t.c.x from t
  binder_error: |-
    Bind error: failed to bind expression: t.c.x

    Caused by:
      Item not found: Invalid column: x
- sql: |
    create table t(c STRUCT<x INTEGER, y INTEGER>);
    select (t.c).x from t
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.c, 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.c, t._row_id ] }
- sql: |
    create table t(c STRUCT<x INTEGER, y INTEGER>);
    select (c).x from t
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.c, 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.c, t._row_id ] }
- sql: |
    create table t(c STRUCT<x INTEGER, y INTEGER>);
    -- select (t).c.x from t
    select (t.c).x from t
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.c, 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.c, t._row_id ] }
- sql: |
    create table t(c STRUCT<x INTEGER, y INTEGER>);
    select (t.c).* from t
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.c, 0:Int32) as $expr1, Field(t.c, 1:Int32) as $expr2 ] }
    └──  LogicalScan { table: t, columns: [ t.c, t._row_id ] }
- sql: |
    create table t(c STRUCT<x INTEGER, y INTEGER>);
    select (c).* from t
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.c, 0:Int32) as $expr1, Field(t.c, 1:Int32) as $expr2 ] }
    └──  LogicalScan { table: t, columns: [ t.c, t._row_id ] }
- sql: |
    create table t(c STRUCT<x INTEGER, y INTEGER>);
    -- select (t).c.* from t
    select (t.c).* from t
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.c, 0:Int32) as $expr1, Field(t.c, 1:Int32) as $expr2 ] }
    └──  LogicalScan { table: t, columns: [ t.c, t._row_id ] }
- sql: |
    create table t1(c STRUCT<x INTEGER, y INTEGER>);
    create table t2(c STRUCT<x INTEGER, y INTEGER>);
    select (c).x from t1 cross join t2;
  binder_error: |-
    Bind error: failed to bind expression: (c).x

    Caused by:
      Bind error: failed to bind expression: c

    Caused by:
      internal error: Ambiguous column name: c
- sql: |
    create table t1(c STRUCT<x INTEGER, y INTEGER>);
    create table t2(c STRUCT<x INTEGER, y INTEGER>);
    -- select * from t1 where exists(select * from t2 where (c).y = 100 and (t1.c).x = (t2).c.x and (c).x = 1000 and (t1).c.y = (t2.c).y);
    select * from t1 where exists(select * from t2 where (c).y = 100 and (t1.c).x = (t2.c).x and (c).x = 1000 and (t1.c).y = (t2.c).y);
  logical_plan: |-
    LogicalProject { exprs: [ t1.c ] }
    └── LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
        ├──  LogicalScan { table: t1, columns: [ t1.c, t1._row_id ] }
        └── LogicalProject { exprs: [ t2.c ] }
            └── LogicalFilter { predicate: (Field(t2.c, 1:Int32) = 100:Int32) AND (Field(CorrelatedInputRef { index: 0, correlated_id: 1 }, 0:Int32) = Field(t2.c, 0:Int32)) AND (Field(t2.c, 0:Int32) = 1000:Int32) AND (Field(CorrelatedInputRef { index: 0, correlated_id: 1 }, 1:Int32) = Field(t2.c, 1:Int32)) }
                └──  LogicalScan { table: t2, columns: [ t2.c, t2._row_id ] }
- sql: |
    create schema s;
    create table s.t(a STRUCT<b INTEGER, c INTEGER>);
    select s.t.a from s.t;
  logical_plan: |-
    LogicalProject { exprs: [ t.a ] }
    └──  LogicalScan { table: t, columns: [ t.a, t._row_id ] }
- sql: |
    create schema s;
    create table s.t(a STRUCT<b INTEGER, c INTEGER>);
    select (s.t.a).b from s.t;
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.a, 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.a, t._row_id ] }
- sql: |
    create schema s;
    create table s.t(a STRUCT<b INTEGER, c INTEGER>);
    -- select (s.t).a.b from s.t;
    select (s.t.a).b from s.t;
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.a, 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.a, t._row_id ] }
- sql: |
    create schema s;
    create table s.t(a STRUCT<b INTEGER, c INTEGER>);
    -- select ((s.t).a).b from s.t;
    select (s.t.a).b from s.t;
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.a, 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.a, t._row_id ] }
- sql: |
    create schema s;
    create table s.t(a STRUCT<b INTEGER, c INTEGER>);
    -- select (s.t).a.* from s.t;
    select (s.t.a).* from s.t;
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.a, 0:Int32) as $expr1, Field(t.a, 1:Int32) as $expr2 ] }
    └──  LogicalScan { table: t, columns: [ t.a, t._row_id ] }
- sql: |
    create schema s;
    create table s.t(a STRUCT<b INTEGER, c INTEGER>);
    -- select ((s.t).a).* from s.t;
    select (s.t.a).* from s.t;
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.a, 0:Int32) as $expr1, Field(t.a, 1:Int32) as $expr2 ] }
    └──  LogicalScan { table: t, columns: [ t.a, t._row_id ] }
- sql: |
    create schema t;
    create table t.t(t STRUCT<t INTEGER>);
    select (t.t.t).t from t.t;
  logical_plan: |-
    LogicalProject { exprs: [ Field(t.t, 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.t, t._row_id ] }
- sql: |
    create schema t;
    create table t.t(t STRUCT<t STRUCT<t INTEGER>>);
    select (t.t.t).t.t from t.t;
  logical_plan: |-
    LogicalProject { exprs: [ Field(Field(t.t, 0:Int32), 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.t, t._row_id ] }
- sql: |
    create table t(c STRUCT<x INTEGER, y INTEGER>[]);
    select (c[1]).x from t
  logical_plan: |-
    LogicalProject { exprs: [ Field(ArrayAccess(t.c, 1:Int32), 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.c, t._row_id ] }
- sql: |
    create table t(c STRUCT<x INTEGER, y INTEGER>);
    select (case when true then c end).x from t
  logical_plan: |-
    LogicalProject { exprs: [ Field(Case(true:Boolean, t.c), 0:Int32) as $expr1 ] }
    └──  LogicalScan { table: t, columns: [ t.c, t._row_id ] }
