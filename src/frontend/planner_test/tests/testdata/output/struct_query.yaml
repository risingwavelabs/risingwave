- sql: |
    create materialized view t as select country from s;
    select * from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: t, columns: [t.country], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [country, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: "NoCheck" }
    └─StreamTableScan { table: t, columns: [t.country, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    -- select (t).country.city,(t).country,(country).city.address from t;
    select (t.country).city,t.country,(country).city.address from t;
  logical_plan: |
    LogicalProject { exprs: [Field(t.country, 1:Int32) as $expr1, t.country, Field(Field(t.country, 1:Int32), 0:Int32) as $expr2] }
    └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    CREATE TABLE t (
      id INTEGER,
      country STRUCT<
        address VARCHAR,
        city STRUCT<address VARCHAR, zipcode VARCHAR>,
        zipcode VARCHAR
      >,
      zipcode BIGINT,
      rate FLOAT);
    -- select (t).country.city.*,(t.country).*,(country).city.* from t;
    select (t.country).city.*,(t.country).*,(country).city.* from t;
  logical_plan: |
    LogicalProject { exprs: [Field(Field(t.country, 1:Int32), 0:Int32) as $expr1, Field(Field(t.country, 1:Int32), 1:Int32) as $expr2, Field(t.country, 0:Int32) as $expr3, Field(t.country, 1:Int32) as $expr4, Field(t.country, 2:Int32) as $expr5, Field(Field(t.country, 1:Int32), 0:Int32) as $expr6, Field(Field(t.country, 1:Int32), 1:Int32) as $expr7] }
    └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
- sql: |
    create materialized view t as select * from s;
    -- select (t).country1.city.*,(t.country2).*,(country3).city.* from t;
    select (t.country1).city.*,(t.country2).*,(country3).city.* from t;
  logical_plan: |
    LogicalProject { exprs: [Field(Field(t.country1, 1:Int32), 0:Int32) as $expr1, Field(Field(t.country1, 1:Int32), 1:Int32) as $expr2, Field(t.country2, 0:Int32) as $expr3, Field(t.country2, 1:Int32) as $expr4, Field(t.country2, 2:Int32) as $expr5, Field(Field(t.country3, 1:Int32), 0:Int32) as $expr6, Field(Field(t.country3, 1:Int32), 1:Int32) as $expr7] }
    └─LogicalScan { table: t, columns: [t.id, t.country1, t.country2, t.country3, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country1 = 3;
        Country country2 = 4;
        Country country3 = 5;
        int64 zipcode = 6;
        float rate = 7;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    -- select (c).zipcode from (select (t).country.city as c from t);
    select (c).zipcode from (select (t.country).city as c from t);
  logical_plan: |
    LogicalProject { exprs: [Field($expr1, 1:Int32) as $expr2] }
    └─LogicalProject { exprs: [Field(t.country, 1:Int32) as $expr1] }
      └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    -- select (c).zipcode from (select min((t).country.city) as c from t);
    select (c).zipcode from (select min((t.country).city) as c from t);
  logical_plan: |
    LogicalProject { exprs: [Field(min($expr1), 1:Int32) as $expr2] }
    └─LogicalProject { exprs: [min($expr1)] }
      └─LogicalAgg { aggs: [min($expr1)] }
        └─LogicalProject { exprs: [Field(t.country, 1:Int32) as $expr1] }
          └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    select * from (select (country).city as c from t) as vv join t on (c).zipcode=(t.country).zipcode;
  logical_plan: |
    LogicalProject { exprs: [$expr1, t.id, t.country, t.zipcode, t.rate] }
    └─LogicalJoin { type: Inner, on: (Field($expr1, 1:Int32) = Field(t.country, 2:Int32)), output: all }
      ├─LogicalProject { exprs: [Field(t.country, 1:Int32) as $expr1] }
      | └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
      └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    select min((t.country).city.address) + max((t.country).city.address) * count(zipcode) from t;
  logical_plan: |
    LogicalProject { exprs: [(min($expr1) + (max($expr1) * count(t.zipcode))) as $expr2] }
    └─LogicalAgg { aggs: [min($expr1), max($expr1), count(t.zipcode)] }
      └─LogicalProject { exprs: [Field(Field(t.country, 1:Int32), 0:Int32) as $expr1, t.zipcode] }
        └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        int64 address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    select count(1), count((country).city.zipcode) from t where (country).city.address>1;
  logical_plan: |
    LogicalProject { exprs: [count(1:Int32), count($expr1)] }
    └─LogicalAgg { aggs: [count(1:Int32), count($expr1)] }
      └─LogicalProject { exprs: [1:Int32, Field(Field(t.country, 1:Int32), 1:Int32) as $expr1] }
        └─LogicalFilter { predicate: (Field(Field(t.country, 1:Int32), 0:Int32) > 1:Int32) }
          └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        int64 address = 1;
        string zipcode = 2;
      }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select (v1).v2 from t;
  binder_error: |-
    Bind error: failed to bind expression: (v1).v2

    Caused by:
      Bind error: column notation .v2 applied to type bigint, which is not a composite type
- sql: |
    create materialized view t as select * from s;
    select (country + country) from t;
  binder_error: |-
    Bind error: failed to bind expression: (country + country)

    Caused by:
      Feature is not yet implemented: Add[Struct, Struct]
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/112
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        string zipcode = 3;
      }
- sql: |
    create materialized view t as select * from s;
    select avg(country) from t;
  binder_error: |-
    Bind error: failed to bind expression: avg(country)

    Caused by:
      Invalid input syntax: Invalid aggregation: avg(struct<address varchar,zipcode varchar>)
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        string zipcode = 3;
      }
- sql: |
    create materialized view t as select * from s;
    select (country).city from t;
  binder_error: |-
    Bind error: failed to bind expression: (country).city

    Caused by:
      Bind error: column "city" not found in struct type
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        string zipcode = 3;
      }
- sql: |
    create materialized view t as select * from s;
    select (country).address.* from t;
  binder_error: 'Bind error: type "varchar" is not composite'
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        string zipcode = 3;
      }
- sql: |
    insert into s values (1,2,(1,2,(1,2,null)));
  logical_plan: |
    LogicalInsert { table: s, mapping: [0:0, 1:1, 2:2] }
    └─LogicalValues { rows: [[1:Int32, 2:Int32, Row(1:Int32, 2:Int32, Row(1:Int32, 2:Int32, null:Int32))]], schema: Schema { fields: [*VALUES*_0.column_0:Int32, *VALUES*_0.column_1:Int32, *VALUES*_0.column_2:Struct(StructType { fields: [Int32, Int32, Struct(StructType { fields: [Int32, Int32, Int32], field_names: ["v1", "v2", "v3"] })], field_names: ["v1", "v2", "v3"] })] } }
  create_table_with_connector:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 v1 = 1;
        int32 v2 = 2;
        V v3 = 3;
      }
      message V {
        int32 v1 = 1;
        int32 v2 = 2;
        U v3 = 3;
      }
      message U {
        int32 v1 = 1;
        int32 v2 = 2;
        int32 v3 = 3;
      }
- sql: |
    select * from s where s.v3 = (1,2,(1,2,3));
  logical_plan: |
    LogicalProject { exprs: [s.v1, s.v2, s.v3] }
    └─LogicalFilter { predicate: (s.v3 = Row(1:Int32, 2:Int32, Row(1:Int32, 2:Int32, 3:Int32))) }
      └─LogicalScan { table: s, columns: [s._row_id, s.v1, s.v2, s.v3] }
  create_table_with_connector:
    row_format: protobuf
    name: s
    file: |-
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 v1 = 1;
        int32 v2 = 2;
        V v3 = 3;
      }
      message V {
        int32 v1 = 1;
        int32 v2 = 2;
        U v3 = 3;
      }
      message U {
        int32 v1 = 1;
        int32 v2 = 2;
        int32 v3 = 3;
      }
- sql: |
    CREATE TABLE a (c STRUCT<i STRUCT<a INTEGER>, j INTEGER>);
    INSERT INTO a VALUES (1);
  binder_error: 'Bind error: cannot cast type "integer" to "struct<i struct<a integer>,j integer>" in Assign context'
- name: test struct type alignment in CASE expression
  sql: |
    select CASE WHEN false THEN ROW(0, INTERVAL '1') WHEN true THEN ROW(1.1, INTERVAL '1') ELSE ROW(1, INTERVAL '1') END;
  logical_plan: |
    LogicalProject { exprs: [Case(false:Boolean, Row(0:Int32::Decimal, '00:00:01':Interval), true:Boolean, Row(1.1:Decimal, '00:00:01':Interval), Row(1:Int32::Decimal, '00:00:01':Interval)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
