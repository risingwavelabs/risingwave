# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    /* T: updatable; Tk: Hash(k) distribution; AO: append-only; S: single distribution */
    create table T  (k int, v int, o int, s varchar);
    create index Tk on T(k) include(k, v, o, s);
    create materialized view S as select * from T order by o limit 100;
    create table AO (k int, v int, o int, s varchar) append only;
- id: extreme_on_single
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [max(s.v)] }
      └─BatchScan { table: s, columns: [s.v], distribution: Single }
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(s.v)] }
      └─StreamSimpleAgg { aggs: [max(s.v), count] }
        └─StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck } { tables: [ Materialize: 4294967294 ] }
    └── StreamProject { exprs: [max(s.v)] }
        └── StreamSimpleAgg { aggs: [max(s.v), count] } { tables: [ SimpleAggState: 1, SimpleAggCall0: 0 ] }
            └── StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
                ├── tables: [ StreamScan: 2 ]
                ├── Upstream
                └── BatchPlanNode

    Table 0 { columns: [ s_v, s_t__row_id, _rw_timestamp ], primary key: [ $0 DESC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ max(s_v), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, o, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: sum_on_single
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [sum(s.v)] }
      └─BatchScan { table: s, columns: [s.v], distribution: Single }
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum(s.v)] }
      └─StreamSimpleAgg { aggs: [sum(s.v), count] }
        └─StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck } { tables: [ Materialize: 4294967294 ] }
    └── StreamProject { exprs: [sum(s.v)] }
        └── StreamSimpleAgg { aggs: [sum(s.v), count] } { tables: [ SimpleAggState: 0 ] }
            └── StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
                ├── tables: [ StreamScan: 1 ]
                ├── Upstream
                └── BatchPlanNode

    Table 0 { columns: [ sum(s_v), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ vnode, o, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: cnt_on_single
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [count(s.v)] }
      └─BatchScan { table: s, columns: [s.v], distribution: Single }
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count(s.v)] }
      └─StreamSimpleAgg { aggs: [count(s.v), count] }
        └─StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck } { tables: [ Materialize: 4294967294 ] }
    └── StreamProject { exprs: [count(s.v)] }
        └── StreamSimpleAgg { aggs: [count(s.v), count] } { tables: [ SimpleAggState: 0 ] }
            └── StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
                ├── tables: [ StreamScan: 1 ]
                ├── Upstream
                └── BatchPlanNode

    Table 0 { columns: [ count(s_v), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ vnode, o, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: string_agg_on_single
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by v) as a1 from S;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC))] }
      └─BatchProject { exprs: [s.s, ',':Varchar, s.v] }
        └─BatchScan { table: s, columns: [s.v, s.s], distribution: Single }
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.v ASC))] }
      └─StreamSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC)), count] }
        └─StreamProject { exprs: [s.s, ',':Varchar, s.v, s.t._row_id] }
          └─StreamTableScan { table: s, columns: [s.v, s.s, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck } { tables: [ Materialize: 4294967294 ] }
    └── StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.v ASC))] }
        └── StreamSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC)), count] } { tables: [ SimpleAggState: 1, SimpleAggCall0: 0 ] }
            └── StreamProject { exprs: [s.s, ',':Varchar, s.v, s.t._row_id] }
                └── StreamTableScan { table: s, columns: [s.v, s.s, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
                    ├── tables: [ StreamScan: 2 ]
                    ├── Upstream
                    └── BatchPlanNode

    Table 0
    ├── columns: [ s_v, s_t__row_id, s_s, ',':Varchar, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 1
    ├── columns: [ string_agg(s_s, ',':Varchar order_by(s_v ASC)), count, _rw_timestamp ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, o, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: extreme_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T;
  batch_plan: |-
    BatchSimpleAgg { aggs: [max(max(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [max(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(max(t.v))] }
      └─StreamSimpleAgg { aggs: [max(max(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamHashAgg { group_key: [_vnode], aggs: [max(t.v), count] }
            └─StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as _vnode] }
              └─StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [max(max(t.v))] }
        └── StreamSimpleAgg { aggs: [max(max(t.v)), count] }
            ├── tables: [ SimpleAggState: 1, SimpleAggCall0: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamHashAgg { group_key: [_vnode], aggs: [max(t.v), count] } { tables: [ HashAggState: 3, HashAggCall0: 2 ] }
    └── StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as _vnode] }
        └── StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
            ├── tables: [ StreamScan: 4 ]
            ├── Upstream
            └── BatchPlanNode

    Table 0 { columns: [ max(t_v), _vnode, _rw_timestamp ], primary key: [ $0 DESC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ max(max(t_v)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ _vnode, t_v, t__row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 2 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3
    ├── columns: [ _vnode, max(t_v), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: []
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: extreme_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO;
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(max(ao.v))] }
      └─StreamSimpleAgg [append_only] { aggs: [max(max(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [max(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [max(max(ao.v))] }
        └── StreamSimpleAgg [append_only] { aggs: [max(max(ao.v)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [max(ao.v)] }
    └── StreamTableScan { table: ao, columns: [ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
        ├── tables: [ StreamScan: 1 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ max(max(ao_v)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: sum_on_T
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T;
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum(sum(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [sum(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum(sum(t.v))] }
      └─StreamSimpleAgg { aggs: [sum(sum(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [sum(t.v)] }
            └─StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [sum(sum(t.v))] }
        └── StreamSimpleAgg { aggs: [sum(sum(t.v)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [sum(t.v)] }
    └── StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        ├── tables: [ StreamScan: 1 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ sum(sum(t_v)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: sum_on_AO
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO;
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum(sum(ao.v))] }
      └─StreamSimpleAgg [append_only] { aggs: [sum(sum(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [sum(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [sum(sum(ao.v))] }
        └── StreamSimpleAgg [append_only] { aggs: [sum(sum(ao.v)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [sum(ao.v)] }
    └── StreamTableScan { table: ao, columns: [ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
        ├── tables: [ StreamScan: 1 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ sum(sum(ao_v)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: cnt_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T;
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum0(count(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum0(count(t.v))] }
      └─StreamSimpleAgg { aggs: [sum0(count(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [count(t.v)] }
            └─StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [sum0(count(t.v))] }
        └── StreamSimpleAgg { aggs: [sum0(count(t.v)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [count(t.v)] }
    └── StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        ├── tables: [ StreamScan: 1 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ sum0(count(t_v)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: cnt_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO;
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum0(count(ao.v))] }
      └─StreamSimpleAgg [append_only] { aggs: [sum0(count(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [count(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [sum0(count(ao.v))] }
        └── StreamSimpleAgg [append_only] { aggs: [sum0(count(ao.v)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [count(ao.v)] }
    └── StreamTableScan { table: ao, columns: [ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
        ├── tables: [ StreamScan: 1 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ sum0(count(ao_v)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: string_agg_on_T
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T;
  batch_plan: |-
    BatchSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.s, ',':Varchar, t.o] }
        └─BatchScan { table: t, columns: [t.o, t.s], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─StreamSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.o, t.s, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
        └── StreamSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
            ├── tables: [ SimpleAggState: 1, SimpleAggCall0: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamProject { exprs: [t.s, ',':Varchar, t.o, t._row_id] }
    └── StreamTableScan { table: t, columns: [t.o, t.s, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        ├── tables: [ StreamScan: 2 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0
    ├── columns: [ t_o, t__row_id, t_s, ',':Varchar, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 1
    ├── columns: [ string_agg(t_s, ',':Varchar order_by(t_o ASC)), count, _rw_timestamp ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: string_agg_on_AO
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO;
  stream_plan: |-
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
      └─StreamSimpleAgg [append_only] { aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.o, ao.s, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
        └── StreamSimpleAgg [append_only] { aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
            ├── tables: [ SimpleAggState: 1, SimpleAggCall0: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamProject { exprs: [ao.s, ',':Varchar, ao.o, ao._row_id] }
    └── StreamTableScan { table: ao, columns: [ao.o, ao.s, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
        ├── tables: [ StreamScan: 2 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0
    ├── columns: [ ao_o, ao__row_id, ao_s, ',':Varchar, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 1
    ├── columns: [ string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count, _rw_timestamp ]
    ├── primary key: []
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: extreme_count_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from T;
  batch_plan: |-
    BatchSimpleAgg { aggs: [max(max(t.v)), sum0(count(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [max(t.v), count(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(max(t.v)), sum0(count(t.v))] }
      └─StreamSimpleAgg { aggs: [max(max(t.v)), sum0(count(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamHashAgg { group_key: [_vnode], aggs: [max(t.v), count(t.v), count] }
            └─StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as _vnode] }
              └─StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [max(max(t.v)), sum0(count(t.v))] }
        └── StreamSimpleAgg { aggs: [max(max(t.v)), sum0(count(t.v)), count] }
            ├── tables: [ SimpleAggState: 1, SimpleAggCall0: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamHashAgg { group_key: [_vnode], aggs: [max(t.v), count(t.v), count] } { tables: [ HashAggState: 3, HashAggCall0: 2 ] }
    └── StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as _vnode] }
        └── StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
            ├── tables: [ StreamScan: 4 ]
            ├── Upstream
            └── BatchPlanNode

    Table 0 { columns: [ max(t_v), _vnode, _rw_timestamp ], primary key: [ $0 DESC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ max(max(t_v)), sum0(count(t_v)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1, 2 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ _vnode, t_v, t__row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 2 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3
    ├── columns: [ _vnode, max(t_v), count(t_v), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: []
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, a2, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

- id: extreme_count_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from AO;
  stream_plan: |-
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(max(ao.v)), sum0(count(ao.v))] }
      └─StreamSimpleAgg [append_only] { aggs: [max(max(ao.v)), sum0(count(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [max(ao.v), count(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [max(max(ao.v)), sum0(count(ao.v))] }
        └── StreamSimpleAgg [append_only] { aggs: [max(max(ao.v)), sum0(count(ao.v)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [max(ao.v), count(ao.v)] }
    └── StreamTableScan { table: ao, columns: [ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
        ├── tables: [ StreamScan: 1 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ max(max(ao_v)), sum0(count(ao_v)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1, 2 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, a2, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

- id: count_string_agg_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |-
    BatchSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
        └─BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─StreamSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
        └── StreamSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
            ├── tables: [ SimpleAggState: 1, SimpleAggCall1: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
    └── StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        ├── tables: [ StreamScan: 2 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0
    ├── columns: [ t_o, t__row_id, t_s, ',':Varchar, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 1
    ├── columns: [ count(t_v), string_agg(t_s, ',':Varchar order_by(t_o ASC)), count, _rw_timestamp ]
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, a2, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

- id: count_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |-
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
      └─StreamSimpleAgg [append_only] { aggs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
        └── StreamSimpleAgg [append_only] { aggs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
            ├── tables: [ SimpleAggState: 1, SimpleAggCall1: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
    └── StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
        ├── tables: [ StreamScan: 2 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ ao_o, ao__row_id, ao_s, ',':Varchar, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ count(ao_v), string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count, _rw_timestamp ]
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, a2, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

- id: extreme_string_agg_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |-
    BatchSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
        └─BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─StreamSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
        └── StreamSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
            ├── tables: [ SimpleAggState: 2, SimpleAggCall0: 0, SimpleAggCall1: 1 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
    └── StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        ├── tables: [ StreamScan: 3 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ t_v, t__row_id, _rw_timestamp ], primary key: [ $0 DESC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ t_o, t__row_id, t_s, ',':Varchar, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ max(t_v), string_agg(t_s, ',':Varchar order_by(t_o ASC)), count, _rw_timestamp ]
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 3
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, a2, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

- id: extreme_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |-
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
      └─StreamSimpleAgg [append_only] { aggs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, a2], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
        └── StreamSimpleAgg [append_only] { aggs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
            ├── tables: [ SimpleAggState: 1, SimpleAggCall1: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
    └── StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
        ├── tables: [ StreamScan: 2 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ ao_o, ao__row_id, ao_s, ',':Varchar, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1
    ├── columns: [ max(ao_v), string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count, _rw_timestamp ]
    ├── primary key: []
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, a2, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

- id: extreme_on_T_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [max(t.v)] }
      └─BatchHashAgg { group_key: [t.k], aggs: [max(t.v)] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1, t.k(hidden)], stream_key: [t.k], pk_columns: [t.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(t.v), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [max(t.v), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, t.k(hidden)], stream_key: [t.k], pk_columns: [t.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [max(t.v), t.k] }
        └── StreamHashAgg { group_key: [t.k], aggs: [max(t.v), count] }
            ├── tables: [ HashAggState: 1, HashAggCall0: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
    ├── tables: [ StreamScan: 2 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0
    ├── columns: [ t_k, t_v, t__row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ t_k, max(t_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, t.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: extreme_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from Tk group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [max(tk.v)] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [max(tk.v)] }
        └─BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |-
    StreamMaterialize { columns: [a1, tk.k(hidden)], stream_key: [tk.k], pk_columns: [tk.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(tk.v), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [max(tk.v), count] }
        └─StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [tk.t._row_id], pk: [k, t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, tk.k(hidden)], stream_key: [tk.k], pk_columns: [tk.k], pk_conflict: NoCheck } { tables: [ Materialize: 4294967294 ] }
    └── StreamProject { exprs: [max(tk.v), tk.k] }
        └── StreamHashAgg { group_key: [tk.k], aggs: [max(tk.v), count] } { tables: [ HashAggState: 1, HashAggCall0: 0 ] }
            └── StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [tk.t._row_id], pk: [k, t._row_id], dist: UpstreamHashShard(tk.k) }
                ├── tables: [ StreamScan: 2 ]
                ├── Upstream
                └── BatchPlanNode

    Table 0 { columns: [ tk_k, tk_v, tk_t__row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 DESC, $2 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ tk_k, max(tk_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2
    ├── columns: [ vnode, k, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, tk.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: extreme_on_S_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [max(s.v)] }
      └─BatchHashAgg { group_key: [s.k], aggs: [max(s.v)] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchScan { table: s, columns: [s.k, s.v], distribution: Single }
  stream_plan: |-
    StreamMaterialize { columns: [a1, s.k(hidden)], stream_key: [s.k], pk_columns: [s.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(s.v), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [max(s.v), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, s.k(hidden)], stream_key: [s.k], pk_columns: [s.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [max(s.v), s.k] }
        └── StreamHashAgg { group_key: [s.k], aggs: [max(s.v), count] }
            ├── tables: [ HashAggState: 1, HashAggCall0: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
    ├── tables: [ StreamScan: 2 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0
    ├── columns: [ s_k, s_v, s_t__row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ s_k, max(s_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2
    ├── columns: [ vnode, o, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, s.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: extreme_on_AO_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO group by k;
  stream_plan: |-
    StreamMaterialize { columns: [a1, ao.k(hidden)], stream_key: [ao.k], pk_columns: [ao.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [max(ao.v), ao.k] }
      └─StreamHashAgg [append_only] { group_key: [ao.k], aggs: [max(ao.v), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, ao.k(hidden)], stream_key: [ao.k], pk_columns: [ao.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [max(ao.v), ao.k] }
        └── StreamHashAgg [append_only] { group_key: [ao.k], aggs: [max(ao.v), count] }
            ├── tables: [ HashAggState: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
    ├── tables: [ StreamScan: 1 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ ao_k, max(ao_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, ao.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: sum_on_T_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [sum(t.v)] }
      └─BatchHashAgg { group_key: [t.k], aggs: [sum(t.v)] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1, t.k(hidden)], stream_key: [t.k], pk_columns: [t.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum(t.v), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [sum(t.v), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, t.k(hidden)], stream_key: [t.k], pk_columns: [t.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [sum(t.v), t.k] }
        └── StreamHashAgg { group_key: [t.k], aggs: [sum(t.v), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
    ├── tables: [ StreamScan: 1 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ t_k, sum(t_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, t.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: sum_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from Tk group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [sum(tk.v)] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [sum(tk.v)] }
        └─BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |-
    StreamMaterialize { columns: [a1, tk.k(hidden)], stream_key: [tk.k], pk_columns: [tk.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum(tk.v), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [sum(tk.v), count] }
        └─StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [tk.t._row_id], pk: [k, t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, tk.k(hidden)], stream_key: [tk.k], pk_columns: [tk.k], pk_conflict: NoCheck } { tables: [ Materialize: 4294967294 ] }
    └── StreamProject { exprs: [sum(tk.v), tk.k] }
        └── StreamHashAgg { group_key: [tk.k], aggs: [sum(tk.v), count] } { tables: [ HashAggState: 0 ] }
            └── StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [tk.t._row_id], pk: [k, t._row_id], dist: UpstreamHashShard(tk.k) }
                ├── tables: [ StreamScan: 1 ]
                ├── Upstream
                └── BatchPlanNode

    Table 0 { columns: [ tk_k, sum(tk_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, k, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, tk.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: sum_on_S_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [sum(s.v)] }
      └─BatchHashAgg { group_key: [s.k], aggs: [sum(s.v)] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchScan { table: s, columns: [s.k, s.v], distribution: Single }
  stream_plan: |-
    StreamMaterialize { columns: [a1, s.k(hidden)], stream_key: [s.k], pk_columns: [s.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum(s.v), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [sum(s.v), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, s.k(hidden)], stream_key: [s.k], pk_columns: [s.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [sum(s.v), s.k] }
        └── StreamHashAgg { group_key: [s.k], aggs: [sum(s.v), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
    ├── tables: [ StreamScan: 1 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ s_k, sum(s_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, o, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, s.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: sum_on_AO_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO group by k;
  stream_plan: |-
    StreamMaterialize { columns: [a1, ao.k(hidden)], stream_key: [ao.k], pk_columns: [ao.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum(ao.v), ao.k] }
      └─StreamHashAgg [append_only] { group_key: [ao.k], aggs: [sum(ao.v), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, ao.k(hidden)], stream_key: [ao.k], pk_columns: [ao.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [sum(ao.v), ao.k] }
        └── StreamHashAgg [append_only] { group_key: [ao.k], aggs: [sum(ao.v), count] }
            ├── tables: [ HashAggState: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
    ├── tables: [ StreamScan: 1 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ ao_k, sum(ao_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, ao.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: cnt_on_T_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count(t.v)] }
      └─BatchHashAgg { group_key: [t.k], aggs: [count(t.v)] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1, t.k(hidden)], stream_key: [t.k], pk_columns: [t.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count(t.v), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [count(t.v), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, t.k(hidden)], stream_key: [t.k], pk_columns: [t.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [count(t.v), t.k] }
        └── StreamHashAgg { group_key: [t.k], aggs: [count(t.v), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
    ├── tables: [ StreamScan: 1 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ t_k, count(t_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, t.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: cnt_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from Tk group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count(tk.v)] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [count(tk.v)] }
        └─BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |-
    StreamMaterialize { columns: [a1, tk.k(hidden)], stream_key: [tk.k], pk_columns: [tk.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count(tk.v), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [count(tk.v), count] }
        └─StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [tk.t._row_id], pk: [k, t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, tk.k(hidden)], stream_key: [tk.k], pk_columns: [tk.k], pk_conflict: NoCheck } { tables: [ Materialize: 4294967294 ] }
    └── StreamProject { exprs: [count(tk.v), tk.k] }
        └── StreamHashAgg { group_key: [tk.k], aggs: [count(tk.v), count] } { tables: [ HashAggState: 0 ] }
            └── StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [tk.t._row_id], pk: [k, t._row_id], dist: UpstreamHashShard(tk.k) }
                ├── tables: [ StreamScan: 1 ]
                ├── Upstream
                └── BatchPlanNode

    Table 0 { columns: [ tk_k, count(tk_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, k, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, tk.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: cnt_on_S_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count(s.v)] }
      └─BatchHashAgg { group_key: [s.k], aggs: [count(s.v)] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchScan { table: s, columns: [s.k, s.v], distribution: Single }
  stream_plan: |-
    StreamMaterialize { columns: [a1, s.k(hidden)], stream_key: [s.k], pk_columns: [s.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count(s.v), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [count(s.v), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, s.k(hidden)], stream_key: [s.k], pk_columns: [s.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [count(s.v), s.k] }
        └── StreamHashAgg { group_key: [s.k], aggs: [count(s.v), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
    ├── tables: [ StreamScan: 1 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ s_k, count(s_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, o, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, s.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: cnt_on_AO_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO group by k;
  stream_plan: |-
    StreamMaterialize { columns: [a1, ao.k(hidden)], stream_key: [ao.k], pk_columns: [ao.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count(ao.v), ao.k] }
      └─StreamHashAgg [append_only] { group_key: [ao.k], aggs: [count(ao.v), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, ao.k(hidden)], stream_key: [ao.k], pk_columns: [ao.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [count(ao.v), ao.k] }
        └── StreamHashAgg [append_only] { group_key: [ao.k], aggs: [count(ao.v), count] }
            ├── tables: [ HashAggState: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
    ├── tables: [ StreamScan: 1 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ ao_k, count(ao_v), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, ao.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: string_agg_on_T_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─BatchHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchProject { exprs: [t.k, t.s, ',':Varchar, t.o] }
            └─BatchScan { table: t, columns: [t.k, t.o, t.s], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a1, t.k(hidden)], stream_key: [t.k], pk_columns: [t.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamProject { exprs: [t.k, t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.k, t.o, t.s, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, t.k(hidden)], stream_key: [t.k], pk_columns: [t.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), t.k] }
        └── StreamHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
            ├── tables: [ HashAggState: 1, HashAggCall0: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [t.k, t.s, ',':Varchar, t.o, t._row_id] }
    └── StreamTableScan { table: t, columns: [t.k, t.o, t.s, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        ├── tables: [ StreamScan: 2 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0
    ├── columns: [ t_k, t_o, t__row_id, t_s, ',':Varchar, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1
    ├── columns: [ t_k, string_agg(t_s, ',':Varchar order_by(t_o ASC)), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, t.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: string_agg_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from Tk group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC))] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC))] }
        └─BatchProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o] }
          └─BatchScan { table: tk, columns: [tk.k, tk.o, tk.s], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |-
    StreamMaterialize { columns: [a1, tk.k(hidden)], stream_key: [tk.k], pk_columns: [tk.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), count] }
        └─StreamProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id] }
          └─StreamTableScan { table: tk, columns: [tk.k, tk.o, tk.s, tk.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [tk.t._row_id], pk: [k, t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, tk.k(hidden)], stream_key: [tk.k], pk_columns: [tk.k], pk_conflict: NoCheck } { tables: [ Materialize: 4294967294 ] }
    └── StreamProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), tk.k] }
        └── StreamHashAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), count] } { tables: [ HashAggState: 1, HashAggCall0: 0 ] }
            └── StreamProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id] }
                └── StreamTableScan { table: tk, columns: [tk.k, tk.o, tk.s, tk.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [tk.t._row_id], pk: [k, t._row_id], dist: UpstreamHashShard(tk.k) }
                    ├── tables: [ StreamScan: 2 ]
                    ├── Upstream
                    └── BatchPlanNode

    Table 0
    ├── columns: [ tk_k, tk_o, tk_t__row_id, tk_s, ',':Varchar, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ tk_k, string_agg(tk_s, ',':Varchar order_by(tk_o ASC)), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2
    ├── columns: [ vnode, k, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, tk.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: string_agg_on_S_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from S group by k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC))] }
      └─BatchHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC))] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchProject { exprs: [s.k, s.s, ',':Varchar, s.o] }
            └─BatchScan { table: s, columns: [s.k, s.o, s.s], distribution: Single }
  stream_plan: |-
    StreamMaterialize { columns: [a1, s.k(hidden)], stream_key: [s.k], pk_columns: [s.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamProject { exprs: [s.k, s.s, ',':Varchar, s.o, s.t._row_id] }
            └─StreamTableScan { table: s, columns: [s.k, s.o, s.s, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, s.k(hidden)], stream_key: [s.k], pk_columns: [s.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), s.k] }
        └── StreamHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), count] }
            ├── tables: [ HashAggState: 1, HashAggCall0: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [s.k, s.s, ',':Varchar, s.o, s.t._row_id] }
    └── StreamTableScan { table: s, columns: [s.k, s.o, s.s, s.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [s.t._row_id], pk: [o, t._row_id], dist: Single }
        ├── tables: [ StreamScan: 2 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0
    ├── columns: [ s_k, s_o, s_t__row_id, s_s, ',':Varchar, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1
    ├── columns: [ s_k, string_agg(s_s, ',':Varchar order_by(s_o ASC)), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 2
    ├── columns: [ vnode, o, t__row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, s.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- id: string_agg_on_AO_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO group by k;
  stream_plan: |-
    StreamMaterialize { columns: [a1, ao.k(hidden)], stream_key: [ao.k], pk_columns: [ao.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), ao.k] }
      └─StreamHashAgg [append_only] { group_key: [ao.k], aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamProject { exprs: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.k, ao.o, ao.s, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a1, ao.k(hidden)], stream_key: [ao.k], pk_columns: [ao.k], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), ao.k] }
        └── StreamHashAgg [append_only] { group_key: [ao.k], aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
            ├── tables: [ HashAggState: 1, HashAggCall0: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id] }
    └── StreamTableScan { table: ao, columns: [ao.k, ao.o, ao.s, ao._row_id], stream_scan_type: ArrangementBackfill, stream_key: [ao._row_id], pk: [_row_id], dist: UpstreamHashShard(ao._row_id) }
        ├── tables: [ StreamScan: 2 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0
    ├── columns: [ ao_k, ao_o, ao__row_id, ao_s, ',':Varchar, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1
    ├── columns: [ ao_k, string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a1, ao.k, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

