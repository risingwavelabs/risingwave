# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: should not unify first_value/last_value since their order by clauses are different
  sql: |
    create table t(a int, b int, c int, d int);
    select first_value(b order by b) first_a, first_value(a order by a) first_b from t group by c;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [first_value(t.b order_by(t.b ASC)), first_value(t.a order_by(t.a ASC))] }
      └─BatchHashAgg { group_key: [t.c], aggs: [first_value(t.b order_by(t.b ASC)), first_value(t.a order_by(t.a ASC))] }
        └─BatchExchange { order: [], dist: HashShard(t.c) }
          └─BatchScan { table: t, columns: [t.a, t.b, t.c], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [first_a, first_b, t.c(hidden)], stream_key: [t.c], pk_columns: [t.c], pk_conflict: NoCheck }
    └─StreamProject { exprs: [first_value(t.b order_by(t.b ASC)), first_value(t.a order_by(t.a ASC)), t.c] }
      └─StreamHashAgg { group_key: [t.c], aggs: [first_value(t.b order_by(t.b ASC)), first_value(t.a order_by(t.a ASC)), count] }
        └─StreamExchange { dist: HashShard(t.c) }
          └─StreamTableScan { table: t, columns: [t.a, t.b, t.c, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: unify first_value and last_value calls, mixed with count
  sql: |
    create table t(a int, b int, c int, d int, e int, f int);
    select
    first_value(a order by d) first_a, last_value(a order by d desc) last_a,
    first_value(b order by d) first_b, last_value(b order by d desc) last_b,
    first_value(c order by d) first_c, last_value(c order by d desc) last_c,
    count(a) count_a, count(b) count_b, count(c) count_c
    from t group by e, f;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Field(first_value($expr1 order_by($expr1 ASC)), 0:Int32) as $expr2, Field(last_value($expr1 order_by($expr1 DESC)), 0:Int32) as $expr3, Field(first_value($expr1 order_by($expr1 ASC)), 1:Int32) as $expr4, Field(last_value($expr1 order_by($expr1 DESC)), 1:Int32) as $expr5, Field(first_value($expr1 order_by($expr1 ASC)), 2:Int32) as $expr6, Field(last_value($expr1 order_by($expr1 DESC)), 2:Int32) as $expr7, count(t.a), count(t.b), count(t.c)] }
      └─BatchHashAgg { group_key: [t.e, t.f], aggs: [first_value($expr1 order_by($expr1 ASC)), last_value($expr1 order_by($expr1 DESC)), count(t.a), count(t.b), count(t.c)] }
        └─BatchExchange { order: [], dist: HashShard(t.e, t.f) }
          └─BatchProject { exprs: [t.e, t.f, t.a, t.b, t.c, $expr1, $expr1] }
            └─BatchProject { exprs: [t.a, t.b, t.c, t.e, t.f, Row(t.a, t.b, t.c) as $expr1] }
              └─BatchScan { table: t, columns: [t.a, t.b, t.c, t.e, t.f], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [first_a, last_a, first_b, last_b, first_c, last_c, count_a, count_b, count_c, t.e(hidden), t.f(hidden)], stream_key: [t.e, t.f], pk_columns: [t.e, t.f], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(first_value($expr1 order_by($expr1 ASC)), 0:Int32) as $expr2, Field(last_value($expr1 order_by($expr1 DESC)), 0:Int32) as $expr3, Field(first_value($expr1 order_by($expr1 ASC)), 1:Int32) as $expr4, Field(last_value($expr1 order_by($expr1 DESC)), 1:Int32) as $expr5, Field(first_value($expr1 order_by($expr1 ASC)), 2:Int32) as $expr6, Field(last_value($expr1 order_by($expr1 DESC)), 2:Int32) as $expr7, count(t.a), count(t.b), count(t.c), t.e, t.f] }
      └─StreamHashAgg { group_key: [t.e, t.f], aggs: [first_value($expr1 order_by($expr1 ASC)), last_value($expr1 order_by($expr1 DESC)), count(t.a), count(t.b), count(t.c), count] }
        └─StreamExchange { dist: HashShard(t.e, t.f) }
          └─StreamProject { exprs: [t.a, t.b, t.c, t.e, t.f, $expr1, $expr1, t._row_id] }
            └─StreamProject { exprs: [t.a, t.b, t.c, t.e, t.f, Row(t.a, t.b, t.c) as $expr1, t._row_id] }
              └─StreamTableScan { table: t, columns: [t.a, t.b, t.c, t.e, t.f, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: unify first_value calls with different filters
  sql: |
    create table t(a int, b int, c int);
    select
    first_value(a order by a) filter (where c > 0) first_a, first_value(b order by a) filter (where c > 0) first_b,
    first_value(c order by a) filter (where c = 1) first_c
    from t;
  batch_plan: |-
    BatchProject { exprs: [Field(first_value($expr1 order_by($expr1 ASC)) filter((t.c > 0:Int32)), 0:Int32) as $expr2, Field(first_value($expr1 order_by($expr1 ASC)) filter((t.c > 0:Int32)), 1:Int32) as $expr3, first_value(t.c order_by(t.a ASC)) filter((t.c = 1:Int32))] }
    └─BatchSimpleAgg { aggs: [first_value($expr1 order_by($expr1 ASC)) filter((t.c > 0:Int32)), first_value(t.c order_by(t.a ASC)) filter((t.c = 1:Int32))] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.c, t.a, Row(t.a, t.b) as $expr1] }
          └─BatchScan { table: t, columns: [t.a, t.b, t.c], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [first_a, first_b, first_c], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(first_value($expr1 order_by($expr1 ASC)) filter((t.c > 0:Int32)), 0:Int32) as $expr2, Field(first_value($expr1 order_by($expr1 ASC)) filter((t.c > 0:Int32)), 1:Int32) as $expr3, first_value(t.c order_by(t.a ASC)) filter((t.c = 1:Int32))] }
      └─StreamSimpleAgg { aggs: [first_value($expr1 order_by($expr1 ASC)) filter((t.c > 0:Int32)), first_value(t.c order_by(t.a ASC)) filter((t.c = 1:Int32)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.a, t.c, Row(t.a, t.b) as $expr1, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.a, t.b, t.c, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
