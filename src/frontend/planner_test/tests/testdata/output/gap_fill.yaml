# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: basic with LOCF
  sql: |
    CREATE TABLE t (id INT, ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val));
  logical_plan: |-
    LogicalProject { exprs: [t.id, t.ts, t.val] }
    └─LogicalGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
      └─LogicalScan { table: t, columns: [t.id, t.ts, t.val, t._rw_timestamp] }
  stream_plan: |-
    StreamMaterialize { columns: [id, ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.id, t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
- name: with INTERPOLATE
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(val));
  logical_plan: |-
    LogicalProject { exprs: [t.ts, t.val] }
    └─LogicalGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }] }
      └─LogicalScan { table: t, columns: [t.ts, t.val, t._rw_timestamp] }
  stream_plan: |-
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
- name: with KEEPNULL strategy
  sql: |
    CREATE TABLE t (ts TIMESTAMP, name VARCHAR, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, KEEPNULL(name));
  logical_plan: |-
    LogicalProject { exprs: [t.ts, t.name] }
    └─LogicalGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Null, target_col: $1 }] }
      └─LogicalScan { table: t, columns: [t.ts, t.name, t._rw_timestamp] }
  stream_plan: |-
    StreamMaterialize { columns: [ts, name], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Null, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.name], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
- name: mixed strategies
  sql: |
    CREATE TABLE t (ts TIMESTAMP, temp DOUBLE, status VARCHAR, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(temp), KEEPNULL(status));
  stream_plan: |-
    StreamMaterialize { columns: [ts, temp, status], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }, BoundFillStrategy { strategy: Null, target_col: $2 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.temp, t.status], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
- name: with timestamptz
  sql: |
    CREATE TABLE t (ts TIMESTAMPTZ, val INT, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' HOUR, LOCF(val));
  stream_plan: |-
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $0, interval: '01:00:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
- name: with projection and filter
  sql: |
    CREATE TABLE t (id INT, ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT id, ts FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val)) WHERE id = 1;
  stream_plan: |-
    StreamMaterialize { columns: [id, ts], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamFilter { predicate: (t.id = 1:Int32) }
      └─StreamGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
        └─StreamExchange { dist: Single }
          └─StreamTableScan { table: t, columns: [t.id, t.ts], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
- name: in materialized view
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    CREATE MATERIALIZED VIEW mv AS SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val));
- name: too few arguments
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts);
  binder_error: 'Bind error: GAP_FILL requires at least 3 arguments: input, time_col, interval'
- name: non-timestamp time column
  sql: |
    CREATE TABLE t (ts INT, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE);
  binder_error: 'Bind error: The 2nd arg of GAP_FILL should be a column of type timestamp or timestamptz'
- name: non-interval argument
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, 60);
  binder_error: 'Bind error: The 3rd arg of GAP_FILL should be an interval'
- name: interpolate non-numeric type
  sql: |
    CREATE TABLE t (ts TIMESTAMP, name VARCHAR);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(name));
  binder_error: 'Bind error: INTERPOLATE only supports numeric types, got character varying'
- name: interpolate on timestamp column
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(ts));
  binder_error: 'Bind error: INTERPOLATE only supports numeric types, got timestamp without time zone'
- name: unsupported fill strategy
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, UNKNOWN(val));
  binder_error: 'Bind error: Unsupported fill strategy: unknown'
- name: fill strategy with no arguments
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF());
  binder_error: 'Bind error: Fill strategy function locf expects exactly one argument'
- name: fill strategy with multiple arguments
  sql: |
    CREATE TABLE t (ts TIMESTAMP, v1 DOUBLE, v2 DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(v1, v2));
  binder_error: 'Bind error: Fill strategy function locf expects exactly one argument'
- name: fill strategy with expression
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val + 1));
  binder_error: 'Bind error: Fill strategy argument must be a column reference'
- name: zero interval
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '0' SECOND, LOCF(val));
  binder_error: 'Bind error: The gap fill interval cannot be zero'
