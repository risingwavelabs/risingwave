- sql: |
    create table t1 (v1 int, v2 int);
    with cte as (select v1, v2 from t1) select v1 from cte;
  logical_plan: |
    LogicalProject { exprs: [t1.v1] }
    └─LogicalShare { id = 2 }
      └─LogicalProject { exprs: [t1.v1, t1.v2] }
        └─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: "NoCheck" }
    └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v3 int, v4 int);
    with cte as (select v1 from t1) select * from t2 inner join cte on t2.v3 = cte.v1;
  logical_plan: |
    LogicalProject { exprs: [t2.v3, t2.v4, t1.v1] }
    └─LogicalJoin { type: Inner, on: (t2.v3 = t1.v1), output: all }
      ├─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
      └─LogicalShare { id = 2 }
        └─LogicalProject { exprs: [t1.v1] }
          └─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [v3, v4, v1, t2._row_id(hidden), t1._row_id(hidden)], stream_key: [t2._row_id, t1._row_id, v3], pk_columns: [t2._row_id, t1._row_id, v3], pk_conflict: "NoCheck" }
    └─StreamHashJoin { type: Inner, predicate: t2.v3 = t1.v1, output: [t2.v3, t2.v4, t1.v1, t2._row_id, t1._row_id] }
      ├─StreamExchange { dist: HashShard(t2.v3) }
      | └─StreamTableScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
      └─StreamExchange { dist: HashShard(t1.v1) }
        └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v3 int, v4 int);
    with cte as (select v1, v2 from t1), cte2 as (select v1 from cte) select * from cte2;
  logical_plan: |
    LogicalProject { exprs: [t1.v1] }
    └─LogicalShare { id = 4 }
      └─LogicalProject { exprs: [t1.v1] }
        └─LogicalShare { id = 2 }
          └─LogicalProject { exprs: [t1.v1, t1.v2] }
            └─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: "NoCheck" }
    └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
- sql: |
    create table t1 (x int);
    with with_0 as (select * from t1 group by x having EXISTS(select 0.1)) select * from with_0;
  logical_plan: |
    LogicalProject { exprs: [t1.x] }
    └─LogicalShare { id = 6 }
      └─LogicalProject { exprs: [t1.x] }
        └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
          ├─LogicalAgg { group_key: [t1.x], aggs: [] }
          | └─LogicalProject { exprs: [t1.x] }
          |   └─LogicalScan { table: t1, columns: [t1.x, t1._row_id] }
          └─LogicalProject { exprs: [0.1:Decimal] }
            └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: Ensure we can bind CTE with aliases in both table name and columns
  sql: |
    create table t1 (x int, y int);
    with cte (cosT) as (select * from t1) select * from cte as t2 (ouTflow, profit) join cte on (outflow = cost);
  logical_plan: |
    LogicalProject { exprs: [t1.x, t1.y, t1.x, t1.y] }
    └─LogicalJoin { type: Inner, on: (t1.x = t1.x), output: all }
      ├─LogicalShare { id = 2 }
      | └─LogicalProject { exprs: [t1.x, t1.y] }
      |   └─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id] }
      └─LogicalShare { id = 2 }
        └─LogicalProject { exprs: [t1.x, t1.y] }
          └─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id] }
- sql: |
    create table t (v int, c varchar);
    with dict(abbr, real) as (values ('cn', 'China'), ('us', 'United States')) select * from t join dict on t.c = dict.abbr;
  logical_plan: |
    LogicalProject { exprs: [t.v, t.c, *VALUES*_0.column_0, *VALUES*_0.column_1] }
    └─LogicalJoin { type: Inner, on: (t.c = *VALUES*_0.column_0), output: all }
      ├─LogicalScan { table: t, columns: [t.v, t.c, t._row_id] }
      └─LogicalShare { id = 1 }
        └─LogicalValues { rows: [['cn':Varchar, 'China':Varchar], ['us':Varchar, 'United States':Varchar]], schema: Schema { fields: [*VALUES*_0.column_0:Varchar, *VALUES*_0.column_1:Varchar] } }
  stream_plan: |
    StreamMaterialize { columns: [v, c, abbr, real, t._row_id(hidden), _row_id(hidden)], stream_key: [t._row_id, _row_id, c], pk_columns: [t._row_id, _row_id, c], pk_conflict: "NoCheck" }
    └─StreamHashJoin { type: Inner, predicate: t.c = *VALUES*_0.column_0, output: [t.v, t.c, *VALUES*_0.column_0, *VALUES*_0.column_1, t._row_id, _row_id] }
      ├─StreamExchange { dist: HashShard(t.c) }
      | └─StreamTableScan { table: t, columns: [t.v, t.c, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
      └─StreamExchange { dist: HashShard(*VALUES*_0.column_0) }
        └─StreamValues { rows: [['cn':Varchar, 'China':Varchar, 0:Int64], ['us':Varchar, 'United States':Varchar, 1:Int64]] }
