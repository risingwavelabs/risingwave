# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Temporal filter works on complex columns on LHS
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts + interval '1 hour' > now();
  stream_plan: |
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [t1.ts, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [$expr1], output: ["t1.ts", "$expr1", "t1._row_id"] }
        ├─StreamProject { exprs: [t1.ts, AddWithTimeZone(t1.ts, '01:00:00':Interval, 'UTC':Varchar) as $expr1, t1._row_id] }
        | └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: ["now"] }
- name: Temporal filter works on complex columns on LHS (part 2)
  sql: |
    create table t1 (ts timestamp with time zone, time_to_live interval);
    select * from t1 where ts + time_to_live * 1.5 > now();
  stream_plan: |
    StreamMaterialize { columns: [ts, time_to_live, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [t1.ts, t1.time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [$expr1], output: ["t1.ts", "t1.time_to_live", "$expr1", "t1._row_id"] }
        ├─StreamProject { exprs: [t1.ts, t1.time_to_live, AddWithTimeZone(t1.ts, (t1.time_to_live * 1.5:Decimal), 'UTC':Varchar) as $expr1, t1._row_id] }
        | └─StreamTableScan { table: t1, columns: [t1.ts, t1.time_to_live, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: ["now"] }
- name: Temporal filter works on complex columns on LHS (part 2, flipped)
  sql: |
    create table t1 (ts timestamp with time zone, additional_time_to_live interval);
    select * from t1 where now() - interval '15 minutes' < ts + additional_time_to_live * 1.5;
  stream_plan: |
    StreamMaterialize { columns: [ts, additional_time_to_live, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [$expr1], output: ["t1.ts", "t1.additional_time_to_live", "$expr1", "t1._row_id"] }
        ├─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, AddWithTimeZone(t1.ts, (t1.additional_time_to_live * 1.5:Decimal), 'UTC':Varchar) as $expr1, t1._row_id] }
        | └─StreamTableScan { table: t1, columns: [t1.ts, t1.additional_time_to_live, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
            └─StreamNow { output: ["now"] }
- name: Temporal filter fails without `now()` in lower bound
  sql: |-
    create table t1 (ts timestamp with time zone);
    select * from t1 where now() - interval '15 minutes' > ts;
  stream_error: 'internal error: All `now()` exprs were valid, but the condition must have at least one now expr as a lower bound.'
- name: Temporal filter reorders now expressions correctly
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts < now() - interval '1 hour' and ts >= now() - interval '2 hour';
  stream_plan: |
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: "NoCheck" }
    └─StreamDynamicFilter { predicate: (t1.ts < $expr2), output: ["t1.ts", "t1._row_id"] }
      ├─StreamDynamicFilter { predicate: (t1.ts >= $expr1), output_watermarks: [t1.ts], output: ["t1.ts", "t1._row_id"] }
      | ├─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      | └─StreamExchange { dist: Broadcast }
      |   └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
      |     └─StreamNow { output: ["now"] }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
          └─StreamNow { output: ["now"] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: "NoCheck" }
    ├── materialized table: 4294967294
    └── StreamDynamicFilter { predicate: (t1.ts < $expr2), output: ["t1.ts", "t1._row_id"] } { left table: 0, right table: 1 }
        ├── StreamDynamicFilter { predicate: (t1.ts >= $expr1), output_watermarks: [t1.ts], output: ["t1.ts", "t1._row_id"] }
        │   ├── left table: 2
        │   ├── right table: 3
        │   ├── Chain { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        │   │   ├── state table: 4
        │   │   ├──  Upstream
        │   │   └──  BatchPlanNode
        │   └──  StreamExchange Broadcast from 1
        └──  StreamExchange Broadcast from 2

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
    └──  StreamNow { output: ["now"] } { state table: 5 }

    Fragment 2
    StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
    └──  StreamNow { output: ["now"] } { state table: 6 }

    Table 0
    ├── columns: [ t1_ts, t1__row_id ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ $expr2 ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ t1_ts, t1__row_id ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 3 { columns: [ $expr1 ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4
    ├── columns: [ vnode, _row_id, t1_backfill_finished ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 5 { columns: [ now ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 6 { columns: [ now ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ ts, t1._row_id ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

