# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Temporal filter works on complex columns on LHS
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts + interval '1 hour' > now();
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.ts, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [[$expr1]], output: [t1.ts, $expr1, t1._row_id], cleaned_by_watermark: true }
        ├─StreamProject { exprs: [t1.ts, AddWithTimeZone(t1.ts, '01:00:00':Interval, 'UTC':Varchar) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: Temporal filter works on complex columns on LHS (part 2)
  sql: |
    create table t1 (ts timestamp with time zone, time_to_live interval);
    select * from t1 where ts + time_to_live * 1.5 > now();
  stream_plan: |-
    StreamMaterialize { columns: [ts, time_to_live, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.ts, t1.time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [[$expr1]], output: [t1.ts, t1.time_to_live, $expr1, t1._row_id], cleaned_by_watermark: true }
        ├─StreamProject { exprs: [t1.ts, t1.time_to_live, AddWithTimeZone(t1.ts, (t1.time_to_live * 1.5:Decimal), 'UTC':Varchar) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.ts, t1.time_to_live, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: Temporal filter works on complex columns on LHS (part 2, flipped)
  sql: |
    create table t1 (ts timestamp with time zone, additional_time_to_live interval);
    select * from t1 where now() - interval '15 minutes' < ts + additional_time_to_live * 1.5;
  stream_plan: |-
    StreamMaterialize { columns: [ts, additional_time_to_live, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [t1.ts, t1.additional_time_to_live, $expr1, t1._row_id], cleaned_by_watermark: true }
        ├─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, AddWithTimeZone(t1.ts, (t1.additional_time_to_live * 1.5:Decimal), 'UTC':Varchar) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.ts, t1.additional_time_to_live, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
            └─StreamNow { output: [now] }
- name: Temporal filter with `now()` in upper bound
  sql: |-
    create table t1 (ts timestamp with time zone);
    select * from t1 where now() - interval '15 minutes' > ts;
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], cleaned_by_watermark: true }
      ├─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
          └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └── StreamDynamicFilter { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ] }
        ├── StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        │   ├── tables: [ StreamScan: 2 ]
        │   ├── Upstream
        │   └── BatchPlanNode
        └── StreamExchange Broadcast from 1

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
    └── StreamNow { output: [now] } { tables: [ Now: 3 ] }

    Table 0 { columns: [ t1_ts, t1__row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ ts, t1._row_id, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- name: Temporal filter with equal condition
  sql: |-
    create table t1 (ts timestamp with time zone);
    select * from t1 where date_trunc('week', now()) = date_trunc('week',ts);
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden), $expr1(hidden)], stream_key: [t1._row_id, $expr1], pk_columns: [t1._row_id, $expr1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1._row_id, $expr1) }
      └─StreamHashJoin { type: LeftSemi, predicate: $expr1 = $expr2, output: [t1.ts, t1._row_id, $expr1] }
        ├─StreamExchange { dist: HashShard($expr1) }
        │ └─StreamProject { exprs: [t1.ts, DateTrunc('week':Varchar, t1.ts, 'UTC':Varchar) as $expr1, t1._row_id] }
        │   └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard($expr2) }
          └─StreamProject { exprs: [DateTrunc('week':Varchar, now, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
            └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, t1._row_id(hidden), $expr1(hidden)], stream_key: [t1._row_id, $expr1], pk_columns: [t1._row_id, $expr1], pk_conflict: NoCheck }
    └── StreamExchange Hash([1, 2]) from 1

    Fragment 1
    StreamHashJoin { type: LeftSemi, predicate: $expr1 = $expr2, output: [t1.ts, t1._row_id, $expr1] }
    ├── tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ]
    ├── StreamExchange Hash([1]) from 2
    └── StreamExchange Hash([0]) from 3

    Fragment 2
    StreamProject { exprs: [t1.ts, DateTrunc('week':Varchar, t1.ts, 'UTC':Varchar) as $expr1, t1._row_id] }
    └── StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        ├── tables: [ StreamScan: 4 ]
        ├── Upstream
        └── BatchPlanNode

    Fragment 3
    StreamProject { exprs: [DateTrunc('week':Varchar, now, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 5 ] }

    Table 0 { columns: [ t1_ts, $expr1, t1__row_id, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr1, t1__row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr2, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr2, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 5 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ ts, t1._row_id, $expr1, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $2 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 1, 2 ]
    └── read pk prefix len hint: 2

- name: Temporal filter with `now()` in upper bound on append only table
  sql: |-
    create table t1 (ts timestamp with time zone) APPEND ONLY;
    select * from t1 where now() - interval '15 minutes' > ts;
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter [append_only] { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], cleaned_by_watermark: true }
      ├─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
          └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └── StreamDynamicFilter [append_only] { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ]
        ├── StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        │   ├── tables: [ StreamScan: 2 ]
        │   ├── Upstream
        │   └── BatchPlanNode
        └── StreamExchange Broadcast from 1

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
    └── StreamNow { output: [now] } { tables: [ Now: 3 ] }

    Table 0 { columns: [ t1_ts, t1__row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ ts, t1._row_id, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- name: Temporal filter reorders now expressions correctly
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts < now() - interval '1 hour' and ts >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamDynamicFilter { predicate: (t1.ts >= $expr2), output_watermarks: [[t1.ts]], output: [t1.ts, t1._row_id], cleaned_by_watermark: true }
      ├─StreamDynamicFilter { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], cleaned_by_watermark: true }
      │ ├─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      │ └─StreamExchange { dist: Broadcast }
      │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
      │     └─StreamNow { output: [now] }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
          └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck, watermark_columns: [ts] }
    └── StreamDynamicFilter { predicate: (t1.ts >= $expr2), output_watermarks: [[t1.ts]], output: [t1.ts, t1._row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ]
        ├── StreamDynamicFilter { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 2, DynamicFilterRight: 3 ] }
        │   ├── StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        │   │   ├── tables: [ StreamScan: 4 ]
        │   │   ├── Upstream
        │   │   └── BatchPlanNode
        │   └── StreamExchange Broadcast from 1
        └── StreamExchange Broadcast from 2

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
    └── StreamNow { output: [now] } { tables: [ Now: 5 ] }

    Fragment 2
    StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 6 ] }

    Table 0 { columns: [ t1_ts, t1__row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2 { columns: [ t1_ts, t1__row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr1, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 5 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 6 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ ts, t1._row_id, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

- name: Temporal filter in on clause for inner join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [a, ta, b, tb, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, a], pk_columns: [t1._row_id, t2._row_id, a], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.a, t1._row_id, t2._row_id) }
      └─StreamHashJoin { type: Inner, predicate: t1.a = t2.b, output: [t1.a, t1.ta, t2.b, t2.tb, t1._row_id, t2._row_id] }
        ├─StreamExchange { dist: HashShard(t1.a) }
        │ └─StreamDynamicFilter { predicate: (t1.ta >= $expr2), output_watermarks: [[t1.ta]], output: [t1.a, t1.ta, t1._row_id], cleaned_by_watermark: true }
        │   ├─StreamDynamicFilter { predicate: (t1.ta < $expr1), output: [t1.a, t1.ta, t1._row_id], cleaned_by_watermark: true }
        │   │ ├─StreamTableScan { table: t1, columns: [t1.a, t1.ta, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        │   │ └─StreamExchange { dist: Broadcast }
        │   │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
        │   │     └─StreamNow { output: [now] }
        │   └─StreamExchange { dist: Broadcast }
        │     └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
        │       └─StreamNow { output: [now] }
        └─StreamExchange { dist: HashShard(t2.b) }
          └─StreamTableScan { table: t2, columns: [t2.b, t2.tb, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Temporal filter in on clause for left join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 left join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_error: |-
    Not supported: optimizer has tried to separate the temporal predicate(with now() expression) from the on condition, but it still reminded in on join's condition. Considering move it into WHERE clause?
    HINT: please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: Temporal filter in on clause for right join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 right join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [a, ta, b, tb, t2._row_id(hidden), t1._row_id(hidden)], stream_key: [t2._row_id, t1._row_id, b], pk_columns: [t2._row_id, t1._row_id, b], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t2.b, t2._row_id, t1._row_id) }
      └─StreamHashJoin { type: LeftOuter, predicate: t2.b = t1.a, output: [t1.a, t1.ta, t2.b, t2.tb, t2._row_id, t1._row_id] }
        ├─StreamExchange { dist: HashShard(t2.b) }
        │ └─StreamTableScan { table: t2, columns: [t2.b, t2.tb, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
        └─StreamExchange { dist: HashShard(t1.a) }
          └─StreamDynamicFilter { predicate: (t1.ta >= $expr2), output_watermarks: [[t1.ta]], output: [t1.a, t1.ta, t1._row_id], cleaned_by_watermark: true }
            ├─StreamDynamicFilter { predicate: (t1.ta < $expr1), output: [t1.a, t1.ta, t1._row_id], cleaned_by_watermark: true }
            │ ├─StreamTableScan { table: t1, columns: [t1.a, t1.ta, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
            │ └─StreamExchange { dist: Broadcast }
            │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
            │     └─StreamNow { output: [now] }
            └─StreamExchange { dist: Broadcast }
              └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
                └─StreamNow { output: [now] }
- name: Temporal filter in on clause for full join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 full join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_error: |-
    Not supported: optimizer has tried to separate the temporal predicate(with now() expression) from the on condition, but it still reminded in on join's condition. Considering move it into WHERE clause?
    HINT: please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: Temporal filter in on clause for left join's right side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 left join t2 on a = b AND tb < now() - interval '1 hour' and tb >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [a, ta, b, tb, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, a], pk_columns: [t1._row_id, t2._row_id, a], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.a, t1._row_id, t2._row_id) }
      └─StreamHashJoin { type: LeftOuter, predicate: t1.a = t2.b, output: [t1.a, t1.ta, t2.b, t2.tb, t1._row_id, t2._row_id] }
        ├─StreamExchange { dist: HashShard(t1.a) }
        │ └─StreamTableScan { table: t1, columns: [t1.a, t1.ta, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard(t2.b) }
          └─StreamDynamicFilter { predicate: (t2.tb >= $expr2), output_watermarks: [[t2.tb]], output: [t2.b, t2.tb, t2._row_id], cleaned_by_watermark: true }
            ├─StreamDynamicFilter { predicate: (t2.tb < $expr1), output: [t2.b, t2.tb, t2._row_id], cleaned_by_watermark: true }
            │ ├─StreamTableScan { table: t2, columns: [t2.b, t2.tb, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
            │ └─StreamExchange { dist: Broadcast }
            │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
            │     └─StreamNow { output: [now] }
            └─StreamExchange { dist: Broadcast }
              └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
                └─StreamNow { output: [now] }
- name: Temporal filter in on clause for right join's right side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 right join t2 on a = b AND tb < now() - interval '1 hour' and tb >= now() - interval '2 hour';
  stream_error: |-
    Not supported: optimizer has tried to separate the temporal predicate(with now() expression) from the on condition, but it still reminded in on join's condition. Considering move it into WHERE clause?
    HINT: please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: Temporal filter after temporal join
  sql: |
    create table stream(id1 int, a1 int, b1 int, v1 timestamp with time zone) APPEND ONLY;
    create table version(id2 int, a2 int, b2 int, primary key (id2));
    select id1, a1, id2, v1 from stream left join version FOR SYSTEM_TIME AS OF PROCTIME() on id1 = id2 where v1 > now();
  stream_plan: |-
    StreamMaterialize { columns: [id1, a1, id2, v1, stream._row_id(hidden)], stream_key: [stream._row_id, id1], pk_columns: [stream._row_id, id1], pk_conflict: NoCheck, watermark_columns: [v1] }
    └─StreamProject { exprs: [stream.id1, stream.a1, version.id2, stream.v1, stream._row_id], output_watermarks: [[stream.v1]] }
      └─StreamDynamicFilter { predicate: (stream.v1 > now), output_watermarks: [[stream.v1]], output: [stream.id1, stream.a1, stream.v1, version.id2, stream._row_id], cleaned_by_watermark: true }
        ├─StreamTemporalJoin { type: LeftOuter, append_only: true, predicate: stream.id1 = version.id2, nested_loop: false, output: [stream.id1, stream.a1, stream.v1, version.id2, stream._row_id] }
        │ ├─StreamExchange { dist: HashShard(stream.id1) }
        │ │ └─StreamTableScan { table: stream, columns: [stream.id1, stream.a1, stream.v1, stream._row_id], stream_scan_type: ArrangementBackfill, stream_key: [stream._row_id], pk: [_row_id], dist: UpstreamHashShard(stream._row_id) }
        │ └─StreamExchange [no_shuffle] { dist: UpstreamHashShard(version.id2) }
        │   └─StreamTableScan { table: version, columns: [version.id2], stream_scan_type: UpstreamOnly, stream_key: [version.id2], pk: [id2], dist: UpstreamHashShard(version.id2) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: Temporal filter with or predicate
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts + interval '1 hour' > now() or ts > ' 2023-12-18 00:00:00+00:00';
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden), $src(hidden)], stream_key: [t1._row_id, $src], pk_columns: [t1._row_id, $src], pk_conflict: NoCheck }
    └─StreamUnion { all: true }
      ├─StreamExchange { dist: HashShard(t1._row_id, 0:Int32) }
      │ └─StreamProject { exprs: [t1.ts, t1._row_id, 0:Int32] }
      │   └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [[$expr1]], output: [t1.ts, $expr1, t1._row_id], cleaned_by_watermark: true }
      │     ├─StreamProject { exprs: [t1.ts, AddWithTimeZone(t1.ts, '01:00:00':Interval, 'UTC':Varchar) as $expr1, t1._row_id] }
      │     │ └─StreamFilter { predicate: Not((t1.ts > '2023-12-18 00:00:00+00:00':Timestamptz)) }
      │     │   └─StreamShare { id: 2 }
      │     │     └─StreamFilter { predicate: IsNotNull(t1.ts) }
      │     │       └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      │     └─StreamExchange { dist: Broadcast }
      │       └─StreamNow { output: [now] }
      └─StreamExchange { dist: HashShard(t1._row_id, 1:Int32) }
        └─StreamProject { exprs: [t1.ts, t1._row_id, 1:Int32] }
          └─StreamFilter { predicate: (t1.ts > '2023-12-18 00:00:00+00:00':Timestamptz) }
            └─StreamShare { id: 2 }
              └─StreamFilter { predicate: IsNotNull(t1.ts) }
                └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
- name: Temporal filter with or is null
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts + interval '1 hour' > now() or ts is null;
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden), $src(hidden)], stream_key: [t1._row_id, $src], pk_columns: [t1._row_id, $src], pk_conflict: NoCheck }
    └─StreamUnion { all: true }
      ├─StreamExchange { dist: HashShard(t1._row_id, 0:Int32) }
      │ └─StreamProject { exprs: [t1.ts, t1._row_id, 0:Int32] }
      │   └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [[$expr1]], output: [t1.ts, $expr1, t1._row_id], cleaned_by_watermark: true }
      │     ├─StreamProject { exprs: [t1.ts, AddWithTimeZone(t1.ts, '01:00:00':Interval, 'UTC':Varchar) as $expr1, t1._row_id] }
      │     │ └─StreamFilter { predicate: Not(IsNull(t1.ts)) }
      │     │   └─StreamShare { id: 1 }
      │     │     └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      │     └─StreamExchange { dist: Broadcast }
      │       └─StreamNow { output: [now] }
      └─StreamExchange { dist: HashShard(t1._row_id, 1:Int32) }
        └─StreamProject { exprs: [t1.ts, t1._row_id, 1:Int32] }
          └─StreamFilter { predicate: IsNull(t1.ts) }
            └─StreamShare { id: 1 }
              └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
- name: Temporal filter with or predicate
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts + interval '1 hour' > now() or ts > ' 2023-12-18 00:00:00+00:00' or ts is null;
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden), $src(hidden)], stream_key: [t1._row_id, $src], pk_columns: [t1._row_id, $src], pk_conflict: NoCheck }
    └─StreamUnion { all: true }
      ├─StreamExchange { dist: HashShard(t1._row_id, 0:Int32) }
      │ └─StreamProject { exprs: [t1.ts, t1._row_id, 0:Int32] }
      │   └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [[$expr1]], output: [t1.ts, $expr1, t1._row_id], cleaned_by_watermark: true }
      │     ├─StreamProject { exprs: [t1.ts, AddWithTimeZone(t1.ts, '01:00:00':Interval, 'UTC':Varchar) as $expr1, t1._row_id] }
      │     │ └─StreamFilter { predicate: Not((t1.ts > '2023-12-18 00:00:00+00:00':Timestamptz)) AND Not(IsNull(t1.ts)) }
      │     │   └─StreamShare { id: 2 }
      │     │     └─StreamFilter { predicate: (((Not((t1.ts > '2023-12-18 00:00:00+00:00':Timestamptz)) AND Not(IsNull(t1.ts))) OR (t1.ts > '2023-12-18 00:00:00+00:00':Timestamptz)) OR IsNull(t1.ts)) }
      │     │       └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      │     └─StreamExchange { dist: Broadcast }
      │       └─StreamNow { output: [now] }
      └─StreamExchange { dist: HashShard(t1._row_id, 1:Int32) }
        └─StreamProject { exprs: [t1.ts, t1._row_id, 1:Int32] }
          └─StreamFilter { predicate: ((t1.ts > '2023-12-18 00:00:00+00:00':Timestamptz) OR IsNull(t1.ts)) }
            └─StreamShare { id: 2 }
              └─StreamFilter { predicate: (((Not((t1.ts > '2023-12-18 00:00:00+00:00':Timestamptz)) AND Not(IsNull(t1.ts))) OR (t1.ts > '2023-12-18 00:00:00+00:00':Timestamptz)) OR IsNull(t1.ts)) }
                └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
- name: Many Temporal filter with or predicate
  sql: |
    create table t (t timestamp with time zone, a int);
    select * from t where (t > NOW() - INTERVAL '1 hour' OR t is NULL OR a < 1) AND (t < NOW() - INTERVAL '1 hour' OR a > 1);
  stream_plan: |-
    StreamMaterialize { columns: [t, a, t._row_id(hidden), $src(hidden), $src#1(hidden)], stream_key: [t._row_id, $src, $src#1], pk_columns: [t._row_id, $src, $src#1], pk_conflict: NoCheck }
    └─StreamUnion { all: true }
      ├─StreamExchange { dist: HashShard(t._row_id, $src, 0:Int32) }
      │ └─StreamProject { exprs: [t.t, t.a, t._row_id, $src, 0:Int32] }
      │   └─StreamDynamicFilter { predicate: (t.t < $expr2), output: [t.t, t.a, t._row_id, $src], cleaned_by_watermark: true }
      │     ├─StreamFilter { predicate: Not((t.a > 1:Int32)) }
      │     │ └─StreamShare { id: 13 }
      │     │   └─StreamUnion { all: true }
      │     │     ├─StreamExchange { dist: HashShard(t._row_id, 0:Int32) }
      │     │     │ └─StreamProject { exprs: [t.t, t.a, t._row_id, 0:Int32], output_watermarks: [[t.t]] }
      │     │     │   └─StreamDynamicFilter { predicate: (t.t > $expr1), output_watermarks: [[t.t]], output: [t.t, t.a, t._row_id], cleaned_by_watermark: true }
      │     │     │     ├─StreamFilter { predicate: IsNotNull(t.a) AND Not(IsNull(t.t)) AND Not((t.a < 1:Int32)) }
      │     │     │     │ └─StreamShare { id: 2 }
      │     │     │     │   └─StreamFilter { predicate: IsNotNull(t.a) AND (((Not(IsNull(t.t)) AND Not((t.a < 1:Int32))) OR IsNull(t.t)) OR (t.a < 1:Int32)) }
      │     │     │     │     └─StreamTableScan { table: t, columns: [t.t, t.a, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
      │     │     │     └─StreamExchange { dist: Broadcast }
      │     │     │       └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
      │     │     │         └─StreamNow { output: [now] }
      │     │     └─StreamExchange { dist: HashShard(t._row_id, 1:Int32) }
      │     │       └─StreamProject { exprs: [t.t, t.a, t._row_id, 1:Int32] }
      │     │         └─StreamFilter { predicate: IsNotNull(t.a) AND (IsNull(t.t) OR (t.a < 1:Int32)) }
      │     │           └─StreamShare { id: 2 }
      │     │             └─StreamFilter { predicate: IsNotNull(t.a) AND (((Not(IsNull(t.t)) AND Not((t.a < 1:Int32))) OR IsNull(t.t)) OR (t.a < 1:Int32)) }
      │     │               └─StreamTableScan { table: t, columns: [t.t, t.a, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
      │     └─StreamExchange { dist: Broadcast }
      │       └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
      │         └─StreamNow { output: [now] }
      └─StreamExchange { dist: HashShard(t._row_id, $src, 1:Int32) }
        └─StreamProject { exprs: [t.t, t.a, t._row_id, $src, 1:Int32] }
          └─StreamFilter { predicate: (t.a > 1:Int32) }
            └─StreamShare { id: 13 }
              └─StreamUnion { all: true }
                ├─StreamExchange { dist: HashShard(t._row_id, 0:Int32) }
                │ └─StreamProject { exprs: [t.t, t.a, t._row_id, 0:Int32], output_watermarks: [[t.t]] }
                │   └─StreamDynamicFilter { predicate: (t.t > $expr1), output_watermarks: [[t.t]], output: [t.t, t.a, t._row_id], cleaned_by_watermark: true }
                │     ├─StreamFilter { predicate: IsNotNull(t.a) AND Not(IsNull(t.t)) AND Not((t.a < 1:Int32)) }
                │     │ └─StreamShare { id: 2 }
                │     │   └─StreamFilter { predicate: IsNotNull(t.a) AND (((Not(IsNull(t.t)) AND Not((t.a < 1:Int32))) OR IsNull(t.t)) OR (t.a < 1:Int32)) }
                │     │     └─StreamTableScan { table: t, columns: [t.t, t.a, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
                │     └─StreamExchange { dist: Broadcast }
                │       └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
                │         └─StreamNow { output: [now] }
                └─StreamExchange { dist: HashShard(t._row_id, 1:Int32) }
                  └─StreamProject { exprs: [t.t, t.a, t._row_id, 1:Int32] }
                    └─StreamFilter { predicate: IsNotNull(t.a) AND (IsNull(t.t) OR (t.a < 1:Int32)) }
                      └─StreamShare { id: 2 }
                        └─StreamFilter { predicate: IsNotNull(t.a) AND (((Not(IsNull(t.t)) AND Not((t.a < 1:Int32))) OR IsNull(t.t)) OR (t.a < 1:Int32)) }
                          └─StreamTableScan { table: t, columns: [t.t, t.a, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: Non-trivial now expression
  sql: |
    create table t (ts timestamp with time zone, a int);
    select * from t where ts + interval '1 hour' > date_trunc('day', now());
  stream_plan: |-
    StreamMaterialize { columns: [ts, a, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t.ts, t.a, t._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [t.ts, t.a, $expr1, t._row_id], cleaned_by_watermark: true }
        ├─StreamProject { exprs: [t.ts, t.a, AddWithTimeZone(t.ts, '01:00:00':Interval, 'UTC':Varchar) as $expr1, t._row_id] }
        │ └─StreamTableScan { table: t, columns: [t.ts, t.a, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [DateTrunc('day':Varchar, now, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
            └─StreamNow { output: [now] }
- name: Non-trivial now expression 2
  sql: |
    create table t (ts timestamp with time zone, a int);
    select * from t where ts + interval '1 hour' > date_trunc('day', ('2024-07-18 00:00:00+00:00'::timestamptz - ('2024-07-18 00:00:00+00:00'::timestamptz - now())));
  stream_plan: |-
    StreamMaterialize { columns: [ts, a, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t.ts, t.a, t._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output: [t.ts, t.a, $expr1, t._row_id] }
        ├─StreamProject { exprs: [t.ts, t.a, AddWithTimeZone(t.ts, '01:00:00':Interval, 'UTC':Varchar) as $expr1, t._row_id] }
        │ └─StreamTableScan { table: t, columns: [t.ts, t.a, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [DateTrunc('day':Varchar, SubtractWithTimeZone('2024-07-18 00:00:00+00:00':Timestamptz, ('2024-07-18 00:00:00+00:00':Timestamptz - now), 'UTC':Varchar), 'UTC':Varchar) as $expr2] }
            └─StreamNow { output: [now] }
- name: Non-monotonic now expression
  sql: |
    create table t (ts timestamp with time zone, a int);
    select * from t where a > extract(hour from now());
  stream_error: Conditions containing now must be in the form of `input_expr cmp now_expr` or `now_expr cmp input_expr`, where `input_expr` references a column and contains no `now()`, and `now_expr` is a non-decreasing expression contains `now()`.
