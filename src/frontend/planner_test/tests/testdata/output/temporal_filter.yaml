# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Temporal filter works on complex columns on LHS
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts + interval '1 hour' > now();
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.ts, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [$expr1], output: [t1.ts, $expr1, t1._row_id] }
        ├─StreamProject { exprs: [t1.ts, AddWithTimeZone(t1.ts, '01:00:00':Interval, 'UTC':Varchar) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: Temporal filter works on complex columns on LHS (part 2)
  sql: |
    create table t1 (ts timestamp with time zone, time_to_live interval);
    select * from t1 where ts + time_to_live * 1.5 > now();
  stream_plan: |-
    StreamMaterialize { columns: [ts, time_to_live, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.ts, t1.time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [$expr1], output: [t1.ts, t1.time_to_live, $expr1, t1._row_id] }
        ├─StreamProject { exprs: [t1.ts, t1.time_to_live, AddWithTimeZone(t1.ts, (t1.time_to_live * 1.5:Decimal), 'UTC':Varchar) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.ts, t1.time_to_live, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: Temporal filter works on complex columns on LHS (part 2, flipped)
  sql: |
    create table t1 (ts timestamp with time zone, additional_time_to_live interval);
    select * from t1 where now() - interval '15 minutes' < ts + additional_time_to_live * 1.5;
  stream_plan: |-
    StreamMaterialize { columns: [ts, additional_time_to_live, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [$expr1], output: [t1.ts, t1.additional_time_to_live, $expr1, t1._row_id] }
        ├─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, AddWithTimeZone(t1.ts, (t1.additional_time_to_live * 1.5:Decimal), 'UTC':Varchar) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.ts, t1.additional_time_to_live, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
            └─StreamNow { output: [now] }
- name: Temporal filter fails without `now()` in lower bound
  sql: |-
    create table t1 (ts timestamp with time zone);
    select * from t1 where now() - interval '15 minutes' > ts;
  stream_error: 'internal error: All `now()` exprs were valid, but the condition must have at least one now expr as a lower bound.'
- name: Temporal filter reorders now expressions correctly
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts < now() - interval '1 hour' and ts >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.ts < $expr2), output: [t1.ts, t1._row_id] }
      ├─StreamDynamicFilter { predicate: (t1.ts >= $expr1), output_watermarks: [t1.ts], output: [t1.ts, t1._row_id] }
      │ ├─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      │ └─StreamExchange { dist: Broadcast }
      │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
      │     └─StreamNow { output: [now] }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
          └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamDynamicFilter { predicate: (t1.ts < $expr2), output: [t1.ts, t1._row_id] } { left table: 0, right table: 1 }
        ├── StreamDynamicFilter { predicate: (t1.ts >= $expr1), output_watermarks: [t1.ts], output: [t1.ts, t1._row_id] }
        │   ├── left table: 2
        │   ├── right table: 3
        │   ├── Chain { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        │   │   ├── state table: 4
        │   │   ├── Upstream
        │   │   └── BatchPlanNode
        │   └── StreamExchange Broadcast from 1
        └── StreamExchange Broadcast from 2

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
    └── StreamNow { output: [now] } { state table: 5 }

    Fragment 2
    StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
    └── StreamNow { output: [now] } { state table: 6 }

    Table 0
    ├── columns: [ t1_ts, t1__row_id ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ $expr2 ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ t1_ts, t1__row_id ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 3 { columns: [ $expr1 ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4
    ├── columns: [ vnode, _row_id, t1_backfill_finished ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 5 { columns: [ now ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 6 { columns: [ now ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ ts, t1._row_id ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

- name: Temporal filter in on clause for inner join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [a, ta, b, tb, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, a], pk_columns: [t1._row_id, t2._row_id, a], pk_conflict: NoCheck }
    └─StreamHashJoin { type: Inner, predicate: t1.a = t2.b, output: [t1.a, t1.ta, t2.b, t2.tb, t1._row_id, t2._row_id] }
      ├─StreamExchange { dist: HashShard(t1.a) }
      │ └─StreamDynamicFilter { predicate: (t1.ta < $expr2), output: [t1.a, t1.ta, t1._row_id] }
      │   ├─StreamDynamicFilter { predicate: (t1.ta >= $expr1), output_watermarks: [t1.ta], output: [t1.a, t1.ta, t1._row_id] }
      │   │ ├─StreamTableScan { table: t1, columns: [t1.a, t1.ta, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      │   │ └─StreamExchange { dist: Broadcast }
      │   │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
      │   │     └─StreamNow { output: [now] }
      │   └─StreamExchange { dist: Broadcast }
      │     └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
      │       └─StreamNow { output: [now] }
      └─StreamExchange { dist: HashShard(t2.b) }
        └─StreamTableScan { table: t2, columns: [t2.b, t2.tb, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Temporal filter in on clause for left join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 left join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_error: |-
    Not supported: optimizer has tried to separate the temporal predicate(with now() expression) from the on condition, but it still reminded in on join's condition. Considering move it into WHERE clause?
    HINT: please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: Temporal filter in on clause for right join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 right join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [a, ta, b, tb, t2._row_id(hidden), t1._row_id(hidden)], stream_key: [t2._row_id, t1._row_id, b], pk_columns: [t2._row_id, t1._row_id, b], pk_conflict: NoCheck }
    └─StreamHashJoin { type: LeftOuter, predicate: t2.b = t1.a, output: [t1.a, t1.ta, t2.b, t2.tb, t2._row_id, t1._row_id] }
      ├─StreamExchange { dist: HashShard(t2.b) }
      │ └─StreamTableScan { table: t2, columns: [t2.b, t2.tb, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
      └─StreamExchange { dist: HashShard(t1.a) }
        └─StreamDynamicFilter { predicate: (t1.ta < $expr2), output: [t1.a, t1.ta, t1._row_id] }
          ├─StreamDynamicFilter { predicate: (t1.ta >= $expr1), output_watermarks: [t1.ta], output: [t1.a, t1.ta, t1._row_id] }
          │ ├─StreamTableScan { table: t1, columns: [t1.a, t1.ta, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
          │ └─StreamExchange { dist: Broadcast }
          │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
          │     └─StreamNow { output: [now] }
          └─StreamExchange { dist: Broadcast }
            └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
              └─StreamNow { output: [now] }
- name: Temporal filter in on clause for full join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 full join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_error: |-
    Not supported: optimizer has tried to separate the temporal predicate(with now() expression) from the on condition, but it still reminded in on join's condition. Considering move it into WHERE clause?
    HINT: please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: Temporal filter in on clause for left join's right side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 left join t2 on a = b AND tb < now() - interval '1 hour' and tb >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [a, ta, b, tb, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, a], pk_columns: [t1._row_id, t2._row_id, a], pk_conflict: NoCheck }
    └─StreamHashJoin { type: LeftOuter, predicate: t1.a = t2.b, output: [t1.a, t1.ta, t2.b, t2.tb, t1._row_id, t2._row_id] }
      ├─StreamExchange { dist: HashShard(t1.a) }
      │ └─StreamTableScan { table: t1, columns: [t1.a, t1.ta, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: HashShard(t2.b) }
        └─StreamDynamicFilter { predicate: (t2.tb < $expr2), output: [t2.b, t2.tb, t2._row_id] }
          ├─StreamDynamicFilter { predicate: (t2.tb >= $expr1), output_watermarks: [t2.tb], output: [t2.b, t2.tb, t2._row_id] }
          │ ├─StreamTableScan { table: t2, columns: [t2.b, t2.tb, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
          │ └─StreamExchange { dist: Broadcast }
          │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
          │     └─StreamNow { output: [now] }
          └─StreamExchange { dist: Broadcast }
            └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
              └─StreamNow { output: [now] }
- name: Temporal filter in on clause for right join's right side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 right join t2 on a = b AND tb < now() - interval '1 hour' and tb >= now() - interval '2 hour';
  stream_error: |-
    Not supported: optimizer has tried to separate the temporal predicate(with now() expression) from the on condition, but it still reminded in on join's condition. Considering move it into WHERE clause?
    HINT: please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
