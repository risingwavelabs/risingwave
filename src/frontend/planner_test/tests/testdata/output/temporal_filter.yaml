# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Temporal filter works on complex columns on LHS
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts + interval '1 hour' > now();
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.ts, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [$expr1], output: [t1.ts, $expr1, t1._row_id], cleaned_by_watermark: true }
        ├─StreamProject { exprs: [t1.ts, AddWithTimeZone(t1.ts, '01:00:00':Interval, 'UTC':Varchar) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: Temporal filter works on complex columns on LHS (part 2)
  sql: |
    create table t1 (ts timestamp with time zone, time_to_live interval);
    select * from t1 where ts + time_to_live * 1.5 > now();
  stream_plan: |-
    StreamMaterialize { columns: [ts, time_to_live, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.ts, t1.time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > now), output_watermarks: [$expr1], output: [t1.ts, t1.time_to_live, $expr1, t1._row_id], cleaned_by_watermark: true }
        ├─StreamProject { exprs: [t1.ts, t1.time_to_live, AddWithTimeZone(t1.ts, (t1.time_to_live * 1.5:Decimal), 'UTC':Varchar) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.ts, t1.time_to_live, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: Temporal filter works on complex columns on LHS (part 2, flipped)
  sql: |
    create table t1 (ts timestamp with time zone, additional_time_to_live interval);
    select * from t1 where now() - interval '15 minutes' < ts + additional_time_to_live * 1.5;
  stream_plan: |-
    StreamMaterialize { columns: [ts, additional_time_to_live, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [$expr1], output: [t1.ts, t1.additional_time_to_live, $expr1, t1._row_id], cleaned_by_watermark: true }
        ├─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, AddWithTimeZone(t1.ts, (t1.additional_time_to_live * 1.5:Decimal), 'UTC':Varchar) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.ts, t1.additional_time_to_live, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
            └─StreamNow { output: [now] }
- name: Temporal filter with `now()` in upper bound
  sql: |-
    create table t1 (ts timestamp with time zone);
    select * from t1 where now() - interval '15 minutes' > ts;
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], condition_always_relax: true }
      ├─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
          └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamDynamicFilter { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], condition_always_relax: true }
        ├── left table: 0
        ├── right table: 1
        ├── StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        │   ├── state table: 2
        │   ├── Upstream
        │   └── BatchPlanNode
        └── StreamExchange Broadcast from 1

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
    └── StreamNow { output: [now] } { state table: 3 }

    Table 0
    ├── columns: [ t1_ts, t1__row_id ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ $expr1 ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, _row_id, t1_backfill_finished, t1_row_count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3 { columns: [ now ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ ts, t1._row_id ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

- name: Temporal filter with `now()` in upper bound on append only table
  sql: |-
    create table t1 (ts timestamp with time zone) APPEND ONLY;
    select * from t1 where now() - interval '15 minutes' > ts;
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter [append_only] { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], condition_always_relax: true }
      ├─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
          └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamDynamicFilter [append_only] { predicate: (t1.ts < $expr1), output: [t1.ts, t1._row_id], condition_always_relax: true }
        ├── left table: 0
        ├── right table: 1
        ├── StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        │   ├── state table: 2
        │   ├── Upstream
        │   └── BatchPlanNode
        └── StreamExchange Broadcast from 1

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:15:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
    └── StreamNow { output: [now] } { state table: 3 }

    Table 0
    ├── columns: [ t1_ts, t1__row_id ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ $expr1 ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, _row_id, t1_backfill_finished, t1_row_count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3 { columns: [ now ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ ts, t1._row_id ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

- name: Temporal filter reorders now expressions correctly
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts < now() - interval '1 hour' and ts >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.ts < $expr2), output: [t1.ts, t1._row_id], condition_always_relax: true }
      ├─StreamDynamicFilter { predicate: (t1.ts >= $expr1), output_watermarks: [t1.ts], output: [t1.ts, t1._row_id], cleaned_by_watermark: true }
      │ ├─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      │ └─StreamExchange { dist: Broadcast }
      │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
      │     └─StreamNow { output: [now] }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
          └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamDynamicFilter { predicate: (t1.ts < $expr2), output: [t1.ts, t1._row_id], condition_always_relax: true }
        ├── left table: 0
        ├── right table: 1
        ├── StreamDynamicFilter { predicate: (t1.ts >= $expr1), output_watermarks: [t1.ts], output: [t1.ts, t1._row_id], cleaned_by_watermark: true }
        │   ├── left table: 2
        │   ├── right table: 3
        │   ├── StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        │   │   ├── state table: 4
        │   │   ├── Upstream
        │   │   └── BatchPlanNode
        │   └── StreamExchange Broadcast from 1
        └── StreamExchange Broadcast from 2

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
    └── StreamNow { output: [now] } { state table: 5 }

    Fragment 2
    StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
    └── StreamNow { output: [now] } { state table: 6 }

    Table 0
    ├── columns: [ t1_ts, t1__row_id ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ $expr2 ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ t1_ts, t1__row_id ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 3 { columns: [ $expr1 ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4
    ├── columns: [ vnode, _row_id, t1_backfill_finished, t1_row_count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 5 { columns: [ now ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 6 { columns: [ now ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ ts, t1._row_id ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

- name: Temporal filter in on clause for inner join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [a, ta, b, tb, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, a], pk_columns: [t1._row_id, t2._row_id, a], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.a, t1._row_id, t2._row_id) }
      └─StreamHashJoin { type: Inner, predicate: t1.a = t2.b, output: [t1.a, t1.ta, t2.b, t2.tb, t1._row_id, t2._row_id] }
        ├─StreamExchange { dist: HashShard(t1.a) }
        │ └─StreamDynamicFilter { predicate: (t1.ta < $expr2), output: [t1.a, t1.ta, t1._row_id], condition_always_relax: true }
        │   ├─StreamDynamicFilter { predicate: (t1.ta >= $expr1), output_watermarks: [t1.ta], output: [t1.a, t1.ta, t1._row_id], cleaned_by_watermark: true }
        │   │ ├─StreamTableScan { table: t1, columns: [t1.a, t1.ta, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        │   │ └─StreamExchange { dist: Broadcast }
        │   │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
        │   │     └─StreamNow { output: [now] }
        │   └─StreamExchange { dist: Broadcast }
        │     └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
        │       └─StreamNow { output: [now] }
        └─StreamExchange { dist: HashShard(t2.b) }
          └─StreamTableScan { table: t2, columns: [t2.b, t2.tb, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Temporal filter in on clause for left join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 left join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_error: |-
    Not supported: optimizer has tried to separate the temporal predicate(with now() expression) from the on condition, but it still reminded in on join's condition. Considering move it into WHERE clause?
    HINT: please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: Temporal filter in on clause for right join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 right join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [a, ta, b, tb, t2._row_id(hidden), t1._row_id(hidden)], stream_key: [t2._row_id, t1._row_id, b], pk_columns: [t2._row_id, t1._row_id, b], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t2.b, t2._row_id, t1._row_id) }
      └─StreamHashJoin { type: LeftOuter, predicate: t2.b = t1.a, output: [t1.a, t1.ta, t2.b, t2.tb, t2._row_id, t1._row_id] }
        ├─StreamExchange { dist: HashShard(t2.b) }
        │ └─StreamTableScan { table: t2, columns: [t2.b, t2.tb, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
        └─StreamExchange { dist: HashShard(t1.a) }
          └─StreamDynamicFilter { predicate: (t1.ta < $expr2), output: [t1.a, t1.ta, t1._row_id], condition_always_relax: true }
            ├─StreamDynamicFilter { predicate: (t1.ta >= $expr1), output_watermarks: [t1.ta], output: [t1.a, t1.ta, t1._row_id], cleaned_by_watermark: true }
            │ ├─StreamTableScan { table: t1, columns: [t1.a, t1.ta, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
            │ └─StreamExchange { dist: Broadcast }
            │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
            │     └─StreamNow { output: [now] }
            └─StreamExchange { dist: Broadcast }
              └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
                └─StreamNow { output: [now] }
- name: Temporal filter in on clause for full join's left side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 full join t2 on a = b AND ta < now() - interval '1 hour' and ta >= now() - interval '2 hour';
  stream_error: |-
    Not supported: optimizer has tried to separate the temporal predicate(with now() expression) from the on condition, but it still reminded in on join's condition. Considering move it into WHERE clause?
    HINT: please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: Temporal filter in on clause for left join's right side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 left join t2 on a = b AND tb < now() - interval '1 hour' and tb >= now() - interval '2 hour';
  stream_plan: |-
    StreamMaterialize { columns: [a, ta, b, tb, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, a], pk_columns: [t1._row_id, t2._row_id, a], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.a, t1._row_id, t2._row_id) }
      └─StreamHashJoin { type: LeftOuter, predicate: t1.a = t2.b, output: [t1.a, t1.ta, t2.b, t2.tb, t1._row_id, t2._row_id] }
        ├─StreamExchange { dist: HashShard(t1.a) }
        │ └─StreamTableScan { table: t1, columns: [t1.a, t1.ta, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard(t2.b) }
          └─StreamDynamicFilter { predicate: (t2.tb < $expr2), output: [t2.b, t2.tb, t2._row_id], condition_always_relax: true }
            ├─StreamDynamicFilter { predicate: (t2.tb >= $expr1), output_watermarks: [t2.tb], output: [t2.b, t2.tb, t2._row_id], cleaned_by_watermark: true }
            │ ├─StreamTableScan { table: t2, columns: [t2.b, t2.tb, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
            │ └─StreamExchange { dist: Broadcast }
            │   └─StreamProject { exprs: [SubtractWithTimeZone(now, '02:00:00':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [$expr1] }
            │     └─StreamNow { output: [now] }
            └─StreamExchange { dist: Broadcast }
              └─StreamProject { exprs: [SubtractWithTimeZone(now, '01:00:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [$expr2] }
                └─StreamNow { output: [now] }
- name: Temporal filter in on clause for right join's right side
  sql: |
    create table t1 (a int, ta timestamp with time zone);
    create table t2 (b int, tb timestamp with time zone);
    select * from t1 right join t2 on a = b AND tb < now() - interval '1 hour' and tb >= now() - interval '2 hour';
  stream_error: |-
    Not supported: optimizer has tried to separate the temporal predicate(with now() expression) from the on condition, but it still reminded in on join's condition. Considering move it into WHERE clause?
    HINT: please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: Temporal filter after temporal join
  sql: |
    create table stream(id1 int, a1 int, b1 int, v1 timestamp with time zone) APPEND ONLY;
    create table version(id2 int, a2 int, b2 int, primary key (id2));
    select id1, a1, id2, v1 from stream left join version FOR SYSTEM_TIME AS OF PROCTIME() on id1 = id2 where v1 > now();
  stream_plan: |-
    StreamMaterialize { columns: [id1, a1, id2, v1, stream._row_id(hidden)], stream_key: [stream._row_id, id1], pk_columns: [stream._row_id, id1], pk_conflict: NoCheck, watermark_columns: [v1] }
    └─StreamProject { exprs: [stream.id1, stream.a1, version.id2, stream.v1, stream._row_id], output_watermarks: [stream.v1] }
      └─StreamDynamicFilter { predicate: (stream.v1 > now), output_watermarks: [stream.v1], output: [stream.id1, stream.a1, stream.v1, version.id2, stream._row_id], cleaned_by_watermark: true }
        ├─StreamTemporalJoin { type: LeftOuter, predicate: stream.id1 = version.id2, output: [stream.id1, stream.a1, stream.v1, version.id2, stream._row_id] }
        │ ├─StreamExchange { dist: HashShard(stream.id1) }
        │ │ └─StreamTableScan { table: stream, columns: [stream.id1, stream.a1, stream.v1, stream._row_id], pk: [stream._row_id], dist: UpstreamHashShard(stream._row_id) }
        │ └─StreamExchange [no_shuffle] { dist: UpstreamHashShard(version.id2) }
        │   └─StreamTableScan { table: version, columns: [version.id2], pk: [version.id2], dist: UpstreamHashShard(version.id2) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
