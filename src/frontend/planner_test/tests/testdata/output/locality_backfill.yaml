# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    set enable_locality_backfill = true;
    create table t (a int, b int, c int);
    select count(*) from t group by b;
  stream_plan: |-
    StreamMaterialize { columns: [count, t.b(hidden)], stream_key: [t.b], pk_columns: [t.b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count, t.b] }
      └─StreamHashAgg { group_key: [t.b], aggs: [count] }
        └─StreamLocalityProvider { locality_columns: [t.b] }
          └─StreamExchange { dist: HashShard(t.b) }
            └─StreamTableScan { table: t, columns: [t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    set enable_locality_backfill = true;
    create table t1 (a int, b int, c int);
    create table t2 (a int, b int, c int);
    select count(*) from t1 join t2 on t1.a = t2.a group by t1.b;
  stream_plan: |-
    StreamMaterialize { columns: [count, t1.b(hidden)], stream_key: [t1.b], pk_columns: [t1.b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count, t1.b] }
      └─StreamHashAgg { group_key: [t1.b], aggs: [count] }
        └─StreamLocalityProvider { locality_columns: [t1.b] }
          └─StreamExchange { dist: HashShard(t1.b) }
            └─StreamHashJoin { type: Inner, predicate: t1.a = t2.a, output: [t1.b, t1._row_id, t1.a, t2._row_id] }
              ├─StreamExchange { dist: HashShard(t1.a) }
              │ └─StreamLocalityProvider { locality_columns: [t1.a] }
              │   └─StreamExchange { dist: HashShard(t1.a) }
              │     └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              └─StreamExchange { dist: HashShard(t2.a) }
                └─StreamLocalityProvider { locality_columns: [t2.a] }
                  └─StreamExchange { dist: HashShard(t2.a) }
                    └─StreamTableScan { table: t2, columns: [t2.a, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- sql: |
    set enable_locality_backfill = true;
    create table t (a int, b int, c int, primary key (b, a));
    select count(*) from t group by a, b;
  stream_plan: |-
    StreamMaterialize { columns: [count, t.a(hidden), t.b(hidden)], stream_key: [t.a, t.b], pk_columns: [t.a, t.b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count, t.a, t.b] }
      └─StreamHashAgg { group_key: [t.a, t.b], aggs: [count] }
        └─StreamLocalityProvider { locality_columns: [t.a, t.b] }
          └─StreamExchange [no_shuffle] { dist: UpstreamHashShard(t.b, t.a) }
            └─StreamTableScan { table: t, columns: [t.a, t.b], stream_scan_type: ArrangementBackfill, stream_key: [t.b, t.a], pk: [b, a], dist: UpstreamHashShard(t.b, t.a) }
