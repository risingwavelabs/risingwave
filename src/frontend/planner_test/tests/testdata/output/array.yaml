# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    values (ARRAY['foo', 'bar']);
  logical_plan: 'LogicalValues { rows: [[Array(''foo'':Varchar, ''bar'':Varchar)]], schema: Schema { fields: [*VALUES*_0.column_0:List(Varchar)] } }'
  batch_plan: 'BatchValues { rows: [[ARRAY[foo, bar]:List(Varchar)]] }'
- sql: |
    values (ARRAY[1, 2+3, 4*5+1]);
  logical_plan: 'LogicalValues { rows: [[Array(1:Int32, (2:Int32 + 3:Int32), ((4:Int32 * 5:Int32) + 1:Int32))]], schema: Schema { fields: [*VALUES*_0.column_0:List(Int32)] } }'
  batch_plan: 'BatchValues { rows: [[ARRAY[1, 5, 21]:List(Int32)]] }'
- sql: |
    create table t (v1 int);
    select (ARRAY[1, v1]) from t;
  logical_plan: |-
    LogicalProject { exprs: [Array(1:Int32, t.v1) as $expr1] }
    └─LogicalScan { table: t, columns: [t.v1, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Array(1:Int32, t.v1) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    select ARRAY[null];
  logical_plan: |-
    LogicalProject { exprs: [Array(null:Varchar) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select ARRAY[];
  binder_error: |
    Failed to bind expression: ARRAY[]

    Caused by:
      Bind error: cannot determine type of empty array
    HINT:  Explicitly cast to the desired type, for example ARRAY[]::integer[].
- sql: |
    select ARRAY[]::int[];
  logical_plan: |-
    LogicalProject { exprs: [Array as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select ARRAY[]::int[][];
  logical_plan: |-
    LogicalProject { exprs: [Array as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select ARRAY[]::int;
  binder_error: |
    Failed to bind expression: CAST(ARRAY[] AS INT)

    Caused by:
      Bind error: cannot determine type of empty array
    HINT:  Explicitly cast to the desired type, for example ARRAY[]::integer[].
- sql: |
    select ARRAY[]::timestamptz[];
  logical_plan: |-
    LogicalProject { exprs: [Array as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: 'BatchValues { rows: [[ARRAY[]:List(Timestamptz)]] }'
  stream_plan: |-
    StreamMaterialize { columns: [array, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamValues { rows: [[ARRAY[]:List(Timestamptz), 0:Int64]] }
- sql: |
    select ARRAY[]::STRUCT<f1 INT>[];
  logical_plan: |-
    LogicalProject { exprs: [Array as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: 'BatchValues { rows: [[ARRAY[]:List(Struct(StructType { fields: [("f1", Int32)] }))]] }'
  stream_plan: |-
    StreamMaterialize { columns: [array, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamValues { rows: [[ARRAY[]:List(Struct(StructType { fields: [("f1", Int32)] })), 0:Int64]] }
- sql: |
    select array_cat(array[66], array[123]);
  logical_plan: |-
    LogicalProject { exprs: [ArrayCat(Array(66:Int32), Array(123:Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: 'BatchValues { rows: [[ARRAY[66, 123]:List(Int32)]] }'
- sql: |
    select array_cat(array[array[66]], array[233]);
  logical_plan: |-
    LogicalProject { exprs: [ArrayCat(Array(Array(66:Int32)), Array(233:Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: 'BatchValues { rows: [[ARRAY[{66}, {233}]:List(List(Int32))]] }'
- sql: |
    select array_cat(array[233], array[array[66]]);
  logical_plan: |-
    LogicalProject { exprs: [ArrayCat(Array(233:Int32), Array(Array(66:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: 'BatchValues { rows: [[ARRAY[{233}, {66}]:List(List(Int32))]] }'
- sql: |
    select array_cat(array[233], array[array[array[66]]]);
  binder_error: |
    Failed to bind expression: array_cat(ARRAY[233], ARRAY[ARRAY[ARRAY[66]]])

    Caused by:
      Bind error: Cannot concatenate integer[] and integer[][][]
- sql: |
    select array_cat(array[233], 123);
  binder_error: |
    Failed to bind expression: array_cat(ARRAY[233], 123)

    Caused by:
      Bind error: Cannot concatenate integer[] and integer
- sql: |
    select array_cat(123, array[233]);
  binder_error: |
    Failed to bind expression: array_cat(123, ARRAY[233])

    Caused by:
      Bind error: Cannot concatenate integer and integer[]
- name: array_cat(unknown as text[], unknown as text[]) -> text[]
  sql: |
    select array_cat(null, null);
  batch_plan: 'BatchValues { rows: [[null:List(Varchar)]] }'
- name: array_cat(unknown as text[], unknown as text[]) -> text[]
  sql: |
    select array_cat('{a}', '{b}');
  batch_plan: 'BatchValues { rows: [[ARRAY[a, b]:List(Varchar)]] }'
- name: array_cat(unknown as text[], unknown as text[]) -> text[]
  sql: |
    select array_cat('{a}', '{"{b}"}') = array['a', '{b}'];
  batch_plan: 'BatchValues { rows: [[true:Boolean]] }'
- name: array_cat(unknown as int[], int[]) -> int[]
  sql: |
    select array_cat('{1}', array[2]);
  batch_plan: 'BatchValues { rows: [[ARRAY[1, 2]:List(Int32)]] }'
- name: array_cat(unknown, int) -> err
  sql: |
    select array_cat('{1}', 2);
  binder_error: |
    Failed to bind expression: array_cat('{1}', 2)

    Caused by:
      Bind error: Cannot concatenate character varying and integer
- sql: |
    select array_append(array[66], 123);
  logical_plan: |-
    LogicalProject { exprs: [ArrayAppend(Array(66:Int32), 123:Int32) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: 'BatchValues { rows: [[ARRAY[66, 123]:List(Int32)]] }'
- sql: |
    select array_append(123, 234);
  binder_error: |
    Failed to bind expression: array_append(123, 234)

    Caused by:
      Bind error: Cannot append integer to integer
- sql: |
    /* Combining multidimensional arrays as such is supported beyond what PostgresSQL allows */
    select array_append(array[array[66]], array[233]);
  logical_plan: |-
    LogicalProject { exprs: [ArrayAppend(Array(Array(66:Int32)), Array(233:Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: array_append(unknown as text[], unknown as text) -> text[]
  sql: |
    select array_append(null, null);
  batch_plan: 'BatchValues { rows: [[ARRAY[null]:List(Varchar)]] }'
- name: array_append(unknown as text[], unknown as text) -> text[]
  sql: |
    select array_append('{a}', 'b');
  batch_plan: 'BatchValues { rows: [[ARRAY[a, b]:List(Varchar)]] }'
- name: array_append(unknown as int[], int) -> int[]
  sql: |
    select array_append(null, 2);
  batch_plan: 'BatchValues { rows: [[ARRAY[2]:List(Int32)]] }'
- name: array_append(int[], unknown as int) -> int[]
  sql: |
    select array_append(array[1], null);
  batch_plan: 'BatchValues { rows: [[ARRAY[1, null]:List(Int32)]] }'
- sql: |
    select array_prepend(123, array[66]);
  logical_plan: |-
    LogicalProject { exprs: [ArrayPrepend(123:Int32, Array(66:Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: 'BatchValues { rows: [[ARRAY[123, 66]:List(Int32)]] }'
- sql: |
    select array_prepend(123, 234);
  binder_error: |
    Failed to bind expression: array_prepend(123, 234)

    Caused by:
      Bind error: Cannot prepend integer to integer
- sql: |
    select array_prepend(array[233], array[array[66]]);
  logical_plan: |-
    LogicalProject { exprs: [ArrayPrepend(Array(233:Int32), Array(Array(66:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: array_contains(int[], int[]) -> bool
  sql: select array[1,2] @> array[2,3];
  logical_plan: |-
    LogicalProject { exprs: [(Array(1:Int32, 2:Int32) @> Array(2:Int32, 3:Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: array_contains(int[][], int[]) -> bool
  sql: select array[[1,2]] @> array[2,3];
  logical_plan: |-
    LogicalProject { exprs: [(Array(Array(1:Int32, 2:Int32)) @> Array(2:Int32, 3:Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: array_contains(int[], int) -> bool
  sql: select array[1,2] @> 2;
  binder_error: |
    Failed to bind expression: ARRAY[1, 2] @> 2

    Caused by:
      Bind error: operator does not exist: integer[] @> integer
- name: array_contains(int[], varchar[]) -> bool
  sql: select array[2,3] @> array['1'];
  binder_error: |
    Failed to bind expression: ARRAY[2, 3] @> ARRAY['1']

    Caused by:
      Bind error: Cannot array_contains unnested type integer to unnested type character varying
- name: array_contains(int[][], varchar[][]) -> bool
  sql: select array[array[1,2]] @> array[array['2','3']];
  binder_error: |
    Failed to bind expression: ARRAY[ARRAY[1, 2]] @> ARRAY[ARRAY['2', '3']]

    Caused by:
      Bind error: Cannot array_contains unnested type integer to unnested type character varying
- name: any contains(null, null) -> bool
  sql: select '{}' @> '{}';
  binder_error: |
    Failed to bind expression: '{}' @> '{}'

    Caused by:
      Bind error: operator does not exist: unknown @> unknown
- name: string from/to varchar[] in implicit context
  sql: |
    values (array['a', 'b']), ('{c,' || 'd}');
  binder_error: 'Bind error: types List(Varchar) and Varchar cannot be matched'
- name: string to varchar[] in assign context
  sql: |
    create table t (v1 varchar[]);
    insert into t values ('{c,' || 'd}');
  binder_error: cannot cast type "character varying" to "character varying[]" in Assign context
- name: string to varchar[] in explicit context
  sql: |
    select ('{c,' || 'd}')::varchar[];
  logical_plan: |-
    LogicalProject { exprs: [ConcatOp('{c,':Varchar, 'd}':Varchar)::List(Varchar) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: unknown to varchar[] in implicit context
  sql: |
    values (array['a', 'b']), ('{c,d}');
  logical_plan: 'LogicalValues { rows: [[Array(''a'':Varchar, ''b'':Varchar)], [ARRAY[c, d]:List(Varchar)]], schema: Schema { fields: [*VALUES*_0.column_0:List(Varchar)] } }'
- name: unknown to varchar[] in assign context
  sql: |
    create table t (v1 varchar[]);
    insert into t values ('{c,d}');
  logical_plan: |-
    LogicalInsert { table: t, mapping: [0:0] }
    └─LogicalValues { rows: [[ARRAY[c, d]:List(Varchar)]], schema: Schema { fields: [*VALUES*_0.column_0:List(Varchar)] } }
- name: unknown to varchar[] in explicit context
  sql: |
    select ('{c,d}')::varchar[];
  logical_plan: |-
    LogicalProject { exprs: [ARRAY[c, d]:List(Varchar)] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: varchar[] to string in assign context
  sql: |
    create table t (v1 varchar);
    insert into t values (array['a', 'b']);
  logical_plan: |-
    LogicalInsert { table: t, mapping: [0:0] }
    └─LogicalValues { rows: [[Array('a':Varchar, 'b':Varchar)::Varchar]], schema: Schema { fields: [*VALUES*_0.column_0:Varchar] } }
- name: varchar[] to string in explicit context
  sql: |
    select array['a', 'b']::varchar;
  logical_plan: |-
    LogicalProject { exprs: [Array('a':Varchar, 'b':Varchar)::Varchar as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bool[] cast in explicit context
  sql: |
    select array[1, true]::bool[];
  logical_plan: |-
    LogicalProject { exprs: [Array(1:Int32::Boolean, true:Boolean) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bool[][] cast in explicit context
  sql: |
    select array[array[1, true]]::bool[][];
  logical_plan: |-
    LogicalProject { exprs: [Array(Array(1:Int32::Boolean, true:Boolean)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: compare with null
  sql: |
    select null = array[1];
  logical_plan: |-
    LogicalProject { exprs: [(null:List(Int32) = Array(1:Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: compare with literal
  sql: |
    select array[1] = '{1}';
  logical_plan: |-
    LogicalProject { exprs: [(Array(1:Int32) = ARRAY[1]:List(Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: compare with different type
  sql: |
    select array[1] = array[1.2];
  binder_error: |
    Failed to bind expression: ARRAY[1] = ARRAY[1.2]

    Caused by:
      Bind error: cannot compare integer[] and numeric[]
