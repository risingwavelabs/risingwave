# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t (a int, b int, c int);
    create index idx_a on t(a);
    create index idx_bc on t(b, c desc);
    select count(*) from t group by b;
  stream_plan: |-
    StreamMaterialize { columns: [count, idx_bc.b(hidden)], stream_key: [idx_bc.b], pk_columns: [idx_bc.b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count, idx_bc.b] }
      └─StreamHashAgg { group_key: [idx_bc.b], aggs: [count] }
        └─StreamTableScan { table: idx_bc, columns: [idx_bc.b, idx_bc.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_bc.t._row_id], pk: [b, c, t._row_id], dist: UpstreamHashShard(idx_bc.b) }
- sql: |
    create table t (a int, b int, c int);
    create index idx_a on t(a);
    create index idx_bc on t(b, c desc);
    select count(*) from t group by a;
  stream_plan: |-
    StreamMaterialize { columns: [count, idx_a.a(hidden)], stream_key: [idx_a.a], pk_columns: [idx_a.a], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count, idx_a.a] }
      └─StreamHashAgg { group_key: [idx_a.a], aggs: [count] }
        └─StreamTableScan { table: idx_a, columns: [idx_a.a, idx_a.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_a.t._row_id], pk: [a, t._row_id], dist: UpstreamHashShard(idx_a.a) }
- sql: |
    create table t (a int, b int, c int);
    create index idx_a on t(a);
    create index idx_bc on t(b, c desc);
    select count(*) from t group by c;
  stream_plan: |-
    StreamMaterialize { columns: [count, t.c(hidden)], stream_key: [t.c], pk_columns: [t.c], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count, t.c] }
      └─StreamHashAgg { group_key: [t.c], aggs: [count] }
        └─StreamExchange { dist: HashShard(t.c) }
          └─StreamTableScan { table: t, columns: [t.c, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (a int, b int, c int);
    create index idx_a on t(a);
    create index idx_bc on t(b, c desc);
    select count(*) from t group by b, c;
  stream_plan: |-
    StreamMaterialize { columns: [count, idx_bc.b(hidden), idx_bc.c(hidden)], stream_key: [idx_bc.b, idx_bc.c], pk_columns: [idx_bc.b, idx_bc.c], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count, idx_bc.b, idx_bc.c] }
      └─StreamHashAgg { group_key: [idx_bc.b, idx_bc.c], aggs: [count] }
        └─StreamTableScan { table: idx_bc, columns: [idx_bc.b, idx_bc.c, idx_bc.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_bc.t._row_id], pk: [b, c, t._row_id], dist: UpstreamHashShard(idx_bc.b) }
- sql: |
    create table t (a int, b int, c int);
    create index idx_a on t(a);
    create index idx_bc on t(b, c desc);
    select count(*) from t group by c, b;
  stream_plan: |-
    StreamMaterialize { columns: [count, idx_bc.b(hidden), idx_bc.c(hidden)], stream_key: [idx_bc.b, idx_bc.c], pk_columns: [idx_bc.b, idx_bc.c], pk_conflict: NoCheck }
    └─StreamProject { exprs: [count, idx_bc.b, idx_bc.c] }
      └─StreamHashAgg { group_key: [idx_bc.b, idx_bc.c], aggs: [count] }
        └─StreamTableScan { table: idx_bc, columns: [idx_bc.b, idx_bc.c, idx_bc.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_bc.t._row_id], pk: [b, c, t._row_id], dist: UpstreamHashShard(idx_bc.b) }
- sql: |
    create table t (a int, b int, c int);
    create index idx_a on t(a);
    create index idx_bc on t(b, c desc);
    select RANK() OVER (PARTITION BY a ORDER BY b) as rank from t;
  stream_plan: |-
    StreamMaterialize { columns: [rank, idx_a.t._row_id(hidden), idx_a.a(hidden)], stream_key: [idx_a.t._row_id, idx_a.a], pk_columns: [idx_a.t._row_id, idx_a.a], pk_conflict: NoCheck }
    └─StreamProject { exprs: [rank, idx_a.t._row_id, idx_a.a] }
      └─StreamOverWindow { window_functions: [rank() OVER(PARTITION BY idx_a.a ORDER BY idx_a.b ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)] }
        └─StreamTableScan { table: idx_a, columns: [idx_a.a, idx_a.b, idx_a.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_a.t._row_id], pk: [a, t._row_id], dist: UpstreamHashShard(idx_a.a) }
- sql: |
    create table t (a int, b int, c int);
    create index idx_a on t(a);
    create index idx_bc on t(b, c desc);
    select RANK() OVER (PARTITION BY b ORDER BY c) as rank from t;
  stream_plan: |-
    StreamMaterialize { columns: [rank, idx_bc.t._row_id(hidden), idx_bc.b(hidden)], stream_key: [idx_bc.t._row_id, idx_bc.b], pk_columns: [idx_bc.t._row_id, idx_bc.b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [rank, idx_bc.t._row_id, idx_bc.b] }
      └─StreamOverWindow { window_functions: [rank() OVER(PARTITION BY idx_bc.b ORDER BY idx_bc.c ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)] }
        └─StreamTableScan { table: idx_bc, columns: [idx_bc.b, idx_bc.c, idx_bc.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_bc.t._row_id], pk: [b, c, t._row_id], dist: UpstreamHashShard(idx_bc.b) }
- sql: |
    create table t (a int, b int, c int);
    create index idx_a on t(a);
    create index idx_bc on t(b, c desc);
    select RANK() OVER (PARTITION BY c ORDER BY b) as rank from t;
  stream_plan: |-
    StreamMaterialize { columns: [rank, t._row_id(hidden), t.c(hidden)], stream_key: [t._row_id, t.c], pk_columns: [t._row_id, t.c], pk_conflict: NoCheck }
    └─StreamProject { exprs: [rank, t._row_id, t.c] }
      └─StreamOverWindow { window_functions: [rank() OVER(PARTITION BY t.c ORDER BY t.b ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)] }
        └─StreamExchange { dist: HashShard(t.c) }
          └─StreamTableScan { table: t, columns: [t.b, t.c, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (a int, b int, c int);
    create index idx_a on t(a);
    create index idx_bc on t(b, c desc);
    select RANK() OVER (PARTITION BY b ORDER BY a) as rank from t;
  stream_plan: |-
    StreamMaterialize { columns: [rank, idx_bc.t._row_id(hidden), idx_bc.b(hidden)], stream_key: [idx_bc.t._row_id, idx_bc.b], pk_columns: [idx_bc.t._row_id, idx_bc.b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [rank, idx_bc.t._row_id, idx_bc.b] }
      └─StreamOverWindow { window_functions: [rank() OVER(PARTITION BY idx_bc.b ORDER BY idx_bc.a ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)] }
        └─StreamTableScan { table: idx_bc, columns: [idx_bc.a, idx_bc.b, idx_bc.t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_bc.t._row_id], pk: [b, c, t._row_id], dist: UpstreamHashShard(idx_bc.b) }
- sql: |
    create table t1 (a1 int, b1 int, c1 int);
    create index idx_a1 on t1(a1);
    create index idx_b1c1 on t1(b1, c1 desc);
    create table t2 (a2 int, b2 int, c2 int);
    create index idx_a2 on t2(a2);
    create index idx_b2c2 on t2(b2, c2 desc);
    select * from t1 join t2 on t1.a1 = t2.a2;
  stream_plan: |-
    StreamMaterialize { columns: [a1, b1, c1, a2, b2, c2, idx_a1.t1._row_id(hidden), idx_a2.t2._row_id(hidden)], stream_key: [idx_a1.t1._row_id, idx_a2.t2._row_id, a1], pk_columns: [idx_a1.t1._row_id, idx_a2.t2._row_id, a1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(idx_a1.a1, idx_a1.t1._row_id, idx_a2.t2._row_id) }
      └─StreamHashJoin { type: Inner, predicate: idx_a1.a1 = idx_a2.a2, output: [idx_a1.a1, idx_a1.b1, idx_a1.c1, idx_a2.a2, idx_a2.b2, idx_a2.c2, idx_a1.t1._row_id, idx_a2.t2._row_id] }
        ├─StreamExchange { dist: HashShard(idx_a1.a1) }
        │ └─StreamTableScan { table: idx_a1, columns: [idx_a1.a1, idx_a1.b1, idx_a1.c1, idx_a1.t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_a1.t1._row_id], pk: [a1, t1._row_id], dist: UpstreamHashShard(idx_a1.a1) }
        └─StreamExchange { dist: HashShard(idx_a2.a2) }
          └─StreamTableScan { table: idx_a2, columns: [idx_a2.a2, idx_a2.b2, idx_a2.c2, idx_a2.t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_a2.t2._row_id], pk: [a2, t2._row_id], dist: UpstreamHashShard(idx_a2.a2) }
- sql: |
    create table t1 (a1 int, b1 int, c1 int);
    create index idx_a1 on t1(a1);
    create index idx_b1c1 on t1(b1, c1 desc);
    create table t2 (a2 int, b2 int, c2 int);
    create index idx_a2 on t2(a2);
    create index idx_b2c2 on t2(b2, c2 desc);
    select * from t1 join t2 on t1.b1 = t2.b2;
  stream_plan: |-
    StreamMaterialize { columns: [a1, b1, c1, a2, b2, c2, idx_b1c1.t1._row_id(hidden), idx_b2c2.t2._row_id(hidden)], stream_key: [idx_b1c1.t1._row_id, idx_b2c2.t2._row_id, b1], pk_columns: [idx_b1c1.t1._row_id, idx_b2c2.t2._row_id, b1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(idx_b1c1.b1, idx_b1c1.t1._row_id, idx_b2c2.t2._row_id) }
      └─StreamHashJoin { type: Inner, predicate: idx_b1c1.b1 = idx_b2c2.b2, output: [idx_b1c1.a1, idx_b1c1.b1, idx_b1c1.c1, idx_b2c2.a2, idx_b2c2.b2, idx_b2c2.c2, idx_b1c1.t1._row_id, idx_b2c2.t2._row_id] }
        ├─StreamExchange { dist: HashShard(idx_b1c1.b1) }
        │ └─StreamTableScan { table: idx_b1c1, columns: [idx_b1c1.a1, idx_b1c1.b1, idx_b1c1.c1, idx_b1c1.t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_b1c1.t1._row_id], pk: [b1, c1, t1._row_id], dist: UpstreamHashShard(idx_b1c1.b1) }
        └─StreamExchange { dist: HashShard(idx_b2c2.b2) }
          └─StreamTableScan { table: idx_b2c2, columns: [idx_b2c2.a2, idx_b2c2.b2, idx_b2c2.c2, idx_b2c2.t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_b2c2.t2._row_id], pk: [b2, c2, t2._row_id], dist: UpstreamHashShard(idx_b2c2.b2) }
- sql: |
    create table t1 (a1 int, b1 int, c1 int);
    create index idx_a1 on t1(a1);
    create index idx_b1c1 on t1(b1, c1 desc);
    create table t2 (a2 int, b2 int, c2 int);
    create index idx_a2 on t2(a2);
    create index idx_b2c2 on t2(b2, c2 desc);
    select * from t1 join t2 on t1.b1 = t2.b2 and t1.c1 = t2.c2;
  stream_plan: |-
    StreamMaterialize { columns: [a1, b1, c1, a2, b2, c2, idx_b1c1.t1._row_id(hidden), idx_b2c2.t2._row_id(hidden)], stream_key: [idx_b1c1.t1._row_id, idx_b2c2.t2._row_id, b1, c1], pk_columns: [idx_b1c1.t1._row_id, idx_b2c2.t2._row_id, b1, c1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(idx_b1c1.b1, idx_b1c1.c1, idx_b1c1.t1._row_id, idx_b2c2.t2._row_id) }
      └─StreamHashJoin { type: Inner, predicate: idx_b1c1.b1 = idx_b2c2.b2 AND idx_b1c1.c1 = idx_b2c2.c2, output: [idx_b1c1.a1, idx_b1c1.b1, idx_b1c1.c1, idx_b2c2.a2, idx_b2c2.b2, idx_b2c2.c2, idx_b1c1.t1._row_id, idx_b2c2.t2._row_id] }
        ├─StreamExchange { dist: HashShard(idx_b1c1.b1, idx_b1c1.c1) }
        │ └─StreamTableScan { table: idx_b1c1, columns: [idx_b1c1.a1, idx_b1c1.b1, idx_b1c1.c1, idx_b1c1.t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_b1c1.t1._row_id], pk: [b1, c1, t1._row_id], dist: UpstreamHashShard(idx_b1c1.b1) }
        └─StreamExchange { dist: HashShard(idx_b2c2.b2, idx_b2c2.c2) }
          └─StreamTableScan { table: idx_b2c2, columns: [idx_b2c2.a2, idx_b2c2.b2, idx_b2c2.c2, idx_b2c2.t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_b2c2.t2._row_id], pk: [b2, c2, t2._row_id], dist: UpstreamHashShard(idx_b2c2.b2) }
- sql: |
    create table t1 (a1 int, b1 int, c1 int);
    create index idx_a1 on t1(a1);
    create index idx_b1c1 on t1(b1, c1 desc);
    create table t2 (a2 int, b2 int, c2 int);
    create index idx_a2 on t2(a2);
    create index idx_b2c2 on t2(b2, c2 desc);
    select * from t1 join t2 on t1.c1 = t2.c2 and t1.b1 = t2.b2;
  stream_plan: |-
    StreamMaterialize { columns: [a1, b1, c1, a2, b2, c2, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, c1, b1], pk_columns: [t1._row_id, t2._row_id, c1, b1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.b1, t1.c1, t1._row_id, t2._row_id) }
      └─StreamHashJoin { type: Inner, predicate: t1.c1 = t2.c2 AND t1.b1 = t2.b2, output: [t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2, t1._row_id, t2._row_id] }
        ├─StreamExchange { dist: HashShard(t1.b1, t1.c1) }
        │ └─StreamTableScan { table: t1, columns: [t1.a1, t1.b1, t1.c1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard(t2.b2, t2.c2) }
          └─StreamTableScan { table: t2, columns: [t2.a2, t2.b2, t2.c2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- sql: |
    create table t1 (a1 int, b1 int, c1 int);
    create index idx_a1 on t1(a1);
    create index idx_b1c1 on t1(b1, c1 desc);
    create table t2 (a2 int, b2 int, c2 int);
    create index idx_a2 on t2(a2);
    create index idx_b2c2 on t2(b2, c2 desc);
    select * from t1 join t2 on t1.b1 = t2.b2 and t1.c1 = t2.c2;
  stream_plan: |-
    StreamMaterialize { columns: [a1, b1, c1, a2, b2, c2, idx_b1c1.t1._row_id(hidden), idx_b2c2.t2._row_id(hidden)], stream_key: [idx_b1c1.t1._row_id, idx_b2c2.t2._row_id, b1, c1], pk_columns: [idx_b1c1.t1._row_id, idx_b2c2.t2._row_id, b1, c1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(idx_b1c1.b1, idx_b1c1.c1, idx_b1c1.t1._row_id, idx_b2c2.t2._row_id) }
      └─StreamHashJoin { type: Inner, predicate: idx_b1c1.b1 = idx_b2c2.b2 AND idx_b1c1.c1 = idx_b2c2.c2, output: [idx_b1c1.a1, idx_b1c1.b1, idx_b1c1.c1, idx_b2c2.a2, idx_b2c2.b2, idx_b2c2.c2, idx_b1c1.t1._row_id, idx_b2c2.t2._row_id] }
        ├─StreamExchange { dist: HashShard(idx_b1c1.b1, idx_b1c1.c1) }
        │ └─StreamTableScan { table: idx_b1c1, columns: [idx_b1c1.a1, idx_b1c1.b1, idx_b1c1.c1, idx_b1c1.t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_b1c1.t1._row_id], pk: [b1, c1, t1._row_id], dist: UpstreamHashShard(idx_b1c1.b1) }
        └─StreamExchange { dist: HashShard(idx_b2c2.b2, idx_b2c2.c2) }
          └─StreamTableScan { table: idx_b2c2, columns: [idx_b2c2.a2, idx_b2c2.b2, idx_b2c2.c2, idx_b2c2.t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [idx_b2c2.t2._row_id], pk: [b2, c2, t2._row_id], dist: UpstreamHashShard(idx_b2c2.b2) }
