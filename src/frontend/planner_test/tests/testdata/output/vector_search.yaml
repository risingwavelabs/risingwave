# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table items (id int primary key, embedding vector(3));
    SELECT * FROM (select *, _rw_timestamp, embedding <-> '[3,1,2]' as distance  from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, $expr1] }
      └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: L2, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), non_distance_columns: [$0, $1, $2], non_distance_columns: true }
    └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  batch_plan: |-
    BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
        └─BatchProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
          └─BatchScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp], distribution: UpstreamHashShard(items.id) }
- sql: |
    create table items (id int primary key, embedding vector(3));
    select count(*), id from (SELECT embedding, id FROM (select id, _rw_timestamp, embedding <-> '[3,1,2]' as distance, embedding  from items) order by distance limit 5) group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalProject { exprs: [items.id] }
        └─LogicalProject { exprs: [items.embedding, items.id] }
          └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
            └─LogicalProject { exprs: [items.embedding, items.id, $expr1] }
              └─LogicalProject { exprs: [items.id, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1, items.embedding] }
                └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalVectorSearch { distance_type: L2, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), non_distance_columns: [$0], non_distance_columns: false }
        └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, items.id] }
      └─BatchHashAgg { group_key: [items.id], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(items.id) }
          └─BatchProject { exprs: [items.id] }
            └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
              └─BatchExchange { order: [], dist: Single }
                └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
                  └─BatchProject { exprs: [items.id, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
                    └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- sql: |
    create table items (id int primary key, embedding vector(3));
    SELECT embedding, distance, id FROM (select id, _rw_timestamp, embedding <-> '[3,1,2]' as distance, embedding  from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.embedding, $expr1, items.id] }
      └─LogicalProject { exprs: [items.id, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1, items.embedding] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [items.embedding, vector_distance, items.id] }
    └─LogicalVectorSearch { distance_type: L2, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), non_distance_columns: [$1, $0], non_distance_columns: true }
      └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.embedding, $expr1, items.id] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.embedding, items.id, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
