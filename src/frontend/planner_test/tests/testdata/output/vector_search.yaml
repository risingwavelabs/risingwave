# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_table
  sql: |
    create table items (id int primary key, embedding vector(3));
- id: no_vector_search_with_offset
  before:
  - create_table
  sql: |
    SELECT * FROM items order by embedding <-> '[3,1,2]' limit 5 offset 1;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
      └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
    └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
      └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.embedding] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 6, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM items order by embedding <-> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
    └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.embedding] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM (select *, _rw_timestamp, embedding <-> '[3,1,2]' as distance from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, $expr1] }
      └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3), items._rw_timestamp:Timestamptz] }
    └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  batch_plan: |-
    BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
        └─BatchProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
          └─BatchScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM (select distance, distance + 1 as distance_ref from (select *, _rw_timestamp, embedding <-> '[3,1,2]' as distance  from items)) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [$expr1, $expr2] }
      └─LogicalProject { exprs: [$expr1, ($expr1 + 1:Int32::Float64) as $expr2] }
        └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [vector_distance, (L2Distance(items.embedding, '[3,1,2]':Vector(3)) + 1:Int32::Float64) as $expr1] }
    └─LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $0, right: '[3,1,2]':Vector(3), output_columns: [items.embedding:Vector(3)] }
      └─LogicalScan { table: items, columns: [items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, (L2Distance(items.embedding, '[3,1,2]':Vector(3)) + 1:Float64) as $expr2] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.embedding], distribution: SomeShard }
- before:
  - create_table
  sql: |
    select count(*), id from (SELECT embedding, id FROM (select id, _rw_timestamp, embedding <=> '[3,1,2]' as distance, embedding  from items) order by distance limit 5) group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalProject { exprs: [items.id] }
        └─LogicalProject { exprs: [items.embedding, items.id] }
          └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
            └─LogicalProject { exprs: [items.embedding, items.id, $expr1] }
              └─LogicalProject { exprs: [items.id, items._rw_timestamp, CosineDistance(items.embedding, '[3,1,2]':Vector(3)) as $expr1, items.embedding] }
                └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalVectorSearch { distance_type: Cosine, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, items.id] }
      └─BatchHashAgg { group_key: [items.id], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(items.id) }
          └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
            └─BatchExchange { order: [], dist: Single }
              └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
                └─BatchProject { exprs: [items.id, CosineDistance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
                  └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT embedding, distance, id FROM (select id, _rw_timestamp, embedding <#> '[3,1,2]' as distance, embedding from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.embedding, $expr1, items.id] }
      └─LogicalProject { exprs: [items.id, items._rw_timestamp, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1, items.embedding] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [items.embedding, vector_distance, items.id] }
    └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
      └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.embedding, $expr1, items.id] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
