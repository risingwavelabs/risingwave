# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_table
  sql: |
    create table items (id int primary key, embedding vector(3));
- id: no_vector_search_with_offset
  before:
  - create_table
  sql: |
    SELECT * FROM items order by embedding <-> '[3,1,2]' limit 5 offset 1;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
      └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
    └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
      └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.embedding] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 6, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM items order by embedding <-> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
    └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.embedding] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM (select *, _rw_timestamp, embedding <-> '[3,1,2]' as distance from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, $expr1] }
      └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3), items._rw_timestamp:Timestamptz] }
    └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  batch_plan: |-
    BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
        └─BatchProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
          └─BatchScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM (select distance, distance + 1 as distance_ref from (select *, _rw_timestamp, embedding <-> '[3,1,2]' as distance  from items)) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [$expr1, $expr2] }
      └─LogicalProject { exprs: [$expr1, ($expr1 + 1:Int32::Float64) as $expr2] }
        └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [vector_distance, (L2Distance(items.embedding, '[3,1,2]':Vector(3)) + 1:Int32::Float64) as $expr1] }
    └─LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $0, right: '[3,1,2]':Vector(3), output_columns: [items.embedding:Vector(3)] }
      └─LogicalScan { table: items, columns: [items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, (L2Distance(items.embedding, '[3,1,2]':Vector(3)) + 1:Float64) as $expr2] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.embedding], distribution: SomeShard }
- before:
  - create_table
  sql: |
    select count(*), id from (SELECT embedding, id FROM (select id, _rw_timestamp, embedding <=> '[3,1,2]' as distance, embedding  from items) order by distance limit 5) group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalProject { exprs: [items.id] }
        └─LogicalProject { exprs: [items.embedding, items.id] }
          └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
            └─LogicalProject { exprs: [items.embedding, items.id, $expr1] }
              └─LogicalProject { exprs: [items.id, items._rw_timestamp, CosineDistance(items.embedding, '[3,1,2]':Vector(3)) as $expr1, items.embedding] }
                └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalVectorSearch { distance_type: Cosine, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, items.id] }
      └─BatchHashAgg { group_key: [items.id], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(items.id) }
          └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
            └─BatchExchange { order: [], dist: Single }
              └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
                └─BatchProject { exprs: [items.id, CosineDistance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
                  └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT embedding, distance, id FROM (select id, _rw_timestamp, embedding <#> '[3,1,2]' as distance, embedding from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.embedding, $expr1, items.id] }
      └─LogicalProject { exprs: [items.id, items._rw_timestamp, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1, items.embedding] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [items.embedding, vector_distance, items.id] }
    └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
      └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.embedding, $expr1, items.id] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- id: create_table_and_index
  sql: |
    create table items (id int primary key, name string, unindexed timestamptz, embedding vector(3)) append only;
    create index vector_index on items using flat (embedding) include (name) with (distance_type = 'inner_product');
- before:
  - create_table_and_index
  sql: |
    SELECT id, name FROM items order by embedding <#> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.name, items.unindexed, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, name] }
    └─BatchExchange { order: [__distance ASC], dist: Single }
      └─BatchProject { exprs: [items.id, name, __distance] }
        └─BatchVectorSearch { schema: [name:Varchar, items.id:Int32, __distance:Float64], top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector: [3,1,2] }
- before:
  - create_table_and_index
  sql: |
    select count(*), id from (SELECT id + 1 as id FROM items order by embedding <#> '[3,1,2]' limit 5) group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, $expr1] }
    └─LogicalAgg { group_key: [$expr1], aggs: [count] }
      └─LogicalProject { exprs: [$expr1] }
        └─LogicalProject { exprs: [$expr1] }
          └─LogicalTopN { order: [$expr2 ASC], limit: 5, offset: 0 }
            └─LogicalProject { exprs: [(items.id + 1:Int32) as $expr1, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr2] }
              └─LogicalScan { table: items, columns: [items.id, items.name, items.unindexed, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, $expr1] }
    └─LogicalAgg { group_key: [$expr1], aggs: [count] }
      └─LogicalProject { exprs: [(items.id + 1:Int32) as $expr1] }
        └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, $expr1] }
      └─BatchHashAgg { group_key: [$expr1], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard($expr1) }
          └─BatchProject { exprs: [(items.id + 1:Int32) as $expr1] }
            └─BatchVectorSearch { schema: [name:Varchar, items.id:Int32, __distance:Float64], top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector: [3,1,2] }
- before:
  - create_table_and_index
  sql: |
    SELECT id, name, embedding FROM items order by embedding <#> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, items.embedding, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.name, items.unindexed, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar, items.embedding:Vector(3)] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.name, items.embedding] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.name, items.embedding, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.name, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table_and_index
  sql: |
    SELECT id, name, unindexed FROM items order by embedding <#> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name, items.unindexed] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, items.unindexed, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.name, items.unindexed, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $3, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar, items.unindexed:Timestamptz] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.unindexed, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.name, items.unindexed] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.name, items.unindexed, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.name, items.unindexed, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table_and_index
  sql: |
    select count(*), id from (SELECT embedding, id FROM (select id, embedding <#> '[3,1,2]' as distance, embedding  from items) order by distance limit 5) where embedding <-> '[1,2,3]' < 2.0 group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalProject { exprs: [items.id] }
        └─LogicalFilter { predicate: (L2Distance(items.embedding, '[1,2,3]':Vector(3)) < 2.0:Decimal::Float64) }
          └─LogicalProject { exprs: [items.embedding, items.id] }
            └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
              └─LogicalProject { exprs: [items.embedding, items.id, $expr1] }
                └─LogicalProject { exprs: [items.id, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1, items.embedding] }
                  └─LogicalScan { table: items, columns: [items.id, items.name, items.unindexed, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalFilter { predicate: (L2Distance(items.embedding, '[1,2,3]':Vector(3)) < 2.0:Decimal::Float64) }
        └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, items.id] }
      └─BatchHashAgg { group_key: [items.id], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(items.id) }
          └─BatchFilter { predicate: (L2Distance(items.embedding, '[1,2,3]':Vector(3)) < 2:Float64) }
            └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
              └─BatchExchange { order: [], dist: Single }
                └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
                  └─BatchProject { exprs: [items.id, items.embedding, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
                    └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
