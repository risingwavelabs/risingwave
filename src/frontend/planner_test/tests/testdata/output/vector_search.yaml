# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_table
  sql: |
    create table items (id int primary key, embedding vector(3));
- id: no_vector_search_with_offset
  before:
  - create_table
  sql: |
    SELECT * FROM items order by embedding <-> '[3,1,2]' limit 5 offset 1;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
      └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
    └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
      └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.embedding] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 6, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM items order by embedding <-> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
    └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.embedding] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM (select *, _rw_timestamp, embedding <-> '[3,1,2]' as distance from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, $expr1] }
      └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3), items._rw_timestamp:Timestamptz] }
    └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  batch_plan: |-
    BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
        └─BatchProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
          └─BatchScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM (select distance, distance + 1 as distance_ref from (select *, _rw_timestamp, embedding <-> '[3,1,2]' as distance  from items)) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [$expr1, $expr2] }
      └─LogicalProject { exprs: [$expr1, ($expr1 + 1:Int32::Float64) as $expr2] }
        └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [vector_distance, (L2Distance(items.embedding, '[3,1,2]':Vector(3)) + 1:Int32::Float64) as $expr1] }
    └─LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $0, right: '[3,1,2]':Vector(3), output_columns: [items.embedding:Vector(3)] }
      └─LogicalScan { table: items, columns: [items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, (L2Distance(items.embedding, '[3,1,2]':Vector(3)) + 1:Float64) as $expr2] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.embedding], distribution: SomeShard }
- before:
  - create_table
  sql: |
    select count(*), id from (SELECT embedding, id FROM (select id, _rw_timestamp, embedding <=> '[3,1,2]' as distance, embedding  from items) order by distance limit 5) group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalProject { exprs: [items.id] }
        └─LogicalProject { exprs: [items.embedding, items.id] }
          └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
            └─LogicalProject { exprs: [items.embedding, items.id, $expr1] }
              └─LogicalProject { exprs: [items.id, items._rw_timestamp, CosineDistance(items.embedding, '[3,1,2]':Vector(3)) as $expr1, items.embedding] }
                └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalVectorSearch { distance_type: Cosine, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, items.id] }
      └─BatchHashAgg { group_key: [items.id], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(items.id) }
          └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
            └─BatchExchange { order: [], dist: Single }
              └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
                └─BatchProject { exprs: [items.id, CosineDistance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
                  └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT embedding, distance, id FROM (select id, _rw_timestamp, embedding <#> '[3,1,2]' as distance, embedding from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.embedding, $expr1, items.id] }
      └─LogicalProject { exprs: [items.id, items._rw_timestamp, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1, items.embedding] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [items.embedding, vector_distance, items.id] }
    └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
      └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.embedding, $expr1, items.id] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- id: explain_create_table_and_index
  sql: |
    create table items (id int primary key, name string, unindexed timestamptz, embedding vector(3)) append only;
    explain create index vector_index on items using flat (embedding) include (name) with (distance_type = 'inner_product');
  explain_output: |
    StreamVectorIndexWrite { vector_column: embedding, columns: [embedding, name, items.id(hidden)], stream_key: [items.id] }
    └─StreamExchange { dist: Single }
      └─StreamProject { exprs: [items.embedding, items.name, items.id] }
        └─StreamTableScan { table: items, columns: [name, embedding, id] }
- id: create_table_and_index
  sql: |
    create table items (id int primary key, unindexed timestamptz, name string, embedding vector(3)) append only;
    create index vector_index on items using flat (embedding) include (name) with (distance_type = 'inner_product');
- before:
  - create_table_and_index
  sql: |
    SELECT id, name FROM items order by embedding <#> '[1, 2, 3]'::vector(3) limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, Neg(InnerProduct(items.embedding, '[1,2,3]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: '[1,2,3]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, $expr2] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchSort { order: [$expr3 ASC] }
        └─BatchProject { exprs: [Field(Unnest($1), 1:Int32) as $expr1, Field(Unnest($1), 0:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
          └─BatchProjectSet { select_list: [Unnest($1)] }
            └─BatchVectorSearch { schema: [:Vector(3), vector_info:List(Struct(StructType { fields: [("name", Varchar), ("items.id", Int32), ("__distance", Float64)] }))], top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector:  }
              └─BatchValues { rows: [['[1,2,3]':Vector(3)]] }
- id: no_vector_index_search_on_table_scan_with_predicate
  before:
  - create_table_and_index
  sql: |
    SELECT id, name FROM items where id > 0 order by embedding <#> '[1, 2, 3]'::vector(3) limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, Neg(InnerProduct(items.embedding, '[1,2,3]':Vector(3))) as $expr1] }
        └─LogicalFilter { predicate: (items.id > 0:Int32) }
          └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: '[1,2,3]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding], predicate: (items.id > 0:Int32) }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.name] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.name, Neg(InnerProduct(items.embedding, '[1,2,3]':Vector(3))) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.name, items.embedding], scan_ranges: [items.id > Int32(0)], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table_and_index
  sql: |
    SELECT id, name FROM items order by embedding <#> openai_embedding('{"model": "model"}'::jsonb, 'hello')::vector(3) limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, Neg(InnerProduct(items.embedding, OpenaiEmbedding('{"model": "model"}':Jsonb, 'hello':Varchar)::Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: OpenaiEmbedding('{"model": "model"}':Jsonb, 'hello':Varchar)::Vector(3), output_columns: [items.id:Int32, items.name:Varchar] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, $expr2] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchSort { order: [$expr3 ASC] }
        └─BatchProject { exprs: [Field(Unnest($1), 1:Int32) as $expr1, Field(Unnest($1), 0:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
          └─BatchProjectSet { select_list: [Unnest($1)] }
            └─BatchVectorSearch { schema: [:Vector(3), vector_info:List(Struct(StructType { fields: [("name", Varchar), ("items.id", Int32), ("__distance", Float64)] }))], top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector:  }
              └─BatchValues { rows: [[OpenaiEmbedding('{"model": "model"}':Jsonb, 'hello':Varchar)::Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    select count(*), id from (SELECT id + 1 as id FROM items order by embedding <#> '[3,1,2]' limit 5) group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, $expr1] }
    └─LogicalAgg { group_key: [$expr1], aggs: [count] }
      └─LogicalProject { exprs: [$expr1] }
        └─LogicalProject { exprs: [$expr1] }
          └─LogicalTopN { order: [$expr2 ASC], limit: 5, offset: 0 }
            └─LogicalProject { exprs: [(items.id + 1:Int32) as $expr1, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr2] }
              └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, $expr1] }
    └─LogicalAgg { group_key: [$expr1], aggs: [count] }
      └─LogicalProject { exprs: [(items.id + 1:Int32) as $expr1] }
        └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, $expr1] }
      └─BatchHashAgg { group_key: [$expr1], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard($expr1) }
          └─BatchProject { exprs: [(Field(Unnest($1), 1:Int32) + 1:Int32) as $expr1] }
            └─BatchProjectSet { select_list: [Unnest($1)] }
              └─BatchVectorSearch { schema: [:Vector(3), vector_info:List(Struct(StructType { fields: [("name", Varchar), ("items.id", Int32), ("__distance", Float64)] }))], top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector:  }
                └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    SELECT id, name, embedding FROM items order by embedding <#> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, items.embedding, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar, items.embedding:Vector(3)] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr2, $expr1, items.embedding] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchSort { order: [$expr3 ASC] }
        └─BatchLookupJoin { type: Inner, predicate: $expr2 IS NOT DISTINCT FROM items.id, output: [$expr2, $expr1, items.embedding, $expr3], lookup table: items }
          └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
            └─BatchProject { exprs: [Field(Unnest($1), 0:Int32) as $expr1, Field(Unnest($1), 1:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
              └─BatchProjectSet { select_list: [Unnest($1)] }
                └─BatchVectorSearch { schema: [:Vector(3), vector_info:List(Struct(StructType { fields: [("name", Varchar), ("items.id", Int32), ("__distance", Float64)] }))], top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector:  }
                  └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    SELECT id, name, unindexed FROM items order by embedding <#> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name, items.unindexed] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, items.unindexed, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [items.id, items.name, items.unindexed, vector_distance] }
    └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $3, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.unindexed:Timestamptz, items.name:Varchar] }
      └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr2, $expr1, items.unindexed] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchProject { exprs: [$expr2, $expr1, items.unindexed, $expr3] }
        └─BatchSort { order: [$expr3 ASC] }
          └─BatchLookupJoin { type: Inner, predicate: $expr2 IS NOT DISTINCT FROM items.id, output: [$expr2, items.unindexed, $expr1, $expr3], lookup table: items }
            └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
              └─BatchProject { exprs: [Field(Unnest($1), 0:Int32) as $expr1, Field(Unnest($1), 1:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
                └─BatchProjectSet { select_list: [Unnest($1)] }
                  └─BatchVectorSearch { schema: [:Vector(3), vector_info:List(Struct(StructType { fields: [("name", Varchar), ("items.id", Int32), ("__distance", Float64)] }))], top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector:  }
                    └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    select id, name, unindexed, power(distance, 2)::int from (select id, name, unindexed, '[3,1,2]' <#> embedding as distance from items order by distance limit 2);
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name, items.unindexed, Pow($expr1, 2:Int32::Float64)::Int32 as $expr2] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 2, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, items.unindexed, Neg(InnerProduct('[3,1,2]':Vector(3), items.embedding)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [items.id, items.name, items.unindexed, Pow(vector_distance, 2:Int32::Float64)::Int32 as $expr1] }
    └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 2, left: '[3,1,2]':Vector(3), right: $3, output_columns: [items.id:Int32, items.unindexed:Timestamptz, items.name:Varchar] }
      └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr2, $expr1, items.unindexed, Pow($expr3, 2:Float64)::Int32 as $expr4] }
      └─BatchLookupJoin { type: Inner, predicate: $expr2 IS NOT DISTINCT FROM items.id, output: [$expr2, items.unindexed, $expr1, $expr3], lookup table: items }
        └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
          └─BatchProject { exprs: [Field(Unnest($1), 0:Int32) as $expr1, Field(Unnest($1), 1:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
            └─BatchProjectSet { select_list: [Unnest($1)] }
              └─BatchVectorSearch { schema: [:Vector(3), vector_info:List(Struct(StructType { fields: [("name", Varchar), ("items.id", Int32), ("__distance", Float64)] }))], top_n: 2, distance_type: InnerProduct, index_name: "vector_index", vector:  }
                └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    select count(*), id from (SELECT embedding, id FROM (select id, embedding <#> '[3,1,2]' as distance, embedding  from items) order by distance limit 5) where embedding <-> '[1,2,3]' < 2.0 group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalProject { exprs: [items.id] }
        └─LogicalFilter { predicate: (L2Distance(items.embedding, '[1,2,3]':Vector(3)) < 2.0:Decimal::Float64) }
          └─LogicalProject { exprs: [items.embedding, items.id] }
            └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
              └─LogicalProject { exprs: [items.embedding, items.id, $expr1] }
                └─LogicalProject { exprs: [items.id, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1, items.embedding] }
                  └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalFilter { predicate: (L2Distance(items.embedding, '[1,2,3]':Vector(3)) < 2.0:Decimal::Float64) }
        └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, $expr2] }
      └─BatchHashAgg { group_key: [$expr2], aggs: [count] }
        └─BatchFilter { predicate: (L2Distance(items.embedding, '[1,2,3]':Vector(3)) < 2:Float64) }
          └─BatchLookupJoin { type: Inner, predicate: $expr2 IS NOT DISTINCT FROM items.id, output: [$expr2, items.embedding, $expr3], lookup table: items }
            └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
              └─BatchProject { exprs: [Field(Unnest($1), 0:Int32) as $expr1, Field(Unnest($1), 1:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
                └─BatchProjectSet { select_list: [Unnest($1)] }
                  └─BatchVectorSearch { schema: [:Vector(3), vector_info:List(Struct(StructType { fields: [("name", Varchar), ("items.id", Int32), ("__distance", Float64)] }))], top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector:  }
                    └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- id: explain_create_function_index
  sql: |
    create table items (id int primary key, name string, unindexed timestamptz, embedding vector(3)) append only;
    explain create index vector_index on items using flat (openai_embedding('{"model": "model"}'::jsonb, name)::vector(3)) include (name) with (distance_type = 'inner_product');
  explain_output: |
    StreamVectorIndexWrite { vector_column: CAST, columns: [CAST, name, items.id(hidden)], stream_key: [items.id] }
    └─StreamExchange { dist: Single }
      └─StreamProject { exprs: [OpenaiEmbedding('{"model": "model"}':Jsonb, items.name)::Vector(3) as $expr1, items.name, items.id] }
        └─StreamTableScan { table: items, columns: [name, id] }
- id: create_table_and_function_index
  sql: |
    create table items (id int primary key, name string, unindexed timestamptz, text string) append only;
    create index vector_index on items using flat (openai_embedding('{"model": "model"}'::jsonb, text)::vector(3)) include (name) with (distance_type = 'inner_product');
- before:
  - create_table_and_function_index
  sql: |
    SELECT id, name FROM items order by openai_embedding('{"model": "model"}'::jsonb, text)::vector(3) <#> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, Neg(InnerProduct(OpenaiEmbedding('{"model": "model"}':Jsonb, items.text)::Vector(3), '[3,1,2]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.name, items.unindexed, items.text, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: OpenaiEmbedding('{"model": "model"}':Jsonb, $2)::Vector(3), right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.text] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, $expr2] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchSort { order: [$expr3 ASC] }
        └─BatchProject { exprs: [Field(Unnest($1), 1:Int32) as $expr1, Field(Unnest($1), 0:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
          └─BatchProjectSet { select_list: [Unnest($1)] }
            └─BatchVectorSearch { schema: [:Vector(3), vector_info:List(Struct(StructType { fields: [("name", Varchar), ("items.id", Int32), ("__distance", Float64)] }))], top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector:  }
              └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
