# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_table
  sql: |
    create table items (id int primary key, embedding vector(3));
- id: no_vector_search_with_offset
  before:
  - create_table
  sql: |
    SELECT * FROM items order by embedding <-> '[3,1,2]' limit 5 offset 1;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
      └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
    └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
      └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.embedding] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 1 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 6, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM items order by embedding <-> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
    └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.embedding] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM (select *, _rw_timestamp, embedding <-> '[3,1,2]' as distance from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, $expr1] }
      └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3), items._rw_timestamp:Timestamptz] }
    └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  batch_plan: |-
    BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
        └─BatchProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
          └─BatchScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT * FROM (select distance, distance + 1 as distance_ref from (select *, _rw_timestamp, embedding <-> '[3,1,2]' as distance  from items)) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [$expr1, $expr2] }
      └─LogicalProject { exprs: [$expr1, ($expr1 + 1:Int32::Float64) as $expr2] }
        └─LogicalProject { exprs: [items.id, items.embedding, items._rw_timestamp, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [vector_distance, (L2Distance(items.embedding, '[3,1,2]':Vector(3)) + 1:Int32::Float64) as $expr1] }
    └─LogicalVectorSearch { distance_type: L2Sqr, top_n: 5, left: $0, right: '[3,1,2]':Vector(3), output_columns: [items.embedding:Vector(3)] }
      └─LogicalScan { table: items, columns: [items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, (L2Distance(items.embedding, '[3,1,2]':Vector(3)) + 1:Float64) as $expr2] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.embedding, L2Distance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
            └─BatchScan { table: items, columns: [items.embedding], distribution: SomeShard }
- before:
  - create_table
  sql: |
    select count(*), id from (SELECT embedding, id FROM (select id, _rw_timestamp, embedding <=> '[3,1,2]' as distance, embedding  from items) order by distance limit 5) group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalProject { exprs: [items.id] }
        └─LogicalProject { exprs: [items.embedding, items.id] }
          └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
            └─LogicalProject { exprs: [items.embedding, items.id, $expr1] }
              └─LogicalProject { exprs: [items.id, items._rw_timestamp, CosineDistance(items.embedding, '[3,1,2]':Vector(3)) as $expr1, items.embedding] }
                └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalVectorSearch { distance_type: Cosine, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, items.id] }
      └─BatchHashAgg { group_key: [items.id], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(items.id) }
          └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
            └─BatchExchange { order: [], dist: Single }
              └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
                └─BatchProject { exprs: [items.id, CosineDistance(items.embedding, '[3,1,2]':Vector(3)) as $expr1] }
                  └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table
  sql: |
    SELECT embedding, distance, id FROM (select id, _rw_timestamp, embedding <#> '[3,1,2]' as distance, embedding from items) order by distance limit 5;
  logical_plan: |-
    LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
    └─LogicalProject { exprs: [items.embedding, $expr1, items.id] }
      └─LogicalProject { exprs: [items.id, items._rw_timestamp, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1, items.embedding] }
        └─LogicalScan { table: items, columns: [items.id, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [items.embedding, vector_distance, items.id] }
    └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
      └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [items.embedding, $expr1, items.id] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.embedding, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.embedding], distribution: UpstreamHashShard(items.id) }
- id: explain_create_table_and_index
  sql: |
    create table items (id int primary key, name string, unindexed timestamptz, embedding vector(3)) append only;
    explain create index vector_index on items using flat (embedding) include (name) with (distance_type = 'inner_product');
  explain_output: |
    StreamVectorIndexWrite { vector_column: embedding, columns: [embedding, name, items.id(hidden)], stream_key: [items.id] }
    └─StreamExchange { dist: Single }
      └─StreamProject { exprs: [items.embedding, items.name, items.id] }
        └─StreamTableScan { table: items, columns: [name, embedding, id] }
- id: create_table_and_index
  sql: |
    create table items (id int primary key, unindexed timestamptz, name string, embedding vector(3)) append only;
    create index vector_index on items using flat (embedding) include (name) with (distance_type = 'inner_product');
- before:
  - create_table_and_index
  sql: |
    SELECT id, name FROM items order by embedding <#> '[1, 2, 3]'::vector(3) limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, Neg(InnerProduct(items.embedding, '[1,2,3]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: '[1,2,3]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, $expr2] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchSort { order: [$expr3 ASC] }
        └─BatchProject { exprs: [Field(Unnest($1), 1:Int32) as $expr1, Field(Unnest($1), 0:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
          └─BatchProjectSet { select_list: [Unnest($1)] }
            └─BatchVectorSearch { top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector: query_vector, lookup_output: [("name", Varchar), ("items.id", Int32)], include_distance: true }
              └─BatchValues { rows: [['[1,2,3]':Vector(3)]] }
- id: no_vector_index_search_on_table_scan_with_predicate
  before:
  - create_table_and_index
  sql: |
    SELECT id, name FROM items where id > 0 order by embedding <#> '[1, 2, 3]'::vector(3) limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, Neg(InnerProduct(items.embedding, '[1,2,3]':Vector(3))) as $expr1] }
        └─LogicalFilter { predicate: (items.id > 0:Int32) }
          └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: '[1,2,3]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding], predicate: (items.id > 0:Int32) }
  batch_plan: |-
    BatchProject { exprs: [items.id, items.name] }
    └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
          └─BatchProject { exprs: [items.id, items.name, Neg(InnerProduct(items.embedding, '[1,2,3]':Vector(3))) as $expr1] }
            └─BatchScan { table: items, columns: [items.id, items.name, items.embedding], scan_ranges: [items.id > Int32(0)], distribution: UpstreamHashShard(items.id) }
- before:
  - create_table_and_index
  sql: |
    SELECT id, name FROM items order by embedding <#> openai_embedding('{"model": "model"}'::jsonb, 'hello')::vector(3) limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, Neg(InnerProduct(items.embedding, OpenaiEmbedding('{"model": "model"}':Jsonb, 'hello':Varchar)::Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: OpenaiEmbedding('{"model": "model"}':Jsonb, 'hello':Varchar)::Vector(3), output_columns: [items.id:Int32, items.name:Varchar] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, $expr2] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchSort { order: [$expr3 ASC] }
        └─BatchProject { exprs: [Field(Unnest($1), 1:Int32) as $expr1, Field(Unnest($1), 0:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
          └─BatchProjectSet { select_list: [Unnest($1)] }
            └─BatchVectorSearch { top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector: query_vector, lookup_output: [("name", Varchar), ("items.id", Int32)], include_distance: true }
              └─BatchValues { rows: [[OpenaiEmbedding('{"model": "model"}':Jsonb, 'hello':Varchar)::Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    select count(*), id from (SELECT id + 1 as id FROM items order by embedding <#> '[3,1,2]' limit 5) group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, $expr1] }
    └─LogicalAgg { group_key: [$expr1], aggs: [count] }
      └─LogicalProject { exprs: [$expr1] }
        └─LogicalProject { exprs: [$expr1] }
          └─LogicalTopN { order: [$expr2 ASC], limit: 5, offset: 0 }
            └─LogicalProject { exprs: [(items.id + 1:Int32) as $expr1, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr2] }
              └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, $expr1] }
    └─LogicalAgg { group_key: [$expr1], aggs: [count] }
      └─LogicalProject { exprs: [(items.id + 1:Int32) as $expr1] }
        └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, $expr1] }
      └─BatchHashAgg { group_key: [$expr1], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard($expr1) }
          └─BatchProject { exprs: [(Field(Unnest($1), 1:Int32) + 1:Int32) as $expr1] }
            └─BatchProjectSet { select_list: [Unnest($1)] }
              └─BatchVectorSearch { top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector: query_vector, lookup_output: [("name", Varchar), ("items.id", Int32)], include_distance: true }
                └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    SELECT id, name, embedding FROM items order by embedding <#> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name, items.embedding] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, items.embedding, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $2, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar, items.embedding:Vector(3)] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr2, $expr1, items.embedding] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchSort { order: [$expr3 ASC] }
        └─BatchLookupJoin { type: Inner, predicate: $expr2 IS NOT DISTINCT FROM items.id, output: [$expr2, $expr1, items.embedding, $expr3], lookup table: items }
          └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
            └─BatchProject { exprs: [Field(Unnest($1), 0:Int32) as $expr1, Field(Unnest($1), 1:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
              └─BatchProjectSet { select_list: [Unnest($1)] }
                └─BatchVectorSearch { top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector: query_vector, lookup_output: [("name", Varchar), ("items.id", Int32)], include_distance: true }
                  └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    SELECT id, name, unindexed FROM items order by embedding <#> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name, items.unindexed] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, items.unindexed, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [items.id, items.name, items.unindexed, vector_distance] }
    └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $3, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.unindexed:Timestamptz, items.name:Varchar] }
      └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding] }
  batch_plan: |-
    BatchProject { exprs: [$expr2, $expr1, items.unindexed] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchProject { exprs: [$expr2, $expr1, items.unindexed, $expr3] }
        └─BatchSort { order: [$expr3 ASC] }
          └─BatchLookupJoin { type: Inner, predicate: $expr2 IS NOT DISTINCT FROM items.id, output: [$expr2, items.unindexed, $expr1, $expr3], lookup table: items }
            └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
              └─BatchProject { exprs: [Field(Unnest($1), 0:Int32) as $expr1, Field(Unnest($1), 1:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
                └─BatchProjectSet { select_list: [Unnest($1)] }
                  └─BatchVectorSearch { top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector: query_vector, lookup_output: [("name", Varchar), ("items.id", Int32)], include_distance: true }
                    └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    select id, name, unindexed, power(distance, 2)::int from (select id, name, unindexed, '[3,1,2]' <#> embedding as distance from items order by distance limit 2);
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name, items.unindexed, Pow($expr1, 2:Int32::Float64)::Int32 as $expr2] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 2, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, items.unindexed, Neg(InnerProduct('[3,1,2]':Vector(3), items.embedding)) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [items.id, items.name, items.unindexed, Pow(vector_distance, 2:Int32::Float64)::Int32 as $expr1] }
    └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 2, left: '[3,1,2]':Vector(3), right: $3, output_columns: [items.id:Int32, items.unindexed:Timestamptz, items.name:Varchar] }
      └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr2, $expr1, items.unindexed, Pow($expr3, 2:Float64)::Int32 as $expr4] }
      └─BatchLookupJoin { type: Inner, predicate: $expr2 IS NOT DISTINCT FROM items.id, output: [$expr2, items.unindexed, $expr1, $expr3], lookup table: items }
        └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
          └─BatchProject { exprs: [Field(Unnest($1), 0:Int32) as $expr1, Field(Unnest($1), 1:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
            └─BatchProjectSet { select_list: [Unnest($1)] }
              └─BatchVectorSearch { top_n: 2, distance_type: InnerProduct, index_name: "vector_index", vector: query_vector, lookup_output: [("name", Varchar), ("items.id", Int32)], include_distance: true }
                └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- before:
  - create_table_and_index
  sql: |
    select count(*), id from (SELECT embedding, id FROM (select id, embedding <#> '[3,1,2]' as distance, embedding  from items) order by distance limit 5) where embedding <-> '[1,2,3]' < 2.0 group by id;
  logical_plan: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalProject { exprs: [items.id] }
        └─LogicalFilter { predicate: (L2Distance(items.embedding, '[1,2,3]':Vector(3)) < 2.0:Decimal::Float64) }
          └─LogicalProject { exprs: [items.embedding, items.id] }
            └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
              └─LogicalProject { exprs: [items.embedding, items.id, $expr1] }
                └─LogicalProject { exprs: [items.id, Neg(InnerProduct(items.embedding, '[3,1,2]':Vector(3))) as $expr1, items.embedding] }
                  └─LogicalScan { table: items, columns: [items.id, items.unindexed, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [count, items.id] }
    └─LogicalAgg { group_key: [items.id], aggs: [count] }
      └─LogicalFilter { predicate: (L2Distance(items.embedding, '[1,2,3]':Vector(3)) < 2.0:Decimal::Float64) }
        └─LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: $1, right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.embedding:Vector(3)] }
          └─LogicalScan { table: items, columns: [items.id, items.embedding] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count, $expr2] }
      └─BatchHashAgg { group_key: [$expr2], aggs: [count] }
        └─BatchFilter { predicate: (L2Distance(items.embedding, '[1,2,3]':Vector(3)) < 2:Float64) }
          └─BatchLookupJoin { type: Inner, predicate: $expr2 IS NOT DISTINCT FROM items.id, output: [$expr2, items.embedding, $expr3], lookup table: items }
            └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
              └─BatchProject { exprs: [Field(Unnest($1), 0:Int32) as $expr1, Field(Unnest($1), 1:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
                └─BatchProjectSet { select_list: [Unnest($1)] }
                  └─BatchVectorSearch { top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector: query_vector, lookup_output: [("name", Varchar), ("items.id", Int32)], include_distance: true }
                    └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- id: explain_create_function_index
  sql: |
    create table items (id int primary key, name string, unindexed timestamptz, embedding vector(3)) append only;
    explain create index vector_index on items using flat (openai_embedding('{"model": "model"}'::jsonb, name)::vector(3)) include (name) with (distance_type = 'inner_product');
  explain_output: |
    StreamVectorIndexWrite { vector_column: CAST, columns: [CAST, name, items.id(hidden)], stream_key: [items.id] }
    └─StreamExchange { dist: Single }
      └─StreamProject { exprs: [OpenaiEmbedding('{"model": "model"}':Jsonb, items.name)::Vector(3) as $expr1, items.name, items.id] }
        └─StreamTableScan { table: items, columns: [name, id] }
- id: create_table_and_function_index
  sql: |
    create table items (id int primary key, name string, unindexed timestamptz, text string) append only;
    create index vector_index on items using flat (openai_embedding('{"model": "model"}'::jsonb, text)::vector(3)) include (name) with (distance_type = 'inner_product');
- before:
  - create_table_and_function_index
  sql: |
    SELECT id, name FROM items order by openai_embedding('{"model": "model"}'::jsonb, text)::vector(3) <#> '[3,1,2]' limit 5;
  logical_plan: |-
    LogicalProject { exprs: [items.id, items.name] }
    └─LogicalTopN { order: [$expr1 ASC], limit: 5, offset: 0 }
      └─LogicalProject { exprs: [items.id, items.name, Neg(InnerProduct(OpenaiEmbedding('{"model": "model"}':Jsonb, items.text)::Vector(3), '[3,1,2]':Vector(3))) as $expr1] }
        └─LogicalScan { table: items, columns: [items.id, items.name, items.unindexed, items.text, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalVectorSearch { distance_type: InnerProduct, top_n: 5, left: OpenaiEmbedding('{"model": "model"}':Jsonb, $2)::Vector(3), right: '[3,1,2]':Vector(3), output_columns: [items.id:Int32, items.name:Varchar] }
    └─LogicalScan { table: items, columns: [items.id, items.name, items.text] }
  batch_plan: |-
    BatchProject { exprs: [$expr1, $expr2] }
    └─BatchExchange { order: [$expr3 ASC], dist: Single }
      └─BatchSort { order: [$expr3 ASC] }
        └─BatchProject { exprs: [Field(Unnest($1), 1:Int32) as $expr1, Field(Unnest($1), 0:Int32) as $expr2, Field(Unnest($1), 2:Int32) as $expr3] }
          └─BatchProjectSet { select_list: [Unnest($1)] }
            └─BatchVectorSearch { top_n: 5, distance_type: InnerProduct, index_name: "vector_index", vector: query_vector, lookup_output: [("name", Varchar), ("items.id", Int32)], include_distance: true }
              └─BatchValues { rows: [['[3,1,2]':Vector(3)]] }
- id: create_correlated_tables
  sql: |
    create table items (id int primary key, name string, embedding vector(3)) append only;
    create table events (event_id int primary key, time timestamp, embedding vector(3));
- id: correlated_read_without_embedding
  before:
  - create_correlated_tables
  sql: "select \n  event_id, array(\n    select row(id, name)\n    from items\n    order by events.embedding <=> items.embedding\n    limit 3\n  ) as related_info, \n  time\nfrom events;\n"
  logical_plan: |-
    LogicalProject { exprs: [events.event_id, $expr3, events.time] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding, events._rw_timestamp] }
      └─LogicalProject { exprs: [Coalesce(array_agg($expr1 order_by($expr2 ASC)), ARRAY[]:List(Struct(StructType { fields: [("f1", Int32), ("f2", Varchar)] }))) as $expr3] }
        └─LogicalAgg { aggs: [array_agg($expr1 order_by($expr2 ASC))] }
          └─LogicalTopN { order: [$expr2 ASC], limit: 3, offset: 0 }
            └─LogicalProject { exprs: [Row(items.id, items.name) as $expr1, CosineDistance(CorrelatedInputRef { index: 2, correlated_id: 1 }, items.embedding) as $expr2] }
              └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [events.event_id, array, events.time] }
    └─LogicalVectorSearchLookupJoin { distance_type: Cosine, top_n: 3, input_vector: events.embedding:Vector(3), lookup_vector: items.embedding, lookup_output_columns: [items.id:Int32, items.name:Varchar], include_distance: false }
      ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding] }
      └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding, items._rw_timestamp] }
- id: correlated_read_with_embedding
  before:
  - create_correlated_tables
  sql: "select \n  event_id, time, embedding, array(\n    select row(id, name)\n    from items\n    order by items.embedding <=> events.embedding \n    limit 3\n  )\nas related_info from events;\n"
  logical_plan: |-
    LogicalProject { exprs: [events.event_id, events.time, events.embedding, $expr3] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding, events._rw_timestamp] }
      └─LogicalProject { exprs: [Coalesce(array_agg($expr1 order_by($expr2 ASC)), ARRAY[]:List(Struct(StructType { fields: [("f1", Int32), ("f2", Varchar)] }))) as $expr3] }
        └─LogicalAgg { aggs: [array_agg($expr1 order_by($expr2 ASC))] }
          └─LogicalTopN { order: [$expr2 ASC], limit: 3, offset: 0 }
            └─LogicalProject { exprs: [Row(items.id, items.name) as $expr1, CosineDistance(items.embedding, CorrelatedInputRef { index: 2, correlated_id: 1 }) as $expr2] }
              └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [events.event_id, events.time, events.embedding, array] }
    └─LogicalVectorSearchLookupJoin { distance_type: Cosine, top_n: 3, input_vector: events.embedding:Vector(3), lookup_vector: items.embedding, lookup_output_columns: [items.id:Int32, items.name:Varchar], include_distance: false }
      ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding] }
      └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding, items._rw_timestamp] }
- id: correlated_read_with_distance
  before:
  - create_correlated_tables
  sql: "select \n  event_id, array(\n    select row(id, distance, name)\n    from (select id, name, events.embedding <=> items.embedding as distance from items order by distance limit 3)\n  ) as related_info, \n  time\nfrom events;\n"
  logical_plan: |-
    LogicalProject { exprs: [events.event_id, $expr3, events.time] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding, events._rw_timestamp] }
      └─LogicalProject { exprs: [Coalesce(array_agg($expr2), ARRAY[]:List(Struct(StructType { fields: [("f1", Int32), ("f2", Float64), ("f3", Varchar)] }))) as $expr3] }
        └─LogicalAgg { aggs: [array_agg($expr2)] }
          └─LogicalProject { exprs: [Row(items.id, $expr1, items.name) as $expr2] }
            └─LogicalTopN { order: [$expr1 ASC], limit: 3, offset: 0 }
              └─LogicalProject { exprs: [items.id, items.name, CosineDistance(CorrelatedInputRef { index: 2, correlated_id: 1 }, items.embedding) as $expr1] }
                └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(events.embedding, events.embedding), output: [events.event_id, $expr3, events.time] }
    ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding] }
    └─LogicalProject { exprs: [events.embedding, Coalesce(array_agg($expr2) filter(IsNotNull(1:Int32)), ARRAY[]:List(Struct(StructType { fields: [("f1", Int32), ("f2", Float64), ("f3", Varchar)] }))) as $expr3] }
      └─LogicalAgg { group_key: [events.embedding], aggs: [array_agg($expr2) filter(IsNotNull(1:Int32))] }
        └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(events.embedding, events.embedding), output: [events.embedding, $expr2, 1:Int32] }
          ├─LogicalAgg { group_key: [events.embedding], aggs: [] }
          │ └─LogicalScan { table: events, columns: [events.embedding] }
          └─LogicalProject { exprs: [events.embedding, Row(items.id, $expr1, items.name) as $expr2, 1:Int32] }
            └─LogicalTopN { order: [$expr1 ASC], limit: 3, offset: 0, group_key: [events.embedding] }
              └─LogicalProject { exprs: [events.embedding, items.id, items.name, CosineDistance(events.embedding, items.embedding) as $expr1] }
                └─LogicalJoin { type: Inner, on: true, output: all }
                  ├─LogicalAgg { group_key: [events.embedding], aggs: [] }
                  │ └─LogicalScan { table: events, columns: [events.embedding] }
                  └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding] }
- id: create_correlated_tables_with_column_value_index
  sql: |
    create table items (id int primary key, name string, embedding vector(3)) append only;
    create table events (event_id int primary key, time timestamp, embedding vector(3));
    create index i on items using flat (embedding) with (distance_type = 'l2');
- id: correlated_read_without_embedding
  before:
  - create_correlated_tables_with_column_value_index
  sql: "select \n  event_id, array(\n    select row(name)\n    from (select name from items order by events.embedding <-> items.embedding limit 3)\n  ) as related_info, \n  time\nfrom events;\n"
  logical_plan: |-
    LogicalProject { exprs: [events.event_id, $expr3, events.time] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding, events._rw_timestamp] }
      └─LogicalProject { exprs: [Coalesce(array_agg($expr2), ARRAY[]:List(Struct(StructType { fields: [("f1", Varchar)] }))) as $expr3] }
        └─LogicalAgg { aggs: [array_agg($expr2)] }
          └─LogicalProject { exprs: [Row(items.name) as $expr2] }
            └─LogicalProject { exprs: [items.name] }
              └─LogicalTopN { order: [$expr1 ASC], limit: 3, offset: 0 }
                └─LogicalProject { exprs: [items.name, L2Distance(CorrelatedInputRef { index: 2, correlated_id: 1 }, items.embedding) as $expr1] }
                  └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [events.event_id, array, events.time] }
    └─LogicalVectorSearchLookupJoin { distance_type: L2Sqr, top_n: 3, input_vector: events.embedding:Vector(3), lookup_vector: items.embedding, lookup_output_columns: [items.name:Varchar], include_distance: false }
      ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding] }
      └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding, items._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [events.event_id, vector_info, events.time] }
      └─BatchVectorSearch { schema: [events.event_id:Int32, events.time:Timestamp, events.embedding:Vector(3), vector_info:List(Struct(StructType { fields: [("name", Varchar)] }))], top_n: 3, distance_type: L2Sqr, index_name: "i", vector: events.embedding }
        └─BatchScan { table: events, columns: [events.event_id, events.time, events.embedding], distribution: Single }
- id: correlated_read_without_embedding
  before:
  - create_correlated_tables_with_column_value_index
  sql: "select \n  event_id, array(\n    select row(id, name, distance)\n    from (select id, name, events.embedding <-> items.embedding as distance from items order by distance limit 3)\n  ) as related_info, \n  time\nfrom events;\n"
  logical_plan: |-
    LogicalProject { exprs: [events.event_id, $expr3, events.time] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding, events._rw_timestamp] }
      └─LogicalProject { exprs: [Coalesce(array_agg($expr2), ARRAY[]:List(Struct(StructType { fields: [("f1", Int32), ("f2", Varchar), ("f3", Float64)] }))) as $expr3] }
        └─LogicalAgg { aggs: [array_agg($expr2)] }
          └─LogicalProject { exprs: [Row(items.id, items.name, $expr1) as $expr2] }
            └─LogicalTopN { order: [$expr1 ASC], limit: 3, offset: 0 }
              └─LogicalProject { exprs: [items.id, items.name, L2Distance(CorrelatedInputRef { index: 2, correlated_id: 1 }, items.embedding) as $expr1] }
                └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding, items._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [events.event_id, array, events.time] }
    └─LogicalVectorSearchLookupJoin { distance_type: L2Sqr, top_n: 3, input_vector: events.embedding:Vector(3), lookup_vector: items.embedding, lookup_output_columns: [items.id:Int32, items.name:Varchar], include_distance: true }
      ├─LogicalScan { table: events, columns: [events.event_id, events.time, events.embedding] }
      └─LogicalScan { table: items, columns: [items.id, items.name, items.embedding, items._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [events.event_id, vector_info, events.time] }
      └─BatchVectorSearch { schema: [events.event_id:Int32, events.time:Timestamp, events.embedding:Vector(3), vector_info:List(Struct(StructType { fields: [("id", Int32), ("name", Varchar), ("__distance", Float64)] }))], top_n: 3, distance_type: L2Sqr, index_name: "i", vector: events.embedding }
        └─BatchScan { table: events, columns: [events.event_id, events.time, events.embedding], distribution: Single }
