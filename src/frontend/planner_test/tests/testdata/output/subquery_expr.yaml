# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    select (select 1);
  logical_plan: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalProject { exprs: [1:Int32] }
        └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: true, output: all }
    ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
    └─LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [1:Int32:Int32] } }
- sql: |
    create table t(x int);
    select (select x from t) a, 1 b from t;
  logical_plan: |-
    LogicalProject { exprs: [t.x, 1:Int32] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
      └─LogicalProject { exprs: [t.x] }
        └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [t.x, 1:Int32] }
    └─LogicalJoin { type: LeftOuter, on: true, output: all }
      ├─LogicalScan { table: t, columns: [] }
      └─LogicalMaxOneRow
        └─LogicalScan { table: t, columns: [t.x] }
  batch_plan: |-
    BatchProject { exprs: [t.x, 1:Int32] }
    └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
      ├─BatchExchange { order: [], dist: Single }
      │ └─BatchScan { table: t, columns: [], distribution: SomeShard }
      └─BatchMaxOneRow
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: t, columns: [t.x], distribution: SomeShard }
  stream_error: Scalar subquery might produce more than one row.
- sql: |
    create table t(x int);
    select (select x from t limit 1), 1 from t;
  logical_plan: |-
    LogicalProject { exprs: [t.x, 1:Int32] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
      └─LogicalLimit { limit: 1, offset: 0 }
        └─LogicalProject { exprs: [t.x] }
          └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [t.x, 1:Int32] }
    └─LogicalJoin { type: LeftOuter, on: true, output: all }
      ├─LogicalScan { table: t, columns: [] }
      └─LogicalLimit { limit: 1, offset: 0 }
        └─LogicalScan { table: t, columns: [t.x] }
- sql: |
    create table t(x int);
    select (select x from t order by x limit 1), 1 from t;
  logical_plan: |-
    LogicalProject { exprs: [t.x, 1:Int32] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
      └─LogicalTopN { order: [t.x ASC], limit: 1, offset: 0 }
        └─LogicalProject { exprs: [t.x] }
          └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [t.x, 1:Int32] }
    └─LogicalJoin { type: LeftOuter, on: true, output: all }
      ├─LogicalScan { table: t, columns: [] }
      └─LogicalTopN { order: [t.x ASC], limit: 1, offset: 0 }
        └─LogicalScan { table: t, columns: [t.x] }
- sql: |
    create table t(x int);
    select (select x from t order by x fetch next 1 rows with ties) a, 1 b from t;
  logical_plan: |-
    LogicalProject { exprs: [t.x, 1:Int32] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
      └─LogicalTopN { order: [t.x ASC], limit: 1, offset: 0, with_ties: true }
        └─LogicalProject { exprs: [t.x] }
          └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [t.x, 1:Int32] }
    └─LogicalJoin { type: LeftOuter, on: true, output: all }
      ├─LogicalScan { table: t, columns: [] }
      └─LogicalMaxOneRow
        └─LogicalTopN { order: [t.x ASC], limit: 1, offset: 0, with_ties: true }
          └─LogicalScan { table: t, columns: [t.x] }
  batch_plan: |-
    BatchProject { exprs: [t.x, 1:Int32] }
    └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
      ├─BatchExchange { order: [], dist: Single }
      │ └─BatchScan { table: t, columns: [], distribution: SomeShard }
      └─BatchMaxOneRow
        └─BatchTopN { order: [t.x ASC], limit: 1, offset: 0, with_ties: true }
          └─BatchExchange { order: [], dist: Single }
            └─BatchTopN { order: [t.x ASC], limit: 1, offset: 0, with_ties: true }
              └─BatchScan { table: t, columns: [t.x], distribution: SomeShard }
  stream_error: Scalar subquery might produce more than one row.
- sql: |
    create table t(x int);
    select (select x from t) + 1 a from t;
  logical_plan: |-
    LogicalProject { exprs: [(t.x + 1:Int32) as $expr1] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
      └─LogicalProject { exprs: [t.x] }
        └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [(t.x + 1:Int32) as $expr1] }
    └─LogicalJoin { type: LeftOuter, on: true, output: all }
      ├─LogicalScan { table: t, columns: [] }
      └─LogicalMaxOneRow
        └─LogicalScan { table: t, columns: [t.x] }
  batch_plan: |-
    BatchProject { exprs: [(t.x + 1:Int32) as $expr1] }
    └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
      ├─BatchExchange { order: [], dist: Single }
      │ └─BatchScan { table: t, columns: [], distribution: SomeShard }
      └─BatchMaxOneRow
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: t, columns: [t.x], distribution: SomeShard }
  stream_error: Scalar subquery might produce more than one row.
- sql: |
    create table t(x int);
    select (select x from t) a, (select 1) b;
  logical_plan: |-
    LogicalProject { exprs: [t.x, 1:Int32] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalJoin { type: FullOuter, on: true, output: all }
        ├─LogicalProject { exprs: [t.x] }
        │ └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
        └─LogicalProject { exprs: [1:Int32] }
          └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: true, output: all }
    ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
    └─LogicalMaxOneRow
      └─LogicalJoin { type: FullOuter, on: true, output: all }
        ├─LogicalScan { table: t, columns: [t.x] }
        └─LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [1:Int32:Int32] } }
  batch_plan: |-
    BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
    ├─BatchValues { rows: [[]] }
    └─BatchMaxOneRow
      └─BatchNestedLoopJoin { type: FullOuter, predicate: true, output: all }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: t, columns: [t.x], distribution: SomeShard }
        └─BatchValues { rows: [[1:Int32]] }
  stream_error: Scalar subquery might produce more than one row.
- sql: |
    create table t(x int);
    select x + (select x + (select x as v1 from t) as v2 from t) as v3 from t;
  logical_plan: |-
    LogicalProject { exprs: [(t.x + $expr1) as $expr2] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
      └─LogicalProject { exprs: [(t.x + t.x) as $expr1] }
        └─LogicalApply { type: LeftOuter, on: true, correlated_id: 2, max_one_row: true }
          ├─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
          └─LogicalProject { exprs: [t.x] }
            └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [(t.x + $expr1) as $expr2] }
    └─LogicalJoin { type: LeftOuter, on: true, output: all }
      ├─LogicalScan { table: t, columns: [t.x] }
      └─LogicalMaxOneRow
        └─LogicalProject { exprs: [(t.x + t.x) as $expr1] }
          └─LogicalJoin { type: LeftOuter, on: true, output: all }
            ├─LogicalScan { table: t, columns: [t.x] }
            └─LogicalMaxOneRow
              └─LogicalScan { table: t, columns: [t.x] }
  batch_plan: |-
    BatchProject { exprs: [(t.x + $expr1) as $expr2] }
    └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
      ├─BatchExchange { order: [], dist: Single }
      │ └─BatchScan { table: t, columns: [t.x], distribution: SomeShard }
      └─BatchMaxOneRow
        └─BatchProject { exprs: [(t.x + t.x) as $expr1] }
          └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
            ├─BatchExchange { order: [], dist: Single }
            │ └─BatchScan { table: t, columns: [t.x], distribution: SomeShard }
            └─BatchMaxOneRow
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: t, columns: [t.x], distribution: SomeShard }
  stream_error: Scalar subquery might produce more than one row.
- sql: |
    create table t1 (x int, y int);
    create table t2 (x int, y int);
    select t1.x, (select y from (select y from t2 order by y desc limit 1 offset 3) t2 limit 2) from t1;
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: true, output: all }
    ├─LogicalScan { table: t1, columns: [t1.x] }
    └─LogicalLimit { limit: 2, offset: 0 }
      └─LogicalTopN { order: [t2.y DESC], limit: 1, offset: 3 }
        └─LogicalScan { table: t2, columns: [t2.y] }
- sql: |
    select (select 1, 2);
  binder_error: |
    Failed to bind expression: (SELECT 1, 2)

    Caused by:
      Bind error: Subquery must return only one column
- sql: |
    create table t(x int);
    select 1 where exists (select * from t);
  logical_plan: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalProject { exprs: [t.x] }
        └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalJoin { type: LeftSemi, on: true, output: all }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalScan { table: t, columns: [] }
- sql: |
    create table t(x int);
    select 1 where not exists (select * from t);
  logical_plan: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalApply { type: LeftAnti, on: true, correlated_id: 1 }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalProject { exprs: [t.x] }
        └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalJoin { type: LeftAnti, on: true, output: all }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalScan { table: t, columns: [] }
- sql: |
    create table t1(x int);
    create table t2(x int);
    select x from t1 where exists (select x from t2);
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.x] }
        └─LogicalScan { table: t2, columns: [t2.x, t2._row_id, t2._rw_timestamp] }
- sql: |
    create table t(x int);
    select x from t where exists (select * from t);
  logical_plan: |-
    LogicalProject { exprs: [t.x] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
      └─LogicalProject { exprs: [t.x] }
        └─LogicalScan { table: t, columns: [t.x, t._row_id, t._rw_timestamp] }
- sql: |
    create table t1(x int);
    create table t2(x int);
    select x from t1 where x > (select x from t2)
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalFilter { predicate: (t1.x > t2.x) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalScan { table: t1, columns: [t1.x, t1._row_id, t1._rw_timestamp] }
        └─LogicalProject { exprs: [t2.x] }
          └─LogicalScan { table: t2, columns: [t2.x, t2._row_id, t2._rw_timestamp] }
- sql: |
    select 1 where 1>0 and exists (values (1))
  logical_plan: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalFilter { predicate: (1:Int32 > 0:Int32) }
      └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
        ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
        └─LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [*VALUES*_0.column_0:Int32] } }
- sql: |
    select 1 where (not exists (values (1))) and (1>0 or exists (values (1)))
  logical_plan: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalFilter { predicate: ((1:Int32 > 0:Int32) OR $expr1) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 2, max_one_row: true }
        ├─LogicalApply { type: LeftAnti, on: true, correlated_id: 1 }
        │ ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
        │ └─LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [*VALUES*_0.column_0:Int32] } }
        └─LogicalProject { exprs: [(count >= 1:Int32) as $expr1] }
          └─LogicalAgg { aggs: [count] }
            └─LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [*VALUES*_1.column_0:Int32] } }
- sql: |
    select a + 1, b::varchar, c from (values (1, 2, 3), (4, 5, 6)) t(a, b, c);
  logical_plan: |-
    LogicalProject { exprs: [(*VALUES*_0.column_0 + 1:Int32) as $expr1, *VALUES*_0.column_1::Varchar as $expr2, *VALUES*_0.column_2] }
    └─LogicalValues { rows: [[1:Int32, 2:Int32, 3:Int32], [4:Int32, 5:Int32, 6:Int32]], schema: Schema { fields: [*VALUES*_0.column_0:Int32, *VALUES*_0.column_1:Int32, *VALUES*_0.column_2:Int32] } }
- sql: |
    select sum(a), max(b + c + 10), string_agg(c::varchar || '~', ',') from (values (1, 2, 3), (4, 5, 6)) as t(a, b, c);
  logical_plan: |-
    LogicalProject { exprs: [sum(*VALUES*_0.column_0), max($expr1), string_agg($expr2, ',':Varchar)] }
    └─LogicalAgg { aggs: [sum(*VALUES*_0.column_0), max($expr1), string_agg($expr2, ',':Varchar)] }
      └─LogicalProject { exprs: [*VALUES*_0.column_0, ((*VALUES*_0.column_1 + *VALUES*_0.column_2) + 10:Int32) as $expr1, ConcatOp(*VALUES*_0.column_2::Varchar, '~':Varchar) as $expr2, ',':Varchar] }
        └─LogicalValues { rows: [[1:Int32, 2:Int32, 3:Int32], [4:Int32, 5:Int32, 6:Int32]], schema: Schema { fields: [*VALUES*_0.column_0:Int32, *VALUES*_0.column_1:Int32, *VALUES*_0.column_2:Int32] } }
- sql: |
    select 1 + (select 2 from t);
  binder_error: |
    Failed to bind expression: 1 + (SELECT 2 FROM t)

    Caused by these errors (recent errors listed first):
      1: Catalog error
      2: table or source not found: t
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y from t2);
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalApply { type: LeftSemi, on: (t1.y = t2.y), correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.y] }
        └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y not in (select y from t2);
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalApply { type: LeftAnti, on: (t1.y = t2.y), correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.y] }
        └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
- sql: |
    create table t1 (a int);
    create table t2 (b int);
    SELECT *
    FROM t1
    WHERE EXISTS
    (SELECT 1
    FROM t2
    GROUP BY a
    ORDER BY a DESC LIMIT 90);
  logical_plan: |-
    LogicalProject { exprs: [t1.a] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.a, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [1:Int32] }
        └─LogicalTopN { order: [$expr2 DESC], limit: 90, offset: 0 }
          └─LogicalProject { exprs: [1:Int32, CorrelatedInputRef { index: 0, correlated_id: 1 } as $expr2] }
            └─LogicalAgg { group_key: [$expr1], aggs: [] }
              └─LogicalProject { exprs: [CorrelatedInputRef { index: 0, correlated_id: 1 } as $expr1] }
                └─LogicalScan { table: t2, columns: [t2.b, t2._row_id, t2._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: LeftSemi, predicate: t1.a IS NOT DISTINCT FROM t1.a, output: all }
      ├─BatchExchange { order: [], dist: HashShard(t1.a) }
      │ └─BatchScan { table: t1, columns: [t1.a], distribution: SomeShard }
      └─BatchProject { exprs: [t1.a] }
        └─BatchGroupTopN { order: [t1.a DESC], limit: 90, offset: 0, group_key: [t1.a] }
          └─BatchExchange { order: [], dist: HashShard(t1.a) }
            └─BatchProject { exprs: [t1.a, t1.a] }
              └─BatchHashAgg { group_key: [t1.a], aggs: [] }
                └─BatchExchange { order: [], dist: HashShard(t1.a) }
                  └─BatchNestedLoopJoin { type: Inner, predicate: true, output: all }
                    ├─BatchExchange { order: [], dist: Single }
                    │ └─BatchHashAgg { group_key: [t1.a], aggs: [] }
                    │   └─BatchExchange { order: [], dist: HashShard(t1.a) }
                    │     └─BatchScan { table: t1, columns: [t1.a], distribution: SomeShard }
                    └─BatchExchange { order: [], dist: Single }
                      └─BatchScan { table: t2, columns: [], distribution: SomeShard }
- sql: |
    create table b (b1 varchar);
    select * from  b cross join repeat(b1, 2);
  logical_plan: |-
    LogicalProject { exprs: [b.b1, ] }
    └─LogicalApply { type: Inner, on: true, correlated_id: 1 }
      ├─LogicalScan { table: b, columns: [b.b1, b._row_id, b._rw_timestamp] }
      └─LogicalProject { exprs: [] }
        └─LogicalValues { rows: [[Repeat(CorrelatedInputRef { index: 0, correlated_id: 1 }, 2:Int32)]], schema: Schema { fields: [:Varchar] } }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [b.b1, Repeat(b.b1, 2:Int32) as $expr1] }
      └─BatchHashJoin { type: Inner, predicate: b.b1 IS NOT DISTINCT FROM b.b1, output: all }
        ├─BatchExchange { order: [], dist: HashShard(b.b1) }
        │ └─BatchScan { table: b, columns: [b.b1], distribution: SomeShard }
        └─BatchExchange { order: [], dist: HashShard(b.b1) }
          └─BatchNestedLoopJoin { type: Inner, predicate: true, output: all }
            ├─BatchExchange { order: [], dist: Single }
            │ └─BatchHashAgg { group_key: [b.b1], aggs: [] }
            │   └─BatchExchange { order: [], dist: HashShard(b.b1) }
            │     └─BatchScan { table: b, columns: [b.b1], distribution: SomeShard }
            └─BatchValues { rows: [[]] }
- sql: |
    create table t (a int);
    create table dl(c1 int, c2 int);
    create table di(d1 int, d2 int);
    select (select 1 from t,di where t.a = dl.c1 limit 1) name, (select 1 from t, di where t.a = dl.c2 limit 1) name2 from dl;
  logical_plan: |-
    LogicalProject { exprs: [1:Int32, 1:Int32] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: dl, columns: [dl.c1, dl.c2, dl._row_id, dl._rw_timestamp] }
      └─LogicalJoin { type: FullOuter, on: true, output: all }
        ├─LogicalLimit { limit: 1, offset: 0 }
        │ └─LogicalProject { exprs: [1:Int32] }
        │   └─LogicalFilter { predicate: (t.a = CorrelatedInputRef { index: 0, correlated_id: 1 }) }
        │     └─LogicalJoin { type: Inner, on: true, output: all }
        │       ├─LogicalScan { table: t, columns: [t.a, t._row_id, t._rw_timestamp] }
        │       └─LogicalScan { table: di, columns: [di.d1, di.d2, di._row_id, di._rw_timestamp] }
        └─LogicalLimit { limit: 1, offset: 0 }
          └─LogicalProject { exprs: [1:Int32] }
            └─LogicalFilter { predicate: (t.a = CorrelatedInputRef { index: 1, correlated_id: 1 }) }
              └─LogicalJoin { type: Inner, on: true, output: all }
                ├─LogicalScan { table: t, columns: [t.a, t._row_id, t._rw_timestamp] }
                └─LogicalScan { table: di, columns: [di.d1, di.d2, di._row_id, di._rw_timestamp] }
