# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    select 1 as k, 2 as v;
  batch_plan: 'BatchValues { rows: [[1:Int32, 2:Int32]] }'
- sql: select 'abc', 1, 1.4 as k from (select 1 as k, 2 from (select 1, 2 union all select 3, 4) union all select * from (select 3, 4) union all select 100, 200 from (select now(), now() - interval '1 hour'));
  batch_plan: 'BatchValues { rows: [[''abc'':Varchar, 1:Int32, 1.4:Decimal], [''abc'':Varchar, 1:Int32, 1.4:Decimal], [''abc'':Varchar, 1:Int32, 1.4:Decimal], [''abc'':Varchar, 1:Int32, 1.4:Decimal]] }'
- sql: |
    select id, value, openai_embedding('sk-test-key', 'text-embedding-3-small', value) as embedding
    from (values (1, 'hello'), (2, 'world')) as t(id, value);
  logical_plan: |-
    LogicalProject { exprs: [*VALUES*_0.column_0, *VALUES*_0.column_1, OpenaiEmbedding('sk-test-key':Varchar, 'text-embedding-3-small':Varchar, *VALUES*_0.column_1) as $expr1] }
    └─LogicalValues { rows: [[1:Int32, 'hello':Varchar], [2:Int32, 'world':Varchar]], schema: Schema { fields: [*VALUES*_0.column_0:Int32, *VALUES*_0.column_1:Varchar] } }
  batch_plan: |-
    BatchProject { exprs: [*VALUES*_0.column_0, *VALUES*_0.column_1, OpenaiEmbedding('sk-test-key':Varchar, 'text-embedding-3-small':Varchar, *VALUES*_0.column_1) as $expr1] }
    └─BatchValues { rows: [[1:Int32, 'hello':Varchar], [2:Int32, 'world':Varchar]] }
  stream_plan: |-
    StreamMaterialize { columns: [id, value, embedding, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [*VALUES*_0.column_0, *VALUES*_0.column_1, $expr1, _row_id] }
      └─StreamMaterializedExprs { exprs: [OpenaiEmbedding('sk-test-key':Varchar, 'text-embedding-3-small':Varchar, *VALUES*_0.column_1) as $expr1] }
        └─StreamValues { rows: [[1:Int32, 'hello':Varchar, 0:Int64], [2:Int32, 'world':Varchar, 1:Int64]] }
- sql: |
    select id, value, id + 1 as id_plus_one,
           openai_embedding('sk-test-key', 'text-embedding-3-small', value) as embedding,
           upper(value) as upper_value
    from (values (1, 'hello'), (2, 'world')) as t(id, value);
  logical_plan: |-
    LogicalProject { exprs: [*VALUES*_0.column_0, *VALUES*_0.column_1, (*VALUES*_0.column_0 + 1:Int32) as $expr1, OpenaiEmbedding('sk-test-key':Varchar, 'text-embedding-3-small':Varchar, *VALUES*_0.column_1) as $expr2, Upper(*VALUES*_0.column_1) as $expr3] }
    └─LogicalValues { rows: [[1:Int32, 'hello':Varchar], [2:Int32, 'world':Varchar]], schema: Schema { fields: [*VALUES*_0.column_0:Int32, *VALUES*_0.column_1:Varchar] } }
  batch_plan: |-
    BatchProject { exprs: [*VALUES*_0.column_0, *VALUES*_0.column_1, (*VALUES*_0.column_0 + 1:Int32) as $expr1, OpenaiEmbedding('sk-test-key':Varchar, 'text-embedding-3-small':Varchar, *VALUES*_0.column_1) as $expr2, Upper(*VALUES*_0.column_1) as $expr3] }
    └─BatchValues { rows: [[1:Int32, 'hello':Varchar], [2:Int32, 'world':Varchar]] }
  stream_plan: |-
    StreamMaterialize { columns: [id, value, id_plus_one, embedding, upper_value, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [*VALUES*_0.column_0, *VALUES*_0.column_1, (*VALUES*_0.column_0 + 1:Int32) as $expr2, $expr1, Upper(*VALUES*_0.column_1) as $expr3, _row_id] }
      └─StreamMaterializedExprs { exprs: [OpenaiEmbedding('sk-test-key':Varchar, 'text-embedding-3-small':Varchar, *VALUES*_0.column_1) as $expr1] }
        └─StreamValues { rows: [[1:Int32, 'hello':Varchar, 0:Int64], [2:Int32, 'world':Varchar, 1:Int64]] }
- name: materialize impure expressions after singleton (top-n)
  sql: |
    create table t (v int);
    with cte as (select v from t order by v limit 10) select pg_sleep(v) from cte;
  stream_plan: |-
    StreamMaterialize { columns: [pg_sleep, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, t._row_id] }
      └─StreamMaterializedExprs { exprs: [PgSleep(t.v::Float64) as $expr1] }
        └─StreamProject { exprs: [t.v, t._row_id] }
          └─StreamTopN { order: [t.v ASC], limit: 10, offset: 0 }
            └─StreamExchange { dist: Single }
              └─StreamGroupTopN { order: [t.v ASC], limit: 10, offset: 0, group_key: [_vnode] }
                └─StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as _vnode] }
                  └─StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: materialized impure expressions after some-shard (full outer join)
  sql: |
    create table t1 (v int);
    create table t2 (v int);
    with cte as (select t1.v v from t1 full outer join t2 on t1.v = t2.v) select pg_sleep(v) from cte;
  stream_plan: |-
    StreamMaterialize { columns: [pg_sleep, t1._row_id(hidden), t2._row_id(hidden), t1.v(hidden), t2.v(hidden)], stream_key: [t1._row_id, t2._row_id, t1.v, t2.v], pk_columns: [t1._row_id, t2._row_id, t1.v, t2.v], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, t1._row_id, t2._row_id, t1.v, t2.v] }
      └─StreamMaterializedExprs { exprs: [PgSleep(t1.v::Float64) as $expr1] }
        └─StreamExchange { dist: HashShard(t1.v, t1._row_id, t2._row_id, t2.v) }
          └─StreamFilter { predicate: (IsNotNull(t1._row_id) OR IsNotNull(t2._row_id)) }
            └─StreamHashJoin { type: FullOuter, predicate: t1.v = t2.v, output: [t1.v, t1._row_id, t2._row_id, t2.v] }
              ├─StreamExchange { dist: HashShard(t1.v) }
              │ └─StreamTableScan { table: t1, columns: [t1.v, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              └─StreamExchange { dist: HashShard(t2.v) }
                └─StreamTableScan { table: t2, columns: [t2.v, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
