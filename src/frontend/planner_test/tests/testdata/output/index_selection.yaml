# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(c);
    select * from t1 where a = 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx1, columns: [idx1.a, idx1.b, idx1.c], scan_ranges: [idx1.a = Int32(1)], distribution: UpstreamHashShard(idx1.a, idx1.b) }
- sql: |
    /* Use index if it provides required order */
    create table t1 (a int, b int, c int);
    create index idx1 on t1(a, b) include(c);
    select * from t1 order by a, b
  batch_plan: |-
    BatchExchange { order: [idx1.a ASC, idx1.b ASC], dist: Single }
    └─BatchScan { table: idx1, columns: [idx1.a, idx1.b, idx1.c], distribution: UpstreamHashShard(idx1.a, idx1.b) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(c);
    select * from t1 where a = 1 or a = 2
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx1, columns: [idx1.a, idx1.b, idx1.c], scan_ranges: [idx1.a = Int32(1), idx1.a = Int32(2)], distribution: UpstreamHashShard(idx1.a, idx1.b) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(c);
    select * from t1 where a in (1,2,3)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx1, columns: [idx1.a, idx1.b, idx1.c], scan_ranges: [idx1.a = Int32(1), idx1.a = Int32(2), idx1.a = Int32(3)], distribution: UpstreamHashShard(idx1.a, idx1.b) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(c);
    select * from t1 where a between 1 and 8
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx1, columns: [idx1.a, idx1.b, idx1.c], scan_ranges: [idx1.a = Int32(1), idx1.a = Int32(2), idx1.a = Int32(3), idx1.a = Int32(4), idx1.a = Int32(5), idx1.a = Int32(6), idx1.a = Int32(7), idx1.a = Int32(8)], distribution: UpstreamHashShard(idx1.a, idx1.b) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(c);
    select * from t1 where a = 1 and b = 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx1, columns: [idx1.a, idx1.b, idx1.c], scan_ranges: [idx1.a = Int32(1) AND idx1.b = Decimal(Normalized(1))], distribution: UpstreamHashShard(idx1.a, idx1.b) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(c);
    create index idx2 on t1(b, a) include(c);
    select * from t1 where b = 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx2, columns: [idx2.a, idx2.b, idx2.c], scan_ranges: [idx2.b = Decimal(Normalized(1))], distribution: UpstreamHashShard(idx2.b, idx2.a) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(a, b);
    create index idx2 on t1(b, a) include(a, b);
    /* non-covering */
    select * from t1 where b = 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx2.t1._row_id) }
        └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(1))], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(c);
    create index idx2 on t1(b, a) include(c);
    /* non-covering */
    select * from t1 where c = 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (t1.c = 1:Int32) }
      └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(c);
    select a,b from t1 where a in (1,2) and b in (2,3)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: In(idx1.b, 2:Decimal, 3:Decimal) }
      └─BatchScan { table: idx1, columns: [idx1.a, idx1.b], scan_ranges: [idx1.a = Int32(1), idx1.a = Int32(2)], distribution: UpstreamHashShard(idx1.a, idx1.b) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a, b) include(c);
    create index idx2 on t1(a) include(a);
    select count(1) from t1;
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum0(count(1:Int32))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count(1:Int32)] }
        └─BatchProject { exprs: [1:Int32] }
          └─BatchScan { table: idx2, columns: [], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include (b, c);
    create index idx2 on t1(b, a) include(c);
    create index idx3 on t1(c) include (a, b);
    select * from t1 where c = 1 and a < 10;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (idx3.a < 10:Int32) }
      └─BatchScan { table: idx3, columns: [idx3.a, idx3.b, idx3.c], scan_ranges: [idx3.c = Int64(1)], distribution: UpstreamHashShard(idx3.c) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include (b, c);
    create index idx2 on t1(b, a) include(c);
    create index idx3 on t1(c) include (a, b);
    select * from t1 where a = 1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx1, columns: [idx1.a, idx1.b, idx1.c], scan_ranges: [idx1.a = Int32(1)], distribution: UpstreamHashShard(idx1.a) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include (b, c);
    create index idx2 on t1(b, a) include(c);
    create index idx3 on t1(c) include (a, b);
    select * from t1 where a = 1 and b = 2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx2, columns: [idx2.a, idx2.b, idx2.c], scan_ranges: [idx2.b = Decimal(Normalized(2)) AND idx2.a = Int32(1)], distribution: UpstreamHashShard(idx2.b, idx2.a) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include (b, c);
    create index idx2 on t1(b, a) include(c);
    create index idx3 on t1(c) include (a, b);
    select * from t1 where b = 2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx2, columns: [idx2.a, idx2.b, idx2.c], scan_ranges: [idx2.b = Decimal(Normalized(2))], distribution: UpstreamHashShard(idx2.b, idx2.a) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include(a);
    create index idx2 on t1(b, a) include(a, b);
    create index idx3 on t1(c) include(c);
    select * from t1 where c = 1 and a < 10;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx3.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (t1.a < 10:Int32), output: [t1.a, t1.b, t1.c] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx3.t1._row_id) }
        └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(1)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx3.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (t1.a < 10:Int32), output: [t1.a, t1.b, t1.c] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(1)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include(a);
    create index idx2 on t1(b, a) include(a, b);
    create index idx3 on t1(c) include(c);
    select * from t1 where a = 1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t1._row_id) }
        └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(1)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(1)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include(a);
    create index idx2 on t1(b, a) include(a, b);
    create index idx3 on t1(c) include(c);
    select * from t1 where a = 1 and b = 2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx2.t1._row_id) }
        └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2)) AND idx2.a = Int32(1)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2)) AND idx2.a = Int32(1)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include(a);
    create index idx2 on t1(b, a) include(a, b);
    create index idx3 on t1(c) include(c);
    select * from t1 where b = 2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx2.t1._row_id) }
        └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2))], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2))], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include(a);
    create index idx2 on t1(b, a) include(a, b);
    create index idx3 on t1(c) include(c);
    delete from t1 where b = 2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchDelete { table: t1 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c, t1._row_id] }
          └─BatchExchange { order: [], dist: UpstreamHashShard(idx2.t1._row_id) }
            └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2))], distribution: SomeShard }
  batch_local_plan: |-
    BatchDelete { table: t1 }
    └─BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c, t1._row_id] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2))], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a) include(a);
    create index idx2 on t1(b, a) include(a, b);
    create index idx3 on t1(c) include(c);
    update t1 set c = 3 where a = 1 and b = 2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t1, exprs: [$0, $1, 3:Int64, $3] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c, t1._row_id] }
          └─BatchExchange { order: [], dist: UpstreamHashShard(idx2.t1._row_id) }
            └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2)) AND idx2.a = Int32(1)], distribution: SomeShard }
  batch_local_plan: |-
    BatchUpdate { table: t1, exprs: [$0, $1, 3:Int64, $3] }
    └─BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c, t1._row_id] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2)) AND idx2.a = Int32(1)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create materialized view v as select count(*) as cnt, p from t1 group by p;
    create index idx1 on v(cnt) include(cnt);
    select * from v where cnt = 1 or p = 2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.v.p IS NOT DISTINCT FROM v.p AND ((v.cnt = 1:Int32) OR (v.p = 2:Int32)), output: [v.cnt, v.p] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.v.p) }
        └─BatchHashAgg { group_key: [idx1.v.p], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx1.v.p) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx1, columns: [idx1.v.p], scan_ranges: [idx1.cnt = Int64(1)], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: v, columns: [v.p], scan_ranges: [v.p = Int32(2)], distribution: UpstreamHashShard(v.p) }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx1.v.p IS NOT DISTINCT FROM v.p AND ((v.cnt = 1:Int32) OR (v.p = 2:Int32)), output: [v.cnt, v.p] }
    └─BatchHashAgg { group_key: [idx1.v.p], aggs: [] }
      └─BatchUnion { all: true }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx1, columns: [idx1.v.p], scan_ranges: [idx1.cnt = Int64(1)], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: v, columns: [v.p], scan_ranges: [v.p = Int32(2)], distribution: UpstreamHashShard(v.p) }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c);
    select * from t1 where a = 1 or c = 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND ((t1.a = 1:Int32) OR (t1.c = 1:Int32)), output: [t1.a, t1.b, t1.c] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t1._row_id) }
        └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx1.t1._row_id) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(1)], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(1)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND ((t1.a = 1:Int32) OR (t1.c = 1:Int32)), output: [t1.a, t1.b, t1.c] }
    └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
      └─BatchUnion { all: true }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(1)], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(1)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c);
    select * from t1 where c = 1 or (a = 2 and b = 3)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id AND ((t1.c = 1:Int32) OR ((t1.a = 2:Int32) AND (t1.b = 3:Decimal))), output: [t1.a, t1.b, t1.c] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx2.t1._row_id) }
        └─BatchHashAgg { group_key: [idx2.t1._row_id], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx2.t1._row_id) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(3)) AND idx2.a = Int32(2)], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(1)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id AND ((t1.c = 1:Int32) OR ((t1.a = 2:Int32) AND (t1.b = 3:Decimal))), output: [t1.a, t1.b, t1.c] }
    └─BatchHashAgg { group_key: [idx2.t1._row_id], aggs: [] }
      └─BatchUnion { all: true }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(3)) AND idx2.a = Int32(2)], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(1)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c);
    create index idx4 on t1(p);
    select * from t1 where p = 1 or (a = 2 and b = 3 and c = 4)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id AND ((t1.p = 1:Int32) OR (((t1.a = 2:Int32) AND (t1.b = 3:Decimal)) AND (t1.c = 4:Int32))), output: [t1.a, t1.b, t1.c, t1.p] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx2.t1._row_id) }
        └─BatchHashAgg { group_key: [idx2.t1._row_id], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx2.t1._row_id) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(3)) AND idx2.a = Int32(2)], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: idx4, columns: [idx4.t1._row_id], scan_ranges: [idx4.p = Int32(1)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx2.t1._row_id IS NOT DISTINCT FROM t1._row_id AND ((t1.p = 1:Int32) OR (((t1.a = 2:Int32) AND (t1.b = 3:Decimal)) AND (t1.c = 4:Int32))), output: [t1.a, t1.b, t1.c, t1.p] }
    └─BatchHashAgg { group_key: [idx2.t1._row_id], aggs: [] }
      └─BatchUnion { all: true }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(3)) AND idx2.a = Int32(2)], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: idx4, columns: [idx4.t1._row_id], scan_ranges: [idx4.p = Int32(1)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c);
    create index idx4 on t1(p);
    select * from t1 where a = 1 or b = 2 or c = 3 or p = 4 or a = 5
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (((((t1.a = 1:Int32) OR (t1.b = 2:Decimal)) OR (t1.c = 3:Int32)) OR (t1.p = 4:Int32)) OR (t1.a = 5:Int32)), output: [t1.a, t1.b, t1.c, t1.p] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t1._row_id) }
        └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx1.t1._row_id) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(5), idx1.a = Int32(1)], distribution: SomeShard }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2))], distribution: SomeShard }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(3)], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: idx4, columns: [idx4.t1._row_id], scan_ranges: [idx4.p = Int32(4)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (((((t1.a = 1:Int32) OR (t1.b = 2:Decimal)) OR (t1.c = 3:Int32)) OR (t1.p = 4:Int32)) OR (t1.a = 5:Int32)), output: [t1.a, t1.b, t1.c, t1.p] }
    └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
      └─BatchUnion { all: true }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(5), idx1.a = Int32(1)], distribution: SomeShard }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2))], distribution: SomeShard }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(3)], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: idx4, columns: [idx4.t1._row_id], scan_ranges: [idx4.p = Int32(4)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c);
    create index idx4 on t1(p);
    select * from t1 where (a = 1 or (b = 2 and a = 5)) and (c = 3 or p = 4)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND ((t1.a = 1:Int32) OR ((t1.b = 2:Decimal) AND (t1.a = 5:Int32))) AND ((t1.c = 3:Int32) OR (t1.p = 4:Int32)), output: [t1.a, t1.b, t1.c, t1.p] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t1._row_id) }
        └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx1.t1._row_id) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(1)], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2)) AND idx2.a = Int32(5)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND ((t1.a = 1:Int32) OR ((t1.b = 2:Decimal) AND (t1.a = 5:Int32))) AND ((t1.c = 3:Int32) OR (t1.p = 4:Int32)), output: [t1.a, t1.b, t1.c, t1.p] }
    └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
      └─BatchUnion { all: true }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(1)], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(2)) AND idx2.a = Int32(5)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c);
    create index idx4 on t1(p);
    select * from t1 where p != 1 and (c = 3 or (c != 4 and (a = 2 or b = 3)))
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (t1.p <> 1:Int32) AND ((t1.c = 3:Int32) OR ((t1.c <> 4:Int32) AND ((t1.a = 2:Int32) OR (t1.b = 3:Decimal)))), output: [t1.a, t1.b, t1.c, t1.p] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t1._row_id) }
        └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx1.t1._row_id) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(2)], distribution: SomeShard }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(3))], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(3)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (t1.p <> 1:Int32) AND ((t1.c = 3:Int32) OR ((t1.c <> 4:Int32) AND ((t1.a = 2:Int32) OR (t1.b = 3:Decimal)))), output: [t1.a, t1.b, t1.c, t1.p] }
    └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
      └─BatchUnion { all: true }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a = Int32(2)], distribution: SomeShard }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx2, columns: [idx2.t1._row_id], scan_ranges: [idx2.b = Decimal(Normalized(3))], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(3)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c);
    create index idx4 on t1(p);
    /* we think merging two TwoSideBound range indexes is better than primary scan */
    select * from t1 where (a > 1 and a < 8) or c between 8 and 9
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (((t1.a > 1:Int32) AND (t1.a < 8:Int32)) OR ((t1.c >= 8:Int32) AND (t1.c <= 9:Int32))), output: [t1.a, t1.b, t1.c, t1.p] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t1._row_id) }
        └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx1.t1._row_id) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a > Int32(1) AND idx1.a < Int32(8)], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(8), idx3.c = Int64(9)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (((t1.a > 1:Int32) AND (t1.a < 8:Int32)) OR ((t1.c >= 8:Int32) AND (t1.c <= 9:Int32))), output: [t1.a, t1.b, t1.c, t1.p] }
    └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
      └─BatchUnion { all: true }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a > Int32(1) AND idx1.a < Int32(8)], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(8), idx3.c = Int64(9)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c);
    create index idx4 on t1(p);
    select * from t1 where (a > 1 and a < 8) or c = 8
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (((t1.a > 1:Int32) AND (t1.a < 8:Int32)) OR (t1.c = 8:Int32)), output: [t1.a, t1.b, t1.c, t1.p] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t1._row_id) }
        └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx1.t1._row_id) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a > Int32(1) AND idx1.a < Int32(8)], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(8)], distribution: SomeShard }
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (((t1.a > 1:Int32) AND (t1.a < 8:Int32)) OR (t1.c = 8:Int32)), output: [t1.a, t1.b, t1.c, t1.p] }
    └─BatchHashAgg { group_key: [idx1.t1._row_id], aggs: [] }
      └─BatchUnion { all: true }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: idx1, columns: [idx1.t1._row_id], scan_ranges: [idx1.a > Int32(1) AND idx1.a < Int32(8)], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: idx3, columns: [idx3.t1._row_id], scan_ranges: [idx3.c = Int64(8)], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c, a);
    /* we think primary scan is better than merging three OneSideBound range indexes */
    select * from t1 where a > 1 or c > 1 or b > 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (((t1.a > 1:Int32) OR (t1.c > 1:Int32)) OR (t1.b > 1:Decimal)) }
      └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c, t1.p], distribution: SomeShard }
  batch_local_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (((t1.a > 1:Int32) OR (t1.c > 1:Int32)) OR (t1.b > 1:Decimal)) }
      └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c, t1.p], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a);
    create index idx2 on t1(b, a);
    create index idx3 on t1(c, a);
    /* we think primary scan is better than merging three TwoSideBound range indexes */
    select * from t1 where a between 1 and 8 or b between 1 and 8 or c between 1 and 8;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((((t1.a >= 1:Int32) AND (t1.a <= 8:Int32)) OR ((t1.b >= 1:Decimal) AND (t1.b <= 8:Decimal))) OR ((t1.c >= 1:Int32) AND (t1.c <= 8:Int32))) }
      └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c, t1.p], distribution: SomeShard }
  batch_local_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((((t1.a >= 1:Int32) AND (t1.a <= 8:Int32)) OR ((t1.b >= 1:Decimal) AND (t1.b <= 8:Decimal))) OR ((t1.c >= 1:Int32) AND (t1.c <= 8:Int32))) }
      └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c, t1.p], distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a) include(a);
    create index idx2 on t1(b, a) include(a, b);
    create index idx3 on t1(c) include(c);
    /* we think primary scan is better than merging two OneSideBound range indexes */
    select * from t1 where a > 1 and b > 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (t1.a > 1:Int32) AND (t1.b > 1:Decimal) }
      └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c, t1.p], distribution: SomeShard }
  batch_local_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (t1.a > 1:Int32) AND (t1.b > 1:Decimal) }
      └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c, t1.p], distribution: SomeShard }
- sql: |
    CREATE TABLE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR,
            l_linestatus VARCHAR,
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR,
            l_shipmode VARCHAR,
            l_comment VARCHAR
    );
    create index non_covered_index on lineitem(l_orderkey) include(l_orderkey);
    create index covered_index on lineitem(l_orderkey) include(l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment);
    /* it should choose covered_index */
    select * from lineitem where l_orderkey = 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan
      ├─table: covered_index
      ├─columns:
      │ ┌─covered_index.l_orderkey
      │ ├─covered_index.l_partkey
      │ ├─covered_index.l_suppkey
      │ ├─covered_index.l_linenumber
      │ ├─covered_index.l_quantity
      │ ├─covered_index.l_extendedprice
      │ ├─covered_index.l_discount
      │ ├─covered_index.l_tax
      │ ├─covered_index.l_returnflag
      │ ├─covered_index.l_linestatus
      │ ├─covered_index.l_shipdate
      │ ├─covered_index.l_commitdate
      │ ├─covered_index.l_receiptdate
      │ ├─covered_index.l_shipinstruct
      │ ├─covered_index.l_shipmode
      │ └─covered_index.l_comment
      ├─scan_ranges: [covered_index.l_orderkey = Int64(1)]
      └─distribution: UpstreamHashShard(covered_index.l_orderkey)
  batch_local_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan
      ├─table: covered_index
      ├─columns:
      │ ┌─covered_index.l_orderkey
      │ ├─covered_index.l_partkey
      │ ├─covered_index.l_suppkey
      │ ├─covered_index.l_linenumber
      │ ├─covered_index.l_quantity
      │ ├─covered_index.l_extendedprice
      │ ├─covered_index.l_discount
      │ ├─covered_index.l_tax
      │ ├─covered_index.l_returnflag
      │ ├─covered_index.l_linestatus
      │ ├─covered_index.l_shipdate
      │ ├─covered_index.l_commitdate
      │ ├─covered_index.l_receiptdate
      │ ├─covered_index.l_shipinstruct
      │ ├─covered_index.l_shipmode
      │ └─covered_index.l_comment
      ├─scan_ranges: [covered_index.l_orderkey = Int64(1)]
      └─distribution: UpstreamHashShard(covered_index.l_orderkey)
- sql: |
    create table t1 (a int, b numeric, c bigint, p int);
    create index idx1 on t1(a) include(a);
    /* test large in number */
    select * from t1 where a in (  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c, t1.p] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t1._row_id) }
        └─BatchScan
          ├─table: idx1
          ├─columns: [idx1.t1._row_id]
          ├─scan_ranges:
          │ ┌─idx1.a = Int32(1)
          │ ├─idx1.a = Int32(2)
          │ ├─idx1.a = Int32(3)
          │ ├─idx1.a = Int32(4)
          │ ├─idx1.a = Int32(5)
          │ ├─idx1.a = Int32(6)
          │ ├─idx1.a = Int32(7)
          │ ├─idx1.a = Int32(8)
          │ ├─idx1.a = Int32(9)
          │ ├─idx1.a = Int32(10)
          │ ├─idx1.a = Int32(11)
          │ ├─idx1.a = Int32(12)
          │ ├─idx1.a = Int32(13)
          │ ├─idx1.a = Int32(14)
          │ ├─idx1.a = Int32(15)
          │ ├─idx1.a = Int32(16)
          │ ├─idx1.a = Int32(17)
          │ ├─idx1.a = Int32(18)
          │ ├─idx1.a = Int32(19)
          │ ├─idx1.a = Int32(20)
          │ └─...
          └─distribution: SomeShard
  batch_local_plan: |-
    BatchLookupJoin { type: Inner, predicate: idx1.t1._row_id IS NOT DISTINCT FROM t1._row_id, output: [t1.a, t1.b, t1.c, t1.p] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan
        ├─table: idx1
        ├─columns: [idx1.t1._row_id]
        ├─scan_ranges:
        │ ┌─idx1.a = Int32(1)
        │ ├─idx1.a = Int32(2)
        │ ├─idx1.a = Int32(3)
        │ ├─idx1.a = Int32(4)
        │ ├─idx1.a = Int32(5)
        │ ├─idx1.a = Int32(6)
        │ ├─idx1.a = Int32(7)
        │ ├─idx1.a = Int32(8)
        │ ├─idx1.a = Int32(9)
        │ ├─idx1.a = Int32(10)
        │ ├─idx1.a = Int32(11)
        │ ├─idx1.a = Int32(12)
        │ ├─idx1.a = Int32(13)
        │ ├─idx1.a = Int32(14)
        │ ├─idx1.a = Int32(15)
        │ ├─idx1.a = Int32(16)
        │ ├─idx1.a = Int32(17)
        │ ├─idx1.a = Int32(18)
        │ ├─idx1.a = Int32(19)
        │ ├─idx1.a = Int32(20)
        │ └─...
        └─distribution: SomeShard
- sql: |
    create table t1 (a int, b int, c int, d int);
    create index d on t1(a) include(a);
    select count(*) from t1 where a = 1 and d > 9;
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum0(count)] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count] }
        └─BatchLookupJoin { type: Inner, predicate: d.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (t1.d > 9:Int32), output: [] }
          └─BatchExchange { order: [], dist: UpstreamHashShard(d.t1._row_id) }
            └─BatchScan { table: d, columns: [d.t1._row_id], scan_ranges: [d.a = Int32(1)], distribution: SomeShard }
  batch_local_plan: |-
    BatchSimpleAgg { aggs: [count] }
    └─BatchLookupJoin { type: Inner, predicate: d.t1._row_id IS NOT DISTINCT FROM t1._row_id AND (t1.d > 9:Int32), output: [] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchScan { table: d, columns: [d.t1._row_id], scan_ranges: [d.a = Int32(1)], distribution: SomeShard }
- name: create index to include all columns by default
  sql: |
    create table t1 (a int, b numeric, c bigint);
    create index idx1 on t1(a);
    select * from t1 where a = 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx1, columns: [idx1.a, idx1.b, idx1.c], scan_ranges: [idx1.a = Int32(1)], distribution: UpstreamHashShard(idx1.a) }
- name: topn on index
  sql: |
    create table t1 (a int, b int);
    create index idx1 on t1(a);
    select * from t1 order by a limit 1
  batch_plan: |-
    BatchTopN { order: [idx1.a ASC], limit: 1, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchLimit { limit: 1, offset: 0 }
        └─BatchScan { table: idx1, columns: [idx1.a, idx1.b], distribution: UpstreamHashShard(idx1.a) }
- name: topn on primary key
  sql: |
    create table t1 (a int primary key, b int);
    create index idx1 on t1(a);
    select * from t1 order by a limit 1
  batch_plan: |-
    BatchTopN { order: [t1.a ASC], limit: 1, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchLimit { limit: 1, offset: 0 }
        └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: UpstreamHashShard(t1.a) }
- name: topn on index with descending ordering
  sql: |
    create table t1 (a int, b int);
    create index idx1 on t1(a desc);
    select * from t1 order by a desc limit 1
  batch_plan: |-
    BatchTopN { order: [idx1.a DESC], limit: 1, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchLimit { limit: 1, offset: 0 }
        └─BatchScan { table: idx1, columns: [idx1.a, idx1.b], distribution: UpstreamHashShard(idx1.a) }
- name: topn on pk streaming case, should NOT optimized
  sql: |
    create table t1 (a int primary key);
    select * from t1 order by a limit 1;
  stream_plan: |-
    StreamMaterialize { columns: [a], stream_key: [], pk_columns: [a], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.a] }
      └─StreamTopN { order: [t1.a ASC], limit: 1, offset: 0 }
        └─StreamExchange { dist: Single }
          └─StreamGroupTopN { order: [t1.a ASC], limit: 1, offset: 0, group_key: [1] }
            └─StreamProject { exprs: [t1.a, Vnode(t1.a) as $expr1] }
              └─StreamTableScan { table: t1, columns: [t1.a], pk: [t1.a], dist: UpstreamHashShard(t1.a) }
- sql: |
    create table t1 (a varchar, b int, c int, d int);
    create index idx on t1(a);
    select * from t1 where a like 'ABC%'
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx, columns: [idx.a, idx.b, idx.c, idx.d], scan_ranges: [idx.a >= Utf8("ABC") AND idx.a < Utf8("ABD")], distribution: UpstreamHashShard(idx.a) }
- sql: |
    create table t1 (a varchar, b int, c int, d int);
    create index idx on t1(a);
    select * from t1 where a like 'ABC%E'
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: Like(idx.a, 'ABC%E':Varchar) }
      └─BatchScan { table: idx, columns: [idx.a, idx.b, idx.c, idx.d], scan_ranges: [idx.a >= Utf8("ABC") AND idx.a < Utf8("ABD")], distribution: UpstreamHashShard(idx.a) }
- sql: |
    create table t1 (a varchar, b int, c int, d int);
    create index idx on t1(a);
    select * from t1 where a like 'ABC_E'
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: Like(idx.a, 'ABC_E':Varchar) }
      └─BatchScan { table: idx, columns: [idx.a, idx.b, idx.c, idx.d], scan_ranges: [idx.a >= Utf8("ABC") AND idx.a < Utf8("ABD")], distribution: UpstreamHashShard(idx.a) }
- sql: |
    create table t1 (a varchar, b int, c int, d int);
    create index idx on t1(a);
    select * from t1 where a like 'ABC'
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx, columns: [idx.a, idx.b, idx.c, idx.d], scan_ranges: [idx.a = Utf8("ABC")], distribution: UpstreamHashShard(idx.a) }
- sql: |
    create table test_table(name varchar);
    select * from test_table where name like 'test_table';
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (test_table.name >= 'test':Varchar) AND (test_table.name < 'tesu':Varchar) AND Like(test_table.name, 'test_table':Varchar) }
      └─BatchScan { table: test_table, columns: [test_table.name], distribution: SomeShard }
- sql: |
    create table test_table(name varchar);
    select * from test_table where name like 'test\_table';
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (test_table.name = 'test_table':Varchar) }
      └─BatchScan { table: test_table, columns: [test_table.name], distribution: SomeShard }
- sql: |
    create table test_table(name varchar);
    select * from test_table where name like 'test\_table_2';
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (test_table.name >= 'test_table':Varchar) AND (test_table.name < 'test_tablf':Varchar) AND Like(test_table.name, 'test\_table_2':Varchar) }
      └─BatchScan { table: test_table, columns: [test_table.name], distribution: SomeShard }
- sql: |
    create table t1 (k1 int primary key, v1 int);
    create table t2 (k2 int primary key, v2 int);
    select v1 +1 , v2_p1 from t1, (select v2+2 as v2_p1, k2 from t2) where k1 = k2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [(t1.v1 + 1:Int32) as $expr1, (t2.v2 + 2:Int32) as $expr2] }
      └─BatchLookupJoin { type: Inner, predicate: t1.k1 = t2.k2, output: all }
        └─BatchExchange { order: [], dist: UpstreamHashShard(t1.k1) }
          └─BatchScan { table: t1, columns: [t1.k1, t1.v1], distribution: UpstreamHashShard(t1.k1) }
- sql: |
    create table t1 (c1 varchar,c2 int,c3 timestamp);
    create table t2 (d1 int,d2 varchar);
    create index idx_t1 on t1(c2) include (c1, c2, c3);
    select * from t2 inner join tumble(t1,  c3, interval '10 minute')  on t2.d1 = t1.c2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [t2.d1, t2.d2, idx_t1.c1, idx_t1.c2, idx_t1.c3, TumbleStart(idx_t1.c3, '00:10:00':Interval) as $expr1, (TumbleStart(idx_t1.c3, '00:10:00':Interval) + '00:10:00':Interval) as $expr2] }
      └─BatchLookupJoin { type: Inner, predicate: t2.d1 = idx_t1.c2, output: all }
        └─BatchExchange { order: [], dist: UpstreamHashShard(t2.d1) }
          └─BatchScan { table: t2, columns: [t2.d1, t2.d2], distribution: SomeShard }
- sql: |
    create table t (j jsonb, v1 int, v2 int);
    create index idx1 on t(j->>'k1');
    select * from t where j->>'k1' = 'abc';
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: idx1, columns: [idx1.j, idx1.v1, idx1.v2], scan_ranges: [idx1.JSONB_ACCESS_STR = Utf8("abc")], distribution: SomeShard }
- sql: |
    create table t (j jsonb, v1 int, v2 int);
    create index idx1 on t(j->>'k1') include(v1);
    select * from t where j->>'k1' = 'abc';
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t._row_id IS NOT DISTINCT FROM t._row_id, output: [t.j, t.v1, t.v2] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t._row_id) }
        └─BatchScan { table: idx1, columns: [idx1.t._row_id], scan_ranges: [idx1.JSONB_ACCESS_STR = Utf8("abc")], distribution: SomeShard }
- sql: |
    create table t (j jsonb, v1 int, v2 int);
    create index idx1 on t(j->>'k1') include(v1);
    create index idx2 on t(j->>'k2') include(v2);
    select * from t where j->>'k1' = 'abc' or j->>'k2' = 'ABC';
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: idx1.t._row_id IS NOT DISTINCT FROM t._row_id AND ((JsonbAccessStr(t.j, 'k1':Varchar) = 'abc':Varchar) OR (JsonbAccessStr(t.j, 'k2':Varchar) = 'ABC':Varchar)), output: [t.j, t.v1, t.v2] }
      └─BatchExchange { order: [], dist: UpstreamHashShard(idx1.t._row_id) }
        └─BatchHashAgg { group_key: [idx1.t._row_id], aggs: [] }
          └─BatchExchange { order: [], dist: HashShard(idx1.t._row_id) }
            └─BatchUnion { all: true }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchScan { table: idx1, columns: [idx1.t._row_id], scan_ranges: [idx1.JSONB_ACCESS_STR = Utf8("abc")], distribution: SomeShard }
              └─BatchExchange { order: [], dist: Single }
                └─BatchScan { table: idx2, columns: [idx2.t._row_id], scan_ranges: [idx2.JSONB_ACCESS_STR = Utf8("ABC")], distribution: SomeShard }
- sql: |
    create table people (first_name varchar, last_name varchar, info varchar);
    create index people_names ON people ((first_name || ' ' || last_name));
    select * from people where (first_name || ' ' || last_name) = 'John Smith';
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: people_names, columns: [people_names.first_name, people_names.last_name, people_names.info], scan_ranges: [people_names.CONCAT_OP = Utf8("John Smith")], distribution: SomeShard }
- name: test distributed by columns for functional indexes
  sql: |
    create table people (first_name varchar, last_name varchar, info varchar);
    create index people_names ON people ((first_name || ' ' || last_name), info) distributed by ((first_name || ' ' || last_name));
    select * from people where (first_name || ' ' || last_name) = 'John Smith';
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: people_names, columns: [people_names.first_name, people_names.last_name, people_names.info], scan_ranges: [people_names.CONCAT_OP = Utf8("John Smith")], distribution: SomeShard }
