# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Common sub expression extract1
  sql: |
    create table t (v1 jsonb);
    select v1->'a'->'c' x, v1->'a'->'b' y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [JsonbAccess($expr1, 'c':Varchar) as $expr2, JsonbAccess($expr1, 'b':Varchar) as $expr3] }
      └─BatchProject { exprs: [t.v1, JsonbAccess(t.v1, 'a':Varchar) as $expr1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [JsonbAccess($expr1, 'c':Varchar) as $expr2, JsonbAccess($expr1, 'b':Varchar) as $expr3, t._row_id], noop_update_hint: true }
      └─StreamProject { exprs: [t.v1, JsonbAccess(t.v1, 'a':Varchar) as $expr1, t._row_id], noop_update_hint: true }
        └─StreamTableScan { table: t, columns: [t.v1, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression extract2
  sql: |
    create table t (v1 jsonb);
    select v1->'a'->'c' x, v1->'a'->'c' y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr1, $expr1] }
      └─BatchProject { exprs: [t.v1, JsonbAccess(JsonbAccess(t.v1, 'a':Varchar), 'c':Varchar) as $expr1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, $expr1, t._row_id] }
      └─StreamProject { exprs: [t.v1, JsonbAccess(JsonbAccess(t.v1, 'a':Varchar), 'c':Varchar) as $expr1, t._row_id], noop_update_hint: true }
        └─StreamTableScan { table: t, columns: [t.v1, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression shouldn't extract impure function
  sql: |
    create table t(v1 varchar, v2 double, v3 double);
    select pg_sleep(v2) + 1 as a,  pg_sleep(v2) + 1 as b, v2 + 1 x, v2 + 1 y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [(PgSleep(t.v2) + 1:Int32) as $expr2, (PgSleep(t.v2) + 1:Int32) as $expr3, $expr1, $expr1] }
      └─BatchProject { exprs: [t.v2, (t.v2 + 1:Float64) as $expr1] }
        └─BatchScan { table: t, columns: [t.v2], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a, b, x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr2, $expr3, $expr1, $expr1, t._row_id] }
      └─StreamMaterializedExprs { exprs: [(PgSleep(t.v2) + 1:Int32) as $expr2, (PgSleep(t.v2) + 1:Int32) as $expr3] }
        └─StreamProject { exprs: [t.v2, (t.v2 + 1:Float64) as $expr1, t._row_id] }
          └─StreamTableScan { table: t, columns: [t.v2, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression shouldn't extract const
  sql: |
    SELECT x,
       tand(x),
       tand(x) IN ('-Infinity'::float8,-1,0,1,'Infinity'::float8) AS tand_exact,
       cotd(x),
       cotd(x) IN ('-Infinity'::float8,-1,0,1,'Infinity'::float8) AS cotd_exact
    FROM (VALUES (0), (45), (90), (135), (180),
    (225), (270), (315), (360)) AS t(x)
  batch_plan: |-
    BatchProject { exprs: [*VALUES*_0.column_0, $expr2, In($expr2, -Infinity:Float64, -1:Float64, 0:Float64, 1:Float64, Infinity:Float64) as $expr4, $expr3, In($expr3, -Infinity:Float64, -1:Float64, 0:Float64, 1:Float64, Infinity:Float64) as $expr5] }
    └─BatchProject { exprs: [*VALUES*_0.column_0, Tand($expr1) as $expr2, Cotd($expr1) as $expr3] }
      └─BatchProject { exprs: [*VALUES*_0.column_0, *VALUES*_0.column_0::Float64 as $expr1] }
        └─BatchValues { rows: [[0:Int32], [45:Int32], [90:Int32], [135:Int32], [180:Int32], [225:Int32], [270:Int32], [315:Int32], [360:Int32]] }
- name: Common sub expression shouldn't extract expression having short cut evaluation semantics and we use stddev_samp and var_samp here because they can rewrite into a case then and have some common sub expressions.
  sql: |
    create table t(v int);
    select stddev_pop(v), stddev_samp(v), var_pop(v), var_samp(v) from t;
  batch_plan: |-
    BatchProject { exprs: [Case((sum0(count(t.v)) = 0:Int32), null:Decimal, Sqrt((Greatest((sum(sum($expr1))::Decimal - ((sum(sum(t.v))::Decimal * sum(sum(t.v))::Decimal) / sum0(count(t.v))::Decimal)), 0:Decimal) / sum0(count(t.v))::Decimal))) as $expr2, Case((sum0(count(t.v)) <= 1:Int32), null:Decimal, Sqrt((Greatest((sum(sum($expr1))::Decimal - ((sum(sum(t.v))::Decimal * sum(sum(t.v))::Decimal) / sum0(count(t.v))::Decimal)), 0:Decimal) / (sum0(count(t.v)) - 1:Int32)::Decimal))) as $expr3, Case((sum0(count(t.v)) = 0:Int32), null:Decimal, (Greatest((sum(sum($expr1))::Decimal - ((sum(sum(t.v))::Decimal * sum(sum(t.v))::Decimal) / sum0(count(t.v))::Decimal)), 0:Decimal) / sum0(count(t.v))::Decimal)) as $expr4, Case((sum0(count(t.v)) <= 1:Int32), null:Decimal, (Greatest((sum(sum($expr1))::Decimal - ((sum(sum(t.v))::Decimal * sum(sum(t.v))::Decimal) / sum0(count(t.v))::Decimal)), 0:Decimal) / (sum0(count(t.v)) - 1:Int32)::Decimal)) as $expr5] }
    └─BatchSimpleAgg { aggs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v))] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchSimpleAgg { aggs: [sum($expr1), sum(t.v), count(t.v)] }
          └─BatchProject { exprs: [(t.v * t.v) as $expr1, t.v] }
            └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [stddev_pop, stddev_samp, var_pop, var_samp], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Case((sum0(count(t.v)) = 0:Int32), null:Decimal, Sqrt((Greatest((sum(sum($expr1))::Decimal - ((sum(sum(t.v))::Decimal * sum(sum(t.v))::Decimal) / sum0(count(t.v))::Decimal)), 0:Decimal) / sum0(count(t.v))::Decimal))) as $expr2, Case((sum0(count(t.v)) <= 1:Int32), null:Decimal, Sqrt((Greatest((sum(sum($expr1))::Decimal - ((sum(sum(t.v))::Decimal * sum(sum(t.v))::Decimal) / sum0(count(t.v))::Decimal)), 0:Decimal) / (sum0(count(t.v)) - 1:Int32)::Decimal))) as $expr3, Case((sum0(count(t.v)) = 0:Int32), null:Decimal, (Greatest((sum(sum($expr1))::Decimal - ((sum(sum(t.v))::Decimal * sum(sum(t.v))::Decimal) / sum0(count(t.v))::Decimal)), 0:Decimal) / sum0(count(t.v))::Decimal)) as $expr4, Case((sum0(count(t.v)) <= 1:Int32), null:Decimal, (Greatest((sum(sum($expr1))::Decimal - ((sum(sum(t.v))::Decimal * sum(sum(t.v))::Decimal) / sum0(count(t.v))::Decimal)), 0:Decimal) / (sum0(count(t.v)) - 1:Int32)::Decimal)) as $expr5] }
      └─StreamSimpleAgg { aggs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [sum($expr1), sum(t.v), count(t.v)] }
            └─StreamProject { exprs: [(t.v * t.v) as $expr1, t.v, t._row_id] }
              └─StreamTableScan { table: t, columns: [t.v, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression shouldn't extract partial expression of `some`/`all`. See 11766
  sql: |
    with t(v, arr) as (select 1, array[2, 3]) select v < all(arr), v < some(arr) from t;
  batch_plan: |-
    BatchProject { exprs: [All((1:Int32 < $expr10006)) as $expr1, Some((1:Int32 < $expr10006)) as $expr2] }
    └─BatchValues { rows: [[1:Int32, ARRAY[2, 3]:List(Int32)]] }
