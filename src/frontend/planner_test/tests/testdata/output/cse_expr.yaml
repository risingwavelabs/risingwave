# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Common sub expression extract1
  sql: |
    create table t (v1 jsonb);
    select v1->'a'->'c' x, v1->'a'->'b' y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [JsonbAccess($expr1, 'c':Varchar) as $expr2, JsonbAccess($expr1, 'b':Varchar) as $expr3] }
      └─BatchProject { exprs: [t.v1, JsonbAccess(t.v1, 'a':Varchar) as $expr1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [JsonbAccess($expr1, 'c':Varchar) as $expr2, JsonbAccess($expr1, 'b':Varchar) as $expr3, t._row_id] }
      └─StreamProject { exprs: [t.v1, JsonbAccess(t.v1, 'a':Varchar) as $expr1, t._row_id] }
        └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression extract2
  sql: |
    create table t (v1 jsonb);
    select v1->'a'->'c' x, v1->'a'->'c' y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr1, $expr1] }
      └─BatchProject { exprs: [t.v1, JsonbAccess(JsonbAccess(t.v1, 'a':Varchar), 'c':Varchar) as $expr1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, $expr1, t._row_id] }
      └─StreamProject { exprs: [t.v1, JsonbAccess(JsonbAccess(t.v1, 'a':Varchar), 'c':Varchar) as $expr1, t._row_id] }
        └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression shouldn't extract impure function
  sql: |
    create table t(v1 varchar, v2 int, v3 int);
    select rw_vnode(v2) + 1 as vnode,  rw_vnode(v2) + 1 as vnode2, v2 + 1 x, v2 + 1 y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [(Vnode(t.v2) + 1:Int32) as $expr2, (Vnode(t.v2) + 1:Int32) as $expr3, $expr1, $expr1] }
      └─BatchProject { exprs: [t.v2, (t.v2 + 1:Int32) as $expr1] }
        └─BatchScan { table: t, columns: [t.v2], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [vnode, vnode2, x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [(Vnode(t.v2) + 1:Int32) as $expr2, (Vnode(t.v2) + 1:Int32) as $expr3, $expr1, $expr1, t._row_id] }
      └─StreamProject { exprs: [t.v2, (t.v2 + 1:Int32) as $expr1, t._row_id] }
        └─StreamTableScan { table: t, columns: [t.v2, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression shouldn't extract const
  sql: |
    SELECT x,
       tand(x),
       tand(x) IN ('-Infinity'::float8,-1,0,1,'Infinity'::float8) AS tand_exact,
       cotd(x),
       cotd(x) IN ('-Infinity'::float8,-1,0,1,'Infinity'::float8) AS cotd_exact
    FROM (VALUES (0), (45), (90), (135), (180),
    (225), (270), (315), (360)) AS t(x)
  batch_plan: |-
    BatchProject { exprs: [*VALUES*_0.column_0, $expr2, In($expr2, -Infinity:Float64, -1:Float64, 0:Float64, 1:Float64, Infinity:Float64) as $expr4, $expr3, In($expr3, -Infinity:Float64, -1:Float64, 0:Float64, 1:Float64, Infinity:Float64) as $expr5] }
    └─BatchProject { exprs: [*VALUES*_0.column_0, Tand($expr1) as $expr2, Cotd($expr1) as $expr3] }
      └─BatchProject { exprs: [*VALUES*_0.column_0, *VALUES*_0.column_0::Float64 as $expr1] }
        └─BatchValues { rows: [[0:Int32], [45:Int32], [90:Int32], [135:Int32], [180:Int32], [225:Int32], [270:Int32], [315:Int32], [360:Int32]] }
- name: Common sub expression shouldn't extract expression having short cut evaluation semantics and we use stddev_samp and var_samp here because they can rewrite into a case then and have some common sub expressions.
  sql: |
    create table t(v int);
    select stddev_pop(v), stddev_samp(v), var_pop(v), var_samp(v) from t;
  batch_plan: |-
    BatchProject { exprs: [Sqrt($expr5) as $expr6, Case((sum0(count(t.v)) <= 1:Int64), null:Decimal, Sqrt(($expr4 / (sum0(count(t.v)) - 1:Int64)::Decimal))) as $expr7, $expr5, Case((sum0(count(t.v)) <= 1:Int64), null:Decimal, ($expr4 / (sum0(count(t.v)) - 1:Int64)::Decimal)) as $expr8] }
    └─BatchProject { exprs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v)), ($expr4 / $expr3) as $expr5, $expr4] }
      └─BatchProject { exprs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v)), (sum(sum($expr1))::Decimal - (($expr2 * $expr2) / $expr3)) as $expr4, $expr3] }
        └─BatchProject { exprs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v)), sum(sum(t.v))::Decimal as $expr2, sum0(count(t.v))::Decimal as $expr3] }
          └─BatchSimpleAgg { aggs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v))] }
            └─BatchExchange { order: [], dist: Single }
              └─BatchSimpleAgg { aggs: [sum($expr1), sum(t.v), count(t.v)] }
                └─BatchProject { exprs: [t.v, (t.v * t.v) as $expr1] }
                  └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [stddev_pop, stddev_samp, var_pop, var_samp], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Sqrt($expr5) as $expr6, Case((sum0(count(t.v)) <= 1:Int64), null:Decimal, Sqrt(($expr4 / (sum0(count(t.v)) - 1:Int64)::Decimal))) as $expr7, $expr5, Case((sum0(count(t.v)) <= 1:Int64), null:Decimal, ($expr4 / (sum0(count(t.v)) - 1:Int64)::Decimal)) as $expr8] }
      └─StreamProject { exprs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v)), ($expr4 / $expr3) as $expr5, $expr4] }
        └─StreamProject { exprs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v)), (sum(sum($expr1))::Decimal - (($expr2 * $expr2) / $expr3)) as $expr4, $expr3] }
          └─StreamProject { exprs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v)), sum(sum(t.v))::Decimal as $expr2, sum0(count(t.v))::Decimal as $expr3] }
            └─StreamSimpleAgg { aggs: [sum(sum($expr1)), sum(sum(t.v)), sum0(count(t.v)), count] }
              └─StreamExchange { dist: Single }
                └─StreamStatelessSimpleAgg { aggs: [sum($expr1), sum(t.v), count(t.v)] }
                  └─StreamProject { exprs: [t.v, (t.v * t.v) as $expr1, t._row_id] }
                    └─StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression shouldn't extract partial expression of `some`/`all`. See 11766
  sql: |
    with t(v, arr) as (select 1, array[2, 3]) select v < all(arr), v < some(arr) from t;
  batch_plan: |-
    BatchProject { exprs: [All((1:Int32 < $expr10063)) as $expr1, Some((1:Int32 < $expr10063)) as $expr2] }
    └─BatchValues { rows: [[1:Int32, ARRAY[2, 3]:List(Int32)]] }
