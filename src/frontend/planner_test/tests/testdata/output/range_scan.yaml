# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_table_and_mv
  sql: |
    CREATE TABLE orders (
            order_id BIGINT,
            user_id BIGINT,
            date INTEGER);
    CREATE MATERIALIZED VIEW orders_count_by_user AS
      SELECT user_id, date, count(*) AS orders_count FROM orders GROUP BY user_id, date;
    CREATE MATERIALIZED VIEW orders_count_by_user_desc AS
      SELECT user_id, date, count(*) AS orders_count FROM orders GROUP BY user_id, date ORDER BY user_id DESC;
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id < 43
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id < Int64(43)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42 + 1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(43)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 1/0
  batch_error: |
    Expr error

    Caused by these errors (recent errors listed first):
      1: error while evaluating expression `general_div('1', '0')`
      2: Division by zero
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 2147483647 + 1
  batch_error: |
    Expr error

    Caused by these errors (recent errors listed first):
      1: error while evaluating expression `general_add('2147483647', '1')`
      2: Numeric out of range
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 'a'
  batch_error: |
    Expr error

    Caused by these errors (recent errors listed first):
      1: error while evaluating expression `str_parse('a')`
      2: Parse error: bigint invalid digit found in string
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id > 'a'
  batch_error: |
    Expr error

    Caused by these errors (recent errors listed first):
      1: error while evaluating expression `str_parse('a')`
      2: Parse error: bigint invalid digit found in string
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = '42'
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = NULL
  batch_plan: 'BatchValues { rows: [] }'
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id IS NULL
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id IS NULL], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id > NULL
  batch_plan: 'BatchValues { rows: [] }'
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42 AND date = 1111
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42) AND orders_count_by_user.date = Int32(1111)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id > 42 AND date = 1111 AND 2>1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (orders_count_by_user.date = 1111:Int32) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id > Int64(42)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE date > 1111 AND user_id = 42 AND 5<6 AND date <= 6666
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42) AND orders_count_by_user.date > Int32(1111) AND orders_count_by_user.date <= Int32(6666)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id in (42, 43)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42), orders_count_by_user.user_id = Int64(43)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id in (42+1, 44-1)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(43)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- name: If the IN list has a larger type than the column, the InputRef is casted. Currently this case is not converted to scan range yet.
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id in (42.0, 43.0)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: In(orders_count_by_user.user_id::Decimal, 42.0:Decimal, 43.0:Decimal) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id in ('42', '43')
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42), orders_count_by_user.user_id = Int64(43)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id in ('42', '43.0')
  batch_error: |
    Expr error

    Caused by these errors (recent errors listed first):
      1: error while evaluating expression `str_parse('43.0')`
      2: Parse error: bigint invalid digit found in string
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id in (2147483648, 2147483649) AND date = 6666
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (orders_count_by_user.date = 6666:Int32) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(2147483648), orders_count_by_user.user_id = Int64(2147483649)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42 AND date in (2222, 3333)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42) AND orders_count_by_user.date = Int32(2222), orders_count_by_user.user_id = Int64(42) AND orders_count_by_user.date = Int32(3333)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- name: test duplicate value in in-list
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42 AND date in (2222, 2222)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42) AND orders_count_by_user.date = Int32(2222)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- name: test NULL in in-list
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42 AND date in (2222, NULL)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42) AND orders_count_by_user.date = Int32(2222)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- name: test NULL in in-list
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42 AND date in (NULL)
  batch_plan: 'BatchValues { rows: [] }'
- name: test multiple in-list
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42 AND date in (2222, 3333) AND date in (4444, 3333)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42) AND orders_count_by_user.date = Int32(3333)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- name: test eq & in-list
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42 AND date in (2222, 3333) AND date = 3333
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(42) AND orders_count_by_user.date = Int32(3333)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- name: test eq & in-list
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 42 AND date in (2222, 3333) AND date = 4444
  batch_plan: 'BatchValues { rows: [] }'
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id in (2147483648, 2147483649) AND date in (2222, 3333)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: In(orders_count_by_user.date, 2222:Int32, 3333:Int32) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(2147483648), orders_count_by_user.user_id = Int64(2147483649)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- id: create_table_and_mv_ordered
  sql: |
    CREATE TABLE orders (
            order_id BIGINT,
            user_id INTEGER,
            date INTEGER);
    CREATE MATERIALIZED VIEW orders_count_by_user_ordered AS
      SELECT user_id, date, count(*) AS orders_count FROM orders
      GROUP BY user_id, date
      ORDER BY orders_count;
- before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE user_id = 42
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (orders_count_by_user_ordered.user_id = 42:Int32) }
      └─BatchScan { table: orders_count_by_user_ordered, columns: [orders_count_by_user_ordered.user_id, orders_count_by_user_ordered.date, orders_count_by_user_ordered.orders_count], distribution: UpstreamHashShard(orders_count_by_user_ordered.orders_count) }
- before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE user_id > 42 AND orders_count = 10
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user_ordered, columns: [orders_count_by_user_ordered.user_id, orders_count_by_user_ordered.date, orders_count_by_user_ordered.orders_count], scan_ranges: [orders_count_by_user_ordered.orders_count = Int64(10) AND orders_count_by_user_ordered.user_id > Int32(42)], distribution: UpstreamHashShard(orders_count_by_user_ordered.orders_count) }
- before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count = 10
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user_ordered, columns: [orders_count_by_user_ordered.user_id, orders_count_by_user_ordered.date, orders_count_by_user_ordered.orders_count], scan_ranges: [orders_count_by_user_ordered.orders_count = Int64(10)], distribution: UpstreamHashShard(orders_count_by_user_ordered.orders_count) }
- name: merge mutiple upper bound
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count < 10 and orders_count < 30
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user_ordered, columns: [orders_count_by_user_ordered.user_id, orders_count_by_user_ordered.date, orders_count_by_user_ordered.orders_count], scan_ranges: [orders_count_by_user_ordered.orders_count < Int64(10)], distribution: UpstreamHashShard(orders_count_by_user_ordered.orders_count) }
- name: merge include and exclude upper bound of same value
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count < 10 and orders_count <= 10
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user_ordered, columns: [orders_count_by_user_ordered.user_id, orders_count_by_user_ordered.date, orders_count_by_user_ordered.orders_count], scan_ranges: [orders_count_by_user_ordered.orders_count < Int64(10)], distribution: UpstreamHashShard(orders_count_by_user_ordered.orders_count) }
- name: merge mutiple lower bound
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count > 10 and orders_count > 30
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user_ordered, columns: [orders_count_by_user_ordered.user_id, orders_count_by_user_ordered.date, orders_count_by_user_ordered.orders_count], scan_ranges: [orders_count_by_user_ordered.orders_count > Int64(30)], distribution: UpstreamHashShard(orders_count_by_user_ordered.orders_count) }
- name: merge include and exclude lower bound of same value
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count > 10 and orders_count >= 10
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user_ordered, columns: [orders_count_by_user_ordered.user_id, orders_count_by_user_ordered.date, orders_count_by_user_ordered.orders_count], scan_ranges: [orders_count_by_user_ordered.orders_count > Int64(10)], distribution: UpstreamHashShard(orders_count_by_user_ordered.orders_count) }
- name: invalid range
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count > 10 and orders_count < 5
  batch_plan: 'BatchValues { rows: [] }'
- name: merge cmp and eq condition
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count > 20 and orders_count < 30 and orders_count = 25
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user_ordered, columns: [orders_count_by_user_ordered.user_id, orders_count_by_user_ordered.date, orders_count_by_user_ordered.orders_count], scan_ranges: [orders_count_by_user_ordered.orders_count = Int64(25)], distribution: UpstreamHashShard(orders_count_by_user_ordered.orders_count) }
- name: invalid range of merging cmp and eq condition
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count > 20 and orders_count < 30 and orders_count = 35
  batch_plan: 'BatchValues { rows: [] }'
- name: merge cmp and const-in condition
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count in (10,20,30,40) and orders_count <30
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user_ordered, columns: [orders_count_by_user_ordered.user_id, orders_count_by_user_ordered.date, orders_count_by_user_ordered.orders_count], scan_ranges: [orders_count_by_user_ordered.orders_count = Int64(10), orders_count_by_user_ordered.orders_count = Int64(20)], distribution: UpstreamHashShard(orders_count_by_user_ordered.orders_count) }
- name: invalid range of merging cmp and const-in condition
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count in (10,20,30,40) and orders_count > 50
  batch_plan: 'BatchValues { rows: [] }'
- name: merge null and cmp condition
  before:
  - create_table_and_mv_ordered
  sql: |
    SELECT * FROM orders_count_by_user_ordered WHERE orders_count is null and orders_count < 30
  batch_plan: 'BatchValues { rows: [] }'
- id: create_small
  sql: |
    CREATE TABLE t(x smallint);
    CREATE MATERIALIZED VIEW mv AS
      SELECT x from t group by x;
- name: When the constant with larger type is out of the range of the column's type, we can convert it as false condition.
  before:
  - create_small
  sql: |
    SELECT * FROM mv WHERE x = 60000;
  batch_plan: 'BatchValues { rows: [] }'
- name: When the constant with larger type is out of the upper bound of the column's type, we can convert < as true condition.
  before:
  - create_small
  sql: |
    SELECT * FROM mv WHERE x < 60000;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (mv.x < 60000:Int32) }
      └─BatchScan { table: mv, columns: [mv.x], distribution: UpstreamHashShard(mv.x) }
- name: When the constant with larger type is out of the upper bound of the column's type, we can convert > as false condition.
  before:
  - create_small
  sql: |
    SELECT * FROM mv WHERE x > 60000;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (mv.x > 60000:Int32) }
      └─BatchScan { table: mv, columns: [mv.x], distribution: UpstreamHashShard(mv.x) }
- name: When the constant with larger type is out of the lower bound of the column's type, we can convert < as false condition.
  before:
  - create_small
  sql: |
    SELECT * FROM mv WHERE x < -60000;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (mv.x < -60000:Int32) }
      └─BatchScan { table: mv, columns: [mv.x], distribution: UpstreamHashShard(mv.x) }
- name: When the constant with larger type is out of the lower bound of the column's type, we can convert > as true condition.
  before:
  - create_small
  sql: |
    SELECT * FROM mv WHERE x > -60000;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (mv.x > -60000:Int32) }
      └─BatchScan { table: mv, columns: [mv.x], distribution: UpstreamHashShard(mv.x) }
- name: When the constant with larger type is in range of the column's type, we can convert it.
  before:
  - create_small
  sql: |
    SELECT * FROM mv WHERE x < 3::bigint and x > 1::bigint;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: mv, columns: [mv.x], scan_ranges: [mv.x > Int16(1) AND mv.x < Int16(3)], distribution: UpstreamHashShard(mv.x) }
- name: Can't push down the in-compatitble numeric type
  before:
  - create_small
  sql: |
    SELECT * FROM mv WHERE x = 3.4;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (mv.x::Decimal = 3.4:Decimal) }
      └─BatchScan { table: mv, columns: [mv.x], distribution: UpstreamHashShard(mv.x) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 1 or user_id = 2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(1), orders_count_by_user.user_id = Int64(2)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id = 1) or (user_id = 2 and date = 2222);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(1), orders_count_by_user.user_id = Int64(2) AND orders_count_by_user.date = Int32(2222)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id = 1) or (user_id = 2 and date in (1111, 2222));
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(1), orders_count_by_user.user_id = Int64(2) AND orders_count_by_user.date = Int32(1111), orders_count_by_user.user_id = Int64(2) AND orders_count_by_user.date = Int32(2222)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- name: When one arm of or clause contains other conditions, we can't convert it to scan range yet.
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id = 1) or (user_id = 2 and date in (1111, 2222)) or (user_id != 3);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (((orders_count_by_user.user_id = 1:Int32) OR ((orders_count_by_user.user_id = 2:Int32) AND In(orders_count_by_user.date, 1111:Int32, 2222:Int32))) OR (orders_count_by_user.user_id <> 3:Int32)) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- name: When any arm of or clause is not equal type, we can't convert it to scan range yet.
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id > 1 or user_id < 10
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((orders_count_by_user.user_id > 1:Int32) OR (orders_count_by_user.user_id < 10:Int32)) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 1 or user_id is null
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(1), orders_count_by_user.user_id IS NULL], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 1 and user_id is null
  batch_plan: 'BatchValues { rows: [] }'
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 1 or (user_id is null and date = 1111)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(1), orders_count_by_user.user_id IS NULL AND orders_count_by_user.date = Int32(1111)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 1 or (user_id = 2 and date is null)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(1), orders_count_by_user.user_id = Int64(2) AND orders_count_by_user.date IS NULL], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id = 1 or (user_id is null and date is null)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id = Int64(1), orders_count_by_user.user_id IS NULL AND orders_count_by_user.date IS NULL], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE user_id is null or (user_id is null and date is null)
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id IS NULL], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- sql: |
    create table sbtest1(id INT, k INT, c VARCHAR, pad VARCHAR);
    create index k1 on sbtest1(k);
    select count(k) from sbtest1 where k between 0 and 5;
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum0(count(k1.k))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count(k1.k)] }
        └─BatchScan { table: k1, columns: [k1.k], scan_ranges: [k1.k = Int32(0), k1.k = Int32(1), k1.k = Int32(2), k1.k = Int32(3), k1.k = Int32(4), k1.k = Int32(5)], distribution: UpstreamHashShard(k1.k) }
- sql: |
    create table sbtest1(id INT, k INT, c VARCHAR, pad VARCHAR);
    create index k1 on sbtest1(k);
    select count(k) from sbtest1 where k between 0 and 500;
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum0(count(k1.k))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count(k1.k)] }
        └─BatchScan { table: k1, columns: [k1.k], scan_ranges: [k1.k >= Int32(0) AND k1.k <= Int32(500)], distribution: UpstreamHashShard(k1.k) }
- sql: |
    create table sbtest1(id INT, k INT, c VARCHAR, pad VARCHAR, primary key(id));
    create index k1 on sbtest1(k);
    select count(k) from sbtest1 where id between 0 and 5;
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum0(count(sbtest1.k))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count(sbtest1.k)] }
        └─BatchScan { table: sbtest1, columns: [sbtest1.k], scan_ranges: [sbtest1.id = Int32(0), sbtest1.id = Int32(1), sbtest1.id = Int32(2), sbtest1.id = Int32(3), sbtest1.id = Int32(4), sbtest1.id = Int32(5)], distribution: SomeShard }
- sql: |
    create table t (k int primary key, v int);
    select v from t where k = 2147483648; -- out of range of int32
  logical_plan: |-
    LogicalProject { exprs: [t.v] }
    └─LogicalFilter { predicate: (t.k = 2147483648:Int64) }
      └─LogicalScan { table: t, columns: [t.k, t.v, t._rw_timestamp] }
  batch_plan: 'BatchValues { rows: [] }'
- name: When OR clauses contain non-overlapping conditions,, we can pushdown serveral scan_range.
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id < 10) or (user_id > 20);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((orders_count_by_user.user_id < 10:Int32) OR (orders_count_by_user.user_id > 20:Int32)) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id < Int64(10), orders_count_by_user.user_id > Int64(20)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user_desc WHERE (user_id < 10) or (user_id > 20);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((orders_count_by_user_desc.user_id < 10:Int32) OR (orders_count_by_user_desc.user_id > 20:Int32)) }
      └─BatchScan { table: orders_count_by_user_desc, columns: [orders_count_by_user_desc.user_id, orders_count_by_user_desc.date, orders_count_by_user_desc.orders_count], scan_ranges: [orders_count_by_user_desc.user_id < Int64(10), orders_count_by_user_desc.user_id > Int64(20)], distribution: UpstreamHashShard(orders_count_by_user_desc.user_id) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id < 10) or (user_id >= 10);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((orders_count_by_user.user_id < 10:Int32) OR (orders_count_by_user.user_id >= 10:Int32)) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id < Int64(10), orders_count_by_user.user_id >= Int64(10)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user_desc WHERE (user_id < 10) or (user_id >= 10);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((orders_count_by_user_desc.user_id < 10:Int32) OR (orders_count_by_user_desc.user_id >= 10:Int32)) }
      └─BatchScan { table: orders_count_by_user_desc, columns: [orders_count_by_user_desc.user_id, orders_count_by_user_desc.date, orders_count_by_user_desc.orders_count], scan_ranges: [orders_count_by_user_desc.user_id < Int64(10), orders_count_by_user_desc.user_id >= Int64(10)], distribution: UpstreamHashShard(orders_count_by_user_desc.user_id) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id < 10) or (user_id > 20) or (user_id = 15);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (((orders_count_by_user.user_id < 10:Int32) OR (orders_count_by_user.user_id > 20:Int32)) OR (orders_count_by_user.user_id = 15:Int32)) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id < Int64(10), orders_count_by_user.user_id = Int64(15), orders_count_by_user.user_id > Int64(20)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user_desc WHERE (user_id < 10) or (user_id > 20) or (user_id = 15);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (((orders_count_by_user_desc.user_id < 10:Int32) OR (orders_count_by_user_desc.user_id > 20:Int32)) OR (orders_count_by_user_desc.user_id = 15:Int32)) }
      └─BatchScan { table: orders_count_by_user_desc, columns: [orders_count_by_user_desc.user_id, orders_count_by_user_desc.date, orders_count_by_user_desc.orders_count], scan_ranges: [orders_count_by_user_desc.user_id < Int64(10), orders_count_by_user_desc.user_id = Int64(15), orders_count_by_user_desc.user_id > Int64(20)], distribution: UpstreamHashShard(orders_count_by_user_desc.user_id) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id < 10 and user_id > 1) or (user_id > 20 and user_id < 30) or (user_id >= 30 and user_id < 40);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((((orders_count_by_user.user_id < 10:Int32) AND (orders_count_by_user.user_id > 1:Int32)) OR ((orders_count_by_user.user_id > 20:Int32) AND (orders_count_by_user.user_id < 30:Int32))) OR ((orders_count_by_user.user_id >= 30:Int32) AND (orders_count_by_user.user_id < 40:Int32))) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id > Int64(1) AND orders_count_by_user.user_id < Int64(10), orders_count_by_user.user_id > Int64(20) AND orders_count_by_user.user_id < Int64(30), orders_count_by_user.user_id >= Int64(30) AND orders_count_by_user.user_id < Int64(40)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user_desc WHERE (user_id < 10 and user_id > 1) or (user_id > 20 and user_id < 30) or (user_id >= 30 and user_id < 40);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((((orders_count_by_user_desc.user_id < 10:Int32) AND (orders_count_by_user_desc.user_id > 1:Int32)) OR ((orders_count_by_user_desc.user_id > 20:Int32) AND (orders_count_by_user_desc.user_id < 30:Int32))) OR ((orders_count_by_user_desc.user_id >= 30:Int32) AND (orders_count_by_user_desc.user_id < 40:Int32))) }
      └─BatchScan { table: orders_count_by_user_desc, columns: [orders_count_by_user_desc.user_id, orders_count_by_user_desc.date, orders_count_by_user_desc.orders_count], scan_ranges: [orders_count_by_user_desc.user_id > Int64(1) AND orders_count_by_user_desc.user_id < Int64(10), orders_count_by_user_desc.user_id > Int64(20) AND orders_count_by_user_desc.user_id < Int64(30), orders_count_by_user_desc.user_id >= Int64(30) AND orders_count_by_user_desc.user_id < Int64(40)], distribution: UpstreamHashShard(orders_count_by_user_desc.user_id) }
- name: When OR clauses contain overlapping conditions, we can merge serveral scan_range and pushdown.
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id < 10 and user_id > 1) or (user_id > 20 and user_id <= 30) or (user_id >= 30 and user_id < 40) or (user_id = 15);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((((orders_count_by_user.user_id < 10:Int32) AND (orders_count_by_user.user_id > 1:Int32)) OR ((orders_count_by_user.user_id > 20:Int32) AND (orders_count_by_user.user_id <= 30:Int32))) OR (((orders_count_by_user.user_id >= 30:Int32) AND (orders_count_by_user.user_id < 40:Int32)) OR (orders_count_by_user.user_id = 15:Int32))) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id > Int64(1) AND orders_count_by_user.user_id < Int64(10), orders_count_by_user.user_id = Int64(15), orders_count_by_user.user_id >= Int64(20) AND orders_count_by_user.user_id <= Int64(40)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user_desc WHERE (user_id < 10 and user_id > 1) or (user_id > 20 and user_id <= 30) or (user_id >= 30 and user_id < 40) or (user_id = 15);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((((orders_count_by_user_desc.user_id < 10:Int32) AND (orders_count_by_user_desc.user_id > 1:Int32)) OR ((orders_count_by_user_desc.user_id > 20:Int32) AND (orders_count_by_user_desc.user_id <= 30:Int32))) OR (((orders_count_by_user_desc.user_id >= 30:Int32) AND (orders_count_by_user_desc.user_id < 40:Int32)) OR (orders_count_by_user_desc.user_id = 15:Int32))) }
      └─BatchScan { table: orders_count_by_user_desc, columns: [orders_count_by_user_desc.user_id, orders_count_by_user_desc.date, orders_count_by_user_desc.orders_count], scan_ranges: [orders_count_by_user_desc.user_id > Int64(1) AND orders_count_by_user_desc.user_id < Int64(10), orders_count_by_user_desc.user_id = Int64(15), orders_count_by_user_desc.user_id >= Int64(20) AND orders_count_by_user_desc.user_id <= Int64(40)], distribution: UpstreamHashShard(orders_count_by_user_desc.user_id) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id < 10) or (user_id > 30) or (user_id > 5 and user_id < 15);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (((orders_count_by_user.user_id < 10:Int32) OR (orders_count_by_user.user_id > 30:Int32)) OR ((orders_count_by_user.user_id > 5:Int32) AND (orders_count_by_user.user_id < 15:Int32))) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], scan_ranges: [orders_count_by_user.user_id <= Int64(15), orders_count_by_user.user_id > Int64(30)], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user_desc WHERE (user_id < 10) or (user_id > 30) or (user_id > 5 and user_id < 15);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: (((orders_count_by_user_desc.user_id < 10:Int32) OR (orders_count_by_user_desc.user_id > 30:Int32)) OR ((orders_count_by_user_desc.user_id > 5:Int32) AND (orders_count_by_user_desc.user_id < 15:Int32))) }
      └─BatchScan { table: orders_count_by_user_desc, columns: [orders_count_by_user_desc.user_id, orders_count_by_user_desc.date, orders_count_by_user_desc.orders_count], scan_ranges: [orders_count_by_user_desc.user_id <= Int64(15), orders_count_by_user_desc.user_id > Int64(30)], distribution: UpstreamHashShard(orders_count_by_user_desc.user_id) }
- name: When OR clauses contain overlapping conditions, we cannot push down if it results in a full table scan.
  before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id < 20) or (user_id > 10);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((orders_count_by_user.user_id < 20:Int32) OR (orders_count_by_user.user_id > 10:Int32)) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user_desc WHERE (user_id < 20) or (user_id > 10);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((orders_count_by_user_desc.user_id < 20:Int32) OR (orders_count_by_user_desc.user_id > 10:Int32)) }
      └─BatchScan { table: orders_count_by_user_desc, columns: [orders_count_by_user_desc.user_id, orders_count_by_user_desc.date, orders_count_by_user_desc.orders_count], distribution: UpstreamHashShard(orders_count_by_user_desc.user_id) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user WHERE (user_id < 20) or (user_id != 10);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((orders_count_by_user.user_id < 20:Int32) OR (orders_count_by_user.user_id <> 10:Int32)) }
      └─BatchScan { table: orders_count_by_user, columns: [orders_count_by_user.user_id, orders_count_by_user.date, orders_count_by_user.orders_count], distribution: UpstreamHashShard(orders_count_by_user.user_id, orders_count_by_user.date) }
- before:
  - create_table_and_mv
  sql: |
    SELECT * FROM orders_count_by_user_desc WHERE (user_id < 20) or (user_id != 10);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchFilter { predicate: ((orders_count_by_user_desc.user_id < 20:Int32) OR (orders_count_by_user_desc.user_id <> 10:Int32)) }
      └─BatchScan { table: orders_count_by_user_desc, columns: [orders_count_by_user_desc.user_id, orders_count_by_user_desc.date, orders_count_by_user_desc.orders_count], distribution: UpstreamHashShard(orders_count_by_user_desc.user_id) }
