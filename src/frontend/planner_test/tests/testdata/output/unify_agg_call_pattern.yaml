# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: unify agg call pattern
  sql: |
    create table t(a int, b int, c int, d int);
    select max(a) max_a, max(b) max_b from t;
  batch_plan: |-
    BatchProject { exprs: [Field(max(max($expr1)), 0:Int32) as $expr2, Field(max(max($expr1)), 1:Int32) as $expr3] }
    └─BatchSimpleAgg { aggs: [max(max($expr1))] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchSimpleAgg { aggs: [max($expr1)] }
          └─BatchProject { exprs: [Row(t.a, t.b) as $expr1] }
            └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [max_a, max_b], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(max(max($expr1)), 0:Int32) as $expr3, Field(max(max($expr1)), 1:Int32) as $expr4] }
      └─StreamSimpleAgg { aggs: [max(max($expr1)), count] }
        └─StreamExchange { dist: Single }
          └─StreamHashAgg { group_key: [$expr2], aggs: [max($expr1), count] }
            └─StreamProject { exprs: [Row(t.a, t.b) as $expr1, t._row_id, Vnode(t._row_id) as $expr2] }
              └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: unify agg call pattern
  sql: |
    create table t(a int, b int, c int, d int);
    select max(a) max_a, max(b) max_b from t group by c;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Field(max($expr1), 0:Int32) as $expr2, Field(max($expr1), 1:Int32) as $expr3] }
      └─BatchHashAgg { group_key: [t.c], aggs: [max($expr1)] }
        └─BatchExchange { order: [], dist: HashShard(t.c) }
          └─BatchProject { exprs: [t.c, Row(t.a, t.b) as $expr1] }
            └─BatchScan { table: t, columns: [t.a, t.b, t.c], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [max_a, max_b, t.c(hidden)], stream_key: [t.c], pk_columns: [t.c], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(max($expr1), 0:Int32) as $expr2, Field(max($expr1), 1:Int32) as $expr3, t.c] }
      └─StreamHashAgg { group_key: [t.c], aggs: [max($expr1), count] }
        └─StreamExchange { dist: HashShard(t.c) }
          └─StreamProject { exprs: [t.c, Row(t.a, t.b) as $expr1, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.a, t.b, t.c, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: unify agg call pattern with distinct
  sql: |
    create table t(a int, b int, c int, d int);
    select max(distinct a) max_a, max(distinct b) max_b from t group by c;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Field(max($expr1), 0:Int32) as $expr2, Field(max($expr1), 1:Int32) as $expr3] }
      └─BatchHashAgg { group_key: [t.c], aggs: [max($expr1)] }
        └─BatchExchange { order: [], dist: HashShard(t.c) }
          └─BatchProject { exprs: [t.c, Row(t.a, t.b) as $expr1] }
            └─BatchScan { table: t, columns: [t.a, t.b, t.c], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [max_a, max_b, t.c(hidden)], stream_key: [t.c], pk_columns: [t.c], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(max($expr1), 0:Int32) as $expr2, Field(max($expr1), 1:Int32) as $expr3, t.c] }
      └─StreamHashAgg { group_key: [t.c], aggs: [max($expr1), count] }
        └─StreamExchange { dist: HashShard(t.c) }
          └─StreamProject { exprs: [t.c, Row(t.a, t.b) as $expr1, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.a, t.b, t.c, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: should not unify agg call pattern with first_value/last_value since their order by clauses are different
  sql: |
    create table t(a int, b int, c int, d int);
    select first_value(b order by b) first_a, first_value(a order by a) first_b from t group by c;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [first_value(t.b order_by(t.b ASC)), first_value(t.a order_by(t.a ASC))] }
      └─BatchHashAgg { group_key: [t.c], aggs: [first_value(t.b order_by(t.b ASC)), first_value(t.a order_by(t.a ASC))] }
        └─BatchExchange { order: [], dist: HashShard(t.c) }
          └─BatchScan { table: t, columns: [t.a, t.b, t.c], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [first_a, first_b, t.c(hidden)], stream_key: [t.c], pk_columns: [t.c], pk_conflict: NoCheck }
    └─StreamProject { exprs: [first_value(t.b order_by(t.b ASC)), first_value(t.a order_by(t.a ASC)), t.c] }
      └─StreamHashAgg { group_key: [t.c], aggs: [first_value(t.b order_by(t.b ASC)), first_value(t.a order_by(t.a ASC)), count] }
        └─StreamExchange { dist: HashShard(t.c) }
          └─StreamTableScan { table: t, columns: [t.a, t.b, t.c, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: unify agg call pattern with min, max, first_value, last_value, and mixed with count
  sql: |
    create table t(a int, b int, c int, d int, e int, f int);
    select
    min(a) min_a, max(a) max_a, first_value(a order by d) first_a, last_value(a order by d desc) last_a,
    min(b) min_b, max(b) max_b, first_value(b order by d) first_b, last_value(b order by d desc) last_b,
    min(c) min_c, max(c) max_c, first_value(c order by d) first_c, last_value(c order by d desc) last_c,
    count(a) count_a, count(b) count_b, count(c) count_c
    from t group by e, f;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Field(min($expr1), 0:Int32) as $expr2, Field(max($expr1), 0:Int32) as $expr3, Field(first_value($expr1 order_by($expr1 ASC)), 0:Int32) as $expr4, Field(last_value($expr1 order_by($expr1 DESC)), 0:Int32) as $expr5, Field(min($expr1), 1:Int32) as $expr6, Field(max($expr1), 1:Int32) as $expr7, Field(first_value($expr1 order_by($expr1 ASC)), 1:Int32) as $expr8, Field(last_value($expr1 order_by($expr1 DESC)), 1:Int32) as $expr9, Field(min($expr1), 2:Int32) as $expr10, Field(max($expr1), 2:Int32) as $expr11, Field(first_value($expr1 order_by($expr1 ASC)), 2:Int32) as $expr12, Field(last_value($expr1 order_by($expr1 DESC)), 2:Int32) as $expr13, count(t.a), count(t.b), count(t.c)] }
      └─BatchHashAgg { group_key: [t.e, t.f], aggs: [max($expr1), last_value($expr1 order_by($expr1 DESC)), min($expr1), first_value($expr1 order_by($expr1 ASC)), count(t.a), count(t.b), count(t.c)] }
        └─BatchExchange { order: [], dist: HashShard(t.e, t.f) }
          └─BatchProject { exprs: [t.e, t.f, t.a, t.b, t.c, $expr1, $expr1, $expr1, $expr1] }
            └─BatchProject { exprs: [t.a, t.b, t.c, t.e, t.f, Row(t.a, t.b, t.c) as $expr1] }
              └─BatchScan { table: t, columns: [t.a, t.b, t.c, t.e, t.f], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [min_a, max_a, first_a, last_a, min_b, max_b, first_b, last_b, min_c, max_c, first_c, last_c, count_a, count_b, count_c, t.e(hidden), t.f(hidden)], stream_key: [t.e, t.f], pk_columns: [t.e, t.f], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(min($expr1), 0:Int32) as $expr2, Field(max($expr1), 0:Int32) as $expr3, Field(first_value($expr1 order_by($expr1 ASC)), 0:Int32) as $expr4, Field(last_value($expr1 order_by($expr1 DESC)), 0:Int32) as $expr5, Field(min($expr1), 1:Int32) as $expr6, Field(max($expr1), 1:Int32) as $expr7, Field(first_value($expr1 order_by($expr1 ASC)), 1:Int32) as $expr8, Field(last_value($expr1 order_by($expr1 DESC)), 1:Int32) as $expr9, Field(min($expr1), 2:Int32) as $expr10, Field(max($expr1), 2:Int32) as $expr11, Field(first_value($expr1 order_by($expr1 ASC)), 2:Int32) as $expr12, Field(last_value($expr1 order_by($expr1 DESC)), 2:Int32) as $expr13, count(t.a), count(t.b), count(t.c), t.e, t.f] }
      └─StreamHashAgg { group_key: [t.e, t.f], aggs: [last_value($expr1 order_by($expr1 DESC)), max($expr1), min($expr1), first_value($expr1 order_by($expr1 ASC)), count(t.a), count(t.b), count(t.c), count] }
        └─StreamExchange { dist: HashShard(t.e, t.f) }
          └─StreamProject { exprs: [t.a, t.b, t.c, t.e, t.f, $expr1, $expr1, $expr1, $expr1, t._row_id] }
            └─StreamProject { exprs: [t.a, t.b, t.c, t.e, t.f, Row(t.a, t.b, t.c) as $expr1, t._row_id] }
              └─StreamTableScan { table: t, columns: [t.a, t.b, t.c, t.e, t.f, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: unify agg call pattern with max with filter
  sql: |
    create table t(a int, b int, c int);
    select
    max(a) filter (where c > 0) max_a, max(b) filter (where c > 0) max_b,
    max(c) filter (where c = 1) max_c
    from t;
  batch_plan: |-
    BatchProject { exprs: [Field(max(max($expr1) filter((t.c > 0:Int32))), 0:Int32) as $expr2, Field(max(max($expr1) filter((t.c > 0:Int32))), 1:Int32) as $expr3, max(max(t.c) filter((t.c = 1:Int32)))] }
    └─BatchSimpleAgg { aggs: [max(max($expr1) filter((t.c > 0:Int32))), max(max(t.c) filter((t.c = 1:Int32)))] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchSimpleAgg { aggs: [max($expr1) filter((t.c > 0:Int32)), max(t.c) filter((t.c = 1:Int32))] }
          └─BatchProject { exprs: [t.c, Row(t.a, t.b) as $expr1] }
            └─BatchScan { table: t, columns: [t.a, t.b, t.c], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [max_a, max_b, max_c], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(max(max($expr1) filter((t.c > 0:Int32))), 0:Int32) as $expr3, Field(max(max($expr1) filter((t.c > 0:Int32))), 1:Int32) as $expr4, max(max(t.c) filter((t.c = 1:Int32)))] }
      └─StreamSimpleAgg { aggs: [max(max($expr1) filter((t.c > 0:Int32))), max(max(t.c) filter((t.c = 1:Int32))), count] }
        └─StreamExchange { dist: Single }
          └─StreamHashAgg { group_key: [$expr2], aggs: [max($expr1) filter((t.c > 0:Int32)), max(t.c) filter((t.c = 1:Int32)), count] }
            └─StreamProject { exprs: [t.c, Row(t.a, t.b) as $expr1, t._row_id, Vnode(t._row_id) as $expr2] }
              └─StreamTableScan { table: t, columns: [t.a, t.b, t.c, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
