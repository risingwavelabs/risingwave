# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t (v1 int, v2 int);
    update t set v1 = 0;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [0:Int32, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 int);
    update t set v1 = true;
  binder_error: 'Bind error: cannot cast type "boolean" to "integer" in Assign context'
- sql: |
    create table t (v1 int, v2 int);
    update t set v1 = v2 + 1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [($1 + 1:Int32), $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 real);
    update t set v1 = v2;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$1::Int32, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 real);
    update t set v1 = DEFAULT;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [null:Int32, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 int);
    update t set v1 = v2 + 1 where v2 > 0;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [($1 + 1:Int32), $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchFilter { predicate: (t.v2 > 0:Int32) }
          └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 int);
    update t set (v1, v2) = (v2 + 1, v1 - 1) where v1 != v2;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [($1 + 1:Int32), ($0 - 1:Int32), $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchFilter { predicate: (t.v1 <> t.v2) }
          └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 int);
    update t set (v1, v2) = (v2 + 1, v1 - 1) where v1 != v2 returning *, v2+1, v1-1;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, (t.v2 + 1:Int32) as $expr1, (t.v1 - 1:Int32) as $expr2] }
    └─LogicalUpdate { table: t, exprs: [($1 + 1:Int32), ($0 - 1:Int32), $2], returning: true }
      └─LogicalFilter { predicate: (t.v1 <> t.v2) }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [t.v1, t.v2, (t.v2 + 1:Int32) as $expr1, (t.v1 - 1:Int32) as $expr2] }
      └─BatchUpdate { table: t, exprs: [($1 + 1:Int32), ($0 - 1:Int32), $2], returning: true }
        └─BatchExchange { order: [], dist: Single }
          └─BatchFilter { predicate: (t.v1 <> t.v2) }
            └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- name: update with returning statement, should keep `Update`
  sql: |
    create table t (v int);
    update t set v = 114 returning 514;
  logical_plan: |
    LogicalProject { exprs: [514:Int32] }
    └─LogicalUpdate { table: t, exprs: [114:Int32, $1], returning: true }
      └─LogicalScan { table: t, columns: [t.v, t._row_id] }
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [514:Int32] }
      └─BatchUpdate { table: t, exprs: [114:Int32, $1], returning: true }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: t, columns: [t.v, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int primary key, v2 int);
    update t set (v2, v1) = (v1, v2);
  binder_error: 'Bind error: update modifying the PK column is banned'
- sql: |
    create table t (v1 int default 1+1, v2 int);
    update t set v1 = default;
  logical_plan: |
    LogicalUpdate { table: t, exprs: [(1:Int32 + 1:Int32), $1, $2] }
    └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [2:Int32, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id], distribution: UpstreamHashShard(t._row_id) }
