# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t (v1 int, v2 int);
    update t set v1 = 0;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, 0:Int32] }
          └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 int);
    update t set v1 = true;
  binder_error: cannot cast type "boolean" to "integer" in Assign context
- sql: |
    create table t (v1 int, v2 int);
    update t set v1 = v2 + 1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, (t.v2 + 1:Int32) as $expr1] }
          └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 real);
    update t set v1 = v2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, t.v2::Int32 as $expr1] }
          └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 real);
    update t set v1 = DEFAULT;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, null:Int32] }
          └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 int);
    update t set v1 = v2 + 1 where v2 > 0;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, (t.v2 + 1:Int32) as $expr1] }
          └─BatchFilter { predicate: (t.v2 > 0:Int32) }
            └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 int);
    update t set (v1, v2) = (v2 + 1, v1 - 1) where v1 != v2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $5, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, (t.v2 + 1:Int32) as $expr1, (t.v1 - 1:Int32) as $expr2] }
          └─BatchFilter { predicate: (t.v1 <> t.v2) }
            └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int, v2 int);
    update t set (v1, v2) = (v2 + 1, v1 - 1) where v1 != v2 returning *, v2+1, v1-1;
  logical_plan: |-
    LogicalProject { exprs: [, , ( + 1:Int32) as $expr3, ( - 1:Int32) as $expr4] }
    └─LogicalUpdate { table: t, exprs: [$4, $5, $2], returning: true }
      └─LogicalProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, (t.v2 + 1:Int32) as $expr1, (t.v1 - 1:Int32) as $expr2] }
        └─LogicalFilter { predicate: (t.v1 <> t.v2) }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [, , ( + 1:Int32) as $expr3, ( - 1:Int32) as $expr4] }
      └─BatchUpdate { table: t, exprs: [$4, $5, $2], returning: true }
        └─BatchExchange { order: [], dist: Single }
          └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, (t.v2 + 1:Int32) as $expr1, (t.v1 - 1:Int32) as $expr2] }
            └─BatchFilter { predicate: (t.v1 <> t.v2) }
              └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- name: update with returning statement, should keep `Update`
  sql: |
    create table t (v int);
    update t set v = 114 returning 514;
  logical_plan: |-
    LogicalProject { exprs: [514:Int32] }
    └─LogicalUpdate { table: t, exprs: [$3, $1], returning: true }
      └─LogicalProject { exprs: [t.v, t._row_id, t._rw_timestamp, 114:Int32] }
        └─LogicalScan { table: t, columns: [t.v, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [514:Int32] }
      └─BatchUpdate { table: t, exprs: [$3, $1], returning: true }
        └─BatchExchange { order: [], dist: Single }
          └─BatchProject { exprs: [t.v, t._row_id, t._rw_timestamp, 114:Int32] }
            └─BatchScan { table: t, columns: [t.v, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int primary key, v2 int);
    update t set (v2, v1) = (v1, v2);
  binder_error: 'Bind error: update modifying the PK column is unsupported'
- sql: |
    create table t (v1 int default 1+1, v2 int);
    update t set v1 = default;
  logical_plan: |-
    LogicalUpdate { table: t, exprs: [$4, $1, $2] }
    └─LogicalProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, (1:Int32 + 1:Int32) as $expr1] }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, 2:Int32] }
          └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- name: update table with generated columns
  sql: |
    create table t(v1 int as v2-1, v2 int, v3 int as v2+1);
    update t set v2 = 3;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$5, $3] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.v1, t.v2, t.v3, t._row_id, t._rw_timestamp, 3:Int32] }
          └─BatchScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- name: update generated column
  sql: |
    create table t(v1 int as v2-1, v2 int, v3 int as v2+1);
    update t set v1 = 3;
  binder_error: 'Bind error: update modifying the generated column is unsupported'
- name: update columns references by generated pk
  sql: |
    create table t(v1 int as v2-1, v2 int, v3 int as v2+1, primary key (v3));
    update t set v2 = 3;
  binder_error: 'Bind error: update modifying the column referenced by generated columns that are part of the primary key is not allowed'
- name: update subquery selection
  sql: |
    create table t (a int, b int);
    update t set a = 777 where b not in (select a from t);
  logical_plan: |-
    LogicalUpdate { table: t, exprs: [$4, $1, $2] }
    └─LogicalProject { exprs: [t.a, t.b, t._row_id, t._rw_timestamp, 777:Int32] }
      └─LogicalApply { type: LeftAnti, on: (t.b = t.a), correlated_id: 1 }
        ├─LogicalScan { table: t, columns: [t.a, t.b, t._row_id, t._rw_timestamp] }
        └─LogicalProject { exprs: [t.a] }
          └─LogicalScan { table: t, columns: [t.a, t.b, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.a, t.b, t._row_id, t._rw_timestamp, 777:Int32] }
          └─BatchHashJoin { type: LeftAnti, predicate: t.b = t.a, output: all }
            ├─BatchExchange { order: [], dist: HashShard(t.b) }
            │ └─BatchScan { table: t, columns: [t.a, t.b, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
            └─BatchExchange { order: [], dist: HashShard(t.a) }
              └─BatchScan { table: t, columns: [t.a], distribution: SomeShard }
- name: delete subquery
  sql: |
    create table t (a int, b int);
    delete from t where a not in (select b from t);
  logical_plan: |-
    LogicalDelete { table: t }
    └─LogicalProject { exprs: [t.a, t.b, t._row_id] }
      └─LogicalApply { type: LeftAnti, on: (t.a = t.b), correlated_id: 1 }
        ├─LogicalScan { table: t, columns: [t.a, t.b, t._row_id, t._rw_timestamp] }
        └─LogicalProject { exprs: [t.b] }
          └─LogicalScan { table: t, columns: [t.a, t.b, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchDelete { table: t }
      └─BatchExchange { order: [], dist: Single }
        └─BatchHashJoin { type: LeftAnti, predicate: t.a = t.b, output: all }
          ├─BatchExchange { order: [], dist: HashShard(t.a) }
          │ └─BatchScan { table: t, columns: [t.a, t.b, t._row_id], distribution: UpstreamHashShard(t._row_id) }
          └─BatchExchange { order: [], dist: HashShard(t.b) }
            └─BatchScan { table: t, columns: [t.b], distribution: SomeShard }
- name: distributed update
  sql: |
    set batch_enable_distributed_dml = true;
    create table t (a int, b int);
    update t set a = a + 1;
  batch_distributed_plan: |-
    BatchSimpleAgg { aggs: [sum()] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
        └─BatchExchange { order: [], dist: HashShard(t.a, t.b, t._row_id, t._rw_timestamp, $expr1) }
          └─BatchProject { exprs: [t.a, t.b, t._row_id, t._rw_timestamp, (t.a + 1:Int32) as $expr1] }
            └─BatchScan { table: t, columns: [t.a, t.b, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
- name: update table to subquery
  sql: |
    create table t (v1 int, v2 int);
    update t set v1 = (select 666);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
        └─BatchValues { rows: [[666:Int32]] }
- name: update table to subquery with runtime cardinality
  sql: |
    create table t (v1 int, v2 int);
    update t set v1 = (select generate_series(888, 888));
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
        ├─BatchExchange { order: [], dist: Single }
        │ └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
        └─BatchMaxOneRow
          └─BatchProject { exprs: [GenerateSeries(888:Int32, 888:Int32)] }
            └─BatchProjectSet { select_list: [GenerateSeries(888:Int32, 888:Int32)] }
              └─BatchValues { rows: [[]] }
- name: update table to correlated subquery
  sql: |
    create table t (v1 int, v2 int);
    update t set v1 = (select count(*) from t as source where source.v2 = t.v2);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [$4, $1, $2] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, count(1:Int32)::Int32 as $expr1] }
          └─BatchHashJoin { type: LeftOuter, predicate: t.v2 IS NOT DISTINCT FROM t.v2, output: [t.v1, t.v2, t._row_id, t._rw_timestamp, count(1:Int32)] }
            ├─BatchExchange { order: [], dist: HashShard(t.v2) }
            │ └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
            └─BatchHashAgg { group_key: [t.v2], aggs: [count(1:Int32)] }
              └─BatchHashJoin { type: LeftOuter, predicate: t.v2 IS NOT DISTINCT FROM t.v2, output: [t.v2, 1:Int32] }
                ├─BatchHashAgg { group_key: [t.v2], aggs: [] }
                │ └─BatchExchange { order: [], dist: HashShard(t.v2) }
                │   └─BatchScan { table: t, columns: [t.v2], distribution: SomeShard }
                └─BatchExchange { order: [], dist: HashShard(t.v2) }
                  └─BatchProject { exprs: [t.v2, 1:Int32] }
                    └─BatchFilter { predicate: IsNotNull(t.v2) }
                      └─BatchScan { table: t, columns: [t.v2], distribution: SomeShard }
- name: update table to subquery with multiple assignments
  sql: |
    create table t (v1 int, v2 int);
    update t set (v1, v2) = (select 666.66, 777);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchUpdate { table: t, exprs: [Field($4, 0:Int32), Field($4, 1:Int32), $2] }
      └─BatchProject { exprs: [t.v1, t.v2, t._row_id, t._rw_timestamp, $expr10011::Struct(StructType { fields: [("v1", Int32), ("v2", Int32)] }) as $expr1] }
        └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
          ├─BatchExchange { order: [], dist: Single }
          │ └─BatchScan { table: t, columns: [t.v1, t.v2, t._row_id, t._rw_timestamp], distribution: UpstreamHashShard(t._row_id) }
          └─BatchValues { rows: [['(666.66,777)':Struct(StructType { fields: [("f1", Decimal), ("f2", Int32)] })]] }
