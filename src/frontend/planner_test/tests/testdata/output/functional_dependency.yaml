# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: test functional dependency for order key pruning (order by - prefix fd)
  sql: |
    create table t1 (id int primary key, i int);
    select id, i from t1 order by id, i limit 2;
  logical_plan: |-
    LogicalTopN { order: [t1.id ASC], limit: 2, offset: 0 }
    └─LogicalProject { exprs: [t1.id, t1.i] }
      └─LogicalScan { table: t1, columns: [t1.id, t1.i, t1._rw_timestamp] }
  batch_plan: |-
    BatchTopN { order: [t1.id ASC], limit: 2, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchLimit { limit: 2, offset: 0 }
        └─BatchScan { table: t1, columns: [t1.id, t1.i], limit: 2, distribution: UpstreamHashShard(t1.id) }
  stream_plan: |-
    StreamMaterialize { columns: [id, i], stream_key: [id], pk_columns: [id], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.id) }
      └─StreamProject { exprs: [t1.id, t1.i] }
        └─StreamTopN { order: [t1.id ASC], limit: 2, offset: 0 }
          └─StreamExchange { dist: Single }
            └─StreamGroupTopN { order: [t1.id ASC], limit: 2, offset: 0, group_key: [_vnode] }
              └─StreamProject { exprs: [t1.id, t1.i, Vnode(t1.id) as _vnode] }
                └─StreamTableScan { table: t1, columns: [t1.id, t1.i], stream_scan_type: ArrangementBackfill, stream_key: [t1.id], pk: [id], dist: UpstreamHashShard(t1.id) }
- name: test functional dependency for order key pruning (order by - suffix fd)
  sql: |
    create table t1 (id int primary key, i int);
    select id, i from t1 order by i, id limit 2;
  logical_plan: |-
    LogicalTopN { order: [t1.i ASC, t1.id ASC], limit: 2, offset: 0 }
    └─LogicalProject { exprs: [t1.id, t1.i] }
      └─LogicalScan { table: t1, columns: [t1.id, t1.i, t1._rw_timestamp] }
  batch_plan: |-
    BatchTopN { order: [t1.i ASC, t1.id ASC], limit: 2, offset: 0 }
    └─BatchExchange { order: [], dist: Single }
      └─BatchTopN { order: [t1.i ASC, t1.id ASC], limit: 2, offset: 0 }
        └─BatchScan { table: t1, columns: [t1.id, t1.i], distribution: UpstreamHashShard(t1.id) }
  stream_plan: |-
    StreamMaterialize { columns: [id, i], stream_key: [id], pk_columns: [i, id], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.i, t1.id) }
      └─StreamProject { exprs: [t1.id, t1.i] }
        └─StreamTopN { order: [t1.i ASC, t1.id ASC], limit: 2, offset: 0 }
          └─StreamExchange { dist: Single }
            └─StreamGroupTopN { order: [t1.i ASC, t1.id ASC], limit: 2, offset: 0, group_key: [_vnode] }
              └─StreamProject { exprs: [t1.id, t1.i, Vnode(t1.id) as _vnode] }
                └─StreamTableScan { table: t1, columns: [t1.id, t1.i], stream_scan_type: ArrangementBackfill, stream_key: [t1.id], pk: [id], dist: UpstreamHashShard(t1.id) }
- name: test functional dependency for order key pruning on singleton
  sql: |
    create table t1 (id int primary key, i int);
    create materialized view v as select count(*) cnt from t1;
    select cnt from v order by cnt;
  logical_plan: |-
    LogicalProject { exprs: [v.cnt] }
    └─LogicalScan { table: v, columns: [v.cnt, v._rw_timestamp], cardinality: 0..=1 }
  batch_plan: |-
    BatchExchange { order: [v.cnt ASC], dist: Single }
    └─BatchSort { order: [v.cnt ASC] }
      └─BatchScan { table: v, columns: [v.cnt], distribution: Single }
  stream_plan: |-
    StreamMaterialize { columns: [cnt], stream_key: [], pk_columns: [cnt], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(v.cnt) }
      └─StreamTableScan { table: v, columns: [v.cnt], stream_scan_type: ArrangementBackfill, stream_key: [], pk: [], dist: Single }
- name: test functional dependency for order key pruning (index)
  sql: |
    create table t1 (v1 int, v2 int);
    create materialized view v as select count(*) cnt from t1;
    explain (verbose) create index mv_idx on v(cnt);
  explain_output: |
    StreamMaterialize { columns: [cnt], stream_key: [], pk_columns: [cnt], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(v.cnt) }
      └─StreamTableScan { table: v, columns: [v.cnt], stream_scan_type: ArrangementBackfill, stream_key: [], pk: [], dist: Single }
- name: test functional dependency for order key pruning (index 2)
  sql: |
    create table t1 (v1 int primary key, v2 int);
    explain (verbose) create index mv_idx on t1(v1, v2);
  explain_output: |
    StreamMaterialize { columns: [v1, v2], stream_key: [v1], pk_columns: [v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.v1) }
      └─StreamTableScan { table: t1, columns: [t1.v1, t1.v2], stream_scan_type: ArrangementBackfill, stream_key: [t1.v1], pk: [v1], dist: UpstreamHashShard(t1.v1) }
- name: test functional dependency for order key pruning (index 3)
  sql: |
    create table t1 (v1 int primary key, v2 int);
    explain (verbose) create index mv_idx on t1(v2, v1);
  explain_output: |
    StreamMaterialize { columns: [v2, v1], stream_key: [v1], pk_columns: [v2, v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.v2) }
      └─StreamProject { exprs: [t1.v2, t1.v1] }
        └─StreamTableScan { table: t1, columns: [t1.v1, t1.v2], stream_scan_type: ArrangementBackfill, stream_key: [t1.v1], pk: [v1], dist: UpstreamHashShard(t1.v1) }
