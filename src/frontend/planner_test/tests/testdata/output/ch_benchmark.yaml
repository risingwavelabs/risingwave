# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: "create table warehouse (\n  w_id INT PRIMARY KEY,\n  w_name VARCHAR,\n  w_street_1 VARCHAR,\n  w_street_2 VARCHAR,\n  w_city VARCHAR,\n  w_state VARCHAR,\n  w_zip VARCHAR,\n  w_tax NUMERIC,\n  w_ytd NUMERIC\n);\n\ncreate table district (\n  d_id INT,\n  d_w_id INT,\n  d_name VARCHAR,\n  d_street_1 VARCHAR,\n  d_street_2 VARCHAR,\n  d_city VARCHAR,\n  d_state VARCHAR,\n  d_zip VARCHAR,\n  d_tax NUMERIC,\n  d_ytd NUMERIC,\n  d_next_o_id INT,\n  PRIMARY KEY (d_w_id, d_id)\n);\n\ncreate table customer (\n  c_id INT,\n  c_d_id INT,\n  c_w_id INT,\n  c_first VARCHAR,\n  c_middle VARCHAR,\n  c_last VARCHAR,\n  c_street_1 VARCHAR,\n  c_street_2 VARCHAR,\n  c_city VARCHAR,\n  c_state VARCHAR,\n  c_zip VARCHAR,\n  c_phone VARCHAR,\n  c_since TIMESTAMP,\n  c_credit VARCHAR,\n  c_credit_lim NUMERIC,\n  c_discount NUMERIC,\n  c_balance NUMERIC,\n  c_ytd_payment NUMERIC,\n  c_payment_cnt INT,\n  c_delivery_cnt INT,\n  c_data VARCHAR,\n  PRIMARY KEY(c_w_id, c_d_id, c_id)\n);\n\ncreate table history (\n  h_c_id INT,\n  h_c_d_id INT,\n  h_c_w_id INT,\n  h_d_id INT,\n  h_w_id INT,\n  h_date TIMESTAMP,\n  h_amount NUMERIC,\n  h_data VARCHAR,\n  PRIMARY KEY(h_c_id, h_d_id, h_w_id, h_data)\n);\n\ncreate table new_order (\n  no_o_id INT,\n  no_d_id INT,\n  no_w_id INT,\n  PRIMARY KEY(no_w_id, no_d_id, no_o_id)\n);\n\ncreate table orders (\n  o_id INT,\n  o_d_id INT,\n  o_w_id INT,\n  o_c_id INT,\n  o_entry_d TIMESTAMP,\n  o_carrier_id INT,\n  o_ol_cnt INT,\n  o_all_local INT,\n  PRIMARY KEY(o_w_id, o_d_id, o_id)\n);\n\ncreate table order_line (\n  ol_o_id INT,\n  ol_d_id INT,\n  ol_w_id INT,\n  ol_number INT,\n  ol_i_id INT,\n  ol_supply_w_id INT,\n  ol_delivery_d TIMESTAMP,\n  ol_quantity INT,\n  ol_amount NUMERIC,\n  ol_dist_info VARCHAR,\n  PRIMARY KEY(ol_w_id, ol_d_id, ol_o_id, ol_number)\n);\n\ncreate table stock (\n  s_i_id INT,\n  s_w_id INT,\n  s_quantity INT,\n  s_dist_01 VARCHAR,\n  s_dist_02 VARCHAR,\n  s_dist_03 VARCHAR,\n  s_dist_04 VARCHAR,\n  s_dist_05 VARCHAR,\n  s_dist_06 VARCHAR,\n  s_dist_07 VARCHAR,\n  s_dist_08 VARCHAR,\n  s_dist_09 VARCHAR,\n  s_dist_10 VARCHAR,\n  s_ytd INT,\n  s_order_cnt INT,\n  s_remote_cnt INT,\n  s_data VARCHAR,\n  PRIMARY KEY(s_w_id, s_i_id)\n);\n\ncreate table item (\n  i_id INT,\n  i_im_id INT,\n  i_name VARCHAR,\n  i_price NUMERIC,\n  i_data VARCHAR,\n  PRIMARY KEY(i_id)\n);\n\ncreate table nation (\n  N_NATIONKEY BIGINT,\n  N_NAME VARCHAR,\n  N_REGIONKEY BIGINT,\n  N_COMMENT VARCHAR,\n  PRIMARY KEY (N_NATIONKEY)\n);\n\ncreate table region (\n  R_REGIONKEY BIGINT,\n  R_NAME VARCHAR,\n  R_COMMENT VARCHAR,\n  PRIMARY KEY (R_REGIONKEY)\n);\n\ncreate table supplier (\n  S_SUPPKEY BIGINT,\n  S_NAME VARCHAR,\n  S_ADDRESS VARCHAR,\n  S_NATIONKEY BIGINT,\n  S_PHONE VARCHAR,\n  S_ACCTBAL NUMERIC,\n  S_COMMENT VARCHAR,\n  PRIMARY KEY (S_SUPPKEY)\n);\n\ncreate materialized view revenue1 (supplier_no, total_revenue) as (\n  select\tmod((s_w_id * s_i_id),10000) as supplier_no,\n            sum(ol_amount) as total_revenue\n  from\torder_line, stock\n  where ol_i_id = s_i_id and ol_supply_w_id = s_w_id\n    and ol_delivery_d >= '2007-01-02 00:00:00.000000'\n  group by mod((s_w_id * s_i_id),10000));\n"
- id: ch_q1
  before:
  - create_tables
  sql: "select   ol_number,\n sum(ol_quantity) as sum_qty,\n sum(ol_amount) as sum_amount,\n avg(ol_quantity) as avg_qty,\n avg(ol_amount) as avg_amount,\n count(*) as count_order\nfrom\t order_line\nwhere\t ol_delivery_d > '2007-01-02 00:00:00.000000'\ngroup by ol_number order by ol_number;\n"
  logical_plan: |-
    LogicalProject { exprs: [order_line.ol_number, sum(order_line.ol_quantity), sum(order_line.ol_amount), (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr1, (sum(order_line.ol_amount) / count(order_line.ol_amount)::Decimal) as $expr2, count] }
    └─LogicalAgg { group_key: [order_line.ol_number], aggs: [sum(order_line.ol_quantity), sum(order_line.ol_amount), count(order_line.ol_quantity), count(order_line.ol_amount), count] }
      └─LogicalProject { exprs: [order_line.ol_number, order_line.ol_quantity, order_line.ol_amount] }
        └─LogicalFilter { predicate: (order_line.ol_delivery_d > '2007-01-02 00:00:00':Timestamp) }
          └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [order_line.ol_number, sum(order_line.ol_quantity), sum(order_line.ol_amount), (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr1, (sum(order_line.ol_amount) / count(order_line.ol_amount)::Decimal) as $expr2, count] }
    └─LogicalAgg { group_key: [order_line.ol_number], aggs: [sum(order_line.ol_quantity), sum(order_line.ol_amount), count(order_line.ol_quantity), count(order_line.ol_amount), count] }
      └─LogicalScan { table: order_line, output_columns: [order_line.ol_number, order_line.ol_quantity, order_line.ol_amount], required_columns: [order_line.ol_number, order_line.ol_quantity, order_line.ol_amount, order_line.ol_delivery_d], predicate: (order_line.ol_delivery_d > '2007-01-02 00:00:00':Timestamp) }
  batch_plan: |-
    BatchExchange { order: [order_line.ol_number ASC], dist: Single }
    └─BatchProject { exprs: [order_line.ol_number, sum(order_line.ol_quantity), sum(order_line.ol_amount), (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr1, (sum(order_line.ol_amount) / count(order_line.ol_amount)::Decimal) as $expr2, count] }
      └─BatchSort { order: [order_line.ol_number ASC] }
        └─BatchHashAgg { group_key: [order_line.ol_number], aggs: [sum(order_line.ol_quantity), sum(order_line.ol_amount), count(order_line.ol_quantity), count(order_line.ol_amount), count] }
          └─BatchExchange { order: [], dist: HashShard(order_line.ol_number) }
            └─BatchProject { exprs: [order_line.ol_number, order_line.ol_quantity, order_line.ol_amount] }
              └─BatchFilter { predicate: (order_line.ol_delivery_d > '2007-01-02 00:00:00':Timestamp) }
                └─BatchScan { table: order_line, columns: [order_line.ol_number, order_line.ol_quantity, order_line.ol_amount, order_line.ol_delivery_d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [ol_number, sum_qty, sum_amount, avg_qty, avg_amount, count_order], stream_key: [ol_number], pk_columns: [ol_number], pk_conflict: NoCheck }
    └─StreamProject { exprs: [order_line.ol_number, sum(order_line.ol_quantity), sum(order_line.ol_amount), (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr1, (sum(order_line.ol_amount) / count(order_line.ol_amount)::Decimal) as $expr2, count] }
      └─StreamHashAgg { group_key: [order_line.ol_number], aggs: [sum(order_line.ol_quantity), sum(order_line.ol_amount), count(order_line.ol_quantity), count(order_line.ol_amount), count] }
        └─StreamExchange { dist: HashShard(order_line.ol_number) }
          └─StreamProject { exprs: [order_line.ol_number, order_line.ol_quantity, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id] }
            └─StreamFilter { predicate: (order_line.ol_delivery_d > '2007-01-02 00:00:00':Timestamp) }
              └─StreamTableScan { table: order_line, columns: [order_line.ol_number, order_line.ol_quantity, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_delivery_d], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ol_number, sum_qty, sum_amount, avg_qty, avg_amount, count_order], stream_key: [ol_number], pk_columns: [ol_number], pk_conflict: NoCheck } { tables: [ Materialize: 4294967294 ] }
    └── StreamProject { exprs: [order_line.ol_number, sum(order_line.ol_quantity), sum(order_line.ol_amount), (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr1, (sum(order_line.ol_amount) / count(order_line.ol_amount)::Decimal) as $expr2, count] }
        └── StreamHashAgg { group_key: [order_line.ol_number], aggs: [sum(order_line.ol_quantity), sum(order_line.ol_amount), count(order_line.ol_quantity), count(order_line.ol_amount), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [order_line.ol_number, order_line.ol_quantity, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id] }
    └── StreamFilter { predicate: (order_line.ol_delivery_d > '2007-01-02 00:00:00':Timestamp) }
        └── StreamTableScan { table: order_line, columns: [order_line.ol_number, order_line.ol_quantity, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_delivery_d], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
            ├── tables: [ StreamScan: 1 ]
            ├── Upstream
            └── BatchPlanNode

    Table 0 { columns: [ order_line_ol_number, sum(order_line_ol_quantity), sum(order_line_ol_amount), count(order_line_ol_quantity), count(order_line_ol_amount), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ ol_number, sum_qty, sum_amount, avg_qty, avg_amount, count_order, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: ch_q2
  before:
  - create_tables
  sql: "select \t s_suppkey, s_name, n_name, i_id, i_name, s_address, s_phone, s_comment\nfrom\t item, supplier, stock, nation, region,\n         (select s_i_id as m_i_id,\n                 min(s_quantity) as m_s_quantity\n          from\t stock, supplier, nation, region\n          where\t mod((s_w_id*s_i_id),10000)=s_suppkey\n            and s_nationkey=n_nationkey\n            and n_regionkey=r_regionkey\n            and r_name like 'EUROP%'\n          group by s_i_id) m\nwhere \t i_id = s_i_id\n  and mod((s_w_id * s_i_id), 10000) = s_suppkey\n  and s_nationkey = n_nationkey\n  and n_regionkey = r_regionkey\n  and i_data like '%b'\n  and r_name like 'EUROP%'\n  and i_id=m_i_id\n  and s_quantity = m_s_quantity\norder by n_name, s_name, i_id;\n"
  logical_plan: |-
    LogicalProject { exprs: [supplier.s_suppkey, supplier.s_name, nation.n_name, item.i_id, item.i_name, supplier.s_address, supplier.s_phone, supplier.s_comment] }
    └─LogicalFilter { predicate: (item.i_id = stock.s_i_id) AND (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey) AND (supplier.s_nationkey = nation.n_nationkey) AND (nation.n_regionkey = region.r_regionkey) AND Like(item.i_data, '%b':Varchar) AND Like(region.r_name, 'EUROP%':Varchar) AND (item.i_id = stock.s_i_id) AND (stock.s_quantity = min(stock.s_quantity)) }
      └─LogicalJoin { type: Inner, on: true, output: all }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ │ │ ├─LogicalScan { table: item, columns: [item.i_id, item.i_im_id, item.i_name, item.i_price, item.i_data, item._rw_timestamp] }
        │ │ │ │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
        │ │ │ └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
        │ │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
        │ └─LogicalScan { table: region, columns: [region.r_regionkey, region.r_name, region.r_comment, region._rw_timestamp] }
        └─LogicalProject { exprs: [stock.s_i_id, min(stock.s_quantity)] }
          └─LogicalAgg { group_key: [stock.s_i_id], aggs: [min(stock.s_quantity)] }
            └─LogicalProject { exprs: [stock.s_i_id, stock.s_quantity] }
              └─LogicalFilter { predicate: (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey) AND (supplier.s_nationkey = nation.n_nationkey) AND (nation.n_regionkey = region.r_regionkey) AND Like(region.r_name, 'EUROP%':Varchar) }
                └─LogicalJoin { type: Inner, on: true, output: all }
                  ├─LogicalJoin { type: Inner, on: true, output: all }
                  │ ├─LogicalJoin { type: Inner, on: true, output: all }
                  │ │ ├─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
                  │ │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
                  │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
                  └─LogicalScan { table: region, columns: [region.r_regionkey, region.r_name, region.r_comment, region._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: (nation.n_regionkey = region.r_regionkey), output: [supplier.s_suppkey, supplier.s_name, nation.n_name, item.i_id, item.i_name, supplier.s_address, supplier.s_phone, supplier.s_comment] }
    ├─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [item.i_id, item.i_name, supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, supplier.s_comment, nation.n_name, nation.n_regionkey] }
    │ ├─LogicalJoin { type: Inner, on: ($expr2 = supplier.s_suppkey), output: [item.i_id, item.i_name, supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_comment] }
    │ │ ├─LogicalProject { exprs: [item.i_id, item.i_name, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr2] }
    │ │ │ └─LogicalJoin { type: Inner, on: (item.i_id = stock.s_i_id) AND (stock.s_quantity = min(stock.s_quantity)), output: [item.i_id, item.i_name, stock.s_i_id, stock.s_w_id] }
    │ │ │   ├─LogicalJoin { type: Inner, on: (item.i_id = stock.s_i_id), output: all }
    │ │ │   │ ├─LogicalScan { table: item, output_columns: [item.i_id, item.i_name], required_columns: [item.i_id, item.i_name, item.i_data], predicate: Like(item.i_data, '%b':Varchar) }
    │ │ │   │ └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity] }
    │ │ │   └─LogicalAgg { group_key: [stock.s_i_id], aggs: [min(stock.s_quantity)] }
    │ │ │     └─LogicalJoin { type: Inner, on: (supplier.s_suppkey = $expr1), output: [stock.s_i_id, stock.s_quantity] }
    │ │ │       ├─LogicalJoin { type: Inner, on: (nation.n_regionkey = region.r_regionkey), output: [supplier.s_suppkey] }
    │ │ │       │ ├─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [supplier.s_suppkey, nation.n_regionkey] }
    │ │ │       │ │ ├─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey] }
    │ │ │       │ │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_regionkey] }
    │ │ │       │ └─LogicalScan { table: region, output_columns: [region.r_regionkey], required_columns: [region.r_regionkey, region.r_name], predicate: (region.r_name >= 'EUROP':Varchar) AND (region.r_name < 'EUROQ':Varchar) }
    │ │ │       └─LogicalProject { exprs: [stock.s_i_id, stock.s_quantity, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
    │ │ │         └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity] }
    │ │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_comment] }
    │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey] }
    └─LogicalScan { table: region, output_columns: [region.r_regionkey], required_columns: [region.r_regionkey, region.r_name], predicate: (region.r_name >= 'EUROP':Varchar) AND (region.r_name < 'EUROQ':Varchar) }
  batch_plan: |-
    BatchExchange { order: [nation.n_name ASC, supplier.s_name ASC, item.i_id ASC], dist: Single }
    └─BatchSort { order: [nation.n_name ASC, supplier.s_name ASC, item.i_id ASC] }
      └─BatchLookupJoin { type: Inner, predicate: nation.n_regionkey = region.r_regionkey AND (region.r_name >= 'EUROP':Varchar) AND (region.r_name < 'EUROQ':Varchar), output: [supplier.s_suppkey, supplier.s_name, nation.n_name, item.i_id, item.i_name, supplier.s_address, supplier.s_phone, supplier.s_comment], lookup table: region }
        └─BatchExchange { order: [], dist: UpstreamHashShard(nation.n_regionkey) }
          └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [item.i_id, item.i_name, supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, supplier.s_comment, nation.n_name, nation.n_regionkey], lookup table: nation }
            └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
              └─BatchLookupJoin { type: Inner, predicate: $expr2 = supplier.s_suppkey, output: [item.i_id, item.i_name, supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_comment], lookup table: supplier }
                └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
                  └─BatchProject { exprs: [item.i_id, item.i_name, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr2] }
                    └─BatchHashJoin { type: Inner, predicate: item.i_id = stock.s_i_id AND stock.s_quantity = min(stock.s_quantity), output: [item.i_id, item.i_name, stock.s_i_id, stock.s_w_id] }
                      ├─BatchHashJoin { type: Inner, predicate: item.i_id = stock.s_i_id, output: all }
                      │ ├─BatchExchange { order: [], dist: HashShard(item.i_id) }
                      │ │ └─BatchProject { exprs: [item.i_id, item.i_name] }
                      │ │   └─BatchFilter { predicate: Like(item.i_data, '%b':Varchar) }
                      │ │     └─BatchScan { table: item, columns: [item.i_id, item.i_name, item.i_data], distribution: UpstreamHashShard(item.i_id) }
                      │ └─BatchExchange { order: [], dist: HashShard(stock.s_i_id) }
                      │   └─BatchScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity], distribution: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
                      └─BatchHashAgg { group_key: [stock.s_i_id], aggs: [min(stock.s_quantity)] }
                        └─BatchExchange { order: [], dist: HashShard(stock.s_i_id) }
                          └─BatchHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr1, output: [stock.s_i_id, stock.s_quantity] }
                            ├─BatchExchange { order: [], dist: HashShard(supplier.s_suppkey) }
                            │ └─BatchLookupJoin { type: Inner, predicate: nation.n_regionkey = region.r_regionkey AND (region.r_name >= 'EUROP':Varchar) AND (region.r_name < 'EUROQ':Varchar), output: [supplier.s_suppkey], lookup table: region }
                            │   └─BatchExchange { order: [], dist: UpstreamHashShard(nation.n_regionkey) }
                            │     └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, nation.n_regionkey], lookup table: nation }
                            │       └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
                            │         └─BatchScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], distribution: UpstreamHashShard(supplier.s_suppkey) }
                            └─BatchExchange { order: [], dist: HashShard($expr1) }
                              └─BatchProject { exprs: [stock.s_i_id, stock.s_quantity, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
                                └─BatchScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity], distribution: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
  stream_plan: |-
    StreamMaterialize { columns: [s_suppkey, s_name, n_name, i_id, i_name, s_address, s_phone, s_comment, stock.s_i_id(hidden), stock.s_w_id(hidden), min(stock.s_quantity)(hidden), $expr2(hidden), region.r_regionkey(hidden), supplier.s_nationkey(hidden)], stream_key: [stock.s_i_id, stock.s_w_id, min(stock.s_quantity), region.r_regionkey, supplier.s_nationkey, $expr2], pk_columns: [n_name, s_name, i_id, stock.s_i_id, stock.s_w_id, min(stock.s_quantity), region.r_regionkey, supplier.s_nationkey, $expr2], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(stock.s_i_id, stock.s_w_id, min(stock.s_quantity), $expr2, region.r_regionkey, supplier.s_nationkey) }
      └─StreamHashJoin { type: Inner, predicate: $expr2 = supplier.s_suppkey, output: [supplier.s_suppkey, supplier.s_name, nation.n_name, item.i_id, item.i_name, supplier.s_address, supplier.s_phone, supplier.s_comment, stock.s_i_id, stock.s_w_id, min(stock.s_quantity), $expr2, region.r_regionkey, supplier.s_nationkey] }
        ├─StreamExchange { dist: HashShard($expr2) }
        │ └─StreamProject { exprs: [item.i_id, item.i_name, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr2, stock.s_i_id, stock.s_w_id, min(stock.s_quantity)] }
        │   └─StreamHashJoin { type: Inner, predicate: stock.s_i_id = item.i_id AND min(stock.s_quantity) = stock.s_quantity AND stock.s_i_id = stock.s_i_id, output: [item.i_id, item.i_name, stock.s_i_id, stock.s_w_id, stock.s_i_id, min(stock.s_quantity)] }
        │     ├─StreamProject { exprs: [stock.s_i_id, min(stock.s_quantity)] }
        │     │ └─StreamHashAgg { group_key: [stock.s_i_id], aggs: [min(stock.s_quantity), count] }
        │     │   └─StreamExchange { dist: HashShard(stock.s_i_id) }
        │     │     └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr1, output: [stock.s_i_id, stock.s_quantity, region.r_regionkey, supplier.s_suppkey, supplier.s_nationkey, stock.s_w_id] }
        │     │       ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
        │     │       │ └─StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [supplier.s_suppkey, region.r_regionkey, supplier.s_nationkey] }
        │     │       │   ├─StreamExchange { dist: HashShard(region.r_regionkey) }
        │     │       │   │ └─StreamProject { exprs: [region.r_regionkey] }
        │     │       │   │   └─StreamFilter { predicate: Like(region.r_name, 'EUROP%':Varchar) }
        │     │       │   │     └─StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], stream_scan_type: ArrangementBackfill, stream_key: [region.r_regionkey], pk: [r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
        │     │       │   └─StreamExchange { dist: HashShard(nation.n_regionkey) }
        │     │       │     └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, nation.n_regionkey, supplier.s_nationkey, nation.n_nationkey] }
        │     │       │       ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
        │     │       │       │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
        │     │       │       └─StreamExchange { dist: HashShard(nation.n_nationkey) }
        │     │       │         └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_regionkey], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
        │     │       └─StreamExchange { dist: HashShard($expr1) }
        │     │         └─StreamProject { exprs: [stock.s_i_id, stock.s_quantity, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, stock.s_w_id] }
        │     │           └─StreamFilter { predicate: IsNotNull(stock.s_i_id) }
        │     │             └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
        │     └─StreamHashJoin { type: Inner, predicate: item.i_id = stock.s_i_id, output: all }
        │       ├─StreamExchange { dist: HashShard(item.i_id) }
        │       │ └─StreamProject { exprs: [item.i_id, item.i_name] }
        │       │   └─StreamFilter { predicate: Like(item.i_data, '%b':Varchar) }
        │       │     └─StreamTableScan { table: item, columns: [item.i_id, item.i_name, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) }
        │       └─StreamExchange { dist: HashShard(stock.s_i_id) }
        │         └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
        └─StreamExchange { dist: HashShard(supplier.s_suppkey) }
          └─StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, supplier.s_comment, nation.n_name, region.r_regionkey, supplier.s_nationkey] }
            ├─StreamExchange { dist: HashShard(region.r_regionkey) }
            │ └─StreamProject { exprs: [region.r_regionkey] }
            │   └─StreamFilter { predicate: Like(region.r_name, 'EUROP%':Varchar) }
            │     └─StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], stream_scan_type: ArrangementBackfill, stream_key: [region.r_regionkey], pk: [r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
            └─StreamExchange { dist: HashShard(nation.n_regionkey) }
              └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, supplier.s_comment, nation.n_name, nation.n_regionkey, supplier.s_nationkey, nation.n_nationkey] }
                ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_comment], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                └─StreamExchange { dist: HashShard(nation.n_nationkey) }
                  └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_suppkey, s_name, n_name, i_id, i_name, s_address, s_phone, s_comment, stock.s_i_id(hidden), stock.s_w_id(hidden), min(stock.s_quantity)(hidden), $expr2(hidden), region.r_regionkey(hidden), supplier.s_nationkey(hidden)], stream_key: [stock.s_i_id, stock.s_w_id, min(stock.s_quantity), region.r_regionkey, supplier.s_nationkey, $expr2], pk_columns: [n_name, s_name, i_id, stock.s_i_id, stock.s_w_id, min(stock.s_quantity), region.r_regionkey, supplier.s_nationkey, $expr2], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamExchange Hash([8, 9, 10, 11, 12, 13]) from 1

    Fragment 1
    StreamHashJoin { type: Inner, predicate: $expr2 = supplier.s_suppkey, output: [supplier.s_suppkey, supplier.s_name, nation.n_name, item.i_id, item.i_name, supplier.s_address, supplier.s_phone, supplier.s_comment, stock.s_i_id, stock.s_w_id, min(stock.s_quantity), $expr2, region.r_regionkey, supplier.s_nationkey] } { tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ] }
    ├── StreamExchange Hash([2]) from 2
    └── StreamExchange Hash([0]) from 12

    Fragment 2
    StreamProject { exprs: [item.i_id, item.i_name, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr2, stock.s_i_id, stock.s_w_id, min(stock.s_quantity)] }
    └── StreamHashJoin { type: Inner, predicate: stock.s_i_id = item.i_id AND min(stock.s_quantity) = stock.s_quantity AND stock.s_i_id = stock.s_i_id, output: [item.i_id, item.i_name, stock.s_i_id, stock.s_w_id, stock.s_i_id, min(stock.s_quantity)] } { tables: [ HashJoinLeft: 4, HashJoinDegreeLeft: 5, HashJoinRight: 6, HashJoinDegreeRight: 7 ] }
        ├── StreamProject { exprs: [stock.s_i_id, min(stock.s_quantity)] }
        │   └── StreamHashAgg { group_key: [stock.s_i_id], aggs: [min(stock.s_quantity), count] } { tables: [ HashAggState: 9, HashAggCall0: 8 ] }
        │       └── StreamExchange Hash([0]) from 3
        └── StreamHashJoin { type: Inner, predicate: item.i_id = stock.s_i_id, output: all } { tables: [ HashJoinLeft: 26, HashJoinDegreeLeft: 27, HashJoinRight: 28, HashJoinDegreeRight: 29 ] }
            ├── StreamExchange Hash([0]) from 10
            └── StreamExchange Hash([0]) from 11

    Fragment 3
    StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr1, output: [stock.s_i_id, stock.s_quantity, region.r_regionkey, supplier.s_suppkey, supplier.s_nationkey, stock.s_w_id] } { tables: [ HashJoinLeft: 10, HashJoinDegreeLeft: 11, HashJoinRight: 12, HashJoinDegreeRight: 13 ] }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([2]) from 9

    Fragment 4
    StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [supplier.s_suppkey, region.r_regionkey, supplier.s_nationkey] } { tables: [ HashJoinLeft: 14, HashJoinDegreeLeft: 15, HashJoinRight: 16, HashJoinDegreeRight: 17 ] }
    ├── StreamExchange Hash([0]) from 5
    └── StreamExchange Hash([1]) from 6

    Fragment 5
    StreamProject { exprs: [region.r_regionkey] }
    └── StreamFilter { predicate: Like(region.r_name, 'EUROP%':Varchar) }
        └── StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], stream_scan_type: ArrangementBackfill, stream_key: [region.r_regionkey], pk: [r_regionkey], dist: UpstreamHashShard(region.r_regionkey) } { tables: [ StreamScan: 18 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 6
    StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, nation.n_regionkey, supplier.s_nationkey, nation.n_nationkey] } { tables: [ HashJoinLeft: 19, HashJoinDegreeLeft: 20, HashJoinRight: 21, HashJoinDegreeRight: 22 ] }
    ├── StreamExchange Hash([1]) from 7
    └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) } { tables: [ StreamScan: 23 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 8
    StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_regionkey], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 24 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 9
    StreamProject { exprs: [stock.s_i_id, stock.s_quantity, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, stock.s_w_id] }
    └── StreamFilter { predicate: IsNotNull(stock.s_i_id) }
        └── StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) } { tables: [ StreamScan: 25 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 10
    StreamProject { exprs: [item.i_id, item.i_name] }
    └── StreamFilter { predicate: Like(item.i_data, '%b':Varchar) }
        └── StreamTableScan { table: item, columns: [item.i_id, item.i_name, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) } { tables: [ StreamScan: 30 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 11
    StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) } { tables: [ StreamScan: 31 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 12
    StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, supplier.s_comment, nation.n_name, region.r_regionkey, supplier.s_nationkey] } { tables: [ HashJoinLeft: 32, HashJoinDegreeLeft: 33, HashJoinRight: 34, HashJoinDegreeRight: 35 ] }
    ├── StreamExchange Hash([0]) from 13
    └── StreamExchange Hash([6]) from 14

    Fragment 13
    StreamProject { exprs: [region.r_regionkey] }
    └── StreamFilter { predicate: Like(region.r_name, 'EUROP%':Varchar) }
        └── StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], stream_scan_type: ArrangementBackfill, stream_key: [region.r_regionkey], pk: [r_regionkey], dist: UpstreamHashShard(region.r_regionkey) } { tables: [ StreamScan: 36 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 14
    StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, supplier.s_comment, nation.n_name, nation.n_regionkey, supplier.s_nationkey, nation.n_nationkey] } { tables: [ HashJoinLeft: 37, HashJoinDegreeLeft: 38, HashJoinRight: 39, HashJoinDegreeRight: 40 ] }
    ├── StreamExchange Hash([3]) from 15
    └── StreamExchange Hash([0]) from 16

    Fragment 15
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_comment], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) } { tables: [ StreamScan: 41 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 16
    StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 42 ] }
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ item_i_id, item_i_name, $expr2, stock_s_i_id, stock_s_w_id, min(stock_s_quantity), _rw_timestamp ], primary key: [ $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr2, stock_s_i_id, stock_s_w_id, min(stock_s_quantity), _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ supplier_s_suppkey, supplier_s_name, supplier_s_address, supplier_s_phone, supplier_s_comment, nation_n_name, region_r_regionkey, supplier_s_nationkey, _rw_timestamp ], primary key: [ $0 ASC, $6 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ supplier_s_suppkey, region_r_regionkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ stock_s_i_id, min(stock_s_quantity), _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 3 }

    Table 5 { columns: [ stock_s_i_id, min(stock_s_quantity), stock_s_i_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 3 }

    Table 6 { columns: [ item_i_id, item_i_name, stock_s_i_id, stock_s_w_id, stock_s_quantity, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC, $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 3 }

    Table 7 { columns: [ item_i_id, stock_s_quantity, stock_s_i_id, stock_s_w_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 3 }

    Table 8 { columns: [ stock_s_i_id, stock_s_quantity, region_r_regionkey, supplier_s_suppkey, supplier_s_nationkey, stock_s_w_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ stock_s_i_id, min(stock_s_quantity), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ supplier_s_suppkey, region_r_regionkey, supplier_s_nationkey, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ supplier_s_suppkey, region_r_regionkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ stock_s_i_id, stock_s_quantity, $expr1, stock_s_w_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ $expr1, stock_s_w_id, stock_s_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 14 { columns: [ region_r_regionkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ region_r_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ supplier_s_suppkey, nation_n_regionkey, supplier_s_nationkey, nation_n_nationkey, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ nation_n_regionkey, supplier_s_suppkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ vnode, r_regionkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 19 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ supplier_s_nationkey, supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ nation_n_nationkey, nation_n_regionkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 24 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 25 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 26 { columns: [ item_i_id, item_i_name, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ stock_s_i_id, stock_s_w_id, stock_s_quantity, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 29 { columns: [ stock_s_i_id, stock_s_w_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ vnode, i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 31 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 32 { columns: [ region_r_regionkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 33 { columns: [ region_r_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 34 { columns: [ supplier_s_suppkey, supplier_s_name, supplier_s_address, supplier_s_phone, supplier_s_comment, nation_n_name, nation_n_regionkey, supplier_s_nationkey, nation_n_nationkey, _rw_timestamp ], primary key: [ $6 ASC, $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 6 ], read pk prefix len hint: 1 }

    Table 35 { columns: [ nation_n_regionkey, supplier_s_suppkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 36 { columns: [ vnode, r_regionkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 37 { columns: [ supplier_s_suppkey, supplier_s_name, supplier_s_address, supplier_s_nationkey, supplier_s_phone, supplier_s_comment, _rw_timestamp ], primary key: [ $3 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 38 { columns: [ supplier_s_nationkey, supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 39 { columns: [ nation_n_nationkey, nation_n_name, nation_n_regionkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 40 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 41 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 42 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ s_suppkey, s_name, n_name, i_id, i_name, s_address, s_phone, s_comment, stock.s_i_id, stock.s_w_id, min(stock.s_quantity), $expr2, region.r_regionkey, supplier.s_nationkey, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $3 ASC, $8 ASC, $9 ASC, $10 ASC, $12 ASC, $13 ASC, $11 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ], distribution key: [ 8, 9, 10, 11, 12, 13 ], read pk prefix len hint: 9 }

- id: ch_q3
  before:
  - create_tables
  sql: "select   ol_o_id, ol_w_id, ol_d_id,\n         sum(ol_amount) as revenue, o_entry_d\nfrom \t customer, new_order, orders, order_line\nwhere \t c_state like 'a%'\n  and c_id = o_c_id\n  and c_w_id = o_w_id\n  and c_d_id = o_d_id\n  and no_w_id = o_w_id\n  and no_d_id = o_d_id\n  and no_o_id = o_id\n  and ol_w_id = o_w_id\n  and ol_d_id = o_d_id\n  and ol_o_id = o_id\n  and o_entry_d > '2007-01-02 00:00:00.000000'\ngroup by ol_o_id, ol_w_id, ol_d_id, o_entry_d\norder by revenue desc, o_entry_d;\n"
  logical_plan: |-
    LogicalProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, sum(order_line.ol_amount), orders.o_entry_d] }
    └─LogicalAgg { group_key: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, orders.o_entry_d], aggs: [sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, orders.o_entry_d, order_line.ol_amount] }
        └─LogicalFilter { predicate: Like(customer.c_state, 'a%':Varchar) AND (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id) AND (new_order.no_w_id = orders.o_w_id) AND (new_order.no_d_id = orders.o_d_id) AND (new_order.no_o_id = orders.o_id) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) AND (orders.o_entry_d > '2007-01-02 00:00:00':Timestamp) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_first, customer.c_middle, customer.c_last, customer.c_street_1, customer.c_street_2, customer.c_city, customer.c_state, customer.c_zip, customer.c_phone, customer.c_since, customer.c_credit, customer.c_credit_lim, customer.c_discount, customer.c_balance, customer.c_ytd_payment, customer.c_payment_cnt, customer.c_delivery_cnt, customer.c_data, customer._rw_timestamp] }
            │ │ └─LogicalScan { table: new_order, columns: [new_order.no_o_id, new_order.no_d_id, new_order.no_w_id, new_order._rw_timestamp] }
            │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
            └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, sum(order_line.ol_amount), orders.o_entry_d] }
    └─LogicalAgg { group_key: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, orders.o_entry_d], aggs: [sum(order_line.ol_amount)] }
      └─LogicalJoin { type: Inner, on: (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id), output: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, orders.o_entry_d, order_line.ol_amount] }
        ├─LogicalJoin { type: Inner, on: (new_order.no_w_id = orders.o_w_id) AND (new_order.no_d_id = orders.o_d_id) AND (new_order.no_o_id = orders.o_id), output: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d] }
        │ ├─LogicalJoin { type: Inner, on: (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id), output: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d] }
        │ │ ├─LogicalScan { table: customer, output_columns: [customer.c_id, customer.c_d_id, customer.c_w_id], required_columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], predicate: (customer.c_state >= 'a':Varchar) AND (customer.c_state < 'b':Varchar) }
        │ │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], predicate: (orders.o_entry_d > '2007-01-02 00:00:00':Timestamp) }
        │ └─LogicalScan { table: new_order, columns: [new_order.no_o_id, new_order.no_d_id, new_order.no_w_id] }
        └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount] }
  batch_plan: |-
    BatchExchange { order: [sum(order_line.ol_amount) DESC, orders.o_entry_d ASC], dist: Single }
    └─BatchProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, sum(order_line.ol_amount), orders.o_entry_d] }
      └─BatchSort { order: [sum(order_line.ol_amount) DESC, orders.o_entry_d ASC] }
        └─BatchHashAgg { group_key: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, orders.o_entry_d], aggs: [sum(order_line.ol_amount)] }
          └─BatchExchange { order: [], dist: HashShard(order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, orders.o_entry_d) }
            └─BatchHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, orders.o_entry_d, order_line.ol_amount] }
              ├─BatchExchange { order: [], dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
              │ └─BatchLookupJoin { type: Inner, predicate: orders.o_w_id = new_order.no_w_id AND orders.o_d_id = new_order.no_d_id AND orders.o_id = new_order.no_o_id, output: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d], lookup table: new_order }
              │   └─BatchExchange { order: [], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
              │     └─BatchHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d] }
              │       ├─BatchExchange { order: [], dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
              │       │ └─BatchProject { exprs: [customer.c_id, customer.c_d_id, customer.c_w_id] }
              │       │   └─BatchFilter { predicate: (customer.c_state >= 'a':Varchar) AND (customer.c_state < 'b':Varchar) }
              │       │     └─BatchScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], distribution: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
              │       └─BatchExchange { order: [], dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
              │         └─BatchFilter { predicate: (orders.o_entry_d > '2007-01-02 00:00:00':Timestamp) }
              │           └─BatchScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], distribution: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
              └─BatchExchange { order: [], dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
                └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [ol_o_id, ol_w_id, ol_d_id, revenue, o_entry_d], stream_key: [o_entry_d, ol_o_id, ol_d_id, ol_w_id], pk_columns: [revenue, o_entry_d, ol_o_id, ol_d_id, ol_w_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, sum(order_line.ol_amount), orders.o_entry_d] }
      └─StreamHashAgg { group_key: [orders.o_entry_d, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id], aggs: [sum(order_line.ol_amount), count] }
        └─StreamExchange { dist: HashShard(orders.o_entry_d, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
          └─StreamHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id AND new_order.no_w_id = orders.o_w_id AND new_order.no_d_id = orders.o_d_id AND new_order.no_o_id = orders.o_id AND customer.c_d_id = order_line.ol_d_id AND customer.c_w_id = order_line.ol_w_id AND new_order.no_o_id = order_line.ol_o_id AND new_order.no_d_id = order_line.ol_d_id AND new_order.no_w_id = order_line.ol_w_id, output: [orders.o_entry_d, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, customer.c_w_id, customer.c_d_id, customer.c_id, new_order.no_o_id, new_order.no_w_id, new_order.no_d_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number] }
            ├─StreamExchange { dist: HashShard(new_order.no_o_id, new_order.no_d_id, new_order.no_w_id) }
            │ └─StreamHashJoin { type: Inner, predicate: customer.c_d_id = new_order.no_d_id AND customer.c_w_id = new_order.no_w_id, output: all }
            │   ├─StreamExchange { dist: HashShard(customer.c_d_id, customer.c_w_id) }
            │   │ └─StreamProject { exprs: [customer.c_id, customer.c_d_id, customer.c_w_id] }
            │   │   └─StreamFilter { predicate: IsNotNull(customer.c_w_id) AND IsNotNull(customer.c_d_id) AND Like(customer.c_state, 'a%':Varchar) }
            │   │     └─StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
            │   └─StreamExchange { dist: HashShard(new_order.no_d_id, new_order.no_w_id) }
            │     └─StreamFilter { predicate: IsNotNull(new_order.no_w_id) AND IsNotNull(new_order.no_d_id) AND IsNotNull(new_order.no_o_id) }
            │       └─StreamTableScan { table: new_order, columns: [new_order.no_o_id, new_order.no_d_id, new_order.no_w_id], stream_scan_type: ArrangementBackfill, stream_key: [new_order.no_w_id, new_order.no_d_id, new_order.no_o_id], pk: [no_w_id, no_d_id, no_o_id], dist: UpstreamHashShard(new_order.no_w_id, new_order.no_d_id, new_order.no_o_id) }
            └─StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: all }
              ├─StreamExchange { dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
              │ └─StreamFilter { predicate: IsNotNull(orders.o_d_id) AND IsNotNull(orders.o_w_id) AND (orders.o_entry_d > '2007-01-02 00:00:00':Timestamp) }
              │   └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
              └─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
                └─StreamFilter { predicate: IsNotNull(order_line.ol_d_id) AND IsNotNull(order_line.ol_w_id) }
                  └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ol_o_id, ol_w_id, ol_d_id, revenue, o_entry_d], stream_key: [o_entry_d, ol_o_id, ol_d_id, ol_w_id], pk_columns: [revenue, o_entry_d, ol_o_id, ol_d_id, ol_w_id], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, sum(order_line.ol_amount), orders.o_entry_d] }
        └── StreamHashAgg { group_key: [orders.o_entry_d, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id], aggs: [sum(order_line.ol_amount), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0, 1, 2, 3]) from 1

    Fragment 1
    StreamHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id AND new_order.no_w_id = orders.o_w_id AND new_order.no_d_id = orders.o_d_id AND new_order.no_o_id = orders.o_id AND customer.c_d_id = order_line.ol_d_id AND customer.c_w_id = order_line.ol_w_id AND new_order.no_o_id = order_line.ol_o_id AND new_order.no_d_id = order_line.ol_d_id AND new_order.no_w_id = order_line.ol_w_id, output: [orders.o_entry_d, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, customer.c_w_id, customer.c_d_id, customer.c_id, new_order.no_o_id, new_order.no_w_id, new_order.no_d_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number] }
    ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
    ├── StreamExchange Hash([3, 4, 5]) from 2
    └── StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: all } { tables: [ HashJoinLeft: 11, HashJoinDegreeLeft: 12, HashJoinRight: 13, HashJoinDegreeRight: 14 ] }
        ├── StreamExchange Hash([0, 1, 2]) from 5
        └── StreamExchange Hash([0, 1, 2]) from 6

    Fragment 2
    StreamHashJoin { type: Inner, predicate: customer.c_d_id = new_order.no_d_id AND customer.c_w_id = new_order.no_w_id, output: all } { tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ] }
    ├── StreamExchange Hash([1, 2]) from 3
    └── StreamExchange Hash([1, 2]) from 4

    Fragment 3
    StreamProject { exprs: [customer.c_id, customer.c_d_id, customer.c_w_id] }
    └── StreamFilter { predicate: IsNotNull(customer.c_w_id) AND IsNotNull(customer.c_d_id) AND Like(customer.c_state, 'a%':Varchar) }
        └── StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) } { tables: [ StreamScan: 9 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 4
    StreamFilter { predicate: IsNotNull(new_order.no_w_id) AND IsNotNull(new_order.no_d_id) AND IsNotNull(new_order.no_o_id) }
    └── StreamTableScan { table: new_order, columns: [new_order.no_o_id, new_order.no_d_id, new_order.no_w_id], stream_scan_type: ArrangementBackfill, stream_key: [new_order.no_w_id, new_order.no_d_id, new_order.no_o_id], pk: [no_w_id, no_d_id, no_o_id], dist: UpstreamHashShard(new_order.no_w_id, new_order.no_d_id, new_order.no_o_id) } { tables: [ StreamScan: 10 ] }
        ├── Upstream
        └── BatchPlanNode

    Fragment 5
    StreamFilter { predicate: IsNotNull(orders.o_d_id) AND IsNotNull(orders.o_w_id) AND (orders.o_entry_d > '2007-01-02 00:00:00':Timestamp) }
    └── StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) } { tables: [ StreamScan: 15 ] }
        ├── Upstream
        └── BatchPlanNode

    Fragment 6
    StreamFilter { predicate: IsNotNull(order_line.ol_d_id) AND IsNotNull(order_line.ol_w_id) }
    └── StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) } { tables: [ StreamScan: 16 ] }
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ orders_o_entry_d, order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, sum(order_line_ol_amount), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4, 5 ], distribution key: [ 0, 1, 2, 3 ], read pk prefix len hint: 4 }

    Table 1 { columns: [ customer_c_id, customer_c_d_id, customer_c_w_id, new_order_no_o_id, new_order_no_d_id, new_order_no_w_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $5 ASC, $4 ASC, $3 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 3, 4, 5 ], read pk prefix len hint: 11 }

    Table 2 { columns: [ customer_c_id, customer_c_w_id, customer_c_d_id, new_order_no_w_id, new_order_no_d_id, new_order_no_o_id, customer_c_d_id_0, customer_c_w_id_0, new_order_no_o_id_0, new_order_no_d_id_0, new_order_no_w_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC ], value indices: [ 11 ], distribution key: [ 5, 4, 3 ], read pk prefix len hint: 11 }

    Table 3 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_c_id, orders_o_entry_d, order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_amount, order_line_ol_number, _rw_timestamp ], primary key: [ $3 ASC, $2 ASC, $1 ASC, $2 ASC, $1 ASC, $0 ASC, $6 ASC, $7 ASC, $5 ASC, $6 ASC, $7 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 11 }

    Table 4 { columns: [ orders_o_c_id, orders_o_w_id, orders_o_d_id, orders_o_w_id_0, orders_o_d_id_0, orders_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_o_id, order_line_ol_d_id_0, order_line_ol_w_id_0, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC ], value indices: [ 12 ], distribution key: [ 5, 4, 3 ], read pk prefix len hint: 11 }

    Table 5 { columns: [ customer_c_id, customer_c_d_id, customer_c_w_id, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1, 2 ], read pk prefix len hint: 2 }

    Table 6 { columns: [ customer_c_d_id, customer_c_w_id, customer_c_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 7 { columns: [ new_order_no_o_id, new_order_no_d_id, new_order_no_w_id, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1, 2 ], read pk prefix len hint: 2 }

    Table 8 { columns: [ new_order_no_d_id, new_order_no_w_id, new_order_no_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 9 { columns: [ vnode, c_w_id, c_d_id, c_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 10 { columns: [ vnode, no_w_id, no_d_id, no_o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 11 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_c_id, orders_o_entry_d, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 12 { columns: [ orders_o_w_id, orders_o_d_id, orders_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 13 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_amount, order_line_ol_number, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 14 { columns: [ order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 15 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 16 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ ol_o_id, ol_w_id, ol_d_id, revenue, o_entry_d, _rw_timestamp ], primary key: [ $3 DESC, $4 ASC, $0 ASC, $2 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 4, 0, 2, 1 ], read pk prefix len hint: 5 }

- id: ch_q4
  before:
  - create_tables
  sql: "select\to_ol_cnt, count(*) as order_count\nfrom\torders\nwhere\n  o_entry_d >= '2007-01-02 00:00:00.000000'\n  and o_entry_d < '2032-01-02 00:00:00.000000'\n  and exists (select *\n              from order_line\n              where o_id = ol_o_id\n                and o_w_id = ol_w_id\n                and o_d_id = ol_d_id\n                and ol_delivery_d >= o_entry_d)\ngroup\tby o_ol_cnt\norder\tby o_ol_cnt;\n"
  logical_plan: |-
    LogicalProject { exprs: [orders.o_ol_cnt, count] }
    └─LogicalAgg { group_key: [orders.o_ol_cnt], aggs: [count] }
      └─LogicalProject { exprs: [orders.o_ol_cnt] }
        └─LogicalFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d < '2032-01-02 00:00:00':Timestamp) }
          └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
            ├─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
            └─LogicalProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info] }
              └─LogicalFilter { predicate: (CorrelatedInputRef { index: 0, correlated_id: 1 } = order_line.ol_o_id) AND (CorrelatedInputRef { index: 2, correlated_id: 1 } = order_line.ol_w_id) AND (CorrelatedInputRef { index: 1, correlated_id: 1 } = order_line.ol_d_id) AND (order_line.ol_delivery_d >= CorrelatedInputRef { index: 4, correlated_id: 1 }) }
                └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [orders.o_ol_cnt], aggs: [count] }
    └─LogicalJoin { type: LeftSemi, on: (orders.o_id = order_line.ol_o_id) AND (orders.o_w_id = order_line.ol_w_id) AND (orders.o_d_id = order_line.ol_d_id) AND (order_line.ol_delivery_d >= orders.o_entry_d), output: [orders.o_ol_cnt] }
      ├─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt], predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d < '2032-01-02 00:00:00':Timestamp) }
      └─LogicalProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_delivery_d] }
        └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d] }
  batch_plan: |-
    BatchExchange { order: [orders.o_ol_cnt ASC], dist: Single }
    └─BatchSort { order: [orders.o_ol_cnt ASC] }
      └─BatchHashAgg { group_key: [orders.o_ol_cnt], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(orders.o_ol_cnt) }
          └─BatchHashJoin { type: LeftSemi, predicate: orders.o_id = order_line.ol_o_id AND orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND (order_line.ol_delivery_d >= orders.o_entry_d), output: [orders.o_ol_cnt] }
            ├─BatchExchange { order: [], dist: HashShard(orders.o_id, orders.o_w_id, orders.o_d_id) }
            │ └─BatchFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d < '2032-01-02 00:00:00':Timestamp) }
            │   └─BatchScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt], distribution: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
            └─BatchExchange { order: [], dist: HashShard(order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id) }
              └─BatchProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_delivery_d] }
                └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [o_ol_cnt, order_count], stream_key: [o_ol_cnt], pk_columns: [o_ol_cnt], pk_conflict: NoCheck }
    └─StreamHashAgg { group_key: [orders.o_ol_cnt], aggs: [count] }
      └─StreamExchange { dist: HashShard(orders.o_ol_cnt) }
        └─StreamHashJoin { type: LeftSemi, predicate: orders.o_id = order_line.ol_o_id AND orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND (order_line.ol_delivery_d >= orders.o_entry_d), output: [orders.o_ol_cnt, orders.o_w_id, orders.o_d_id, orders.o_id] }
          ├─StreamExchange { dist: HashShard(orders.o_id, orders.o_w_id, orders.o_d_id) }
          │ └─StreamFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d < '2032-01-02 00:00:00':Timestamp) }
          │   └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
          └─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id) }
            └─StreamProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_delivery_d, order_line.ol_number] }
              └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [o_ol_cnt, order_count], stream_key: [o_ol_cnt], pk_columns: [o_ol_cnt], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamHashAgg { group_key: [orders.o_ol_cnt], aggs: [count] } { tables: [ HashAggState: 0 ] }
        └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamHashJoin { type: LeftSemi, predicate: orders.o_id = order_line.ol_o_id AND orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND (order_line.ol_delivery_d >= orders.o_entry_d), output: [orders.o_ol_cnt, orders.o_w_id, orders.o_d_id, orders.o_id] }
    ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
    ├── StreamExchange Hash([0, 2, 1]) from 2
    └── StreamExchange Hash([0, 1, 2]) from 3

    Fragment 2
    StreamFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d < '2032-01-02 00:00:00':Timestamp) }
    └── StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
        ├── tables: [ StreamScan: 5 ]
        ├── Upstream
        └── BatchPlanNode

    Fragment 3
    StreamProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_delivery_d, order_line.ol_number] }
    └── StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
        ├── tables: [ StreamScan: 6 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ orders_o_ol_cnt, count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_entry_d, orders_o_ol_cnt, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 2, 1 ], read pk prefix len hint: 3 }

    Table 2 { columns: [ orders_o_id, orders_o_w_id, orders_o_d_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 3 { columns: [ order_line_ol_o_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_delivery_d, order_line_ol_number, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 4 { columns: [ order_line_ol_o_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 5 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 6 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ o_ol_cnt, order_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: ch_q5
  before:
  - create_tables
  sql: "select\t n_name,\n       sum(ol_amount) as revenue\nfrom\t customer, orders, order_line, stock, supplier, nation, region\nwhere\t c_id = o_c_id\nand c_w_id = o_w_id\nand c_d_id = o_d_id\nand ol_o_id = o_id\nand ol_w_id = o_w_id\nand ol_d_id=o_d_id\nand ol_w_id = s_w_id\nand ol_i_id = s_i_id\nand mod((s_w_id * s_i_id),10000) = s_suppkey\nand ascii(substr(c_state,1,1)) - 65 = s_nationkey\nand s_nationkey = n_nationkey\nand n_regionkey = r_regionkey\nand r_name = 'EUROPE'\nand o_entry_d >= '2007-01-02 00:00:00.000000'\ngroup by n_name;\n"
  logical_plan: |-
    LogicalProject { exprs: [nation.n_name, sum(order_line.ol_amount)] }
    └─LogicalAgg { group_key: [nation.n_name], aggs: [sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [nation.n_name, order_line.ol_amount] }
        └─LogicalFilter { predicate: (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_w_id = stock.s_w_id) AND (order_line.ol_i_id = stock.s_i_id) AND (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey) AND ((Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32) = supplier.s_nationkey) AND (supplier.s_nationkey = nation.n_nationkey) AND (nation.n_regionkey = region.r_regionkey) AND (region.r_name = 'EUROPE':Varchar) AND (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ │ ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_first, customer.c_middle, customer.c_last, customer.c_street_1, customer.c_street_2, customer.c_city, customer.c_state, customer.c_zip, customer.c_phone, customer.c_since, customer.c_credit, customer.c_credit_lim, customer.c_discount, customer.c_balance, customer.c_ytd_payment, customer.c_payment_cnt, customer.c_delivery_cnt, customer.c_data, customer._rw_timestamp] }
            │ │ │ │ │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
            │ │ │ │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
            │ │ │ └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
            │ │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
            │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
            └─LogicalScan { table: region, columns: [region.r_regionkey, region.r_name, region.r_comment, region._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [nation.n_name], aggs: [sum(order_line.ol_amount)] }
    └─LogicalJoin { type: Inner, on: (nation.n_regionkey = region.r_regionkey), output: [nation.n_name, order_line.ol_amount] }
      ├─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [order_line.ol_amount, nation.n_name, nation.n_regionkey] }
      │ ├─LogicalJoin { type: Inner, on: ($expr1 = supplier.s_suppkey) AND ($expr2 = supplier.s_nationkey), output: [order_line.ol_amount, supplier.s_nationkey] }
      │ │ ├─LogicalProject { exprs: [order_line.ol_amount, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2] }
      │ │ │ └─LogicalJoin { type: Inner, on: (order_line.ol_w_id = stock.s_w_id) AND (order_line.ol_i_id = stock.s_i_id), output: [customer.c_state, order_line.ol_amount, stock.s_i_id, stock.s_w_id] }
      │ │ │   ├─LogicalJoin { type: Inner, on: (order_line.ol_o_id = orders.o_id) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id), output: [customer.c_state, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount] }
      │ │ │   │ ├─LogicalJoin { type: Inner, on: (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id), output: [customer.c_state, orders.o_id, orders.o_d_id, orders.o_w_id] }
      │ │ │   │ │ ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state] }
      │ │ │   │ │ └─LogicalScan { table: orders, output_columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id], required_columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) }
      │ │ │   │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount] }
      │ │ │   └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id] }
      │ │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey] }
      │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey] }
      └─LogicalScan { table: region, output_columns: [region.r_regionkey], required_columns: [region.r_regionkey, region.r_name], predicate: (region.r_name = 'EUROPE':Varchar) }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashAgg { group_key: [nation.n_name], aggs: [sum(order_line.ol_amount)] }
      └─BatchExchange { order: [], dist: HashShard(nation.n_name) }
        └─BatchLookupJoin { type: Inner, predicate: nation.n_regionkey = region.r_regionkey AND (region.r_name = 'EUROPE':Varchar), output: [nation.n_name, order_line.ol_amount], lookup table: region }
          └─BatchExchange { order: [], dist: UpstreamHashShard(nation.n_regionkey) }
            └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [order_line.ol_amount, nation.n_name, nation.n_regionkey], lookup table: nation }
              └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
                └─BatchLookupJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey AND $expr2 = supplier.s_nationkey, output: [order_line.ol_amount, supplier.s_nationkey], lookup table: supplier }
                  └─BatchExchange { order: [], dist: UpstreamHashShard($expr1) }
                    └─BatchProject { exprs: [order_line.ol_amount, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2] }
                      └─BatchLookupJoin { type: Inner, predicate: order_line.ol_w_id = stock.s_w_id AND order_line.ol_i_id = stock.s_i_id, output: [customer.c_state, order_line.ol_amount, stock.s_i_id, stock.s_w_id], lookup table: stock }
                        └─BatchExchange { order: [], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_i_id) }
                          └─BatchHashJoin { type: Inner, predicate: orders.o_id = order_line.ol_o_id AND orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id, output: [customer.c_state, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount] }
                            ├─BatchExchange { order: [], dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
                            │ └─BatchHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_state, orders.o_id, orders.o_d_id, orders.o_w_id] }
                            │   ├─BatchExchange { order: [], dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
                            │   │ └─BatchScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], distribution: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
                            │   └─BatchExchange { order: [], dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
                            │     └─BatchProject { exprs: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id] }
                            │       └─BatchFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) }
                            │         └─BatchScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], distribution: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
                            └─BatchExchange { order: [], dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
                              └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [n_name], pk_conflict: NoCheck }
    └─StreamProject { exprs: [nation.n_name, sum(order_line.ol_amount)] }
      └─StreamHashAgg { group_key: [nation.n_name], aggs: [sum(order_line.ol_amount), count] }
        └─StreamExchange { dist: HashShard(nation.n_name) }
          └─StreamHashJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey AND $expr2 = supplier.s_nationkey, output: [order_line.ol_amount, nation.n_name, customer.c_w_id, customer.c_d_id, customer.c_id, orders.o_id, order_line.ol_number, order_line.ol_i_id, orders.o_w_id, orders.o_d_id, $expr1, $expr2, region.r_regionkey, supplier.s_suppkey, supplier.s_nationkey] }
            ├─StreamExchange { dist: HashShard($expr1, $expr2) }
            │ └─StreamProject { exprs: [order_line.ol_amount, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2, customer.c_w_id, customer.c_d_id, customer.c_id, orders.o_id, order_line.ol_number, order_line.ol_i_id, orders.o_w_id, orders.o_d_id] }
            │   └─StreamHashJoin { type: Inner, predicate: orders.o_id = order_line.ol_o_id AND orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND customer.c_d_id = order_line.ol_d_id AND customer.c_w_id = order_line.ol_w_id AND orders.o_w_id = stock.s_w_id, output: [customer.c_state, order_line.ol_amount, stock.s_i_id, stock.s_w_id, customer.c_w_id, customer.c_d_id, customer.c_id, orders.o_id, orders.o_w_id, orders.o_d_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id] }
            │     ├─StreamExchange { dist: HashShard(orders.o_id, customer.c_d_id, customer.c_w_id, orders.o_w_id) }
            │     │ └─StreamHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_d_id, customer.c_w_id, customer.c_state, orders.o_id, orders.o_d_id, orders.o_w_id, customer.c_id] }
            │     │   ├─StreamExchange { dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
            │     │   │ └─StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
            │     │   └─StreamExchange { dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
            │     │     └─StreamProject { exprs: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id] }
            │     │       └─StreamFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) }
            │     │         └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
            │     └─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, stock.s_w_id) }
            │       └─StreamHashJoin { type: Inner, predicate: order_line.ol_w_id = stock.s_w_id AND order_line.ol_i_id = stock.s_i_id, output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, stock.s_i_id, stock.s_w_id, order_line.ol_number, order_line.ol_i_id] }
            │         ├─StreamExchange { dist: HashShard(order_line.ol_w_id, order_line.ol_i_id) }
            │         │ └─StreamFilter { predicate: IsNotNull(order_line.ol_d_id) }
            │         │   └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
            │         └─StreamExchange { dist: HashShard(stock.s_w_id, stock.s_i_id) }
            │           └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
            └─StreamExchange { dist: HashShard(supplier.s_suppkey, supplier.s_nationkey) }
              └─StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [supplier.s_suppkey, supplier.s_nationkey, nation.n_name, region.r_regionkey] }
                ├─StreamExchange { dist: HashShard(region.r_regionkey) }
                │ └─StreamProject { exprs: [region.r_regionkey] }
                │   └─StreamFilter { predicate: (region.r_name = 'EUROPE':Varchar) }
                │     └─StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], stream_scan_type: ArrangementBackfill, stream_key: [region.r_regionkey], pk: [r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
                └─StreamExchange { dist: HashShard(nation.n_regionkey) }
                  └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, supplier.s_nationkey, nation.n_name, nation.n_regionkey, nation.n_nationkey] }
                    ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                    │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                    └─StreamExchange { dist: HashShard(nation.n_nationkey) }
                      └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [n_name], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [nation.n_name, sum(order_line.ol_amount)] }
        └── StreamHashAgg { group_key: [nation.n_name], aggs: [sum(order_line.ol_amount), count] }
            ├── tables: [ HashAggState: 0 ]
            └── StreamExchange Hash([1]) from 1

    Fragment 1
    StreamHashJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey AND $expr2 = supplier.s_nationkey, output: [order_line.ol_amount, nation.n_name, customer.c_w_id, customer.c_d_id, customer.c_id, orders.o_id, order_line.ol_number, order_line.ol_i_id, orders.o_w_id, orders.o_d_id, $expr1, $expr2, region.r_regionkey, supplier.s_suppkey, supplier.s_nationkey] }
    ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
    ├── StreamExchange Hash([1, 2]) from 2
    └── StreamExchange Hash([0, 1]) from 9

    Fragment 2
    StreamProject { exprs: [order_line.ol_amount, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2, customer.c_w_id, customer.c_d_id, customer.c_id, orders.o_id, order_line.ol_number, order_line.ol_i_id, orders.o_w_id, orders.o_d_id] }
    └── StreamHashJoin { type: Inner, predicate: orders.o_id = order_line.ol_o_id AND orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND customer.c_d_id = order_line.ol_d_id AND customer.c_w_id = order_line.ol_w_id AND orders.o_w_id = stock.s_w_id, output: [customer.c_state, order_line.ol_amount, stock.s_i_id, stock.s_w_id, customer.c_w_id, customer.c_d_id, customer.c_id, orders.o_id, orders.o_w_id, orders.o_d_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id] }
        ├── tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ]
        ├── StreamExchange Hash([3, 0, 1, 5]) from 3
        └── StreamExchange Hash([0, 1, 2, 5]) from 6

    Fragment 3
    StreamHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_d_id, customer.c_w_id, customer.c_state, orders.o_id, orders.o_d_id, orders.o_w_id, customer.c_id] } { tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ] }
    ├── StreamExchange Hash([1, 2, 0]) from 4
    └── StreamExchange Hash([1, 2, 3]) from 5

    Fragment 4
    StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) } { tables: [ StreamScan: 13 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 5
    StreamProject { exprs: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id] }
    └── StreamFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) }
        └── StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) } { tables: [ StreamScan: 14 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 6
    StreamHashJoin { type: Inner, predicate: order_line.ol_w_id = stock.s_w_id AND order_line.ol_i_id = stock.s_i_id, output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, stock.s_i_id, stock.s_w_id, order_line.ol_number, order_line.ol_i_id] } { tables: [ HashJoinLeft: 15, HashJoinDegreeLeft: 16, HashJoinRight: 17, HashJoinDegreeRight: 18 ] }
    ├── StreamExchange Hash([2, 3]) from 7
    └── StreamExchange Hash([1, 0]) from 8

    Fragment 7
    StreamFilter { predicate: IsNotNull(order_line.ol_d_id) }
    └── StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) } { tables: [ StreamScan: 19 ] }
        ├── Upstream
        └── BatchPlanNode

    Fragment 8
    StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) } { tables: [ StreamScan: 20 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 9
    StreamHashJoin { type: Inner, predicate: region.r_regionkey = nation.n_regionkey, output: [supplier.s_suppkey, supplier.s_nationkey, nation.n_name, region.r_regionkey] } { tables: [ HashJoinLeft: 21, HashJoinDegreeLeft: 22, HashJoinRight: 23, HashJoinDegreeRight: 24 ] }
    ├── StreamExchange Hash([0]) from 10
    └── StreamExchange Hash([3]) from 11

    Fragment 10
    StreamProject { exprs: [region.r_regionkey] }
    └── StreamFilter { predicate: (region.r_name = 'EUROPE':Varchar) }
        └── StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], stream_scan_type: ArrangementBackfill, stream_key: [region.r_regionkey], pk: [r_regionkey], dist: UpstreamHashShard(region.r_regionkey) } { tables: [ StreamScan: 25 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 11
    StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, supplier.s_nationkey, nation.n_name, nation.n_regionkey, nation.n_nationkey] } { tables: [ HashJoinLeft: 26, HashJoinDegreeLeft: 27, HashJoinRight: 28, HashJoinDegreeRight: 29 ] }
    ├── StreamExchange Hash([1]) from 12
    └── StreamExchange Hash([0]) from 13

    Fragment 12
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) } { tables: [ StreamScan: 30 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 13
    StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 31 ] }
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ nation_n_name, sum(order_line_ol_amount), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ order_line_ol_amount, $expr1, $expr2, customer_c_w_id, customer_c_d_id, customer_c_id, orders_o_id, order_line_ol_number, order_line_ol_i_id, orders_o_w_id, orders_o_d_id, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], distribution key: [ 1, 2 ], read pk prefix len hint: 2 }

    Table 2 { columns: [ $expr1, $expr2, customer_c_w_id, customer_c_d_id, customer_c_id, orders_o_id, order_line_ol_number, order_line_ol_i_id, orders_o_w_id, orders_o_d_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 3 { columns: [ supplier_s_suppkey, supplier_s_nationkey, nation_n_name, region_r_regionkey, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 4 { columns: [ supplier_s_suppkey, supplier_s_nationkey, region_r_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 5 { columns: [ customer_c_d_id, customer_c_w_id, customer_c_state, orders_o_id, orders_o_d_id, orders_o_w_id, customer_c_id, _rw_timestamp ], primary key: [ $3 ASC, $5 ASC, $4 ASC, $0 ASC, $1 ASC, $5 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 3, 0, 1, 5 ], read pk prefix len hint: 6 }

    Table 6 { columns: [ orders_o_id, orders_o_w_id, orders_o_d_id, customer_c_d_id, customer_c_w_id, orders_o_w_id_0, customer_c_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC ], value indices: [ 7 ], distribution key: [ 0, 3, 4, 5 ], read pk prefix len hint: 6 }

    Table 7 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_amount, stock_s_i_id, stock_s_w_id, order_line_ol_number, order_line_ol_i_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $1 ASC, $2 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0, 1, 2, 5 ], read pk prefix len hint: 6 }

    Table 8 { columns: [ order_line_ol_o_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_d_id_0, order_line_ol_w_id_0, stock_s_w_id, order_line_ol_number, order_line_ol_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0, 3, 4, 5 ], read pk prefix len hint: 6 }

    Table 9 { columns: [ customer_c_id, customer_c_d_id, customer_c_w_id, customer_c_state, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1, 2, 0 ], read pk prefix len hint: 3 }

    Table 10 { columns: [ customer_c_id, customer_c_w_id, customer_c_d_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 11 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_c_id, _rw_timestamp ], primary key: [ $3 ASC, $2 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1, 2, 3 ], read pk prefix len hint: 3 }

    Table 12 { columns: [ orders_o_c_id, orders_o_w_id, orders_o_d_id, orders_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 13 { columns: [ vnode, c_w_id, c_d_id, c_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 14 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 15 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_i_id, order_line_ol_amount, order_line_ol_number, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC, $1 ASC, $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2, 3 ], read pk prefix len hint: 2 }

    Table 16 { columns: [ order_line_ol_w_id, order_line_ol_i_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 17 { columns: [ stock_s_i_id, stock_s_w_id, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 1, 0 ], read pk prefix len hint: 2 }

    Table 18 { columns: [ stock_s_w_id, stock_s_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 19 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 20 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 21 { columns: [ region_r_regionkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ region_r_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ supplier_s_suppkey, supplier_s_nationkey, nation_n_name, nation_n_regionkey, nation_n_nationkey, _rw_timestamp ], primary key: [ $3 ASC, $0 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ nation_n_regionkey, supplier_s_suppkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ vnode, r_regionkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 26 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ supplier_s_nationkey, supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ nation_n_nationkey, nation_n_name, nation_n_regionkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 29 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 31 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ n_name, revenue, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: ch_q6
  before:
  - create_tables
  sql: "select\tsum(ol_amount) as revenue\nfrom\torder_line\nwhere\nol_delivery_d >= '1997-01-01 00:00:00'\nand ol_delivery_d < '2030-01-01 00:00:00'\nand ol_quantity between 1 and 100000;\n"
  logical_plan: |-
    LogicalProject { exprs: [sum(order_line.ol_amount)] }
    └─LogicalAgg { aggs: [sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [order_line.ol_amount] }
        └─LogicalFilter { predicate: (order_line.ol_delivery_d >= '1997-01-01 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) AND (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 100000:Int32) }
          └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { aggs: [sum(order_line.ol_amount)] }
    └─LogicalScan { table: order_line, output_columns: [order_line.ol_amount], required_columns: [order_line.ol_amount, order_line.ol_delivery_d, order_line.ol_quantity], predicate: (order_line.ol_delivery_d >= '1997-01-01 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) AND (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 100000:Int32) }
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum(sum(order_line.ol_amount))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [sum(order_line.ol_amount)] }
        └─BatchProject { exprs: [order_line.ol_amount] }
          └─BatchFilter { predicate: (order_line.ol_delivery_d >= '1997-01-01 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) AND (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 100000:Int32) }
            └─BatchScan { table: order_line, columns: [order_line.ol_amount, order_line.ol_delivery_d, order_line.ol_quantity], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [revenue], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum(sum(order_line.ol_amount))] }
      └─StreamSimpleAgg { aggs: [sum(sum(order_line.ol_amount)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [sum(order_line.ol_amount)] }
            └─StreamProject { exprs: [order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
              └─StreamFilter { predicate: (order_line.ol_delivery_d >= '1997-01-01 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) AND (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 100000:Int32) }
                └─StreamTableScan { table: order_line, columns: [order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_delivery_d, order_line.ol_quantity], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [revenue], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [sum(sum(order_line.ol_amount))] }
        └── StreamSimpleAgg { aggs: [sum(sum(order_line.ol_amount)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [sum(order_line.ol_amount)] }
    └── StreamProject { exprs: [order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
        └── StreamFilter { predicate: (order_line.ol_delivery_d >= '1997-01-01 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) AND (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 100000:Int32) }
            └── StreamTableScan { table: order_line, columns: [order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_delivery_d, order_line.ol_quantity], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
                ├── tables: [ StreamScan: 1 ]
                ├── Upstream
                └── BatchPlanNode

    Table 0 { columns: [ sum(sum(order_line_ol_amount)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ revenue, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: ch_q7
  before:
  - create_tables
  sql: "select\t s_nationkey as supp_nation,\n           substr(c_state,1,1) as cust_nation,\n           extract(year from o_entry_d) as l_year,\n           sum(ol_amount) as revenue\nfrom\t supplier, stock, order_line, orders, customer, nation n1, nation n2\nwhere\t ol_supply_w_id = s_w_id\n  and ol_i_id = s_i_id\n  and mod((s_w_id * s_i_id), 10000) = s_suppkey\n  and ol_w_id = o_w_id\n  and ol_d_id = o_d_id\n  and ol_o_id = o_id\n  and c_id = o_c_id\n  and c_w_id = o_w_id\n  and c_d_id = o_d_id\n  and s_nationkey = n1.n_nationkey\n  and ascii(substr(c_state,1,1)) - 65 = n2.n_nationkey\n  and (\n        (n1.n_name = 'JAPAN' and n2.n_name = 'CHINA')\n        or\n        (n1.n_name = 'CHINA' and n2.n_name = 'JAPAN')\n    )\n  and ol_delivery_d between '2007-01-02 00:00:00.000000' and '2032-01-02 00:00:00.000000'\ngroup by s_nationkey, substr(c_state,1,1), extract(year from o_entry_d)\norder by s_nationkey, cust_nation, l_year;\n"
  logical_plan: |-
    LogicalProject { exprs: [supplier.s_nationkey, $expr1, $expr2, sum(order_line.ol_amount)] }
    └─LogicalProject { exprs: [supplier.s_nationkey, $expr1, $expr2, sum(order_line.ol_amount), supplier.s_nationkey] }
      └─LogicalAgg { group_key: [supplier.s_nationkey, $expr1, $expr2], aggs: [sum(order_line.ol_amount)] }
        └─LogicalProject { exprs: [supplier.s_nationkey, Substr(customer.c_state, 1:Int32, 1:Int32) as $expr1, Extract('YEAR':Varchar, orders.o_entry_d) as $expr2, order_line.ol_amount] }
          └─LogicalFilter { predicate: (order_line.ol_supply_w_id = stock.s_w_id) AND (order_line.ol_i_id = stock.s_i_id) AND (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) AND (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id) AND (supplier.s_nationkey = nation.n_nationkey) AND ((Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32) = nation.n_nationkey) AND (((nation.n_name = 'JAPAN':Varchar) AND (nation.n_name = 'CHINA':Varchar)) OR ((nation.n_name = 'CHINA':Varchar) AND (nation.n_name = 'JAPAN':Varchar))) AND (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d <= '2032-01-02 00:00:00':Timestamp) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ │ ├─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
              │ │ │ │ │ └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
              │ │ │ │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
              │ │ │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
              │ │ └─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_first, customer.c_middle, customer.c_last, customer.c_street_1, customer.c_street_2, customer.c_city, customer.c_state, customer.c_zip, customer.c_phone, customer.c_since, customer.c_credit, customer.c_credit_lim, customer.c_discount, customer.c_balance, customer.c_ytd_payment, customer.c_payment_cnt, customer.c_delivery_cnt, customer.c_data, customer._rw_timestamp] }
              │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
              └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [supplier.s_nationkey, $expr3, $expr4, sum(order_line.ol_amount), supplier.s_nationkey] }
    └─LogicalAgg { group_key: [supplier.s_nationkey, $expr3, $expr4], aggs: [sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [supplier.s_nationkey, Substr(customer.c_state, 1:Int32, 1:Int32) as $expr3, Extract('YEAR':Varchar, orders.o_entry_d) as $expr4, order_line.ol_amount] }
        └─LogicalJoin { type: Inner, on: ($expr2 = nation.n_nationkey) AND (((nation.n_name = 'JAPAN':Varchar) AND (nation.n_name = 'CHINA':Varchar)) OR ((nation.n_name = 'CHINA':Varchar) AND (nation.n_name = 'JAPAN':Varchar))), output: [supplier.s_nationkey, order_line.ol_amount, orders.o_entry_d, customer.c_state] }
          ├─LogicalProject { exprs: [order_line.ol_amount, orders.o_entry_d, customer.c_state, supplier.s_nationkey, nation.n_name, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2] }
          │ └─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [order_line.ol_amount, orders.o_entry_d, customer.c_state, supplier.s_nationkey, nation.n_name] }
          │   ├─LogicalJoin { type: Inner, on: ($expr1 = supplier.s_suppkey), output: [order_line.ol_amount, orders.o_entry_d, customer.c_state, supplier.s_nationkey] }
          │   │ ├─LogicalProject { exprs: [order_line.ol_amount, orders.o_entry_d, customer.c_state, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
          │   │ │ └─LogicalJoin { type: Inner, on: (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id), output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state] }
          │   │ │   ├─LogicalJoin { type: Inner, on: (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id), output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d] }
          │   │ │   │ ├─LogicalJoin { type: Inner, on: (order_line.ol_supply_w_id = stock.s_w_id) AND (order_line.ol_i_id = stock.s_i_id), output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount] }
          │   │ │   │ │ ├─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id] }
          │   │ │   │ │ └─LogicalScan { table: order_line, output_columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount], required_columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_delivery_d], predicate: (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d <= '2032-01-02 00:00:00':Timestamp) }
          │   │ │   │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d] }
          │   │ │   └─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state] }
          │   │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey] }
          │   └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name] }
          └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name] }
  batch_plan: |-
    BatchProject { exprs: [supplier.s_nationkey, $expr3, $expr4, sum(order_line.ol_amount)] }
    └─BatchExchange { order: [supplier.s_nationkey ASC, $expr3 ASC, $expr4 ASC], dist: Single }
      └─BatchProject { exprs: [supplier.s_nationkey, $expr3, $expr4, sum(order_line.ol_amount), supplier.s_nationkey] }
        └─BatchSort { order: [supplier.s_nationkey ASC, $expr3 ASC, $expr4 ASC] }
          └─BatchHashAgg { group_key: [supplier.s_nationkey, $expr3, $expr4], aggs: [sum(order_line.ol_amount)] }
            └─BatchExchange { order: [], dist: HashShard(supplier.s_nationkey, $expr3, $expr4) }
              └─BatchProject { exprs: [supplier.s_nationkey, Substr(customer.c_state, 1:Int32, 1:Int32) as $expr3, Extract('YEAR':Varchar, orders.o_entry_d) as $expr4, order_line.ol_amount] }
                └─BatchLookupJoin { type: Inner, predicate: $expr2 = nation.n_nationkey AND (((nation.n_name = 'JAPAN':Varchar) AND (nation.n_name = 'CHINA':Varchar)) OR ((nation.n_name = 'CHINA':Varchar) AND (nation.n_name = 'JAPAN':Varchar))), output: [supplier.s_nationkey, order_line.ol_amount, orders.o_entry_d, customer.c_state], lookup table: nation }
                  └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
                    └─BatchProject { exprs: [order_line.ol_amount, orders.o_entry_d, customer.c_state, supplier.s_nationkey, nation.n_name, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2] }
                      └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [order_line.ol_amount, orders.o_entry_d, customer.c_state, supplier.s_nationkey, nation.n_name], lookup table: nation }
                        └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
                          └─BatchLookupJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [order_line.ol_amount, orders.o_entry_d, customer.c_state, supplier.s_nationkey], lookup table: supplier }
                            └─BatchExchange { order: [], dist: UpstreamHashShard($expr1) }
                              └─BatchProject { exprs: [order_line.ol_amount, orders.o_entry_d, customer.c_state, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
                                └─BatchLookupJoin { type: Inner, predicate: orders.o_w_id = customer.c_w_id AND orders.o_d_id = customer.c_d_id AND orders.o_c_id = customer.c_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state], lookup table: customer }
                                  └─BatchExchange { order: [], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_c_id) }
                                    └─BatchLookupJoin { type: Inner, predicate: order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id AND order_line.ol_o_id = orders.o_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], lookup table: orders }
                                      └─BatchExchange { order: [], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id) }
                                        └─BatchHashJoin { type: Inner, predicate: stock.s_w_id = order_line.ol_supply_w_id AND stock.s_i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount] }
                                          ├─BatchExchange { order: [], dist: HashShard(stock.s_i_id, stock.s_w_id) }
                                          │ └─BatchScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], distribution: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
                                          └─BatchExchange { order: [], dist: HashShard(order_line.ol_i_id, order_line.ol_supply_w_id) }
                                            └─BatchProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount] }
                                              └─BatchFilter { predicate: (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d <= '2032-01-02 00:00:00':Timestamp) }
                                                └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_delivery_d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue, supplier.s_nationkey(hidden)], stream_key: [supplier.s_nationkey, cust_nation, l_year], pk_columns: [supplier.s_nationkey, cust_nation, l_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [supplier.s_nationkey, $expr3, $expr4, sum(order_line.ol_amount), supplier.s_nationkey] }
      └─StreamHashAgg { group_key: [supplier.s_nationkey, $expr3, $expr4], aggs: [sum(order_line.ol_amount), count] }
        └─StreamExchange { dist: HashShard(supplier.s_nationkey, $expr3, $expr4) }
          └─StreamProject { exprs: [supplier.s_nationkey, Substr(customer.c_state, 1:Int32, 1:Int32) as $expr3, Extract('YEAR':Varchar, orders.o_entry_d) as $expr4, order_line.ol_amount, stock.s_w_id, stock.s_i_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_c_id, $expr1, $expr2] }
            └─StreamFilter { predicate: (((nation.n_name = 'JAPAN':Varchar) AND (nation.n_name = 'CHINA':Varchar)) OR ((nation.n_name = 'CHINA':Varchar) AND (nation.n_name = 'JAPAN':Varchar))) }
              └─StreamHashJoin { type: Inner, predicate: $expr2 = supplier.s_suppkey, output: all }
                ├─StreamExchange { dist: HashShard($expr2) }
                │ └─StreamProject { exprs: [order_line.ol_amount, orders.o_entry_d, customer.c_state, nation.n_name, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr2, stock.s_w_id, stock.s_i_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_c_id, $expr1] }
                │   └─StreamHashJoin { type: Inner, predicate: $expr1 = nation.n_nationkey, output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state, nation.n_name, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_c_id, $expr1, nation.n_nationkey] }
                │     ├─StreamExchange { dist: HashShard($expr1) }
                │     │ └─StreamProject { exprs: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr1, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_c_id] }
                │     │   └─StreamHashJoin { type: Inner, predicate: order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id AND order_line.ol_o_id = orders.o_id AND order_line.ol_d_id = customer.c_d_id AND order_line.ol_w_id = customer.c_w_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id] }
                │     │     ├─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_w_id) }
                │     │     │ └─StreamHashJoin { type: Inner, predicate: stock.s_w_id = order_line.ol_supply_w_id AND stock.s_i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, order_line.ol_number] }
                │     │     │   ├─StreamExchange { dist: HashShard(stock.s_i_id, stock.s_w_id) }
                │     │     │   │ └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
                │     │     │   └─StreamExchange { dist: HashShard(order_line.ol_i_id, order_line.ol_supply_w_id) }
                │     │     │     └─StreamProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_number] }
                │     │     │       └─StreamFilter { predicate: IsNotNull(order_line.ol_w_id) AND IsNotNull(order_line.ol_d_id) AND (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d <= '2032-01-02 00:00:00':Timestamp) }
                │     │     │         └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_number, order_line.ol_delivery_d], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
                │     │     └─StreamExchange { dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id, customer.c_d_id, customer.c_w_id) }
                │     │       └─StreamHashJoin { type: Inner, predicate: orders.o_c_id = customer.c_id AND orders.o_w_id = customer.c_w_id AND orders.o_d_id = customer.c_d_id, output: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, customer.c_d_id, customer.c_w_id, customer.c_state, orders.o_c_id, customer.c_id] }
                │     │         ├─StreamExchange { dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
                │     │         │ └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
                │     │         └─StreamExchange { dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
                │     │           └─StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
                │     └─StreamExchange { dist: HashShard(nation.n_nationkey) }
                │       └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                └─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                  └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, supplier.s_nationkey, nation.n_name, nation.n_nationkey] }
                    ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                    │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                    └─StreamExchange { dist: HashShard(nation.n_nationkey) }
                      └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue, supplier.s_nationkey(hidden)], stream_key: [supplier.s_nationkey, cust_nation, l_year], pk_columns: [supplier.s_nationkey, cust_nation, l_year], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [supplier.s_nationkey, $expr3, $expr4, sum(order_line.ol_amount), supplier.s_nationkey] }
        └── StreamHashAgg { group_key: [supplier.s_nationkey, $expr3, $expr4], aggs: [sum(order_line.ol_amount), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0, 1, 2]) from 1

    Fragment 1
    StreamProject { exprs: [supplier.s_nationkey, Substr(customer.c_state, 1:Int32, 1:Int32) as $expr3, Extract('YEAR':Varchar, orders.o_entry_d) as $expr4, order_line.ol_amount, stock.s_w_id, stock.s_i_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_c_id, $expr1, $expr2] }
    └── StreamFilter { predicate: (((nation.n_name = 'JAPAN':Varchar) AND (nation.n_name = 'CHINA':Varchar)) OR ((nation.n_name = 'CHINA':Varchar) AND (nation.n_name = 'JAPAN':Varchar))) }
        └── StreamHashJoin { type: Inner, predicate: $expr2 = supplier.s_suppkey, output: all } { tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ] }
            ├── StreamExchange Hash([4]) from 2
            └── StreamExchange Hash([0]) from 11

    Fragment 2
    StreamProject { exprs: [order_line.ol_amount, orders.o_entry_d, customer.c_state, nation.n_name, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr2, stock.s_w_id, stock.s_i_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_c_id, $expr1] }
    └── StreamHashJoin { type: Inner, predicate: $expr1 = nation.n_nationkey, output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state, nation.n_name, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_c_id, $expr1, nation.n_nationkey] }
        ├── tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ]
        ├── StreamExchange Hash([5]) from 3
        └── StreamExchange Hash([0]) from 10

    Fragment 3
    StreamProject { exprs: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr1, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_c_id] }
    └── StreamHashJoin { type: Inner, predicate: order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id AND order_line.ol_o_id = orders.o_id AND order_line.ol_d_id = customer.c_d_id AND order_line.ol_w_id = customer.c_w_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id] }
        ├── tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ]
        ├── StreamExchange Hash([2, 3, 4, 3, 4]) from 4
        └── StreamExchange Hash([0, 1, 2, 4, 5]) from 7

    Fragment 4
    StreamHashJoin { type: Inner, predicate: stock.s_w_id = order_line.ol_supply_w_id AND stock.s_i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, order_line.ol_number] } { tables: [ HashJoinLeft: 13, HashJoinDegreeLeft: 14, HashJoinRight: 15, HashJoinDegreeRight: 16 ] }
    ├── StreamExchange Hash([0, 1]) from 5
    └── StreamExchange Hash([3, 4]) from 6

    Fragment 5
    StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) } { tables: [ StreamScan: 17 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 6
    StreamProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_number] }
    └── StreamFilter { predicate: IsNotNull(order_line.ol_w_id) AND IsNotNull(order_line.ol_d_id) AND (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d <= '2032-01-02 00:00:00':Timestamp) }
        └── StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_number, order_line.ol_delivery_d], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
            ├── tables: [ StreamScan: 18 ]
            ├── Upstream
            └── BatchPlanNode

    Fragment 7
    StreamHashJoin { type: Inner, predicate: orders.o_c_id = customer.c_id AND orders.o_w_id = customer.c_w_id AND orders.o_d_id = customer.c_d_id, output: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, customer.c_d_id, customer.c_w_id, customer.c_state, orders.o_c_id, customer.c_id] } { tables: [ HashJoinLeft: 19, HashJoinDegreeLeft: 20, HashJoinRight: 21, HashJoinDegreeRight: 22 ] }
    ├── StreamExchange Hash([1, 2, 3]) from 8
    └── StreamExchange Hash([1, 2, 0]) from 9

    Fragment 8
    StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) } { tables: [ StreamScan: 23 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 9
    StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) } { tables: [ StreamScan: 24 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 10
    StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 25 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 11
    StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, supplier.s_nationkey, nation.n_name, nation.n_nationkey] } { tables: [ HashJoinLeft: 26, HashJoinDegreeLeft: 27, HashJoinRight: 28, HashJoinDegreeRight: 29 ] }
    ├── StreamExchange Hash([1]) from 12
    └── StreamExchange Hash([0]) from 13

    Fragment 12
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) } { tables: [ StreamScan: 30 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 13
    StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 31 ] }
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ supplier_s_nationkey, $expr3, $expr4, sum(order_line_ol_amount), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 1 { columns: [ order_line_ol_amount, orders_o_entry_d, customer_c_state, nation_n_name, $expr2, stock_s_w_id, stock_s_i_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, orders_o_c_id, $expr1, _rw_timestamp ], primary key: [ $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ], distribution key: [ 4 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr2, stock_s_w_id, stock_s_i_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, orders_o_c_id, $expr1, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC ], value indices: [ 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ supplier_s_suppkey, supplier_s_nationkey, nation_n_name, nation_n_nationkey, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ stock_s_i_id, stock_s_w_id, order_line_ol_amount, orders_o_entry_d, customer_c_state, $expr1, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, orders_o_c_id, _rw_timestamp ], primary key: [ $5 ASC, $1 ASC, $0 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ $expr1, stock_s_w_id, stock_s_i_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, orders_o_c_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ nation_n_nationkey, nation_n_name, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ stock_s_i_id, stock_s_w_id, order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_amount, order_line_ol_number, _rw_timestamp ], primary key: [ $4 ASC, $3 ASC, $2 ASC, $3 ASC, $4 ASC, $1 ASC, $0 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 2, 3, 4, 3, 4 ], read pk prefix len hint: 5 }

    Table 10 { columns: [ order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_d_id_0, order_line_ol_w_id_0, stock_s_w_id, stock_s_i_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 2, 1, 0, 3, 4 ], read pk prefix len hint: 5 }

    Table 11 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_entry_d, customer_c_d_id, customer_c_w_id, customer_c_state, orders_o_c_id, customer_c_id, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC, $4 ASC, $5 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0, 1, 2, 4, 5 ], read pk prefix len hint: 5 }

    Table 12 { columns: [ orders_o_w_id, orders_o_d_id, orders_o_id, customer_c_d_id, customer_c_w_id, orders_o_c_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 2, 1, 0, 3, 4 ], read pk prefix len hint: 5 }

    Table 13 { columns: [ stock_s_i_id, stock_s_w_id, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 14 { columns: [ stock_s_w_id, stock_s_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 1, 0 ], read pk prefix len hint: 2 }

    Table 15 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_i_id, order_line_ol_supply_w_id, order_line_ol_amount, order_line_ol_number, _rw_timestamp ], primary key: [ $4 ASC, $3 ASC, $2 ASC, $1 ASC, $0 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 3, 4 ], read pk prefix len hint: 2 }

    Table 16 { columns: [ order_line_ol_supply_w_id, order_line_ol_i_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 1, 0 ], read pk prefix len hint: 2 }

    Table 17 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 18 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 19 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_c_id, orders_o_entry_d, _rw_timestamp ], primary key: [ $3 ASC, $2 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1, 2, 3 ], read pk prefix len hint: 3 }

    Table 20 { columns: [ orders_o_c_id, orders_o_w_id, orders_o_d_id, orders_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 21 { columns: [ customer_c_id, customer_c_d_id, customer_c_w_id, customer_c_state, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1, 2, 0 ], read pk prefix len hint: 3 }

    Table 22 { columns: [ customer_c_id, customer_c_w_id, customer_c_d_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 23 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 24 { columns: [ vnode, c_w_id, c_d_id, c_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 25 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 26 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ supplier_s_nationkey, supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ nation_n_nationkey, nation_n_name, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 29 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 31 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ supp_nation, cust_nation, l_year, revenue, supplier.s_nationkey, _rw_timestamp ], primary key: [ $4 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 4, 1, 2 ], read pk prefix len hint: 3 }

- id: ch_q8
  before:
  - create_tables
  sql: "select\t extract(year from o_entry_d) as l_year,\n       sum(case when n2.n_name = 'INDIA' then ol_amount else 0 end) / sum(ol_amount) as mkt_share\nfrom\t item, supplier, stock, order_line, orders, customer, nation n1, nation n2, region\nwhere\t i_id = s_i_id\nand ol_i_id = s_i_id\nand ol_supply_w_id = s_w_id\nand mod((s_w_id * s_i_id),10000) = s_suppkey\nand ol_w_id = o_w_id\nand ol_d_id = o_d_id\nand ol_o_id = o_id\nand c_id = o_c_id\nand c_w_id = o_w_id\nand c_d_id = o_d_id\nand n1.n_nationkey = ascii(substr(c_state,1,1)) - 65\nand n1.n_regionkey = r_regionkey\nand ol_i_id < 1000\nand r_name = 'ASIA'\nand s_nationkey = n2.n_nationkey\nand o_entry_d between '2007-01-02 00:00:00.000000' and '2032-01-02 00:00:00.000000'\nand i_id = ol_i_id\ngroup by extract(year from o_entry_d)\norder by l_year;\n"
  logical_plan: |-
    LogicalProject { exprs: [$expr1, (sum($expr2) / sum(order_line.ol_amount)) as $expr3] }
    └─LogicalAgg { group_key: [$expr1], aggs: [sum($expr2), sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [Extract('YEAR':Varchar, orders.o_entry_d) as $expr1, Case((nation.n_name = 'INDIA':Varchar), order_line.ol_amount, 0:Int32::Decimal) as $expr2, order_line.ol_amount] }
        └─LogicalFilter { predicate: (item.i_id = stock.s_i_id) AND (order_line.ol_i_id = stock.s_i_id) AND (order_line.ol_supply_w_id = stock.s_w_id) AND (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) AND (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id) AND (nation.n_nationkey = (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)) AND (nation.n_regionkey = region.r_regionkey) AND (order_line.ol_i_id < 1000:Int32) AND (region.r_name = 'ASIA':Varchar) AND (supplier.s_nationkey = nation.n_nationkey) AND (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d <= '2032-01-02 00:00:00':Timestamp) AND (item.i_id = order_line.ol_i_id) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ │ │ │ ├─LogicalScan { table: item, columns: [item.i_id, item.i_im_id, item.i_name, item.i_price, item.i_data, item._rw_timestamp] }
            │ │ │ │ │ │ │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
            │ │ │ │ │ │ └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
            │ │ │ │ │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
            │ │ │ │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
            │ │ │ └─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_first, customer.c_middle, customer.c_last, customer.c_street_1, customer.c_street_2, customer.c_city, customer.c_state, customer.c_zip, customer.c_phone, customer.c_since, customer.c_credit, customer.c_credit_lim, customer.c_discount, customer.c_balance, customer.c_ytd_payment, customer.c_payment_cnt, customer.c_delivery_cnt, customer.c_data, customer._rw_timestamp] }
            │ │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
            │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
            └─LogicalScan { table: region, columns: [region.r_regionkey, region.r_name, region.r_comment, region._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [$expr3, (sum($expr4) / sum(order_line.ol_amount)) as $expr5] }
    └─LogicalAgg { group_key: [$expr3], aggs: [sum($expr4), sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [Extract('YEAR':Varchar, orders.o_entry_d) as $expr3, Case((nation.n_name = 'INDIA':Varchar), order_line.ol_amount, 0:Int32::Decimal) as $expr4, order_line.ol_amount] }
        └─LogicalJoin { type: Inner, on: (nation.n_regionkey = region.r_regionkey), output: [order_line.ol_amount, orders.o_entry_d, nation.n_name] }
          ├─LogicalJoin { type: Inner, on: ($expr2 = nation.n_nationkey), output: [order_line.ol_amount, orders.o_entry_d, nation.n_name, nation.n_regionkey] }
          │ ├─LogicalProject { exprs: [order_line.ol_amount, orders.o_entry_d, nation.n_name, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2] }
          │ │ └─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [order_line.ol_amount, orders.o_entry_d, customer.c_state, nation.n_name] }
          │ │   ├─LogicalJoin { type: Inner, on: ($expr1 = supplier.s_suppkey), output: [order_line.ol_amount, orders.o_entry_d, customer.c_state, supplier.s_nationkey] }
          │ │   │ ├─LogicalProject { exprs: [order_line.ol_amount, orders.o_entry_d, customer.c_state, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
          │ │   │ │ └─LogicalJoin { type: Inner, on: (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id), output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state] }
          │ │   │ │   ├─LogicalJoin { type: Inner, on: (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id), output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d] }
          │ │   │ │   │ ├─LogicalJoin { type: Inner, on: (order_line.ol_i_id = stock.s_i_id) AND (order_line.ol_supply_w_id = stock.s_w_id) AND (item.i_id = order_line.ol_i_id), output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount] }
          │ │   │ │   │ │ ├─LogicalJoin { type: Inner, on: (item.i_id = stock.s_i_id), output: all }
          │ │   │ │   │ │ │ ├─LogicalScan { table: item, columns: [item.i_id], predicate: (item.i_id < 1000:Int32) }
          │ │   │ │   │ │ │ └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], predicate: (stock.s_i_id < 1000:Int32) }
          │ │   │ │   │ │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount], predicate: IsNotNull(order_line.ol_i_id) AND (order_line.ol_i_id < 1000:Int32) }
          │ │   │ │   │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d <= '2032-01-02 00:00:00':Timestamp) }
          │ │   │ │   └─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state] }
          │ │   │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey] }
          │ │   └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name] }
          │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_regionkey] }
          └─LogicalScan { table: region, output_columns: [region.r_regionkey], required_columns: [region.r_regionkey, region.r_name], predicate: (region.r_name = 'ASIA':Varchar) }
  batch_plan: |-
    BatchExchange { order: [$expr3 ASC], dist: Single }
    └─BatchProject { exprs: [$expr3, (sum($expr4) / sum(order_line.ol_amount)) as $expr5] }
      └─BatchSort { order: [$expr3 ASC] }
        └─BatchHashAgg { group_key: [$expr3], aggs: [sum($expr4), sum(order_line.ol_amount)] }
          └─BatchExchange { order: [], dist: HashShard($expr3) }
            └─BatchProject { exprs: [Extract('YEAR':Varchar, orders.o_entry_d) as $expr3, Case((nation.n_name = 'INDIA':Varchar), order_line.ol_amount, 0:Decimal) as $expr4, order_line.ol_amount] }
              └─BatchLookupJoin { type: Inner, predicate: nation.n_regionkey = region.r_regionkey AND (region.r_name = 'ASIA':Varchar), output: [order_line.ol_amount, orders.o_entry_d, nation.n_name], lookup table: region }
                └─BatchExchange { order: [], dist: UpstreamHashShard(nation.n_regionkey) }
                  └─BatchLookupJoin { type: Inner, predicate: $expr2 = nation.n_nationkey, output: [order_line.ol_amount, orders.o_entry_d, nation.n_name, nation.n_regionkey], lookup table: nation }
                    └─BatchExchange { order: [], dist: UpstreamHashShard($expr2) }
                      └─BatchProject { exprs: [order_line.ol_amount, orders.o_entry_d, nation.n_name, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2] }
                        └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [order_line.ol_amount, orders.o_entry_d, customer.c_state, nation.n_name], lookup table: nation }
                          └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
                            └─BatchLookupJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [order_line.ol_amount, orders.o_entry_d, customer.c_state, supplier.s_nationkey], lookup table: supplier }
                              └─BatchExchange { order: [], dist: UpstreamHashShard($expr1) }
                                └─BatchProject { exprs: [order_line.ol_amount, orders.o_entry_d, customer.c_state, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
                                  └─BatchLookupJoin { type: Inner, predicate: orders.o_w_id = customer.c_w_id AND orders.o_d_id = customer.c_d_id AND orders.o_c_id = customer.c_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_entry_d, customer.c_state], lookup table: customer }
                                    └─BatchExchange { order: [], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_c_id) }
                                      └─BatchLookupJoin { type: Inner, predicate: order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id AND order_line.ol_o_id = orders.o_id AND (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d <= '2032-01-02 00:00:00':Timestamp), output: [stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], lookup table: orders }
                                        └─BatchExchange { order: [], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id) }
                                          └─BatchHashJoin { type: Inner, predicate: stock.s_i_id = order_line.ol_i_id AND stock.s_w_id = order_line.ol_supply_w_id AND item.i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount] }
                                            ├─BatchExchange { order: [], dist: HashShard(item.i_id, stock.s_w_id) }
                                            │ └─BatchHashJoin { type: Inner, predicate: item.i_id = stock.s_i_id, output: all }
                                            │   ├─BatchExchange { order: [], dist: HashShard(item.i_id) }
                                            │   │ └─BatchScan { table: item, columns: [item.i_id], scan_ranges: [item.i_id < Int32(1000)], distribution: UpstreamHashShard(item.i_id) }
                                            │   └─BatchExchange { order: [], dist: HashShard(stock.s_i_id) }
                                            │     └─BatchFilter { predicate: (stock.s_i_id < 1000:Int32) }
                                            │       └─BatchScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], distribution: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
                                            └─BatchExchange { order: [], dist: HashShard(order_line.ol_i_id, order_line.ol_supply_w_id) }
                                              └─BatchFilter { predicate: IsNotNull(order_line.ol_i_id) AND (order_line.ol_i_id < 1000:Int32) }
                                                └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [l_year, mkt_share], stream_key: [l_year], pk_columns: [l_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr3, (sum($expr4) / sum(order_line.ol_amount)) as $expr5] }
      └─StreamHashAgg { group_key: [$expr3], aggs: [sum($expr4), sum(order_line.ol_amount), count] }
        └─StreamExchange { dist: HashShard($expr3) }
          └─StreamProject { exprs: [Extract('YEAR':Varchar, orders.o_entry_d) as $expr3, Case((nation.n_name = 'INDIA':Varchar), order_line.ol_amount, 0:Decimal) as $expr4, order_line.ol_amount, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id, supplier.s_nationkey, $expr1, nation.n_regionkey, $expr2] }
            └─StreamHashJoin { type: Inner, predicate: $expr2 = nation.n_nationkey, output: [order_line.ol_amount, orders.o_entry_d, nation.n_name, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id, supplier.s_nationkey, $expr1, $expr2, nation.n_nationkey, nation.n_regionkey] }
              ├─StreamExchange { dist: HashShard($expr2) }
              │ └─StreamProject { exprs: [orders.o_entry_d, order_line.ol_amount, nation.n_name, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id, supplier.s_nationkey, $expr1] }
              │   └─StreamHashJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [orders.o_entry_d, customer.c_state, order_line.ol_amount, nation.n_name, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id, $expr1, supplier.s_suppkey, supplier.s_nationkey] }
              │     ├─StreamExchange { dist: HashShard($expr1) }
              │     │ └─StreamProject { exprs: [orders.o_entry_d, customer.c_state, order_line.ol_amount, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id] }
              │     │   └─StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id AND customer.c_d_id = order_line.ol_d_id AND customer.c_w_id = order_line.ol_w_id, output: [orders.o_entry_d, customer.c_state, stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, customer.c_d_id, customer.c_w_id, item.i_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
              │     │     ├─StreamExchange { dist: HashShard(orders.o_id, customer.c_d_id, customer.c_w_id) }
              │     │     │ └─StreamHashJoin { type: Inner, predicate: orders.o_c_id = customer.c_id AND orders.o_w_id = customer.c_w_id AND orders.o_d_id = customer.c_d_id, output: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, customer.c_d_id, customer.c_w_id, customer.c_state, orders.o_c_id, customer.c_id] }
              │     │     │   ├─StreamExchange { dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
              │     │     │   │ └─StreamFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d <= '2032-01-02 00:00:00':Timestamp) }
              │     │     │   │   └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
              │     │     │   └─StreamExchange { dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
              │     │     │     └─StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
              │     │     └─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
              │     │       └─StreamHashJoin { type: Inner, predicate: stock.s_i_id = order_line.ol_i_id AND stock.s_w_id = order_line.ol_supply_w_id AND item.i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, item.i_id, order_line.ol_number] }
              │     │         ├─StreamExchange { dist: HashShard(item.i_id, stock.s_w_id) }
              │     │         │ └─StreamHashJoin { type: Inner, predicate: item.i_id = stock.s_i_id, output: all }
              │     │         │   ├─StreamExchange { dist: HashShard(item.i_id) }
              │     │         │   │ └─StreamFilter { predicate: (item.i_id < 1000:Int32) }
              │     │         │   │   └─StreamTableScan { table: item, columns: [item.i_id], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) }
              │     │         │   └─StreamExchange { dist: HashShard(stock.s_i_id) }
              │     │         │     └─StreamFilter { predicate: (stock.s_i_id < 1000:Int32) }
              │     │         │       └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
              │     │         └─StreamExchange { dist: HashShard(order_line.ol_i_id, order_line.ol_supply_w_id) }
              │     │           └─StreamFilter { predicate: IsNotNull(order_line.ol_w_id) AND IsNotNull(order_line.ol_d_id) AND IsNotNull(order_line.ol_i_id) AND (order_line.ol_i_id < 1000:Int32) }
              │     │             └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
              │     └─StreamExchange { dist: HashShard(supplier.s_suppkey) }
              │       └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, nation.n_name, supplier.s_nationkey, nation.n_nationkey] }
              │         ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
              │         │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
              │         └─StreamExchange { dist: HashShard(nation.n_nationkey) }
              │           └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
              └─StreamExchange { dist: HashShard(nation.n_nationkey) }
                └─StreamHashJoin { type: Inner, predicate: nation.n_regionkey = region.r_regionkey, output: all }
                  ├─StreamExchange { dist: HashShard(nation.n_regionkey) }
                  │ └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_regionkey], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                  └─StreamExchange { dist: HashShard(region.r_regionkey) }
                    └─StreamProject { exprs: [region.r_regionkey] }
                      └─StreamFilter { predicate: (region.r_name = 'ASIA':Varchar) }
                        └─StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], stream_scan_type: ArrangementBackfill, stream_key: [region.r_regionkey], pk: [r_regionkey], dist: UpstreamHashShard(region.r_regionkey) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [l_year, mkt_share], stream_key: [l_year], pk_columns: [l_year], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [$expr3, (sum($expr4) / sum(order_line.ol_amount)) as $expr5] }
        └── StreamHashAgg { group_key: [$expr3], aggs: [sum($expr4), sum(order_line.ol_amount), count] }
            ├── tables: [ HashAggState: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [Extract('YEAR':Varchar, orders.o_entry_d) as $expr3, Case((nation.n_name = 'INDIA':Varchar), order_line.ol_amount, 0:Decimal) as $expr4, order_line.ol_amount, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id, supplier.s_nationkey, $expr1, nation.n_regionkey, $expr2] }
    └── StreamHashJoin { type: Inner, predicate: $expr2 = nation.n_nationkey, output: [order_line.ol_amount, orders.o_entry_d, nation.n_name, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id, supplier.s_nationkey, $expr1, $expr2, nation.n_nationkey, nation.n_regionkey] }
        ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
        ├── StreamExchange Hash([3]) from 2
        └── StreamExchange Hash([0]) from 15

    Fragment 2
    StreamProject { exprs: [orders.o_entry_d, order_line.ol_amount, nation.n_name, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr2, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id, supplier.s_nationkey, $expr1] }
    └── StreamHashJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [orders.o_entry_d, customer.c_state, order_line.ol_amount, nation.n_name, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id, $expr1, supplier.s_suppkey, supplier.s_nationkey] }
        ├── tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ]
        ├── StreamExchange Hash([3]) from 3
        └── StreamExchange Hash([0]) from 12

    Fragment 3
    StreamProject { exprs: [orders.o_entry_d, customer.c_state, order_line.ol_amount, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, item.i_id, stock.s_w_id, order_line.ol_number, stock.s_i_id, customer.c_d_id, customer.c_w_id] }
    └── StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id AND customer.c_d_id = order_line.ol_d_id AND customer.c_w_id = order_line.ol_w_id, output: [orders.o_entry_d, customer.c_state, stock.s_i_id, stock.s_w_id, order_line.ol_amount, orders.o_w_id, orders.o_d_id, orders.o_id, orders.o_c_id, customer.c_d_id, customer.c_w_id, item.i_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
        ├── tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ]
        ├── StreamExchange Hash([0, 4, 5]) from 4
        └── StreamExchange Hash([2, 3, 4]) from 7

    Fragment 4
    StreamHashJoin { type: Inner, predicate: orders.o_c_id = customer.c_id AND orders.o_w_id = customer.c_w_id AND orders.o_d_id = customer.c_d_id, output: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, customer.c_d_id, customer.c_w_id, customer.c_state, orders.o_c_id, customer.c_id] } { tables: [ HashJoinLeft: 13, HashJoinDegreeLeft: 14, HashJoinRight: 15, HashJoinDegreeRight: 16 ] }
    ├── StreamExchange Hash([1, 2, 3]) from 5
    └── StreamExchange Hash([1, 2, 0]) from 6

    Fragment 5
    StreamFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d <= '2032-01-02 00:00:00':Timestamp) }
    └── StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) } { tables: [ StreamScan: 17 ] }
        ├── Upstream
        └── BatchPlanNode

    Fragment 6
    StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) } { tables: [ StreamScan: 18 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 7
    StreamHashJoin { type: Inner, predicate: stock.s_i_id = order_line.ol_i_id AND stock.s_w_id = order_line.ol_supply_w_id AND item.i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, item.i_id, order_line.ol_number] } { tables: [ HashJoinLeft: 19, HashJoinDegreeLeft: 20, HashJoinRight: 21, HashJoinDegreeRight: 22 ] }
    ├── StreamExchange Hash([0, 2]) from 8
    └── StreamExchange Hash([3, 4]) from 11

    Fragment 8
    StreamHashJoin { type: Inner, predicate: item.i_id = stock.s_i_id, output: all } { tables: [ HashJoinLeft: 23, HashJoinDegreeLeft: 24, HashJoinRight: 25, HashJoinDegreeRight: 26 ] }
    ├── StreamExchange Hash([0]) from 9
    └── StreamExchange Hash([0]) from 10

    Fragment 9
    StreamFilter { predicate: (item.i_id < 1000:Int32) }
    └── StreamTableScan { table: item, columns: [item.i_id], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) } { tables: [ StreamScan: 27 ] }
        ├── Upstream
        └── BatchPlanNode

    Fragment 10
    StreamFilter { predicate: (stock.s_i_id < 1000:Int32) }
    └── StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) } { tables: [ StreamScan: 28 ] }
        ├── Upstream
        └── BatchPlanNode

    Fragment 11
    StreamFilter { predicate: IsNotNull(order_line.ol_w_id) AND IsNotNull(order_line.ol_d_id) AND IsNotNull(order_line.ol_i_id) AND (order_line.ol_i_id < 1000:Int32) }
    └── StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
        ├── tables: [ StreamScan: 29 ]
        ├── Upstream
        └── BatchPlanNode

    Fragment 12
    StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, nation.n_name, supplier.s_nationkey, nation.n_nationkey] } { tables: [ HashJoinLeft: 30, HashJoinDegreeLeft: 31, HashJoinRight: 32, HashJoinDegreeRight: 33 ] }
    ├── StreamExchange Hash([1]) from 13
    └── StreamExchange Hash([0]) from 14

    Fragment 13
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) } { tables: [ StreamScan: 34 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 14
    StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 35 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 15
    StreamHashJoin { type: Inner, predicate: nation.n_regionkey = region.r_regionkey, output: all } { tables: [ HashJoinLeft: 36, HashJoinDegreeLeft: 37, HashJoinRight: 38, HashJoinDegreeRight: 39 ] }
    ├── StreamExchange Hash([1]) from 16
    └── StreamExchange Hash([0]) from 17

    Fragment 16
    StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_regionkey], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 40 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 17
    StreamProject { exprs: [region.r_regionkey] }
    └── StreamFilter { predicate: (region.r_name = 'ASIA':Varchar) }
        └── StreamTableScan { table: region, columns: [region.r_regionkey, region.r_name], stream_scan_type: ArrangementBackfill, stream_key: [region.r_regionkey], pk: [r_regionkey], dist: UpstreamHashShard(region.r_regionkey) } { tables: [ StreamScan: 41 ] }
            ├── Upstream
            └── BatchPlanNode

    Table 0 { columns: [ $expr3, sum($expr4), sum(order_line_ol_amount), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ orders_o_entry_d, order_line_ol_amount, nation_n_name, $expr2, orders_o_w_id, orders_o_d_id, orders_o_id, orders_o_c_id, item_i_id, stock_s_w_id, order_line_ol_number, stock_s_i_id, customer_c_d_id, customer_c_w_id, supplier_s_nationkey, $expr1, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC, $13 ASC, $14 ASC, $15 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]
    ├── distribution key: [ 3 ]
    └── read pk prefix len hint: 1

    Table 2 { columns: [ $expr2, orders_o_w_id, orders_o_d_id, orders_o_id, orders_o_c_id, item_i_id, stock_s_w_id, order_line_ol_number, stock_s_i_id, customer_c_d_id, customer_c_w_id, supplier_s_nationkey, $expr1, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC ], value indices: [ 13 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ nation_n_nationkey, nation_n_regionkey, region_r_regionkey, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ nation_n_nationkey, nation_n_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ orders_o_entry_d, customer_c_state, order_line_ol_amount, $expr1, orders_o_w_id, orders_o_d_id, orders_o_id, orders_o_c_id, item_i_id, stock_s_w_id, order_line_ol_number, stock_s_i_id, customer_c_d_id, customer_c_w_id, _rw_timestamp ], primary key: [ $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC, $13 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ $expr1, orders_o_w_id, orders_o_d_id, orders_o_id, orders_o_c_id, item_i_id, stock_s_w_id, order_line_ol_number, stock_s_i_id, customer_c_d_id, customer_c_w_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC ], value indices: [ 11 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ supplier_s_suppkey, nation_n_name, supplier_s_nationkey, nation_n_nationkey, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_entry_d, customer_c_d_id, customer_c_w_id, customer_c_state, orders_o_c_id, customer_c_id, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC, $4 ASC, $5 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0, 4, 5 ], read pk prefix len hint: 5 }

    Table 10 { columns: [ orders_o_w_id, orders_o_d_id, orders_o_id, customer_c_d_id, customer_c_w_id, orders_o_c_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 2, 3, 4 ], read pk prefix len hint: 5 }

    Table 11 { columns: [ stock_s_i_id, stock_s_w_id, order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_amount, item_i_id, order_line_ol_number, _rw_timestamp ], primary key: [ $4 ASC, $3 ASC, $2 ASC, $3 ASC, $4 ASC, $6 ASC, $1 ASC, $7 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 2, 3, 4 ], read pk prefix len hint: 5 }

    Table 12 { columns: [ order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_d_id_0, order_line_ol_w_id_0, item_i_id, stock_s_w_id, order_line_ol_number, stock_s_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC ], value indices: [ 9 ], distribution key: [ 2, 3, 4 ], read pk prefix len hint: 5 }

    Table 13 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_c_id, orders_o_entry_d, _rw_timestamp ], primary key: [ $3 ASC, $2 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1, 2, 3 ], read pk prefix len hint: 3 }

    Table 14 { columns: [ orders_o_c_id, orders_o_w_id, orders_o_d_id, orders_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 15 { columns: [ customer_c_id, customer_c_d_id, customer_c_w_id, customer_c_state, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1, 2, 0 ], read pk prefix len hint: 3 }

    Table 16 { columns: [ customer_c_id, customer_c_w_id, customer_c_d_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 17 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 18 { columns: [ vnode, c_w_id, c_d_id, c_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 19 { columns: [ item_i_id, stock_s_i_id, stock_s_w_id, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 2 ], read pk prefix len hint: 3 }

    Table 20 { columns: [ stock_s_i_id, stock_s_w_id, item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1 ], read pk prefix len hint: 3 }

    Table 21 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_i_id, order_line_ol_supply_w_id, order_line_ol_amount, order_line_ol_number, _rw_timestamp ], primary key: [ $3 ASC, $4 ASC, $3 ASC, $2 ASC, $1 ASC, $0 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 3, 4 ], read pk prefix len hint: 3 }

    Table 22 { columns: [ order_line_ol_i_id, order_line_ol_supply_w_id, order_line_ol_i_id_0, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC ], value indices: [ 7 ], distribution key: [ 2, 1 ], read pk prefix len hint: 3 }

    Table 23 { columns: [ item_i_id, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ stock_s_i_id, stock_s_w_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 26 { columns: [ stock_s_i_id, stock_s_w_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ vnode, i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 28 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 29 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 30 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 31 { columns: [ supplier_s_nationkey, supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 32 { columns: [ nation_n_nationkey, nation_n_name, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 33 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 34 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 35 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 36 { columns: [ nation_n_nationkey, nation_n_regionkey, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 37 { columns: [ nation_n_regionkey, nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 38 { columns: [ region_r_regionkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 39 { columns: [ region_r_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 40 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 41 { columns: [ vnode, r_regionkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ l_year, mkt_share, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: ch_q9
  before:
  - create_tables
  sql: "select\t n_name, extract(year from o_entry_d) as l_year, sum(ol_amount) as sum_profit\nfrom\t item, stock, supplier, order_line, orders, nation\nwhere\t ol_i_id = s_i_id\nand ol_supply_w_id = s_w_id\nand mod((s_w_id * s_i_id), 10000) = s_suppkey\nand ol_w_id = o_w_id\nand ol_d_id = o_d_id\nand ol_o_id = o_id\nand ol_i_id = i_id\nand s_nationkey = n_nationkey\nand i_data like '%BB'\ngroup by n_name, extract(year from o_entry_d)\norder by n_name, l_year desc;\n"
  logical_plan: |-
    LogicalProject { exprs: [nation.n_name, $expr1, sum(order_line.ol_amount)] }
    └─LogicalAgg { group_key: [nation.n_name, $expr1], aggs: [sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [nation.n_name, Extract('YEAR':Varchar, orders.o_entry_d) as $expr1, order_line.ol_amount] }
        └─LogicalFilter { predicate: (order_line.ol_i_id = stock.s_i_id) AND (order_line.ol_supply_w_id = stock.s_w_id) AND (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) AND (order_line.ol_i_id = item.i_id) AND (supplier.s_nationkey = nation.n_nationkey) AND Like(item.i_data, '%BB':Varchar) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalScan { table: item, columns: [item.i_id, item.i_im_id, item.i_name, item.i_price, item.i_data, item._rw_timestamp] }
            │ │ │ │ └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
            │ │ │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
            │ │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
            │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
            └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [nation.n_name, $expr2], aggs: [sum(order_line.ol_amount)] }
    └─LogicalProject { exprs: [nation.n_name, Extract('YEAR':Varchar, orders.o_entry_d) as $expr2, order_line.ol_amount] }
      └─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [order_line.ol_amount, orders.o_entry_d, nation.n_name] }
        ├─LogicalJoin { type: Inner, on: ($expr1 = supplier.s_suppkey), output: [order_line.ol_amount, orders.o_entry_d, supplier.s_nationkey] }
        │ ├─LogicalProject { exprs: [order_line.ol_amount, orders.o_entry_d, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
        │ │ └─LogicalJoin { type: Inner, on: (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id), output: [order_line.ol_amount, stock.s_i_id, stock.s_w_id, orders.o_entry_d] }
        │ │   ├─LogicalJoin { type: Inner, on: (order_line.ol_i_id = stock.s_i_id) AND (order_line.ol_supply_w_id = stock.s_w_id), output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, stock.s_i_id, stock.s_w_id] }
        │ │   │ ├─LogicalJoin { type: Inner, on: (order_line.ol_i_id = item.i_id), output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount] }
        │ │   │ │ ├─LogicalScan { table: item, output_columns: [item.i_id], required_columns: [item.i_id, item.i_data], predicate: Like(item.i_data, '%BB':Varchar) }
        │ │   │ │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount] }
        │ │   │ └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id] }
        │ │   └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d] }
        │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey] }
        └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name] }
  batch_plan: |-
    BatchExchange { order: [nation.n_name ASC, $expr2 DESC], dist: Single }
    └─BatchSort { order: [nation.n_name ASC, $expr2 DESC] }
      └─BatchHashAgg { group_key: [nation.n_name, $expr2], aggs: [sum(order_line.ol_amount)] }
        └─BatchExchange { order: [], dist: HashShard(nation.n_name, $expr2) }
          └─BatchProject { exprs: [nation.n_name, Extract('YEAR':Varchar, orders.o_entry_d) as $expr2, order_line.ol_amount] }
            └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [order_line.ol_amount, orders.o_entry_d, nation.n_name], lookup table: nation }
              └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
                └─BatchLookupJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [order_line.ol_amount, orders.o_entry_d, supplier.s_nationkey], lookup table: supplier }
                  └─BatchExchange { order: [], dist: UpstreamHashShard($expr1) }
                    └─BatchProject { exprs: [order_line.ol_amount, orders.o_entry_d, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
                      └─BatchLookupJoin { type: Inner, predicate: order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id AND order_line.ol_o_id = orders.o_id, output: [order_line.ol_amount, stock.s_i_id, stock.s_w_id, orders.o_entry_d], lookup table: orders }
                        └─BatchExchange { order: [], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id) }
                          └─BatchLookupJoin { type: Inner, predicate: order_line.ol_supply_w_id = stock.s_w_id AND order_line.ol_i_id = stock.s_i_id, output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, stock.s_i_id, stock.s_w_id], lookup table: stock }
                            └─BatchExchange { order: [], dist: UpstreamHashShard(order_line.ol_supply_w_id, order_line.ol_i_id) }
                              └─BatchHashJoin { type: Inner, predicate: item.i_id = order_line.ol_i_id, output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount] }
                                ├─BatchExchange { order: [], dist: HashShard(item.i_id) }
                                │ └─BatchProject { exprs: [item.i_id] }
                                │   └─BatchFilter { predicate: Like(item.i_data, '%BB':Varchar) }
                                │     └─BatchScan { table: item, columns: [item.i_id, item.i_data], distribution: UpstreamHashShard(item.i_id) }
                                └─BatchExchange { order: [], dist: HashShard(order_line.ol_i_id) }
                                  └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [n_name, l_year, sum_profit], stream_key: [n_name, l_year], pk_columns: [n_name, l_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [nation.n_name, $expr2, sum(order_line.ol_amount)] }
      └─StreamHashAgg { group_key: [nation.n_name, $expr2], aggs: [sum(order_line.ol_amount), count] }
        └─StreamExchange { dist: HashShard(nation.n_name, $expr2) }
          └─StreamProject { exprs: [nation.n_name, Extract('YEAR':Varchar, orders.o_entry_d) as $expr2, order_line.ol_amount, item.i_id, stock.s_w_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number, stock.s_i_id, supplier.s_nationkey, $expr1] }
            └─StreamHashJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [order_line.ol_amount, orders.o_entry_d, nation.n_name, item.i_id, stock.s_w_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number, stock.s_i_id, $expr1, supplier.s_suppkey, supplier.s_nationkey] }
              ├─StreamExchange { dist: HashShard($expr1) }
              │ └─StreamProject { exprs: [orders.o_entry_d, order_line.ol_amount, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, item.i_id, stock.s_w_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number, stock.s_i_id] }
              │   └─StreamHashJoin { type: Inner, predicate: stock.s_i_id = order_line.ol_i_id AND stock.s_w_id = order_line.ol_supply_w_id AND item.i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, orders.o_entry_d, order_line.ol_amount, item.i_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number] }
              │     ├─StreamExchange { dist: HashShard(item.i_id, stock.s_w_id) }
              │     │ └─StreamHashJoin { type: Inner, predicate: item.i_id = stock.s_i_id, output: all }
              │     │   ├─StreamExchange { dist: HashShard(item.i_id) }
              │     │   │ └─StreamProject { exprs: [item.i_id] }
              │     │   │   └─StreamFilter { predicate: Like(item.i_data, '%BB':Varchar) }
              │     │   │     └─StreamTableScan { table: item, columns: [item.i_id, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) }
              │     │   └─StreamExchange { dist: HashShard(stock.s_i_id) }
              │     │     └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
              │     └─StreamExchange { dist: HashShard(order_line.ol_i_id, order_line.ol_supply_w_id) }
              │       └─StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: [orders.o_entry_d, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
              │         ├─StreamExchange { dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
              │         │ └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
              │         └─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
              │           └─StreamFilter { predicate: IsNotNull(order_line.ol_i_id) }
              │             └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
              └─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, nation.n_name, supplier.s_nationkey, nation.n_nationkey] }
                  ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                  │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                  └─StreamExchange { dist: HashShard(nation.n_nationkey) }
                    └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [n_name, l_year, sum_profit], stream_key: [n_name, l_year], pk_columns: [n_name, l_year], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [nation.n_name, $expr2, sum(order_line.ol_amount)] }
        └── StreamHashAgg { group_key: [nation.n_name, $expr2], aggs: [sum(order_line.ol_amount), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0, 1]) from 1

    Fragment 1
    StreamProject { exprs: [nation.n_name, Extract('YEAR':Varchar, orders.o_entry_d) as $expr2, order_line.ol_amount, item.i_id, stock.s_w_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number, stock.s_i_id, supplier.s_nationkey, $expr1] }
    └── StreamHashJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [order_line.ol_amount, orders.o_entry_d, nation.n_name, item.i_id, stock.s_w_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number, stock.s_i_id, $expr1, supplier.s_suppkey, supplier.s_nationkey] }
        ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
        ├── StreamExchange Hash([2]) from 2
        └── StreamExchange Hash([0]) from 9

    Fragment 2
    StreamProject { exprs: [orders.o_entry_d, order_line.ol_amount, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, item.i_id, stock.s_w_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number, stock.s_i_id] }
    └── StreamHashJoin { type: Inner, predicate: stock.s_i_id = order_line.ol_i_id AND stock.s_w_id = order_line.ol_supply_w_id AND item.i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, orders.o_entry_d, order_line.ol_amount, item.i_id, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number] }
        ├── tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ]
        ├── StreamExchange Hash([0, 2]) from 3
        └── StreamExchange Hash([1, 2]) from 6

    Fragment 3
    StreamHashJoin { type: Inner, predicate: item.i_id = stock.s_i_id, output: all } { tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ] }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([0]) from 5

    Fragment 4
    StreamProject { exprs: [item.i_id] }
    └── StreamFilter { predicate: Like(item.i_data, '%BB':Varchar) }
        └── StreamTableScan { table: item, columns: [item.i_id, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) } { tables: [ StreamScan: 13 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 5
    StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) } { tables: [ StreamScan: 14 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 6
    StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: [orders.o_entry_d, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
    ├── tables: [ HashJoinLeft: 15, HashJoinDegreeLeft: 16, HashJoinRight: 17, HashJoinDegreeRight: 18 ]
    ├── StreamExchange Hash([0, 1, 2]) from 7
    └── StreamExchange Hash([0, 1, 2]) from 8

    Fragment 7
    StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) } { tables: [ StreamScan: 19 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 8
    StreamFilter { predicate: IsNotNull(order_line.ol_i_id) }
    └── StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
        ├── tables: [ StreamScan: 20 ]
        ├── Upstream
        └── BatchPlanNode

    Fragment 9
    StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: [supplier.s_suppkey, nation.n_name, supplier.s_nationkey, nation.n_nationkey] } { tables: [ HashJoinLeft: 21, HashJoinDegreeLeft: 22, HashJoinRight: 23, HashJoinDegreeRight: 24 ] }
    ├── StreamExchange Hash([1]) from 10
    └── StreamExchange Hash([0]) from 11

    Fragment 10
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) } { tables: [ StreamScan: 25 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 11
    StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 26 ] }
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ nation_n_name, $expr2, sum(order_line_ol_amount), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 1 { columns: [ orders_o_entry_d, order_line_ol_amount, $expr1, item_i_id, stock_s_w_id, orders_o_w_id, orders_o_d_id, orders_o_id, order_line_ol_number, stock_s_i_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr1, item_i_id, stock_s_w_id, orders_o_w_id, orders_o_d_id, orders_o_id, order_line_ol_number, stock_s_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ supplier_s_suppkey, nation_n_name, supplier_s_nationkey, nation_n_nationkey, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ item_i_id, stock_s_i_id, stock_s_w_id, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 2 ], read pk prefix len hint: 3 }

    Table 6 { columns: [ stock_s_i_id, stock_s_w_id, item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1 ], read pk prefix len hint: 3 }

    Table 7 { columns: [ orders_o_entry_d, order_line_ol_i_id, order_line_ol_supply_w_id, order_line_ol_amount, orders_o_w_id, orders_o_d_id, orders_o_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $1 ASC, $4 ASC, $5 ASC, $6 ASC, $10 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], distribution key: [ 1, 2 ], read pk prefix len hint: 3 }

    Table 8 { columns: [ order_line_ol_i_id, order_line_ol_supply_w_id, order_line_ol_i_id_0, orders_o_w_id, orders_o_d_id, orders_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC ], value indices: [ 7 ], distribution key: [ 2, 1 ], read pk prefix len hint: 3 }

    Table 9 { columns: [ item_i_id, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ stock_s_i_id, stock_s_w_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ stock_s_i_id, stock_s_w_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ vnode, i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 14 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 15 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_entry_d, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 16 { columns: [ orders_o_w_id, orders_o_d_id, orders_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 17 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_i_id, order_line_ol_supply_w_id, order_line_ol_amount, order_line_ol_number, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 18 { columns: [ order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 19 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 20 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 21 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ supplier_s_nationkey, supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ nation_n_nationkey, nation_n_name, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 26 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ n_name, l_year, sum_profit, _rw_timestamp ], primary key: [ $0 ASC, $1 DESC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

- id: ch_q10
  before:
  - create_tables
  sql: "select\t c_id, c_last, sum(ol_amount) as revenue, c_city, c_phone, n_name\nfrom\t customer, orders, order_line, nation\nwhere\t c_id = o_c_id\n  and c_w_id = o_w_id\n  and c_d_id = o_d_id\n  and ol_w_id = o_w_id\n  and ol_d_id = o_d_id\n  and ol_o_id = o_id\n  and o_entry_d >= '2007-01-02 00:00:00.000000'\n  and o_entry_d <= ol_delivery_d\n  and n_nationkey = ascii(substr(c_state,1,1)) - 65\ngroup by c_id, c_last, c_city, c_phone, n_name\norder by revenue desc;\n"
  logical_plan: |-
    LogicalProject { exprs: [customer.c_id, customer.c_last, sum(order_line.ol_amount), customer.c_city, customer.c_phone, nation.n_name] }
    └─LogicalAgg { group_key: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name], aggs: [sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name, order_line.ol_amount] }
        └─LogicalFilter { predicate: (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) AND (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) AND (orders.o_entry_d <= order_line.ol_delivery_d) AND (nation.n_nationkey = (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_first, customer.c_middle, customer.c_last, customer.c_street_1, customer.c_street_2, customer.c_city, customer.c_state, customer.c_zip, customer.c_phone, customer.c_since, customer.c_credit, customer.c_credit_lim, customer.c_discount, customer.c_balance, customer.c_ytd_payment, customer.c_payment_cnt, customer.c_delivery_cnt, customer.c_data, customer._rw_timestamp] }
            │ │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
            │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
            └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [customer.c_id, customer.c_last, sum(order_line.ol_amount), customer.c_city, customer.c_phone, nation.n_name] }
    └─LogicalAgg { group_key: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name], aggs: [sum(order_line.ol_amount)] }
      └─LogicalJoin { type: Inner, on: ($expr1 = nation.n_nationkey), output: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name, order_line.ol_amount] }
        ├─LogicalProject { exprs: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, order_line.ol_amount, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr1] }
        │ └─LogicalJoin { type: Inner, on: (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) AND (orders.o_entry_d <= order_line.ol_delivery_d), output: [customer.c_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone, order_line.ol_amount] }
        │   ├─LogicalJoin { type: Inner, on: (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id), output: [customer.c_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d] }
        │   │ ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone] }
        │   │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) }
        │   └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_amount] }
        └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name] }
  batch_plan: |-
    BatchExchange { order: [sum(order_line.ol_amount) DESC], dist: Single }
    └─BatchProject { exprs: [customer.c_id, customer.c_last, sum(order_line.ol_amount), customer.c_city, customer.c_phone, nation.n_name] }
      └─BatchSort { order: [sum(order_line.ol_amount) DESC] }
        └─BatchHashAgg { group_key: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name], aggs: [sum(order_line.ol_amount)] }
          └─BatchExchange { order: [], dist: HashShard(customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name) }
            └─BatchLookupJoin { type: Inner, predicate: $expr1 = nation.n_nationkey, output: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name, order_line.ol_amount], lookup table: nation }
              └─BatchExchange { order: [], dist: UpstreamHashShard($expr1) }
                └─BatchProject { exprs: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, order_line.ol_amount, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr1] }
                  └─BatchHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id AND (orders.o_entry_d <= order_line.ol_delivery_d), output: [customer.c_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone, order_line.ol_amount] }
                    ├─BatchExchange { order: [], dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
                    │ └─BatchHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d] }
                    │   ├─BatchExchange { order: [], dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
                    │   │ └─BatchScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone], distribution: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
                    │   └─BatchExchange { order: [], dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
                    │     └─BatchFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) }
                    │       └─BatchScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], distribution: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
                    └─BatchExchange { order: [], dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
                      └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_amount], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [c_id, c_last, revenue, c_city, c_phone, n_name], stream_key: [c_id, c_last, c_city, c_phone, n_name], pk_columns: [revenue, c_id, c_last, c_city, c_phone, n_name], pk_conflict: NoCheck }
    └─StreamProject { exprs: [customer.c_id, customer.c_last, sum(order_line.ol_amount), customer.c_city, customer.c_phone, nation.n_name] }
      └─StreamHashAgg { group_key: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name], aggs: [sum(order_line.ol_amount), count] }
        └─StreamExchange { dist: HashShard(customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name) }
          └─StreamHashJoin { type: Inner, predicate: $expr1 = nation.n_nationkey, output: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, order_line.ol_amount, nation.n_name, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, $expr1, nation.n_nationkey] }
            ├─StreamExchange { dist: HashShard($expr1) }
            │ └─StreamProject { exprs: [order_line.ol_amount, customer.c_id, customer.c_last, customer.c_city, customer.c_phone, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr1, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
            │   └─StreamFilter { predicate: (orders.o_entry_d <= order_line.ol_delivery_d) }
            │     └─StreamHashJoin { type: Inner, predicate: order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id AND order_line.ol_o_id = orders.o_id AND order_line.ol_d_id = customer.c_d_id AND order_line.ol_w_id = customer.c_w_id, output: all }
            │       ├─StreamExchange { dist: HashShard(order_line.ol_d_id, order_line.ol_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
            │       │ └─StreamFilter { predicate: IsNotNull(order_line.ol_w_id) AND IsNotNull(order_line.ol_d_id) }
            │       │   └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
            │       └─StreamExchange { dist: HashShard(customer.c_d_id, customer.c_w_id, orders.o_id, orders.o_d_id, orders.o_w_id) }
            │         └─StreamHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d] }
            │           ├─StreamExchange { dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
            │           │ └─StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
            │           └─StreamExchange { dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
            │             └─StreamFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) }
            │               └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
            └─StreamExchange { dist: HashShard(nation.n_nationkey) }
              └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [c_id, c_last, revenue, c_city, c_phone, n_name], stream_key: [c_id, c_last, c_city, c_phone, n_name], pk_columns: [revenue, c_id, c_last, c_city, c_phone, n_name], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [customer.c_id, customer.c_last, sum(order_line.ol_amount), customer.c_city, customer.c_phone, nation.n_name] }
        └── StreamHashAgg { group_key: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, nation.n_name], aggs: [sum(order_line.ol_amount), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0, 1, 2, 3, 5]) from 1

    Fragment 1
    StreamHashJoin { type: Inner, predicate: $expr1 = nation.n_nationkey, output: [customer.c_id, customer.c_last, customer.c_city, customer.c_phone, order_line.ol_amount, nation.n_name, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, $expr1, nation.n_nationkey] }
    ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
    ├── StreamExchange Hash([5]) from 2
    └── StreamExchange Hash([0]) from 7

    Fragment 2
    StreamProject { exprs: [order_line.ol_amount, customer.c_id, customer.c_last, customer.c_city, customer.c_phone, (Ascii(Substr(customer.c_state, 1:Int32, 1:Int32)) - 65:Int32)::Int64 as $expr1, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
    └── StreamFilter { predicate: (orders.o_entry_d <= order_line.ol_delivery_d) }
        └── StreamHashJoin { type: Inner, predicate: order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id AND order_line.ol_o_id = orders.o_id AND order_line.ol_d_id = customer.c_d_id AND order_line.ol_w_id = customer.c_w_id, output: all }
            ├── tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ]
            ├── StreamExchange Hash([1, 2, 0, 1, 2]) from 3
            └── StreamExchange Hash([1, 2, 7, 8, 9]) from 4

    Fragment 3
    StreamFilter { predicate: IsNotNull(order_line.ol_w_id) AND IsNotNull(order_line.ol_d_id) }
    └── StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
        ├── tables: [ StreamScan: 9 ]
        ├── Upstream
        └── BatchPlanNode

    Fragment 4
    StreamHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d] } { tables: [ HashJoinLeft: 10, HashJoinDegreeLeft: 11, HashJoinRight: 12, HashJoinDegreeRight: 13 ] }
    ├── StreamExchange Hash([1, 2, 0]) from 5
    └── StreamExchange Hash([1, 2, 3]) from 6

    Fragment 5
    StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last, customer.c_city, customer.c_state, customer.c_phone], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) } { tables: [ StreamScan: 14 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 6
    StreamFilter { predicate: (orders.o_entry_d >= '2007-01-02 00:00:00':Timestamp) }
    └── StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) } { tables: [ StreamScan: 15 ] }
        ├── Upstream
        └── BatchPlanNode

    Fragment 7
    StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 16 ] }
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ customer_c_id, customer_c_last, customer_c_city, customer_c_phone, nation_n_name, sum(order_line_ol_amount), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5, 6 ], distribution key: [ 0, 1, 2, 3, 4 ], read pk prefix len hint: 5 }

    Table 1 { columns: [ order_line_ol_amount, customer_c_id, customer_c_last, customer_c_city, customer_c_phone, $expr1, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _rw_timestamp ], primary key: [ $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr1, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, customer_c_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ nation_n_nationkey, nation_n_name, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_delivery_d, order_line_ol_amount, order_line_ol_number, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC, $1 ASC, $2 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 1, 2, 0, 1, 2 ], read pk prefix len hint: 5 }

    Table 6 { columns: [ order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_d_id_0, order_line_ol_w_id_0, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 3, 4, 2, 1, 0 ], read pk prefix len hint: 5 }

    Table 7 { columns: [ customer_c_id, customer_c_d_id, customer_c_w_id, customer_c_last, customer_c_city, customer_c_state, customer_c_phone, orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_entry_d, _rw_timestamp ], primary key: [ $9 ASC, $8 ASC, $7 ASC, $1 ASC, $2 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], distribution key: [ 1, 2, 7, 8, 9 ], read pk prefix len hint: 5 }

    Table 8 { columns: [ orders_o_w_id, orders_o_d_id, orders_o_id, customer_c_d_id, customer_c_w_id, customer_c_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 3, 4, 2, 1, 0 ], read pk prefix len hint: 5 }

    Table 9 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 10 { columns: [ customer_c_id, customer_c_d_id, customer_c_w_id, customer_c_last, customer_c_city, customer_c_state, customer_c_phone, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 1, 2, 0 ], read pk prefix len hint: 3 }

    Table 11 { columns: [ customer_c_id, customer_c_w_id, customer_c_d_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 12 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_c_id, orders_o_entry_d, _rw_timestamp ], primary key: [ $3 ASC, $2 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1, 2, 3 ], read pk prefix len hint: 3 }

    Table 13 { columns: [ orders_o_c_id, orders_o_w_id, orders_o_d_id, orders_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 14 { columns: [ vnode, c_w_id, c_d_id, c_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 15 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 16 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ c_id, c_last, revenue, c_city, c_phone, n_name, _rw_timestamp ], primary key: [ $2 DESC, $0 ASC, $1 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0, 1, 3, 4, 5 ], read pk prefix len hint: 6 }

- id: ch_q11
  before:
  - create_tables
  sql: "select\t s_i_id, sum(s_order_cnt) as ordercount\nfrom\t stock, supplier, nation\nwhere\t mod((s_w_id * s_i_id),10000) = s_suppkey\n  and s_nationkey = n_nationkey\n  and n_name = 'CHINA'\ngroup by s_i_id\nhaving   sum(s_order_cnt) >\n         (select sum(s_order_cnt) * .005\n          from stock, supplier, nation\n          where mod((s_w_id * s_i_id),10000) = s_suppkey\n            and s_nationkey = n_nationkey\n            and n_name = 'CHINA')\norder by ordercount desc;\n"
  logical_plan: |-
    LogicalProject { exprs: [stock.s_i_id, sum(stock.s_order_cnt)] }
    └─LogicalFilter { predicate: (sum(stock.s_order_cnt)::Decimal > $expr1) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalAgg { group_key: [stock.s_i_id], aggs: [sum(stock.s_order_cnt)] }
        │ └─LogicalProject { exprs: [stock.s_i_id, stock.s_order_cnt] }
        │   └─LogicalFilter { predicate: (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey) AND (supplier.s_nationkey = nation.n_nationkey) AND (nation.n_name = 'CHINA':Varchar) }
        │     └─LogicalJoin { type: Inner, on: true, output: all }
        │       ├─LogicalJoin { type: Inner, on: true, output: all }
        │       │ ├─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
        │       │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
        │       └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
        └─LogicalProject { exprs: [(sum(stock.s_order_cnt)::Decimal * 0.005:Decimal) as $expr1] }
          └─LogicalAgg { aggs: [sum(stock.s_order_cnt)] }
            └─LogicalProject { exprs: [stock.s_order_cnt] }
              └─LogicalFilter { predicate: (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey) AND (supplier.s_nationkey = nation.n_nationkey) AND (nation.n_name = 'CHINA':Varchar) }
                └─LogicalJoin { type: Inner, on: true, output: all }
                  ├─LogicalJoin { type: Inner, on: true, output: all }
                  │ ├─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
                  │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
                  └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: ($expr2 > $expr4), output: [stock.s_i_id, sum(stock.s_order_cnt)] }
    ├─LogicalProject { exprs: [stock.s_i_id, sum(stock.s_order_cnt), sum(stock.s_order_cnt)::Decimal as $expr2] }
    │ └─LogicalAgg { group_key: [stock.s_i_id], aggs: [sum(stock.s_order_cnt)] }
    │   └─LogicalJoin { type: Inner, on: (supplier.s_suppkey = $expr1), output: [stock.s_i_id, stock.s_order_cnt] }
    │     ├─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [supplier.s_suppkey] }
    │     │ ├─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey] }
    │     │ └─LogicalScan { table: nation, output_columns: [nation.n_nationkey], required_columns: [nation.n_nationkey, nation.n_name], predicate: (nation.n_name = 'CHINA':Varchar) }
    │     └─LogicalProject { exprs: [stock.s_i_id, stock.s_order_cnt, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
    │       └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_order_cnt] }
    └─LogicalProject { exprs: [(sum(stock.s_order_cnt)::Decimal * 0.005:Decimal) as $expr4] }
      └─LogicalAgg { aggs: [sum(stock.s_order_cnt)] }
        └─LogicalJoin { type: Inner, on: (supplier.s_suppkey = $expr3), output: [stock.s_order_cnt] }
          ├─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [supplier.s_suppkey] }
          │ ├─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey] }
          │ └─LogicalScan { table: nation, output_columns: [nation.n_nationkey], required_columns: [nation.n_nationkey, nation.n_name], predicate: (nation.n_name = 'CHINA':Varchar) }
          └─LogicalProject { exprs: [stock.s_order_cnt, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr3] }
            └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_order_cnt] }
  batch_plan: |-
    BatchSort { order: [sum(stock.s_order_cnt) DESC] }
    └─BatchNestedLoopJoin { type: Inner, predicate: ($expr2 > $expr4), output: [stock.s_i_id, sum(stock.s_order_cnt)] }
      ├─BatchExchange { order: [], dist: Single }
      │ └─BatchProject { exprs: [stock.s_i_id, sum(stock.s_order_cnt), sum(stock.s_order_cnt)::Decimal as $expr2] }
      │   └─BatchHashAgg { group_key: [stock.s_i_id], aggs: [sum(stock.s_order_cnt)] }
      │     └─BatchExchange { order: [], dist: HashShard(stock.s_i_id) }
      │       └─BatchHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr1, output: [stock.s_i_id, stock.s_order_cnt] }
      │         ├─BatchExchange { order: [], dist: HashShard(supplier.s_suppkey) }
      │         │ └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey AND (nation.n_name = 'CHINA':Varchar), output: [supplier.s_suppkey], lookup table: nation }
      │         │   └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
      │         │     └─BatchScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], distribution: UpstreamHashShard(supplier.s_suppkey) }
      │         └─BatchExchange { order: [], dist: HashShard($expr1) }
      │           └─BatchProject { exprs: [stock.s_i_id, stock.s_order_cnt, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
      │             └─BatchScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_order_cnt], distribution: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
      └─BatchProject { exprs: [(sum(sum(stock.s_order_cnt))::Decimal * 0.005:Decimal) as $expr4] }
        └─BatchSimpleAgg { aggs: [sum(sum(stock.s_order_cnt))] }
          └─BatchExchange { order: [], dist: Single }
            └─BatchSimpleAgg { aggs: [sum(stock.s_order_cnt)] }
              └─BatchHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr3, output: [stock.s_order_cnt] }
                ├─BatchExchange { order: [], dist: HashShard(supplier.s_suppkey) }
                │ └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey AND (nation.n_name = 'CHINA':Varchar), output: [supplier.s_suppkey], lookup table: nation }
                │   └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
                │     └─BatchScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], distribution: UpstreamHashShard(supplier.s_suppkey) }
                └─BatchExchange { order: [], dist: HashShard($expr3) }
                  └─BatchProject { exprs: [stock.s_order_cnt, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr3] }
                    └─BatchScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_order_cnt], distribution: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
  stream_plan: |-
    StreamMaterialize { columns: [s_i_id, ordercount], stream_key: [s_i_id], pk_columns: [ordercount, s_i_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [stock.s_i_id, sum(stock.s_order_cnt)] }
      └─StreamDynamicFilter { predicate: ($expr2 > $expr3), output: [stock.s_i_id, sum(stock.s_order_cnt), $expr2] }
        ├─StreamProject { exprs: [stock.s_i_id, sum(stock.s_order_cnt), sum(stock.s_order_cnt)::Decimal as $expr2] }
        │ └─StreamHashAgg { group_key: [stock.s_i_id], aggs: [sum(stock.s_order_cnt), count] }
        │   └─StreamExchange { dist: HashShard(stock.s_i_id) }
        │     └─StreamShare { id: 10 }
        │       └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr1, output: [stock.s_i_id, stock.s_order_cnt, supplier.s_suppkey, supplier.s_nationkey, stock.s_w_id] }
        │         ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
        │         │ └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: all }
        │         │   ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
        │         │   │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
        │         │   └─StreamExchange { dist: HashShard(nation.n_nationkey) }
        │         │     └─StreamProject { exprs: [nation.n_nationkey] }
        │         │       └─StreamFilter { predicate: (nation.n_name = 'CHINA':Varchar) }
        │         │         └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
        │         └─StreamExchange { dist: HashShard($expr1) }
        │           └─StreamProject { exprs: [stock.s_i_id, stock.s_order_cnt, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, stock.s_w_id] }
        │             └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_order_cnt], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [(sum(sum(stock.s_order_cnt))::Decimal * 0.005:Decimal) as $expr3] }
            └─StreamSimpleAgg { aggs: [sum(sum(stock.s_order_cnt)), count] }
              └─StreamExchange { dist: Single }
                └─StreamStatelessSimpleAgg { aggs: [sum(stock.s_order_cnt)] }
                  └─StreamShare { id: 10 }
                    └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr1, output: [stock.s_i_id, stock.s_order_cnt, supplier.s_suppkey, supplier.s_nationkey, stock.s_w_id] }
                      ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                      │ └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: all }
                      │   ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
                      │   │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
                      │   └─StreamExchange { dist: HashShard(nation.n_nationkey) }
                      │     └─StreamProject { exprs: [nation.n_nationkey] }
                      │       └─StreamFilter { predicate: (nation.n_name = 'CHINA':Varchar) }
                      │         └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
                      └─StreamExchange { dist: HashShard($expr1) }
                        └─StreamProject { exprs: [stock.s_i_id, stock.s_order_cnt, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, stock.s_w_id] }
                          └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_order_cnt], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_i_id, ordercount], stream_key: [s_i_id], pk_columns: [ordercount, s_i_id], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [stock.s_i_id, sum(stock.s_order_cnt)] }
        └── StreamDynamicFilter { predicate: ($expr2 > $expr3), output: [stock.s_i_id, sum(stock.s_order_cnt), $expr2] }
            ├── tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ]
            ├── StreamProject { exprs: [stock.s_i_id, sum(stock.s_order_cnt), sum(stock.s_order_cnt)::Decimal as $expr2] }
            │   └── StreamHashAgg { group_key: [stock.s_i_id], aggs: [sum(stock.s_order_cnt), count] }
            │       ├── tables: [ HashAggState: 2 ]
            │       └── StreamExchange Hash([0]) from 1
            └── StreamExchange Broadcast from 7

    Fragment 1
    StreamNoOp
    └── StreamExchange NoShuffle from 2

    Fragment 2
    StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr1, output: [stock.s_i_id, stock.s_order_cnt, supplier.s_suppkey, supplier.s_nationkey, stock.s_w_id] }
    ├── tables: [ HashJoinLeft: 3, HashJoinDegreeLeft: 4, HashJoinRight: 5, HashJoinDegreeRight: 6 ]
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([2]) from 6

    Fragment 3
    StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: all }
    ├── tables: [ HashJoinLeft: 7, HashJoinDegreeLeft: 8, HashJoinRight: 9, HashJoinDegreeRight: 10 ]
    ├── StreamExchange Hash([1]) from 4
    └── StreamExchange Hash([0]) from 5

    Fragment 4
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
    ├── tables: [ StreamScan: 11 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 5
    StreamProject { exprs: [nation.n_nationkey] }
    └── StreamFilter { predicate: (nation.n_name = 'CHINA':Varchar) }
        └── StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
            ├── tables: [ StreamScan: 12 ]
            ├── Upstream
            └── BatchPlanNode

    Fragment 6
    StreamProject { exprs: [stock.s_i_id, stock.s_order_cnt, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, stock.s_w_id] }
    └── StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_order_cnt], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
        ├── tables: [ StreamScan: 13 ]
        ├── Upstream
        └── BatchPlanNode

    Fragment 7
    StreamProject { exprs: [(sum(sum(stock.s_order_cnt))::Decimal * 0.005:Decimal) as $expr3] }
    └── StreamSimpleAgg { aggs: [sum(sum(stock.s_order_cnt)), count] } { tables: [ SimpleAggState: 14 ] }
        └── StreamExchange Single from 8

    Fragment 8
    StreamStatelessSimpleAgg { aggs: [sum(stock.s_order_cnt)] }
    └── StreamExchange NoShuffle from 2

    Table 0 { columns: [ stock_s_i_id, sum(stock_s_order_cnt), $expr2, _rw_timestamp ], primary key: [ $2 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr3, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2 { columns: [ stock_s_i_id, sum(stock_s_order_cnt), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ supplier_s_suppkey, supplier_s_nationkey, nation_n_nationkey, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ stock_s_i_id, stock_s_order_cnt, $expr1, stock_s_w_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ $expr1, stock_s_w_id, stock_s_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ supplier_s_nationkey, supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ nation_n_nationkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 12 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 13 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 14 { columns: [ sum(sum(stock_s_order_cnt)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ s_i_id, ordercount, _rw_timestamp ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

- id: ch_q12
  before:
  - create_tables
  sql: "select\t o_ol_cnt,\n           sum(case when o_carrier_id = 1 or o_carrier_id = 2 then 1 else 0 end) as high_line_count,\n           sum(case when o_carrier_id <> 1 and o_carrier_id <> 2 then 1 else 0 end) as low_line_count\nfrom\t orders, order_line\nwhere\t ol_w_id = o_w_id\n  and ol_d_id = o_d_id\n  and ol_o_id = o_id\n  and o_entry_d <= ol_delivery_d\n  and ol_delivery_d < '2030-01-01 00:00:00.000000'\ngroup by o_ol_cnt\norder by o_ol_cnt;\n"
  logical_plan: |-
    LogicalProject { exprs: [orders.o_ol_cnt, sum($expr1), sum($expr2)] }
    └─LogicalAgg { group_key: [orders.o_ol_cnt], aggs: [sum($expr1), sum($expr2)] }
      └─LogicalProject { exprs: [orders.o_ol_cnt, Case(((orders.o_carrier_id = 1:Int32) OR (orders.o_carrier_id = 2:Int32)), 1:Int32, 0:Int32) as $expr1, Case(((orders.o_carrier_id <> 1:Int32) AND (orders.o_carrier_id <> 2:Int32)), 1:Int32, 0:Int32) as $expr2] }
        └─LogicalFilter { predicate: (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) AND (orders.o_entry_d <= order_line.ol_delivery_d) AND (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
            └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [orders.o_ol_cnt], aggs: [sum($expr1), sum($expr2)] }
    └─LogicalProject { exprs: [orders.o_ol_cnt, Case(((orders.o_carrier_id = 1:Int32) OR (orders.o_carrier_id = 2:Int32)), 1:Int32, 0:Int32) as $expr1, Case(((orders.o_carrier_id <> 1:Int32) AND (orders.o_carrier_id <> 2:Int32)), 1:Int32, 0:Int32) as $expr2] }
      └─LogicalJoin { type: Inner, on: (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) AND (orders.o_entry_d <= order_line.ol_delivery_d), output: [orders.o_carrier_id, orders.o_ol_cnt] }
        ├─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt] }
        └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d], predicate: (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) }
  batch_plan: |-
    BatchExchange { order: [orders.o_ol_cnt ASC], dist: Single }
    └─BatchSort { order: [orders.o_ol_cnt ASC] }
      └─BatchHashAgg { group_key: [orders.o_ol_cnt], aggs: [sum($expr1), sum($expr2)] }
        └─BatchExchange { order: [], dist: HashShard(orders.o_ol_cnt) }
          └─BatchProject { exprs: [orders.o_ol_cnt, Case(((orders.o_carrier_id = 1:Int32) OR (orders.o_carrier_id = 2:Int32)), 1:Int32, 0:Int32) as $expr1, Case(((orders.o_carrier_id <> 1:Int32) AND (orders.o_carrier_id <> 2:Int32)), 1:Int32, 0:Int32) as $expr2] }
            └─BatchHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id AND (orders.o_entry_d <= order_line.ol_delivery_d), output: [orders.o_carrier_id, orders.o_ol_cnt] }
              ├─BatchExchange { order: [], dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
              │ └─BatchScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt], distribution: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
              └─BatchExchange { order: [], dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
                └─BatchFilter { predicate: (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) }
                  └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [o_ol_cnt, high_line_count, low_line_count], stream_key: [o_ol_cnt], pk_columns: [o_ol_cnt], pk_conflict: NoCheck }
    └─StreamProject { exprs: [orders.o_ol_cnt, sum($expr1), sum($expr2)] }
      └─StreamHashAgg { group_key: [orders.o_ol_cnt], aggs: [sum($expr1), sum($expr2), count] }
        └─StreamExchange { dist: HashShard(orders.o_ol_cnt) }
          └─StreamProject { exprs: [orders.o_ol_cnt, Case(((orders.o_carrier_id = 1:Int32) OR (orders.o_carrier_id = 2:Int32)), 1:Int32, 0:Int32) as $expr1, Case(((orders.o_carrier_id <> 1:Int32) AND (orders.o_carrier_id <> 2:Int32)), 1:Int32, 0:Int32) as $expr2, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number] }
            └─StreamFilter { predicate: (orders.o_entry_d <= order_line.ol_delivery_d) }
              └─StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: all }
                ├─StreamExchange { dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
                │ └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
                └─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
                  └─StreamFilter { predicate: (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) }
                    └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [o_ol_cnt, high_line_count, low_line_count], stream_key: [o_ol_cnt], pk_columns: [o_ol_cnt], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [orders.o_ol_cnt, sum($expr1), sum($expr2)] }
        └── StreamHashAgg { group_key: [orders.o_ol_cnt], aggs: [sum($expr1), sum($expr2), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [orders.o_ol_cnt, Case(((orders.o_carrier_id = 1:Int32) OR (orders.o_carrier_id = 2:Int32)), 1:Int32, 0:Int32) as $expr1, Case(((orders.o_carrier_id <> 1:Int32) AND (orders.o_carrier_id <> 2:Int32)), 1:Int32, 0:Int32) as $expr2, orders.o_w_id, orders.o_d_id, orders.o_id, order_line.ol_number] }
    └── StreamFilter { predicate: (orders.o_entry_d <= order_line.ol_delivery_d) }
        └── StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: all } { tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ] }
            ├── StreamExchange Hash([0, 1, 2]) from 2
            └── StreamExchange Hash([0, 1, 2]) from 3

    Fragment 2
    StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
    ├── tables: [ StreamScan: 5 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 3
    StreamFilter { predicate: (order_line.ol_delivery_d < '2030-01-01 00:00:00':Timestamp) }
    └── StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
        ├── tables: [ StreamScan: 6 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ orders_o_ol_cnt, sum($expr1), sum($expr2), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_entry_d, orders_o_carrier_id, orders_o_ol_cnt, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 2 { columns: [ orders_o_w_id, orders_o_d_id, orders_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 3 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_delivery_d, order_line_ol_number, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 4 { columns: [ order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 5 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 6 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ o_ol_cnt, high_line_count, low_line_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: ch_q13
  before:
  - create_tables
  sql: "select\t c_count, count(*) as custdist\nfrom\t (select c_id, count(o_id) as c_count\nfrom customer left outer join orders on (\nc_w_id = o_w_id\nand c_d_id = o_d_id\nand c_id = o_c_id\nand o_carrier_id > 8)\ngroup by c_id) as c_orders\ngroup by c_count\norder by custdist desc, c_count desc;\n"
  logical_plan: |-
    LogicalProject { exprs: [count(orders.o_id), count] }
    └─LogicalAgg { group_key: [count(orders.o_id)], aggs: [count] }
      └─LogicalProject { exprs: [count(orders.o_id)] }
        └─LogicalProject { exprs: [customer.c_id, count(orders.o_id)] }
          └─LogicalAgg { group_key: [customer.c_id], aggs: [count(orders.o_id)] }
            └─LogicalProject { exprs: [customer.c_id, orders.o_id] }
              └─LogicalJoin { type: LeftOuter, on: (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id) AND (customer.c_id = orders.o_c_id) AND (orders.o_carrier_id > 8:Int32), output: all }
                ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_first, customer.c_middle, customer.c_last, customer.c_street_1, customer.c_street_2, customer.c_city, customer.c_state, customer.c_zip, customer.c_phone, customer.c_since, customer.c_credit, customer.c_credit_lim, customer.c_discount, customer.c_balance, customer.c_ytd_payment, customer.c_payment_cnt, customer.c_delivery_cnt, customer.c_data, customer._rw_timestamp] }
                └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [count(orders.o_id)], aggs: [count] }
    └─LogicalAgg { group_key: [customer.c_id], aggs: [count(orders.o_id)] }
      └─LogicalJoin { type: LeftOuter, on: (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id) AND (customer.c_id = orders.o_c_id), output: [customer.c_id, orders.o_id] }
        ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id] }
        └─LogicalScan { table: orders, output_columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id], required_columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_carrier_id], predicate: (orders.o_carrier_id > 8:Int32) }
  batch_plan: |-
    BatchExchange { order: [count DESC, count(orders.o_id) DESC], dist: Single }
    └─BatchSort { order: [count DESC, count(orders.o_id) DESC] }
      └─BatchHashAgg { group_key: [count(orders.o_id)], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(count(orders.o_id)) }
          └─BatchHashAgg { group_key: [customer.c_id], aggs: [count(orders.o_id)] }
            └─BatchExchange { order: [], dist: HashShard(customer.c_id) }
              └─BatchHashJoin { type: LeftOuter, predicate: customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id AND customer.c_id = orders.o_c_id, output: [customer.c_id, orders.o_id] }
                ├─BatchExchange { order: [], dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
                │ └─BatchScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id], distribution: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
                └─BatchExchange { order: [], dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
                  └─BatchProject { exprs: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id] }
                    └─BatchFilter { predicate: (orders.o_carrier_id > 8:Int32) }
                      └─BatchScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_carrier_id], distribution: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
  stream_plan: |-
    StreamMaterialize { columns: [c_count, custdist], stream_key: [c_count], pk_columns: [custdist, c_count], pk_conflict: NoCheck }
    └─StreamHashAgg { group_key: [count(orders.o_id)], aggs: [count] }
      └─StreamExchange { dist: HashShard(count(orders.o_id)) }
        └─StreamProject { exprs: [customer.c_id, count(orders.o_id)] }
          └─StreamHashAgg { group_key: [customer.c_id], aggs: [count(orders.o_id), count] }
            └─StreamExchange { dist: HashShard(customer.c_id) }
              └─StreamHashJoin { type: LeftOuter, predicate: customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id AND customer.c_id = orders.o_c_id, output: [customer.c_id, orders.o_id, customer.c_w_id, customer.c_d_id, orders.o_w_id, orders.o_d_id] }
                ├─StreamExchange { dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
                │ └─StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
                └─StreamExchange { dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
                  └─StreamProject { exprs: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id] }
                    └─StreamFilter { predicate: (orders.o_carrier_id > 8:Int32) }
                      └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_carrier_id], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [c_count, custdist], stream_key: [c_count], pk_columns: [custdist, c_count], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamHashAgg { group_key: [count(orders.o_id)], aggs: [count] } { tables: [ HashAggState: 0 ] }
        └── StreamExchange Hash([1]) from 1

    Fragment 1
    StreamProject { exprs: [customer.c_id, count(orders.o_id)] }
    └── StreamHashAgg { group_key: [customer.c_id], aggs: [count(orders.o_id), count] } { tables: [ HashAggState: 1 ] }
        └── StreamExchange Hash([0]) from 2

    Fragment 2
    StreamHashJoin { type: LeftOuter, predicate: customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id AND customer.c_id = orders.o_c_id, output: [customer.c_id, orders.o_id, customer.c_w_id, customer.c_d_id, orders.o_w_id, orders.o_d_id] }
    ├── tables: [ HashJoinLeft: 2, HashJoinDegreeLeft: 3, HashJoinRight: 4, HashJoinDegreeRight: 5 ]
    ├── StreamExchange Hash([1, 2, 0]) from 3
    └── StreamExchange Hash([1, 2, 3]) from 4

    Fragment 3
    StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
    ├── tables: [ StreamScan: 6 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 4
    StreamProject { exprs: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id] }
    └── StreamFilter { predicate: (orders.o_carrier_id > 8:Int32) }
        └── StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_carrier_id], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
            ├── tables: [ StreamScan: 7 ]
            ├── Upstream
            └── BatchPlanNode

    Table 0 { columns: [ count(orders_o_id), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ customer_c_id, count(orders_o_id), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ customer_c_id, customer_c_d_id, customer_c_w_id, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1, 2, 0 ], read pk prefix len hint: 3 }

    Table 3 { columns: [ customer_c_w_id, customer_c_d_id, customer_c_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 1, 0, 2 ], read pk prefix len hint: 3 }

    Table 4 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_c_id, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $3 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1, 2, 3 ], read pk prefix len hint: 3 }

    Table 5 { columns: [ orders_o_w_id, orders_o_d_id, orders_o_c_id, orders_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 1, 0, 2 ], read pk prefix len hint: 3 }

    Table 6 { columns: [ vnode, c_w_id, c_d_id, c_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 7 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ c_count, custdist, _rw_timestamp ], primary key: [ $1 DESC, $0 DESC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

- id: ch_q14
  before:
  - create_tables
  sql: "select\t100.00 * sum(case when i_data like 'PR%' then ol_amount else 0 end) / (1+sum(ol_amount)) as promo_revenue\nfrom\torder_line, item\nwhere\tol_i_id = i_id and ol_delivery_d >= '2007-01-02 00:00:00.000000'\n  and ol_delivery_d < '2030-01-02 00:00:00.000000';\n"
  logical_plan: |-
    LogicalProject { exprs: [((100.00:Decimal * sum($expr1)) / (1:Int32::Decimal + sum(order_line.ol_amount))) as $expr2] }
    └─LogicalAgg { aggs: [sum($expr1), sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [Case(Like(item.i_data, 'PR%':Varchar), order_line.ol_amount, 0:Int32::Decimal) as $expr1, order_line.ol_amount] }
        └─LogicalFilter { predicate: (order_line.ol_i_id = item.i_id) AND (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-02 00:00:00':Timestamp) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
            └─LogicalScan { table: item, columns: [item.i_id, item.i_im_id, item.i_name, item.i_price, item.i_data, item._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [((100.00:Decimal * sum($expr1)) / (1:Int32::Decimal + sum(order_line.ol_amount))) as $expr2] }
    └─LogicalAgg { aggs: [sum($expr1), sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [Case(Like(item.i_data, 'PR%':Varchar), order_line.ol_amount, 0:Int32::Decimal) as $expr1, order_line.ol_amount] }
        └─LogicalJoin { type: Inner, on: (order_line.ol_i_id = item.i_id), output: [order_line.ol_amount, item.i_data] }
          ├─LogicalScan { table: order_line, output_columns: [order_line.ol_i_id, order_line.ol_amount], required_columns: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_delivery_d], predicate: (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-02 00:00:00':Timestamp) }
          └─LogicalScan { table: item, columns: [item.i_id, item.i_data] }
  batch_plan: |-
    BatchProject { exprs: [((100.00:Decimal * sum(sum($expr1))) / (1:Decimal + sum(sum(order_line.ol_amount)))) as $expr2] }
    └─BatchSimpleAgg { aggs: [sum(sum($expr1)), sum(sum(order_line.ol_amount))] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchSimpleAgg { aggs: [sum($expr1), sum(order_line.ol_amount)] }
          └─BatchProject { exprs: [Case(Like(item.i_data, 'PR%':Varchar), order_line.ol_amount, 0:Decimal) as $expr1, order_line.ol_amount] }
            └─BatchLookupJoin { type: Inner, predicate: order_line.ol_i_id = item.i_id, output: [order_line.ol_amount, item.i_data], lookup table: item }
              └─BatchExchange { order: [], dist: UpstreamHashShard(order_line.ol_i_id) }
                └─BatchProject { exprs: [order_line.ol_i_id, order_line.ol_amount] }
                  └─BatchFilter { predicate: (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-02 00:00:00':Timestamp) }
                    └─BatchScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_delivery_d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [promo_revenue], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [((100.00:Decimal * sum(sum($expr1))) / (1:Decimal + sum(sum(order_line.ol_amount)))) as $expr2] }
      └─StreamSimpleAgg { aggs: [sum(sum($expr1)), sum(sum(order_line.ol_amount)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [sum($expr1), sum(order_line.ol_amount)] }
            └─StreamProject { exprs: [Case(Like(item.i_data, 'PR%':Varchar), order_line.ol_amount, 0:Decimal) as $expr1, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id] }
              └─StreamHashJoin { type: Inner, predicate: order_line.ol_i_id = item.i_id, output: [order_line.ol_amount, item.i_data, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id, item.i_id] }
                ├─StreamExchange { dist: HashShard(order_line.ol_i_id) }
                │ └─StreamProject { exprs: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
                │   └─StreamFilter { predicate: (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-02 00:00:00':Timestamp) }
                │     └─StreamTableScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_delivery_d], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
                └─StreamExchange { dist: HashShard(item.i_id) }
                  └─StreamTableScan { table: item, columns: [item.i_id, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [promo_revenue], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [((100.00:Decimal * sum(sum($expr1))) / (1:Decimal + sum(sum(order_line.ol_amount)))) as $expr2] }
        └── StreamSimpleAgg { aggs: [sum(sum($expr1)), sum(sum(order_line.ol_amount)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [sum($expr1), sum(order_line.ol_amount)] }
    └── StreamProject { exprs: [Case(Like(item.i_data, 'PR%':Varchar), order_line.ol_amount, 0:Decimal) as $expr1, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id] }
        └── StreamHashJoin { type: Inner, predicate: order_line.ol_i_id = item.i_id, output: [order_line.ol_amount, item.i_data, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id, item.i_id] }
            ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
            ├── StreamExchange Hash([0]) from 2
            └── StreamExchange Hash([0]) from 3

    Fragment 2
    StreamProject { exprs: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
    └── StreamFilter { predicate: (order_line.ol_delivery_d >= '2007-01-02 00:00:00':Timestamp) AND (order_line.ol_delivery_d < '2030-01-02 00:00:00':Timestamp) }
        └── StreamTableScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_delivery_d], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
            ├── tables: [ StreamScan: 5 ]
            ├── Upstream
            └── BatchPlanNode

    Fragment 3
    StreamTableScan { table: item, columns: [item.i_id, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) } { tables: [ StreamScan: 6 ] }
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ sum(sum($expr1)), sum(sum(order_line_ol_amount)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1, 2 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ order_line_ol_i_id, order_line_ol_amount, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ order_line_ol_i_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ item_i_id, item_i_data, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 6 { columns: [ vnode, i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ promo_revenue, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: ch_q15
  before:
  - create_tables
  sql: "select\t s_suppkey, s_name, s_address, s_phone, total_revenue\nfrom\t supplier, revenue1\nwhere\t s_suppkey = supplier_no\nand total_revenue = (select max(total_revenue) from revenue1)\norder by s_suppkey;\n"
  logical_plan: |-
    LogicalProject { exprs: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, revenue1.total_revenue] }
    └─LogicalFilter { predicate: (supplier.s_suppkey = revenue1.supplier_no) AND (revenue1.total_revenue = max(revenue1.total_revenue)) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
        │ └─LogicalScan { table: revenue1, columns: [revenue1.supplier_no, revenue1.total_revenue, revenue1._rw_timestamp] }
        └─LogicalProject { exprs: [max(revenue1.total_revenue)] }
          └─LogicalAgg { aggs: [max(revenue1.total_revenue)] }
            └─LogicalProject { exprs: [revenue1.total_revenue] }
              └─LogicalScan { table: revenue1, columns: [revenue1.supplier_no, revenue1.total_revenue, revenue1._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: (revenue1.total_revenue = max(revenue1.total_revenue)), output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, revenue1.total_revenue] }
    ├─LogicalJoin { type: Inner, on: (supplier.s_suppkey = $expr1), output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, revenue1.total_revenue] }
    │ ├─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone] }
    │ └─LogicalProject { exprs: [revenue1.total_revenue, revenue1.supplier_no::Int64 as $expr1] }
    │   └─LogicalScan { table: revenue1, columns: [revenue1.supplier_no, revenue1.total_revenue] }
    └─LogicalAgg { aggs: [max(revenue1.total_revenue)] }
      └─LogicalScan { table: revenue1, columns: [revenue1.total_revenue] }
  stream_plan: |-
    StreamMaterialize { columns: [s_suppkey, s_name, s_address, s_phone, total_revenue, revenue1.supplier_no(hidden)], stream_key: [s_suppkey, revenue1.supplier_no, total_revenue], pk_columns: [s_suppkey, revenue1.supplier_no, total_revenue], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(supplier.s_suppkey, revenue1.total_revenue, revenue1.supplier_no) }
      └─StreamHashJoin { type: Inner, predicate: revenue1.total_revenue = max(max(revenue1.total_revenue)), output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, revenue1.total_revenue, revenue1.supplier_no] }
        ├─StreamExchange { dist: HashShard(revenue1.total_revenue) }
        │ └─StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr1, output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, revenue1.total_revenue, revenue1.supplier_no] }
        │   ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
        │   │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
        │   └─StreamExchange { dist: HashShard($expr1) }
        │     └─StreamProject { exprs: [revenue1.total_revenue, revenue1.supplier_no::Int64 as $expr1, revenue1.supplier_no] }
        │       └─StreamTableScan { table: revenue1, columns: [revenue1.supplier_no, revenue1.total_revenue], stream_scan_type: ArrangementBackfill, stream_key: [revenue1.supplier_no], pk: [supplier_no], dist: UpstreamHashShard(revenue1.supplier_no) }
        └─StreamExchange { dist: HashShard(max(max(revenue1.total_revenue))) }
          └─StreamProject { exprs: [max(max(revenue1.total_revenue))] }
            └─StreamSimpleAgg { aggs: [max(max(revenue1.total_revenue)), count] }
              └─StreamExchange { dist: Single }
                └─StreamHashAgg { group_key: [_vnode], aggs: [max(revenue1.total_revenue), count] }
                  └─StreamProject { exprs: [revenue1.total_revenue, revenue1.supplier_no, Vnode(revenue1.supplier_no) as _vnode] }
                    └─StreamTableScan { table: revenue1, columns: [revenue1.total_revenue, revenue1.supplier_no], stream_scan_type: ArrangementBackfill, stream_key: [revenue1.supplier_no], pk: [supplier_no], dist: UpstreamHashShard(revenue1.supplier_no) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_suppkey, s_name, s_address, s_phone, total_revenue, revenue1.supplier_no(hidden)], stream_key: [s_suppkey, revenue1.supplier_no, total_revenue], pk_columns: [s_suppkey, revenue1.supplier_no, total_revenue], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamExchange Hash([0, 4, 5]) from 1

    Fragment 1
    StreamHashJoin { type: Inner, predicate: revenue1.total_revenue = max(max(revenue1.total_revenue)), output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, revenue1.total_revenue, revenue1.supplier_no] }
    ├── tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ]
    ├── StreamExchange Hash([4]) from 2
    └── StreamExchange Hash([0]) from 5

    Fragment 2
    StreamHashJoin { type: Inner, predicate: supplier.s_suppkey = $expr1, output: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone, revenue1.total_revenue, revenue1.supplier_no] }
    ├── tables: [ HashJoinLeft: 4, HashJoinDegreeLeft: 5, HashJoinRight: 6, HashJoinDegreeRight: 7 ]
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([1]) from 4

    Fragment 3
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_phone], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
    ├── tables: [ StreamScan: 8 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 4
    StreamProject { exprs: [revenue1.total_revenue, revenue1.supplier_no::Int64 as $expr1, revenue1.supplier_no] }
    └── StreamTableScan { table: revenue1, columns: [revenue1.supplier_no, revenue1.total_revenue], stream_scan_type: ArrangementBackfill, stream_key: [revenue1.supplier_no], pk: [supplier_no], dist: UpstreamHashShard(revenue1.supplier_no) }
        ├── tables: [ StreamScan: 9 ]
        ├── Upstream
        └── BatchPlanNode

    Fragment 5
    StreamProject { exprs: [max(max(revenue1.total_revenue))] }
    └── StreamSimpleAgg { aggs: [max(max(revenue1.total_revenue)), count] } { tables: [ SimpleAggState: 11, SimpleAggCall0: 10 ] }
        └── StreamExchange Single from 6

    Fragment 6
    StreamHashAgg { group_key: [_vnode], aggs: [max(revenue1.total_revenue), count] } { tables: [ HashAggState: 13, HashAggCall0: 12 ] }
    └── StreamProject { exprs: [revenue1.total_revenue, revenue1.supplier_no, Vnode(revenue1.supplier_no) as _vnode] }
        └── StreamTableScan { table: revenue1, columns: [revenue1.total_revenue, revenue1.supplier_no], stream_scan_type: ArrangementBackfill, stream_key: [revenue1.supplier_no], pk: [supplier_no], dist: UpstreamHashShard(revenue1.supplier_no) }
            ├── tables: [ StreamScan: 14 ]
            ├── Upstream
            └── BatchPlanNode

    Table 0
    ├── columns: [ supplier_s_suppkey, supplier_s_name, supplier_s_address, supplier_s_phone, revenue1_total_revenue, revenue1_supplier_no, _rw_timestamp ]
    ├── primary key: [ $4 ASC, $0 ASC, $5 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5 ]
    ├── distribution key: [ 4 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ revenue1_total_revenue, supplier_s_suppkey, revenue1_supplier_no, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ max(max(revenue1_total_revenue)), _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ max(max(revenue1_total_revenue)), _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ supplier_s_suppkey, supplier_s_name, supplier_s_address, supplier_s_phone, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ revenue1_total_revenue, $expr1, revenue1_supplier_no, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ $expr1, revenue1_supplier_no, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 9 { columns: [ vnode, supplier_no, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 10 { columns: [ max(revenue1_total_revenue), _vnode, _rw_timestamp ], primary key: [ $0 DESC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 11 { columns: [ max(max(revenue1_total_revenue)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 12 { columns: [ _vnode, revenue1_total_revenue, revenue1_supplier_no, _rw_timestamp ], primary key: [ $0 ASC, $1 DESC, $2 ASC ], value indices: [ 1, 2 ], distribution key: [ 2 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 13 { columns: [ _vnode, max(revenue1_total_revenue), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 14 { columns: [ vnode, supplier_no, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ s_suppkey, s_name, s_address, s_phone, total_revenue, revenue1.supplier_no, _rw_timestamp ], primary key: [ $0 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0, 4, 5 ], read pk prefix len hint: 3 }

- id: ch_q16
  before:
  - create_tables
  sql: "select\t i_name,\n           substr(i_data, 1, 3) as brand,\n           i_price,\n           count(distinct (mod((s_w_id * s_i_id),10000))) as supplier_cnt\nfrom\t stock, item\nwhere\t i_id = s_i_id\n  and i_data not like 'zz%'\n  and (mod((s_w_id * s_i_id),10000) not in\n       (select s_suppkey\n        from supplier\n        where s_comment like '%bad%'))\ngroup by i_name, substr(i_data, 1, 3), i_price\norder by supplier_cnt desc;\n"
  logical_plan: |-
    LogicalProject { exprs: [item.i_name, $expr1, item.i_price, count(distinct $expr2)] }
    └─LogicalAgg { group_key: [item.i_name, $expr1, item.i_price], aggs: [count(distinct $expr2)] }
      └─LogicalProject { exprs: [item.i_name, Substr(item.i_data, 1:Int32, 3:Int32) as $expr1, item.i_price, ((stock.s_w_id * stock.s_i_id) % 10000:Int32) as $expr2] }
        └─LogicalFilter { predicate: (item.i_id = stock.s_i_id) AND Not(Like(item.i_data, 'zz%':Varchar)) }
          └─LogicalApply { type: LeftAnti, on: (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey), correlated_id: 1 }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
            │ └─LogicalScan { table: item, columns: [item.i_id, item.i_im_id, item.i_name, item.i_price, item.i_data, item._rw_timestamp] }
            └─LogicalProject { exprs: [supplier.s_suppkey] }
              └─LogicalFilter { predicate: Like(supplier.s_comment, '%bad%':Varchar) }
                └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [item.i_name, $expr2, item.i_price], aggs: [count($expr3)] }
    └─LogicalAgg { group_key: [item.i_name, $expr2, item.i_price, $expr3], aggs: [] }
      └─LogicalProject { exprs: [item.i_name, Substr(item.i_data, 1:Int32, 3:Int32) as $expr2, item.i_price, ((stock.s_w_id * stock.s_i_id) % 10000:Int32) as $expr3] }
        └─LogicalJoin { type: LeftAnti, on: ($expr1 = supplier.s_suppkey), output: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data] }
          ├─LogicalProject { exprs: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
          │ └─LogicalJoin { type: Inner, on: (item.i_id = stock.s_i_id), output: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data] }
          │   ├─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id] }
          │   └─LogicalScan { table: item, columns: [item.i_id, item.i_name, item.i_price, item.i_data], predicate: (Not((item.i_data >= 'zz':Varchar)) OR Not((item.i_data < 'z{':Varchar))) }
          └─LogicalScan { table: supplier, output_columns: [supplier.s_suppkey], required_columns: [supplier.s_suppkey, supplier.s_comment], predicate: Like(supplier.s_comment, '%bad%':Varchar) }
  batch_plan: |-
    BatchExchange { order: [count($expr3) DESC], dist: Single }
    └─BatchSort { order: [count($expr3) DESC] }
      └─BatchHashAgg { group_key: [item.i_name, $expr2, item.i_price], aggs: [count($expr3)] }
        └─BatchExchange { order: [], dist: HashShard(item.i_name, $expr2, item.i_price) }
          └─BatchHashAgg { group_key: [item.i_name, $expr2, item.i_price, $expr3], aggs: [] }
            └─BatchExchange { order: [], dist: HashShard(item.i_name, $expr2, item.i_price, $expr3) }
              └─BatchProject { exprs: [item.i_name, Substr(item.i_data, 1:Int32, 3:Int32) as $expr2, item.i_price, ((stock.s_w_id * stock.s_i_id) % 10000:Int32) as $expr3] }
                └─BatchLookupJoin { type: LeftAnti, predicate: $expr1 = supplier.s_suppkey AND Like(supplier.s_comment, '%bad%':Varchar), output: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data], lookup table: supplier }
                  └─BatchExchange { order: [], dist: UpstreamHashShard($expr1) }
                    └─BatchProject { exprs: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
                      └─BatchLookupJoin { type: Inner, predicate: stock.s_i_id = item.i_id AND (Not((item.i_data >= 'zz':Varchar)) OR Not((item.i_data < 'z{':Varchar))), output: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data], lookup table: item }
                        └─BatchExchange { order: [], dist: UpstreamHashShard(stock.s_i_id) }
                          └─BatchScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], distribution: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
  stream_plan: |-
    StreamMaterialize { columns: [i_name, brand, i_price, supplier_cnt], stream_key: [i_name, brand, i_price], pk_columns: [supplier_cnt, i_name, brand, i_price], pk_conflict: NoCheck }
    └─StreamProject { exprs: [item.i_name, $expr2, item.i_price, count(distinct $expr3)] }
      └─StreamHashAgg { group_key: [item.i_name, $expr2, item.i_price], aggs: [count(distinct $expr3), count] }
        └─StreamExchange { dist: HashShard(item.i_name, $expr2, item.i_price) }
          └─StreamProject { exprs: [item.i_name, Substr(item.i_data, 1:Int32, 3:Int32) as $expr2, item.i_price, ((stock.s_w_id * stock.s_i_id) % 10000:Int32) as $expr3, stock.s_w_id, stock.s_i_id, $expr1] }
            └─StreamHashJoin { type: LeftAnti, predicate: $expr1 = supplier.s_suppkey, output: all }
              ├─StreamExchange { dist: HashShard($expr1) }
              │ └─StreamProject { exprs: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
              │   └─StreamHashJoin { type: Inner, predicate: stock.s_i_id = item.i_id, output: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data, item.i_id] }
              │     ├─StreamExchange { dist: HashShard(stock.s_i_id) }
              │     │ └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
              │     └─StreamExchange { dist: HashShard(item.i_id) }
              │       └─StreamFilter { predicate: Not(Like(item.i_data, 'zz%':Varchar)) }
              │         └─StreamTableScan { table: item, columns: [item.i_id, item.i_name, item.i_price, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) }
              └─StreamExchange { dist: HashShard(supplier.s_suppkey) }
                └─StreamProject { exprs: [supplier.s_suppkey] }
                  └─StreamFilter { predicate: Like(supplier.s_comment, '%bad%':Varchar) }
                    └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_comment], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [i_name, brand, i_price, supplier_cnt], stream_key: [i_name, brand, i_price], pk_columns: [supplier_cnt, i_name, brand, i_price], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [item.i_name, $expr2, item.i_price, count(distinct $expr3)] }
        └── StreamHashAgg { group_key: [item.i_name, $expr2, item.i_price], aggs: [count(distinct $expr3), count] } { tables: [ HashAggState: 0, HashAggDedupForCol3: 1 ] }
            └── StreamExchange Hash([0, 1, 2]) from 1

    Fragment 1
    StreamProject { exprs: [item.i_name, Substr(item.i_data, 1:Int32, 3:Int32) as $expr2, item.i_price, ((stock.s_w_id * stock.s_i_id) % 10000:Int32) as $expr3, stock.s_w_id, stock.s_i_id, $expr1] }
    └── StreamHashJoin { type: LeftAnti, predicate: $expr1 = supplier.s_suppkey, output: all } { tables: [ HashJoinLeft: 2, HashJoinDegreeLeft: 3, HashJoinRight: 4, HashJoinDegreeRight: 5 ] }
        ├── StreamExchange Hash([5]) from 2
        └── StreamExchange Hash([0]) from 5

    Fragment 2
    StreamProject { exprs: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
    └── StreamHashJoin { type: Inner, predicate: stock.s_i_id = item.i_id, output: [stock.s_i_id, stock.s_w_id, item.i_name, item.i_price, item.i_data, item.i_id] }
        ├── tables: [ HashJoinLeft: 6, HashJoinDegreeLeft: 7, HashJoinRight: 8, HashJoinDegreeRight: 9 ]
        ├── StreamExchange Hash([0]) from 3
        └── StreamExchange Hash([0]) from 4

    Fragment 3
    StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
    ├── tables: [ StreamScan: 10 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 4
    StreamFilter { predicate: Not(Like(item.i_data, 'zz%':Varchar)) }
    └── StreamTableScan { table: item, columns: [item.i_id, item.i_name, item.i_price, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) }
        ├── tables: [ StreamScan: 11 ]
        ├── Upstream
        └── BatchPlanNode

    Fragment 5
    StreamProject { exprs: [supplier.s_suppkey] }
    └── StreamFilter { predicate: Like(supplier.s_comment, '%bad%':Varchar) }
        └── StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_comment], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
            ├── tables: [ StreamScan: 12 ]
            ├── Upstream
            └── BatchPlanNode

    Table 0 { columns: [ item_i_name, $expr2, item_i_price, count(distinct $expr3), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 1
    ├── columns: [ item_i_name, $expr2, item_i_price, $expr3, count_for_agg_call_0, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ]
    ├── value indices: [ 4 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 4

    Table 2
    ├── columns: [ stock_s_i_id, stock_s_w_id, item_i_name, item_i_price, item_i_data, $expr1, _rw_timestamp ]
    ├── primary key: [ $5 ASC, $1 ASC, $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5 ]
    ├── distribution key: [ 5 ]
    └── read pk prefix len hint: 1

    Table 3 { columns: [ $expr1, stock_s_w_id, stock_s_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ supplier_s_suppkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ stock_s_i_id, stock_s_w_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ stock_s_i_id, stock_s_w_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ item_i_id, item_i_name, item_i_price, item_i_data, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 11 { columns: [ vnode, i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 12 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ i_name, brand, i_price, supplier_cnt, _rw_timestamp ], primary key: [ $3 DESC, $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 4 }

- id: ch_q17
  before:
  - create_tables
  sql: "select\tsum(ol_amount) / 2.0 as avg_yearly\nfrom\torder_line, (select   i_id, avg(ol_quantity) as a\nfrom     item, order_line\nwhere    i_data like '%b'\nand ol_i_id = i_id\ngroup by i_id) t\nwhere\tol_i_id = t.i_id\nand ol_quantity < t.a;\n"
  logical_plan: |-
    LogicalProject { exprs: [(sum(order_line.ol_amount) / 2.0:Decimal) as $expr2] }
    └─LogicalAgg { aggs: [sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [order_line.ol_amount] }
        └─LogicalFilter { predicate: (order_line.ol_i_id = item.i_id) AND (order_line.ol_quantity::Decimal < $expr1) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
            └─LogicalProject { exprs: [item.i_id, (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr1] }
              └─LogicalAgg { group_key: [item.i_id], aggs: [sum(order_line.ol_quantity), count(order_line.ol_quantity)] }
                └─LogicalProject { exprs: [item.i_id, order_line.ol_quantity] }
                  └─LogicalFilter { predicate: Like(item.i_data, '%b':Varchar) AND (order_line.ol_i_id = item.i_id) }
                    └─LogicalJoin { type: Inner, on: true, output: all }
                      ├─LogicalScan { table: item, columns: [item.i_id, item.i_im_id, item.i_name, item.i_price, item.i_data, item._rw_timestamp] }
                      └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [(sum(order_line.ol_amount) / 2.0:Decimal) as $expr3] }
    └─LogicalAgg { aggs: [sum(order_line.ol_amount)] }
      └─LogicalJoin { type: Inner, on: (order_line.ol_i_id = item.i_id) AND ($expr1 < $expr2), output: [order_line.ol_amount] }
        ├─LogicalProject { exprs: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_quantity::Decimal as $expr1] }
        │ └─LogicalScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_amount] }
        └─LogicalProject { exprs: [item.i_id, (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr2] }
          └─LogicalAgg { group_key: [item.i_id], aggs: [sum(order_line.ol_quantity), count(order_line.ol_quantity)] }
            └─LogicalJoin { type: Inner, on: (order_line.ol_i_id = item.i_id), output: [item.i_id, order_line.ol_quantity] }
              ├─LogicalScan { table: item, output_columns: [item.i_id], required_columns: [item.i_id, item.i_data], predicate: Like(item.i_data, '%b':Varchar) }
              └─LogicalScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity] }
  batch_plan: |-
    BatchProject { exprs: [(sum(sum(order_line.ol_amount)) / 2.0:Decimal) as $expr3] }
    └─BatchSimpleAgg { aggs: [sum(sum(order_line.ol_amount))] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchSimpleAgg { aggs: [sum(order_line.ol_amount)] }
          └─BatchHashJoin { type: Inner, predicate: order_line.ol_i_id = item.i_id AND ($expr1 < $expr2), output: [order_line.ol_amount] }
            ├─BatchExchange { order: [], dist: HashShard(order_line.ol_i_id) }
            │ └─BatchProject { exprs: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_quantity::Decimal as $expr1] }
            │   └─BatchScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_amount], distribution: SomeShard }
            └─BatchProject { exprs: [item.i_id, (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr2] }
              └─BatchHashAgg { group_key: [item.i_id], aggs: [sum(order_line.ol_quantity), count(order_line.ol_quantity)] }
                └─BatchHashJoin { type: Inner, predicate: item.i_id = order_line.ol_i_id, output: [item.i_id, order_line.ol_quantity] }
                  ├─BatchExchange { order: [], dist: HashShard(item.i_id) }
                  │ └─BatchProject { exprs: [item.i_id] }
                  │   └─BatchFilter { predicate: Like(item.i_data, '%b':Varchar) }
                  │     └─BatchScan { table: item, columns: [item.i_id, item.i_data], distribution: UpstreamHashShard(item.i_id) }
                  └─BatchExchange { order: [], dist: HashShard(order_line.ol_i_id) }
                    └─BatchScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [avg_yearly], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [(sum(sum(order_line.ol_amount)) / 2.0:Decimal) as $expr3] }
      └─StreamSimpleAgg { aggs: [sum(sum(order_line.ol_amount)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [sum(order_line.ol_amount)] }
            └─StreamProject { exprs: [order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id, item.i_id] }
              └─StreamFilter { predicate: ($expr1 < $expr2) }
                └─StreamHashJoin { type: Inner, predicate: order_line.ol_i_id = item.i_id, output: all }
                  ├─StreamExchange { dist: HashShard(order_line.ol_i_id) }
                  │ └─StreamProject { exprs: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_quantity::Decimal as $expr1, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
                  │   └─StreamTableScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
                  └─StreamProject { exprs: [item.i_id, (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr2] }
                    └─StreamHashAgg { group_key: [item.i_id], aggs: [sum(order_line.ol_quantity), count(order_line.ol_quantity), count] }
                      └─StreamHashJoin { type: Inner, predicate: item.i_id = order_line.ol_i_id, output: [item.i_id, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
                        ├─StreamExchange { dist: HashShard(item.i_id) }
                        │ └─StreamProject { exprs: [item.i_id] }
                        │   └─StreamFilter { predicate: Like(item.i_data, '%b':Varchar) }
                        │     └─StreamTableScan { table: item, columns: [item.i_id, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) }
                        └─StreamExchange { dist: HashShard(order_line.ol_i_id) }
                          └─StreamTableScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [avg_yearly], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [(sum(sum(order_line.ol_amount)) / 2.0:Decimal) as $expr3] }
        └── StreamSimpleAgg { aggs: [sum(sum(order_line.ol_amount)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [sum(order_line.ol_amount)] }
    └── StreamProject { exprs: [order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id, item.i_id] }
        └── StreamFilter { predicate: ($expr1 < $expr2) }
            └── StreamHashJoin { type: Inner, predicate: order_line.ol_i_id = item.i_id, output: all } { tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ] }
                ├── StreamExchange Hash([0]) from 2
                └── StreamProject { exprs: [item.i_id, (sum(order_line.ol_quantity)::Decimal / count(order_line.ol_quantity)::Decimal) as $expr2] }
                    └── StreamHashAgg { group_key: [item.i_id], aggs: [sum(order_line.ol_quantity), count(order_line.ol_quantity), count] } { tables: [ HashAggState: 6 ] }
                        └── StreamHashJoin { type: Inner, predicate: item.i_id = order_line.ol_i_id, output: [item.i_id, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
                            ├── tables: [ HashJoinLeft: 7, HashJoinDegreeLeft: 8, HashJoinRight: 9, HashJoinDegreeRight: 10 ]
                            ├── StreamExchange Hash([0]) from 3
                            └── StreamExchange Hash([0]) from 4

    Fragment 2
    StreamProject { exprs: [order_line.ol_i_id, order_line.ol_amount, order_line.ol_quantity::Decimal as $expr1, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
    └── StreamTableScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
        ├── tables: [ StreamScan: 5 ]
        ├── Upstream
        └── BatchPlanNode

    Fragment 3
    StreamProject { exprs: [item.i_id] }
    └── StreamFilter { predicate: Like(item.i_data, '%b':Varchar) }
        └── StreamTableScan { table: item, columns: [item.i_id, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) } { tables: [ StreamScan: 11 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 4
    StreamTableScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
    ├── tables: [ StreamScan: 12 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ sum(sum(order_line_ol_amount)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ order_line_ol_i_id, order_line_ol_amount, $expr1, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ order_line_ol_i_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ item_i_id, $expr2, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 6 { columns: [ item_i_id, sum(order_line_ol_quantity), count(order_line_ol_quantity), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ item_i_id, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ order_line_ol_i_id, order_line_ol_quantity, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ order_line_ol_i_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ vnode, i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 12 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ avg_yearly, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: ch_q18
  before:
  - create_tables
  sql: "select\t c_last, c_id o_id, o_entry_d, o_ol_cnt, sum(ol_amount)\nfrom\t customer, orders, order_line\nwhere\t c_id = o_c_id\n  and c_w_id = o_w_id\n  and c_d_id = o_d_id\n  and ol_w_id = o_w_id\n  and ol_d_id = o_d_id\n  and ol_o_id = o_id\ngroup by o_id, o_w_id, o_d_id, c_id, c_last, o_entry_d, o_ol_cnt\nhaving\t sum(ol_amount) > 200\norder by sum(ol_amount) desc, o_entry_d;\n"
  logical_plan: |-
    LogicalProject { exprs: [customer.c_last, customer.c_id, orders.o_entry_d, orders.o_ol_cnt, sum(order_line.ol_amount)] }
    └─LogicalProject { exprs: [customer.c_last, customer.c_id, orders.o_entry_d, orders.o_ol_cnt, sum(order_line.ol_amount), sum(order_line.ol_amount)] }
      └─LogicalFilter { predicate: (sum(order_line.ol_amount) > 200:Int32::Decimal) }
        └─LogicalAgg { group_key: [orders.o_id, orders.o_w_id, orders.o_d_id, customer.c_id, customer.c_last, orders.o_entry_d, orders.o_ol_cnt], aggs: [sum(order_line.ol_amount)] }
          └─LogicalProject { exprs: [orders.o_id, orders.o_w_id, orders.o_d_id, customer.c_id, customer.c_last, orders.o_entry_d, orders.o_ol_cnt, order_line.ol_amount] }
            └─LogicalFilter { predicate: (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id) }
              └─LogicalJoin { type: Inner, on: true, output: all }
                ├─LogicalJoin { type: Inner, on: true, output: all }
                │ ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_first, customer.c_middle, customer.c_last, customer.c_street_1, customer.c_street_2, customer.c_city, customer.c_state, customer.c_zip, customer.c_phone, customer.c_since, customer.c_credit, customer.c_credit_lim, customer.c_discount, customer.c_balance, customer.c_ytd_payment, customer.c_payment_cnt, customer.c_delivery_cnt, customer.c_data, customer._rw_timestamp] }
                │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
                └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [customer.c_last, customer.c_id, orders.o_entry_d, orders.o_ol_cnt, sum(order_line.ol_amount), sum(order_line.ol_amount)] }
    └─LogicalFilter { predicate: (sum(order_line.ol_amount) > 200:Int32::Decimal) }
      └─LogicalAgg { group_key: [orders.o_id, orders.o_w_id, orders.o_d_id, customer.c_id, customer.c_last, orders.o_entry_d, orders.o_ol_cnt], aggs: [sum(order_line.ol_amount)] }
        └─LogicalJoin { type: Inner, on: (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_o_id = orders.o_id), output: [orders.o_id, orders.o_w_id, orders.o_d_id, customer.c_id, customer.c_last, orders.o_entry_d, orders.o_ol_cnt, order_line.ol_amount] }
          ├─LogicalJoin { type: Inner, on: (customer.c_id = orders.o_c_id) AND (customer.c_w_id = orders.o_w_id) AND (customer.c_d_id = orders.o_d_id), output: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt] }
          │ ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last] }
          │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_ol_cnt] }
          └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount] }
  batch_plan: |-
    BatchProject { exprs: [customer.c_last, customer.c_id, orders.o_entry_d, orders.o_ol_cnt, sum(order_line.ol_amount)] }
    └─BatchExchange { order: [sum(order_line.ol_amount) DESC, orders.o_entry_d ASC], dist: Single }
      └─BatchProject { exprs: [customer.c_last, customer.c_id, orders.o_entry_d, orders.o_ol_cnt, sum(order_line.ol_amount), sum(order_line.ol_amount)] }
        └─BatchSort { order: [sum(order_line.ol_amount) DESC, orders.o_entry_d ASC] }
          └─BatchFilter { predicate: (sum(order_line.ol_amount) > 200:Decimal) }
            └─BatchHashAgg { group_key: [orders.o_id, orders.o_w_id, orders.o_d_id, customer.c_id, customer.c_last, orders.o_entry_d, orders.o_ol_cnt], aggs: [sum(order_line.ol_amount)] }
              └─BatchHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: [orders.o_id, orders.o_w_id, orders.o_d_id, customer.c_id, customer.c_last, orders.o_entry_d, orders.o_ol_cnt, order_line.ol_amount] }
                ├─BatchExchange { order: [], dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
                │ └─BatchHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt] }
                │   ├─BatchExchange { order: [], dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
                │   │ └─BatchScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last], distribution: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
                │   └─BatchExchange { order: [], dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
                │     └─BatchScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_ol_cnt], distribution: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
                └─BatchExchange { order: [], dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
                  └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [c_last, o_id, o_entry_d, o_ol_cnt, sum, sum(order_line.ol_amount)(hidden), orders.o_id(hidden), orders.o_d_id(hidden), orders.o_w_id(hidden)], stream_key: [o_id, c_last, orders.o_id, orders.o_d_id, orders.o_w_id, o_entry_d, o_ol_cnt], pk_columns: [sum(order_line.ol_amount), o_entry_d, o_id, c_last, orders.o_id, orders.o_d_id, orders.o_w_id, o_ol_cnt], pk_conflict: NoCheck }
    └─StreamProject { exprs: [customer.c_last, customer.c_id, orders.o_entry_d, orders.o_ol_cnt, sum(order_line.ol_amount), sum(order_line.ol_amount), orders.o_id, orders.o_d_id, orders.o_w_id] }
      └─StreamFilter { predicate: (sum(order_line.ol_amount) > 200:Decimal) }
        └─StreamProject { exprs: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt, sum(order_line.ol_amount)] }
          └─StreamHashAgg { group_key: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt], aggs: [sum(order_line.ol_amount), count] }
            └─StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt, order_line.ol_amount, customer.c_w_id, customer.c_d_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
              ├─StreamExchange { dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
              │ └─StreamHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt, customer.c_w_id, customer.c_d_id] }
              │   ├─StreamExchange { dist: HashShard(customer.c_d_id, customer.c_w_id, customer.c_id) }
              │   │ └─StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
              │   └─StreamExchange { dist: HashShard(orders.o_d_id, orders.o_w_id, orders.o_c_id) }
              │     └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_ol_cnt], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
              └─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
                └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [c_last, o_id, o_entry_d, o_ol_cnt, sum, sum(order_line.ol_amount)(hidden), orders.o_id(hidden), orders.o_d_id(hidden), orders.o_w_id(hidden)], stream_key: [o_id, c_last, orders.o_id, orders.o_d_id, orders.o_w_id, o_entry_d, o_ol_cnt], pk_columns: [sum(order_line.ol_amount), o_entry_d, o_id, c_last, orders.o_id, orders.o_d_id, orders.o_w_id, o_ol_cnt], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [customer.c_last, customer.c_id, orders.o_entry_d, orders.o_ol_cnt, sum(order_line.ol_amount), sum(order_line.ol_amount), orders.o_id, orders.o_d_id, orders.o_w_id] }
        └── StreamFilter { predicate: (sum(order_line.ol_amount) > 200:Decimal) }
            └── StreamProject { exprs: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt, sum(order_line.ol_amount)] }
                └── StreamHashAgg { group_key: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt], aggs: [sum(order_line.ol_amount), count] } { tables: [ HashAggState: 0 ] }
                    └── StreamHashJoin { type: Inner, predicate: orders.o_w_id = order_line.ol_w_id AND orders.o_d_id = order_line.ol_d_id AND orders.o_id = order_line.ol_o_id, output: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt, order_line.ol_amount, customer.c_w_id, customer.c_d_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
                        ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
                        ├── StreamExchange Hash([2, 3, 4]) from 1
                        └── StreamExchange Hash([0, 1, 2]) from 4

    Fragment 1
    StreamHashJoin { type: Inner, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_id, customer.c_last, orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d, orders.o_ol_cnt, customer.c_w_id, customer.c_d_id] } { tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ] }
    ├── StreamExchange Hash([1, 2, 0]) from 2
    └── StreamExchange Hash([1, 2, 3]) from 3

    Fragment 2
    StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_last], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) } { tables: [ StreamScan: 9 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 3
    StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_ol_cnt], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) } { tables: [ StreamScan: 10 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 4
    StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_amount, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
    ├── tables: [ StreamScan: 11 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ customer_c_id, customer_c_last, orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_entry_d, orders_o_ol_cnt, sum(order_line_ol_amount), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC ], value indices: [ 7, 8 ], distribution key: [ 2, 3, 4 ], read pk prefix len hint: 7 }

    Table 1 { columns: [ customer_c_id, customer_c_last, orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_entry_d, orders_o_ol_cnt, customer_c_w_id, customer_c_d_id, _rw_timestamp ], primary key: [ $4 ASC, $3 ASC, $2 ASC, $7 ASC, $8 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 2, 3, 4 ], read pk prefix len hint: 3 }

    Table 2 { columns: [ orders_o_w_id, orders_o_d_id, orders_o_id, customer_c_w_id, customer_c_d_id, customer_c_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 3 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_amount, order_line_ol_number, _rw_timestamp ], primary key: [ $2 ASC, $1 ASC, $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 4 { columns: [ order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 5 { columns: [ customer_c_id, customer_c_d_id, customer_c_w_id, customer_c_last, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1, 2, 0 ], read pk prefix len hint: 3 }

    Table 6 { columns: [ customer_c_id, customer_c_w_id, customer_c_d_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 7 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_c_id, orders_o_entry_d, orders_o_ol_cnt, _rw_timestamp ], primary key: [ $3 ASC, $2 ASC, $1 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 1, 2, 3 ], read pk prefix len hint: 3 }

    Table 8 { columns: [ orders_o_c_id, orders_o_w_id, orders_o_d_id, orders_o_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1, 0 ], read pk prefix len hint: 3 }

    Table 9 { columns: [ vnode, c_w_id, c_d_id, c_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 10 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 11 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ c_last, o_id, o_entry_d, o_ol_cnt, sum, sum(order_line.ol_amount), orders.o_id, orders.o_d_id, orders.o_w_id, _rw_timestamp ], primary key: [ $5 DESC, $2 ASC, $1 ASC, $0 ASC, $6 ASC, $7 ASC, $8 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 6, 7, 8 ], read pk prefix len hint: 8 }

- id: ch_q19
  before:
  - create_tables
  sql: "select\tsum(ol_amount) as revenue\nfrom\torder_line, item\nwhere\t(\nol_i_id = i_id\nand i_data like '%a'\nand ol_quantity >= 1\nand ol_quantity <= 10\nand i_price between 1 and 400000\nand ol_w_id in (1,2,3)\n) or (\nol_i_id = i_id\nand i_data like '%b'\nand ol_quantity >= 1\nand ol_quantity <= 10\nand i_price between 1 and 400000\nand ol_w_id in (1,2,4)\n) or (\nol_i_id = i_id\nand i_data like '%c'\nand ol_quantity >= 1\nand ol_quantity <= 10\nand i_price between 1 and 400000\nand ol_w_id in (1,5,3)\n)\n"
  logical_plan: |-
    LogicalProject { exprs: [sum(order_line.ol_amount)] }
    └─LogicalAgg { aggs: [sum(order_line.ol_amount)] }
      └─LogicalProject { exprs: [order_line.ol_amount] }
        └─LogicalFilter { predicate: (order_line.ol_i_id = item.i_id) AND (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 10:Int32) AND (item.i_price >= 1:Int32::Decimal) AND (item.i_price <= 400000:Int32::Decimal) AND (((Like(item.i_data, '%a':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 3:Int32)) OR (Like(item.i_data, '%b':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 4:Int32))) OR (Like(item.i_data, '%c':Varchar) AND In(order_line.ol_w_id, 1:Int32, 5:Int32, 3:Int32))) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
            └─LogicalScan { table: item, columns: [item.i_id, item.i_im_id, item.i_name, item.i_price, item.i_data, item._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { aggs: [sum(order_line.ol_amount)] }
    └─LogicalJoin { type: Inner, on: (order_line.ol_i_id = item.i_id) AND (((Like(item.i_data, '%a':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 3:Int32)) OR (Like(item.i_data, '%b':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 4:Int32))) OR (Like(item.i_data, '%c':Varchar) AND In(order_line.ol_w_id, 1:Int32, 5:Int32, 3:Int32))), output: [order_line.ol_amount] }
      ├─LogicalScan { table: order_line, output_columns: [order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount], required_columns: [order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount, order_line.ol_quantity], predicate: (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 10:Int32) }
      └─LogicalScan { table: item, output_columns: [item.i_id, item.i_data], required_columns: [item.i_id, item.i_data, item.i_price], predicate: (item.i_price >= 1:Int32::Decimal) AND (item.i_price <= 400000:Int32::Decimal) }
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum(sum(order_line.ol_amount))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [sum(order_line.ol_amount)] }
        └─BatchLookupJoin { type: Inner, predicate: order_line.ol_i_id = item.i_id AND (((Like(item.i_data, '%a':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 3:Int32)) OR (Like(item.i_data, '%b':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 4:Int32))) OR (Like(item.i_data, '%c':Varchar) AND In(order_line.ol_w_id, 1:Int32, 5:Int32, 3:Int32))) AND (item.i_price >= 1:Decimal) AND (item.i_price <= 400000:Decimal), output: [order_line.ol_amount], lookup table: item }
          └─BatchExchange { order: [], dist: UpstreamHashShard(order_line.ol_i_id) }
            └─BatchProject { exprs: [order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount] }
              └─BatchFilter { predicate: (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 10:Int32) }
                └─BatchScan { table: order_line, columns: [order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount, order_line.ol_quantity], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [revenue], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [sum(sum(order_line.ol_amount))] }
      └─StreamSimpleAgg { aggs: [sum(sum(order_line.ol_amount)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessSimpleAgg { aggs: [sum(order_line.ol_amount)] }
            └─StreamProject { exprs: [order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id, item.i_id] }
              └─StreamFilter { predicate: (((Like(item.i_data, '%a':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 3:Int32)) OR (Like(item.i_data, '%b':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 4:Int32))) OR (Like(item.i_data, '%c':Varchar) AND In(order_line.ol_w_id, 1:Int32, 5:Int32, 3:Int32))) }
                └─StreamHashJoin { type: Inner, predicate: order_line.ol_i_id = item.i_id, output: all }
                  ├─StreamExchange { dist: HashShard(order_line.ol_i_id) }
                  │ └─StreamProject { exprs: [order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
                  │   └─StreamFilter { predicate: (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 10:Int32) }
                  │     └─StreamTableScan { table: order_line, columns: [order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_quantity], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
                  └─StreamExchange { dist: HashShard(item.i_id) }
                    └─StreamProject { exprs: [item.i_id, item.i_data] }
                      └─StreamFilter { predicate: (item.i_price >= 1:Decimal) AND (item.i_price <= 400000:Decimal) }
                        └─StreamTableScan { table: item, columns: [item.i_id, item.i_data, item.i_price], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [revenue], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamProject { exprs: [sum(sum(order_line.ol_amount))] }
        └── StreamSimpleAgg { aggs: [sum(sum(order_line.ol_amount)), count] }
            ├── tables: [ SimpleAggState: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamStatelessSimpleAgg { aggs: [sum(order_line.ol_amount)] }
    └── StreamProject { exprs: [order_line.ol_amount, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_i_id, item.i_id] }
        └── StreamFilter { predicate: (((Like(item.i_data, '%a':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 3:Int32)) OR (Like(item.i_data, '%b':Varchar) AND In(order_line.ol_w_id, 1:Int32, 2:Int32, 4:Int32))) OR (Like(item.i_data, '%c':Varchar) AND In(order_line.ol_w_id, 1:Int32, 5:Int32, 3:Int32))) }
            └── StreamHashJoin { type: Inner, predicate: order_line.ol_i_id = item.i_id, output: all } { tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ] }
                ├── StreamExchange Hash([1]) from 2
                └── StreamExchange Hash([0]) from 3

    Fragment 2
    StreamProject { exprs: [order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
    └── StreamFilter { predicate: (order_line.ol_quantity >= 1:Int32) AND (order_line.ol_quantity <= 10:Int32) }
        └── StreamTableScan { table: order_line, columns: [order_line.ol_w_id, order_line.ol_i_id, order_line.ol_amount, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_quantity], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
            ├── tables: [ StreamScan: 5 ]
            ├── Upstream
            └── BatchPlanNode

    Fragment 3
    StreamProject { exprs: [item.i_id, item.i_data] }
    └── StreamFilter { predicate: (item.i_price >= 1:Decimal) AND (item.i_price <= 400000:Decimal) }
        └── StreamTableScan { table: item, columns: [item.i_id, item.i_data, item.i_price], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) } { tables: [ StreamScan: 6 ] }
            ├── Upstream
            └── BatchPlanNode

    Table 0 { columns: [ sum(sum(order_line_ol_amount)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ order_line_ol_w_id, order_line_ol_i_id, order_line_ol_amount, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ order_line_ol_i_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ item_i_id, item_i_data, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 6 { columns: [ vnode, i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ revenue, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

- id: ch_q20
  before:
  - create_tables
  sql: "select\t s_name, s_address\nfrom\t supplier, nation\nwhere\t s_suppkey in\n          (select  mod(s_i_id * s_w_id, 10000)\n           from     stock, order_line\n           where    s_i_id in\n                    (select i_id\n                     from item\n                     where i_data like 'co%')\n             and ol_i_id=s_i_id\n             and ol_delivery_d > '2010-05-23 12:00:00'\n           group by s_i_id, s_w_id, s_quantity\n           having   2*s_quantity > sum(ol_quantity))\n  and s_nationkey = n_nationkey\n  and n_name = 'CHINA'\norder by s_name;\n"
  logical_plan: |-
    LogicalProject { exprs: [supplier.s_name, supplier.s_address] }
    └─LogicalFilter { predicate: (supplier.s_nationkey = nation.n_nationkey) AND (nation.n_name = 'CHINA':Varchar) }
      └─LogicalApply { type: LeftSemi, on: (supplier.s_suppkey = $expr1), correlated_id: 1 }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
        │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
        └─LogicalProject { exprs: [((stock.s_i_id * stock.s_w_id) % 10000:Int32) as $expr1] }
          └─LogicalFilter { predicate: ((2:Int32 * stock.s_quantity) > sum(order_line.ol_quantity)) }
            └─LogicalAgg { group_key: [stock.s_i_id, stock.s_w_id, stock.s_quantity], aggs: [sum(order_line.ol_quantity)] }
              └─LogicalProject { exprs: [stock.s_i_id, stock.s_w_id, stock.s_quantity, order_line.ol_quantity] }
                └─LogicalFilter { predicate: (order_line.ol_i_id = stock.s_i_id) AND (order_line.ol_delivery_d > '2010-05-23 12:00:00':Timestamp) }
                  └─LogicalApply { type: LeftSemi, on: (stock.s_i_id = item.i_id), correlated_id: 2 }
                    ├─LogicalJoin { type: Inner, on: true, output: all }
                    │ ├─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
                    │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
                    └─LogicalProject { exprs: [item.i_id] }
                      └─LogicalFilter { predicate: Like(item.i_data, 'co%':Varchar) }
                        └─LogicalScan { table: item, columns: [item.i_id, item.i_im_id, item.i_name, item.i_price, item.i_data, item._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (supplier.s_suppkey = $expr1), output: [supplier.s_name, supplier.s_address] }
    ├─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [supplier.s_suppkey, supplier.s_name, supplier.s_address] }
    │ ├─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey] }
    │ └─LogicalScan { table: nation, output_columns: [nation.n_nationkey], required_columns: [nation.n_nationkey, nation.n_name], predicate: (nation.n_name = 'CHINA':Varchar) }
    └─LogicalProject { exprs: [((stock.s_i_id * stock.s_w_id) % 10000:Int32)::Int64 as $expr1] }
      └─LogicalFilter { predicate: ((2:Int32 * stock.s_quantity) > sum(order_line.ol_quantity)) }
        └─LogicalAgg { group_key: [stock.s_i_id, stock.s_w_id, stock.s_quantity], aggs: [sum(order_line.ol_quantity)] }
          └─LogicalJoin { type: LeftSemi, on: (stock.s_i_id = item.i_id), output: all }
            ├─LogicalJoin { type: Inner, on: (order_line.ol_i_id = stock.s_i_id), output: [stock.s_i_id, stock.s_w_id, stock.s_quantity, order_line.ol_quantity] }
            │ ├─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity] }
            │ └─LogicalScan { table: order_line, output_columns: [order_line.ol_i_id, order_line.ol_quantity], required_columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_delivery_d], predicate: (order_line.ol_delivery_d > '2010-05-23 12:00:00':Timestamp) }
            └─LogicalScan { table: item, output_columns: [item.i_id], required_columns: [item.i_id, item.i_data], predicate: (item.i_data >= 'co':Varchar) AND (item.i_data < 'cp':Varchar) }
  batch_plan: |-
    BatchExchange { order: [supplier.s_name ASC], dist: Single }
    └─BatchSort { order: [supplier.s_name ASC] }
      └─BatchHashJoin { type: LeftSemi, predicate: supplier.s_suppkey = $expr1, output: [supplier.s_name, supplier.s_address] }
        ├─BatchExchange { order: [], dist: HashShard(supplier.s_suppkey) }
        │ └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey AND (nation.n_name = 'CHINA':Varchar), output: [supplier.s_suppkey, supplier.s_name, supplier.s_address], lookup table: nation }
        │   └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
        │     └─BatchScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey], distribution: UpstreamHashShard(supplier.s_suppkey) }
        └─BatchExchange { order: [], dist: HashShard($expr1) }
          └─BatchProject { exprs: [((stock.s_i_id * stock.s_w_id) % 10000:Int32)::Int64 as $expr1] }
            └─BatchFilter { predicate: ((2:Int32 * stock.s_quantity) > sum(order_line.ol_quantity)) }
              └─BatchHashAgg { group_key: [stock.s_i_id, stock.s_w_id, stock.s_quantity], aggs: [sum(order_line.ol_quantity)] }
                └─BatchLookupJoin { type: LeftSemi, predicate: stock.s_i_id = item.i_id AND (item.i_data >= 'co':Varchar) AND (item.i_data < 'cp':Varchar), output: all, lookup table: item }
                  └─BatchExchange { order: [], dist: UpstreamHashShard(stock.s_i_id) }
                    └─BatchHashJoin { type: Inner, predicate: stock.s_i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, stock.s_quantity, order_line.ol_quantity] }
                      ├─BatchExchange { order: [], dist: HashShard(stock.s_i_id) }
                      │ └─BatchScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity], distribution: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
                      └─BatchExchange { order: [], dist: HashShard(order_line.ol_i_id) }
                        └─BatchProject { exprs: [order_line.ol_i_id, order_line.ol_quantity] }
                          └─BatchFilter { predicate: (order_line.ol_delivery_d > '2010-05-23 12:00:00':Timestamp) }
                            └─BatchScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_delivery_d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, s_address, supplier.s_suppkey(hidden), supplier.s_nationkey(hidden)], stream_key: [supplier.s_suppkey, supplier.s_nationkey], pk_columns: [s_name, supplier.s_suppkey, supplier.s_nationkey], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(supplier.s_suppkey, supplier.s_nationkey) }
      └─StreamHashJoin { type: LeftSemi, predicate: supplier.s_suppkey = $expr1, output: [supplier.s_name, supplier.s_address, supplier.s_suppkey, supplier.s_nationkey] }
        ├─StreamExchange { dist: HashShard(supplier.s_suppkey) }
        │ └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: all }
        │   ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
        │   │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
        │   └─StreamExchange { dist: HashShard(nation.n_nationkey) }
        │     └─StreamProject { exprs: [nation.n_nationkey] }
        │       └─StreamFilter { predicate: (nation.n_name = 'CHINA':Varchar) }
        │         └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
        └─StreamExchange { dist: HashShard($expr1) }
          └─StreamProject { exprs: [((stock.s_i_id * stock.s_w_id) % 10000:Int32)::Int64 as $expr1, stock.s_i_id, stock.s_w_id, stock.s_quantity] }
            └─StreamFilter { predicate: ((2:Int32 * stock.s_quantity) > sum(order_line.ol_quantity)) }
              └─StreamProject { exprs: [stock.s_i_id, stock.s_w_id, stock.s_quantity, sum(order_line.ol_quantity)] }
                └─StreamHashAgg { group_key: [stock.s_i_id, stock.s_w_id, stock.s_quantity], aggs: [sum(order_line.ol_quantity), count] }
                  └─StreamHashJoin { type: LeftSemi, predicate: stock.s_i_id = item.i_id, output: all }
                    ├─StreamHashJoin { type: Inner, predicate: stock.s_i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, stock.s_quantity, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
                    │ ├─StreamExchange { dist: HashShard(stock.s_i_id) }
                    │ │ └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
                    │ └─StreamExchange { dist: HashShard(order_line.ol_i_id) }
                    │   └─StreamProject { exprs: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
                    │     └─StreamFilter { predicate: (order_line.ol_delivery_d > '2010-05-23 12:00:00':Timestamp) }
                    │       └─StreamTableScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_delivery_d], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
                    └─StreamExchange { dist: HashShard(item.i_id) }
                      └─StreamProject { exprs: [item.i_id] }
                        └─StreamFilter { predicate: Like(item.i_data, 'co%':Varchar) }
                          └─StreamTableScan { table: item, columns: [item.i_id, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, s_address, supplier.s_suppkey(hidden), supplier.s_nationkey(hidden)], stream_key: [supplier.s_suppkey, supplier.s_nationkey], pk_columns: [s_name, supplier.s_suppkey, supplier.s_nationkey], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamExchange Hash([2, 3]) from 1

    Fragment 1
    StreamHashJoin { type: LeftSemi, predicate: supplier.s_suppkey = $expr1, output: [supplier.s_name, supplier.s_address, supplier.s_suppkey, supplier.s_nationkey] }
    ├── tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ]
    ├── StreamExchange Hash([0]) from 2
    └── StreamExchange Hash([0]) from 5

    Fragment 2
    StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: all } { tables: [ HashJoinLeft: 4, HashJoinDegreeLeft: 5, HashJoinRight: 6, HashJoinDegreeRight: 7 ] }
    ├── StreamExchange Hash([3]) from 3
    └── StreamExchange Hash([0]) from 4

    Fragment 3
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
    ├── tables: [ StreamScan: 8 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 4
    StreamProject { exprs: [nation.n_nationkey] }
    └── StreamFilter { predicate: (nation.n_name = 'CHINA':Varchar) }
        └── StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 9 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 5
    StreamProject { exprs: [((stock.s_i_id * stock.s_w_id) % 10000:Int32)::Int64 as $expr1, stock.s_i_id, stock.s_w_id, stock.s_quantity] }
    └── StreamFilter { predicate: ((2:Int32 * stock.s_quantity) > sum(order_line.ol_quantity)) }
        └── StreamProject { exprs: [stock.s_i_id, stock.s_w_id, stock.s_quantity, sum(order_line.ol_quantity)] }
            └── StreamHashAgg { group_key: [stock.s_i_id, stock.s_w_id, stock.s_quantity], aggs: [sum(order_line.ol_quantity), count] } { tables: [ HashAggState: 10 ] }
                └── StreamHashJoin { type: LeftSemi, predicate: stock.s_i_id = item.i_id, output: all } { tables: [ HashJoinLeft: 11, HashJoinDegreeLeft: 12, HashJoinRight: 13, HashJoinDegreeRight: 14 ] }
                    ├── StreamHashJoin { type: Inner, predicate: stock.s_i_id = order_line.ol_i_id, output: [stock.s_i_id, stock.s_w_id, stock.s_quantity, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
                    │   ├── tables: [ HashJoinLeft: 15, HashJoinDegreeLeft: 16, HashJoinRight: 17, HashJoinDegreeRight: 18 ]
                    │   ├── StreamExchange Hash([0]) from 6
                    │   └── StreamExchange Hash([0]) from 7
                    └── StreamExchange Hash([0]) from 8

    Fragment 6
    StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
    ├── tables: [ StreamScan: 19 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 7
    StreamProject { exprs: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number] }
    └── StreamFilter { predicate: (order_line.ol_delivery_d > '2010-05-23 12:00:00':Timestamp) }
        └── StreamTableScan { table: order_line, columns: [order_line.ol_i_id, order_line.ol_quantity, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, order_line.ol_delivery_d], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
            ├── tables: [ StreamScan: 20 ]
            ├── Upstream
            └── BatchPlanNode

    Fragment 8
    StreamProject { exprs: [item.i_id] }
    └── StreamFilter { predicate: Like(item.i_data, 'co%':Varchar) }
        └── StreamTableScan { table: item, columns: [item.i_id, item.i_data], stream_scan_type: ArrangementBackfill, stream_key: [item.i_id], pk: [i_id], dist: UpstreamHashShard(item.i_id) } { tables: [ StreamScan: 21 ] }
            ├── Upstream
            └── BatchPlanNode

    Table 0 { columns: [ supplier_s_suppkey, supplier_s_name, supplier_s_address, supplier_s_nationkey, nation_n_nationkey, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr1, stock_s_i_id, stock_s_w_id, stock_s_quantity, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr1, stock_s_i_id, stock_s_w_id, stock_s_quantity, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ supplier_s_suppkey, supplier_s_name, supplier_s_address, supplier_s_nationkey, _rw_timestamp ], primary key: [ $3 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ supplier_s_nationkey, supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ nation_n_nationkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 9 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 10 { columns: [ stock_s_i_id, stock_s_w_id, stock_s_quantity, sum(order_line_ol_quantity), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 3 }

    Table 11 { columns: [ stock_s_i_id, stock_s_w_id, stock_s_quantity, order_line_ol_quantity, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ stock_s_i_id, stock_s_w_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ item_i_id, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 14 { columns: [ item_i_id, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ stock_s_i_id, stock_s_w_id, stock_s_quantity, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ stock_s_i_id, stock_s_w_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ order_line_ol_i_id, order_line_ol_quantity, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ order_line_ol_i_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 20 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 21 { columns: [ vnode, i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ s_name, s_address, supplier.s_suppkey, supplier.s_nationkey, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2, 3 ], read pk prefix len hint: 3 }

- id: ch_q21
  before:
  - create_tables
  sql: "select\t s_name, count(*) as numwait\nfrom\t supplier, order_line l1, orders, stock, nation\nwhere\t ol_o_id = o_id\nand ol_w_id = o_w_id\nand ol_d_id = o_d_id\nand ol_w_id = s_w_id\nand ol_i_id = s_i_id\nand mod((s_w_id * s_i_id),10000) = s_suppkey\nand l1.ol_delivery_d > o_entry_d\nand not exists (select *\nfrom\torder_line l2\nwhere  l2.ol_o_id = l1.ol_o_id\nand l2.ol_w_id = l1.ol_w_id\nand l2.ol_d_id = l1.ol_d_id\nand l2.ol_delivery_d > l1.ol_delivery_d)\nand s_nationkey = n_nationkey\nand n_name = 'CHINA'\ngroup by s_name\norder by numwait desc, s_name;\n"
  logical_plan: |-
    LogicalProject { exprs: [supplier.s_name, count] }
    └─LogicalAgg { group_key: [supplier.s_name], aggs: [count] }
      └─LogicalProject { exprs: [supplier.s_name] }
        └─LogicalFilter { predicate: (order_line.ol_o_id = orders.o_id) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_w_id = stock.s_w_id) AND (order_line.ol_i_id = stock.s_i_id) AND (((stock.s_w_id * stock.s_i_id) % 10000:Int32) = supplier.s_suppkey) AND (order_line.ol_delivery_d > orders.o_entry_d) AND (supplier.s_nationkey = nation.n_nationkey) AND (nation.n_name = 'CHINA':Varchar) }
          └─LogicalApply { type: LeftAnti, on: true, correlated_id: 1 }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_address, supplier.s_nationkey, supplier.s_phone, supplier.s_acctbal, supplier.s_comment, supplier._rw_timestamp] }
            │ │ │ │ └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
            │ │ │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
            │ │ └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id, stock.s_quantity, stock.s_dist_01, stock.s_dist_02, stock.s_dist_03, stock.s_dist_04, stock.s_dist_05, stock.s_dist_06, stock.s_dist_07, stock.s_dist_08, stock.s_dist_09, stock.s_dist_10, stock.s_ytd, stock.s_order_cnt, stock.s_remote_cnt, stock.s_data, stock._rw_timestamp] }
            │ └─LogicalScan { table: nation, columns: [nation.n_nationkey, nation.n_name, nation.n_regionkey, nation.n_comment, nation._rw_timestamp] }
            └─LogicalProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info] }
              └─LogicalFilter { predicate: (order_line.ol_o_id = CorrelatedInputRef { index: 8, correlated_id: 1 }) AND (order_line.ol_w_id = CorrelatedInputRef { index: 10, correlated_id: 1 }) AND (order_line.ol_d_id = CorrelatedInputRef { index: 9, correlated_id: 1 }) AND (order_line.ol_delivery_d > CorrelatedInputRef { index: 14, correlated_id: 1 }) }
                └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_number, order_line.ol_i_id, order_line.ol_supply_w_id, order_line.ol_delivery_d, order_line.ol_quantity, order_line.ol_amount, order_line.ol_dist_info, order_line._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [supplier.s_name], aggs: [count] }
    └─LogicalJoin { type: LeftAnti, on: (order_line.ol_o_id = order_line.ol_o_id) AND (order_line.ol_w_id = order_line.ol_w_id) AND (order_line.ol_d_id = order_line.ol_d_id) AND (order_line.ol_delivery_d > order_line.ol_delivery_d), output: [supplier.s_name] }
      ├─LogicalJoin { type: Inner, on: (supplier.s_nationkey = nation.n_nationkey), output: [supplier.s_name, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d] }
      │ ├─LogicalJoin { type: Inner, on: ($expr1 = supplier.s_suppkey), output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, supplier.s_name, supplier.s_nationkey] }
      │ │ ├─LogicalProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
      │ │ │ └─LogicalJoin { type: Inner, on: (order_line.ol_w_id = stock.s_w_id) AND (order_line.ol_i_id = stock.s_i_id), output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, stock.s_i_id, stock.s_w_id] }
      │ │ │   ├─LogicalJoin { type: Inner, on: (order_line.ol_o_id = orders.o_id) AND (order_line.ol_w_id = orders.o_w_id) AND (order_line.ol_d_id = orders.o_d_id) AND (order_line.ol_delivery_d > orders.o_entry_d), output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_delivery_d] }
      │ │ │   │ ├─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_delivery_d] }
      │ │ │   │ └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d] }
      │ │ │   └─LogicalScan { table: stock, columns: [stock.s_i_id, stock.s_w_id] }
      │ │ └─LogicalScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_nationkey] }
      │ └─LogicalScan { table: nation, output_columns: [nation.n_nationkey], required_columns: [nation.n_nationkey, nation.n_name], predicate: (nation.n_name = 'CHINA':Varchar) }
      └─LogicalProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_delivery_d] }
        └─LogicalScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d] }
  batch_plan: |-
    BatchExchange { order: [count DESC, supplier.s_name ASC], dist: Single }
    └─BatchSort { order: [count DESC, supplier.s_name ASC] }
      └─BatchHashAgg { group_key: [supplier.s_name], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(supplier.s_name) }
          └─BatchHashJoin { type: LeftAnti, predicate: order_line.ol_o_id = order_line.ol_o_id AND order_line.ol_w_id = order_line.ol_w_id AND order_line.ol_d_id = order_line.ol_d_id AND (order_line.ol_delivery_d > order_line.ol_delivery_d), output: [supplier.s_name] }
            ├─BatchExchange { order: [], dist: HashShard(order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id) }
            │ └─BatchLookupJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey AND (nation.n_name = 'CHINA':Varchar), output: [supplier.s_name, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d], lookup table: nation }
            │   └─BatchExchange { order: [], dist: UpstreamHashShard(supplier.s_nationkey) }
            │     └─BatchLookupJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, supplier.s_name, supplier.s_nationkey], lookup table: supplier }
            │       └─BatchExchange { order: [], dist: UpstreamHashShard($expr1) }
            │         └─BatchProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1] }
            │           └─BatchLookupJoin { type: Inner, predicate: order_line.ol_w_id = stock.s_w_id AND order_line.ol_i_id = stock.s_i_id, output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, stock.s_i_id, stock.s_w_id], lookup table: stock }
            │             └─BatchExchange { order: [], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_i_id) }
            │               └─BatchLookupJoin { type: Inner, predicate: order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id AND order_line.ol_o_id = orders.o_id AND (order_line.ol_delivery_d > orders.o_entry_d), output: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_delivery_d], lookup table: orders }
            │                 └─BatchExchange { order: [], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id) }
            │                   └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_delivery_d], distribution: SomeShard }
            └─BatchExchange { order: [], dist: HashShard(order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id) }
              └─BatchProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_delivery_d] }
                └─BatchScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: NoCheck }
    └─StreamHashAgg { group_key: [supplier.s_name], aggs: [count] }
      └─StreamExchange { dist: HashShard(supplier.s_name) }
        └─StreamHashJoin { type: LeftAnti, predicate: order_line.ol_o_id = order_line.ol_o_id AND order_line.ol_w_id = order_line.ol_w_id AND order_line.ol_d_id = order_line.ol_d_id AND (order_line.ol_delivery_d > order_line.ol_delivery_d), output: [supplier.s_name, stock.s_w_id, stock.s_i_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, supplier.s_nationkey, $expr1, order_line.ol_w_id] }
          ├─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id) }
          │ └─StreamHashJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [supplier.s_name, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, stock.s_w_id, stock.s_i_id, order_line.ol_number, $expr1, supplier.s_suppkey, supplier.s_nationkey] }
          │   ├─StreamExchange { dist: HashShard($expr1) }
          │   │ └─StreamProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, stock.s_w_id, stock.s_i_id, order_line.ol_number] }
          │   │   └─StreamHashJoin { type: Inner, predicate: stock.s_w_id = order_line.ol_w_id AND stock.s_i_id = order_line.ol_i_id AND stock.s_w_id = orders.o_w_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_number] }
          │   │     ├─StreamExchange { dist: HashShard(stock.s_w_id, stock.s_i_id, stock.s_w_id) }
          │   │     │ └─StreamFilter { predicate: IsNotNull(stock.s_w_id) }
          │   │     │   └─StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) }
          │   │     └─StreamExchange { dist: HashShard(order_line.ol_w_id, order_line.ol_i_id, orders.o_w_id) }
          │   │       └─StreamProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_delivery_d, orders.o_w_id, order_line.ol_number, orders.o_d_id, orders.o_id] }
          │   │         └─StreamFilter { predicate: (order_line.ol_delivery_d > orders.o_entry_d) }
          │   │           └─StreamHashJoin { type: Inner, predicate: order_line.ol_o_id = orders.o_id AND order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id, output: all }
          │   │             ├─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id) }
          │   │             │ └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_delivery_d, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
          │   │             └─StreamExchange { dist: HashShard(orders.o_id, orders.o_d_id, orders.o_w_id) }
          │   │               └─StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
          │   └─StreamExchange { dist: HashShard(supplier.s_suppkey) }
          │     └─StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: all }
          │       ├─StreamExchange { dist: HashShard(supplier.s_nationkey) }
          │       │ └─StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) }
          │       └─StreamExchange { dist: HashShard(nation.n_nationkey) }
          │         └─StreamProject { exprs: [nation.n_nationkey] }
          │           └─StreamFilter { predicate: (nation.n_name = 'CHINA':Varchar) }
          │             └─StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) }
          └─StreamExchange { dist: HashShard(order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id) }
            └─StreamProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_delivery_d, order_line.ol_number] }
              └─StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: NoCheck }
    ├── tables: [ Materialize: 4294967294 ]
    └── StreamHashAgg { group_key: [supplier.s_name], aggs: [count] } { tables: [ HashAggState: 0 ] }
        └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamHashJoin { type: LeftAnti, predicate: order_line.ol_o_id = order_line.ol_o_id AND order_line.ol_w_id = order_line.ol_w_id AND order_line.ol_d_id = order_line.ol_d_id AND (order_line.ol_delivery_d > order_line.ol_delivery_d), output: [supplier.s_name, stock.s_w_id, stock.s_i_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number, supplier.s_nationkey, $expr1, order_line.ol_w_id] }
    ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
    ├── StreamExchange Hash([1, 3, 2]) from 2
    └── StreamExchange Hash([0, 1, 2]) from 11

    Fragment 2
    StreamHashJoin { type: Inner, predicate: $expr1 = supplier.s_suppkey, output: [supplier.s_name, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, stock.s_w_id, stock.s_i_id, order_line.ol_number, $expr1, supplier.s_suppkey, supplier.s_nationkey] } { tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ] }
    ├── StreamExchange Hash([4]) from 3
    └── StreamExchange Hash([0]) from 8

    Fragment 3
    StreamProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, ((stock.s_w_id * stock.s_i_id) % 10000:Int32)::Int64 as $expr1, stock.s_w_id, stock.s_i_id, order_line.ol_number] }
    └── StreamHashJoin { type: Inner, predicate: stock.s_w_id = order_line.ol_w_id AND stock.s_i_id = order_line.ol_i_id AND stock.s_w_id = orders.o_w_id, output: [stock.s_i_id, stock.s_w_id, order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_number] } { tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ] }
        ├── StreamExchange Hash([1, 0, 1]) from 4
        └── StreamExchange Hash([2, 3, 5]) from 5

    Fragment 4
    StreamFilter { predicate: IsNotNull(stock.s_w_id) }
    └── StreamTableScan { table: stock, columns: [stock.s_i_id, stock.s_w_id], stream_scan_type: ArrangementBackfill, stream_key: [stock.s_w_id, stock.s_i_id], pk: [s_w_id, s_i_id], dist: UpstreamHashShard(stock.s_w_id, stock.s_i_id) } { tables: [ StreamScan: 13 ] }
        ├── Upstream
        └── BatchPlanNode

    Fragment 5
    StreamProject { exprs: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_delivery_d, orders.o_w_id, order_line.ol_number, orders.o_d_id, orders.o_id] }
    └── StreamFilter { predicate: (order_line.ol_delivery_d > orders.o_entry_d) }
        └── StreamHashJoin { type: Inner, predicate: order_line.ol_o_id = orders.o_id AND order_line.ol_w_id = orders.o_w_id AND order_line.ol_d_id = orders.o_d_id, output: all } { tables: [ HashJoinLeft: 14, HashJoinDegreeLeft: 15, HashJoinRight: 16, HashJoinDegreeRight: 17 ] }
            ├── StreamExchange Hash([0, 1, 2]) from 6
            └── StreamExchange Hash([0, 1, 2]) from 7

    Fragment 6
    StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_i_id, order_line.ol_delivery_d, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
    ├── tables: [ StreamScan: 18 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 7
    StreamTableScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_entry_d], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) } { tables: [ StreamScan: 19 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 8
    StreamHashJoin { type: Inner, predicate: supplier.s_nationkey = nation.n_nationkey, output: all } { tables: [ HashJoinLeft: 20, HashJoinDegreeLeft: 21, HashJoinRight: 22, HashJoinDegreeRight: 23 ] }
    ├── StreamExchange Hash([2]) from 9
    └── StreamExchange Hash([0]) from 10

    Fragment 9
    StreamTableScan { table: supplier, columns: [supplier.s_suppkey, supplier.s_name, supplier.s_nationkey], stream_scan_type: ArrangementBackfill, stream_key: [supplier.s_suppkey], pk: [s_suppkey], dist: UpstreamHashShard(supplier.s_suppkey) } { tables: [ StreamScan: 24 ] }
    ├── Upstream
    └── BatchPlanNode

    Fragment 10
    StreamProject { exprs: [nation.n_nationkey] }
    └── StreamFilter { predicate: (nation.n_name = 'CHINA':Varchar) }
        └── StreamTableScan { table: nation, columns: [nation.n_nationkey, nation.n_name], stream_scan_type: ArrangementBackfill, stream_key: [nation.n_nationkey], pk: [n_nationkey], dist: UpstreamHashShard(nation.n_nationkey) } { tables: [ StreamScan: 25 ] }
            ├── Upstream
            └── BatchPlanNode

    Fragment 11
    StreamProject { exprs: [order_line.ol_o_id, order_line.ol_w_id, order_line.ol_d_id, order_line.ol_delivery_d, order_line.ol_number] }
    └── StreamTableScan { table: order_line, columns: [order_line.ol_o_id, order_line.ol_d_id, order_line.ol_w_id, order_line.ol_delivery_d, order_line.ol_number], stream_scan_type: ArrangementBackfill, stream_key: [order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number], pk: [ol_w_id, ol_d_id, ol_o_id, ol_number], dist: UpstreamHashShard(order_line.ol_w_id, order_line.ol_d_id, order_line.ol_o_id, order_line.ol_number) }
        ├── tables: [ StreamScan: 26 ]
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ supplier_s_name, count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ supplier_s_name, order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_delivery_d, stock_s_w_id, stock_s_i_id, order_line_ol_number, $expr1, supplier_s_suppkey, supplier_s_nationkey, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $5 ASC, $6 ASC, $7 ASC, $10 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], distribution key: [ 1, 3, 2 ], read pk prefix len hint: 3 }

    Table 2 { columns: [ order_line_ol_o_id, order_line_ol_w_id, order_line_ol_d_id, stock_s_w_id, stock_s_i_id, order_line_ol_number, supplier_s_nationkey, $expr1, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 3 { columns: [ order_line_ol_o_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_delivery_d, order_line_ol_number, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 4 { columns: [ order_line_ol_o_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 5 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_delivery_d, $expr1, stock_s_w_id, stock_s_i_id, order_line_ol_number, _rw_timestamp ], primary key: [ $4 ASC, $5 ASC, $6 ASC, $1 ASC, $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 4 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ $expr1, stock_s_w_id, stock_s_i_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ supplier_s_suppkey, supplier_s_name, supplier_s_nationkey, nation_n_nationkey, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ supplier_s_suppkey, supplier_s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ stock_s_i_id, stock_s_w_id, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 1, 0, 1 ], read pk prefix len hint: 3 }

    Table 10 { columns: [ stock_s_w_id, stock_s_i_id, stock_s_w_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 11 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_i_id, order_line_ol_delivery_d, orders_o_w_id, order_line_ol_number, orders_o_d_id, orders_o_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC, $5 ASC, $1 ASC, $0 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 2, 3, 5 ], read pk prefix len hint: 3 }

    Table 12 { columns: [ order_line_ol_w_id, order_line_ol_i_id, orders_o_w_id, order_line_ol_d_id, order_line_ol_o_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 13 { columns: [ vnode, s_w_id, s_i_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 14 { columns: [ order_line_ol_o_id, order_line_ol_d_id, order_line_ol_w_id, order_line_ol_i_id, order_line_ol_delivery_d, order_line_ol_number, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 15 { columns: [ order_line_ol_o_id, order_line_ol_w_id, order_line_ol_d_id, order_line_ol_number, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0, 2, 1 ], read pk prefix len hint: 3 }

    Table 16 { columns: [ orders_o_id, orders_o_d_id, orders_o_w_id, orders_o_entry_d, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 17 { columns: [ orders_o_id, orders_o_w_id, orders_o_d_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 2, 1 ], read pk prefix len hint: 3 }

    Table 18 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 19 { columns: [ vnode, o_w_id, o_d_id, o_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 20 { columns: [ supplier_s_suppkey, supplier_s_name, supplier_s_nationkey, _rw_timestamp ], primary key: [ $2 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ supplier_s_nationkey, supplier_s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ nation_n_nationkey, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ nation_n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ vnode, s_suppkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 25 { columns: [ vnode, n_nationkey, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 26 { columns: [ vnode, ol_w_id, ol_d_id, ol_o_id, ol_number, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ s_name, numwait, _rw_timestamp ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

- id: ch_q22
  before:
  - create_tables
  sql: "select\t substr(c_state,1,1) as country,\n           count(*) as numcust,\n           sum(c_balance) as totacctbal\nfrom\t customer\nwhere\t substr(c_phone,1,1) in ('1','2','3','4','5','6','7')\n  and c_balance > (select avg(c_BALANCE)\n                   from \t customer\n                   where  c_balance > 0.00\n                     and substr(c_phone,1,1) in ('1','2','3','4','5','6','7'))\n  and not exists (select *\n                  from\torders\n                  where\to_c_id = c_id\n                    and o_w_id = c_w_id\n                    and o_d_id = c_d_id)\ngroup by substr(c_state,1,1)\norder by substr(c_state,1,1);\n"
  logical_plan: |-
    LogicalProject { exprs: [$expr2, count, sum(customer.c_balance)] }
    └─LogicalProject { exprs: [$expr2, count, sum(customer.c_balance), $expr2] }
      └─LogicalAgg { group_key: [$expr2], aggs: [count, sum(customer.c_balance)] }
        └─LogicalProject { exprs: [Substr(customer.c_state, 1:Int32, 1:Int32) as $expr2, customer.c_balance] }
          └─LogicalFilter { predicate: In(Substr(customer.c_phone, 1:Int32, 1:Int32), '1':Varchar, '2':Varchar, '3':Varchar, '4':Varchar, '5':Varchar, '6':Varchar, '7':Varchar) AND (customer.c_balance > $expr1) }
            └─LogicalApply { type: LeftOuter, on: true, correlated_id: 2, max_one_row: true }
              ├─LogicalApply { type: LeftAnti, on: true, correlated_id: 1 }
              │ ├─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_first, customer.c_middle, customer.c_last, customer.c_street_1, customer.c_street_2, customer.c_city, customer.c_state, customer.c_zip, customer.c_phone, customer.c_since, customer.c_credit, customer.c_credit_lim, customer.c_discount, customer.c_balance, customer.c_ytd_payment, customer.c_payment_cnt, customer.c_delivery_cnt, customer.c_data, customer._rw_timestamp] }
              │ └─LogicalProject { exprs: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local] }
              │   └─LogicalFilter { predicate: (orders.o_c_id = CorrelatedInputRef { index: 0, correlated_id: 1 }) AND (orders.o_w_id = CorrelatedInputRef { index: 2, correlated_id: 1 }) AND (orders.o_d_id = CorrelatedInputRef { index: 1, correlated_id: 1 }) }
              │     └─LogicalScan { table: orders, columns: [orders.o_id, orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_entry_d, orders.o_carrier_id, orders.o_ol_cnt, orders.o_all_local, orders._rw_timestamp] }
              └─LogicalProject { exprs: [(sum(customer.c_balance) / count(customer.c_balance)::Decimal) as $expr1] }
                └─LogicalAgg { aggs: [sum(customer.c_balance), count(customer.c_balance)] }
                  └─LogicalProject { exprs: [customer.c_balance] }
                    └─LogicalFilter { predicate: (customer.c_balance > 0.00:Decimal) AND In(Substr(customer.c_phone, 1:Int32, 1:Int32), '1':Varchar, '2':Varchar, '3':Varchar, '4':Varchar, '5':Varchar, '6':Varchar, '7':Varchar) }
                      └─LogicalScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_first, customer.c_middle, customer.c_last, customer.c_street_1, customer.c_street_2, customer.c_city, customer.c_state, customer.c_zip, customer.c_phone, customer.c_since, customer.c_credit, customer.c_credit_lim, customer.c_discount, customer.c_balance, customer.c_ytd_payment, customer.c_payment_cnt, customer.c_delivery_cnt, customer.c_data, customer._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [$expr2, count, sum(customer.c_balance), $expr2] }
    └─LogicalAgg { group_key: [$expr2], aggs: [count, sum(customer.c_balance)] }
      └─LogicalProject { exprs: [Substr(customer.c_state, 1:Int32, 1:Int32) as $expr2, customer.c_balance] }
        └─LogicalJoin { type: Inner, on: (customer.c_balance > $expr1), output: [customer.c_state, customer.c_balance] }
          ├─LogicalJoin { type: LeftAnti, on: (orders.o_c_id = customer.c_id) AND (orders.o_w_id = customer.c_w_id) AND (orders.o_d_id = customer.c_d_id), output: [customer.c_state, customer.c_balance] }
          │ ├─LogicalScan { table: customer, output_columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state, customer.c_balance], required_columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state, customer.c_balance, customer.c_phone], predicate: In(Substr(customer.c_phone, 1:Int32, 1:Int32), '1':Varchar, '2':Varchar, '3':Varchar, '4':Varchar, '5':Varchar, '6':Varchar, '7':Varchar) }
          │ └─LogicalProject { exprs: [orders.o_c_id, orders.o_w_id, orders.o_d_id] }
          │   └─LogicalScan { table: orders, columns: [orders.o_d_id, orders.o_w_id, orders.o_c_id] }
          └─LogicalProject { exprs: [(sum(customer.c_balance) / count(customer.c_balance)::Decimal) as $expr1] }
            └─LogicalAgg { aggs: [sum(customer.c_balance), count(customer.c_balance)] }
              └─LogicalScan { table: customer, output_columns: [customer.c_balance], required_columns: [customer.c_balance, customer.c_phone], predicate: (customer.c_balance > 0.00:Decimal) AND In(Substr(customer.c_phone, 1:Int32, 1:Int32), '1':Varchar, '2':Varchar, '3':Varchar, '4':Varchar, '5':Varchar, '6':Varchar, '7':Varchar) }
  batch_plan: |-
    BatchProject { exprs: [$expr2, count, sum(customer.c_balance)] }
    └─BatchExchange { order: [$expr2 ASC], dist: Single }
      └─BatchProject { exprs: [$expr2, count, sum(customer.c_balance), $expr2] }
        └─BatchSort { order: [$expr2 ASC] }
          └─BatchHashAgg { group_key: [$expr2], aggs: [count, sum(customer.c_balance)] }
            └─BatchExchange { order: [], dist: HashShard($expr2) }
              └─BatchProject { exprs: [Substr(customer.c_state, 1:Int32, 1:Int32) as $expr2, customer.c_balance] }
                └─BatchNestedLoopJoin { type: Inner, predicate: (customer.c_balance > $expr1), output: [customer.c_state, customer.c_balance] }
                  ├─BatchExchange { order: [], dist: Single }
                  │ └─BatchHashJoin { type: LeftAnti, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_state, customer.c_balance] }
                  │   ├─BatchExchange { order: [], dist: HashShard(customer.c_id, customer.c_w_id, customer.c_d_id) }
                  │   │ └─BatchProject { exprs: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state, customer.c_balance] }
                  │   │   └─BatchFilter { predicate: In(Substr(customer.c_phone, 1:Int32, 1:Int32), '1':Varchar, '2':Varchar, '3':Varchar, '4':Varchar, '5':Varchar, '6':Varchar, '7':Varchar) }
                  │   │     └─BatchScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state, customer.c_balance, customer.c_phone], distribution: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
                  │   └─BatchExchange { order: [], dist: HashShard(orders.o_c_id, orders.o_w_id, orders.o_d_id) }
                  │     └─BatchProject { exprs: [orders.o_c_id, orders.o_w_id, orders.o_d_id] }
                  │       └─BatchScan { table: orders, columns: [orders.o_d_id, orders.o_w_id, orders.o_c_id], distribution: SomeShard }
                  └─BatchProject { exprs: [(sum(sum(customer.c_balance)) / sum0(count(customer.c_balance))::Decimal) as $expr1] }
                    └─BatchSimpleAgg { aggs: [sum(sum(customer.c_balance)), sum0(count(customer.c_balance))] }
                      └─BatchExchange { order: [], dist: Single }
                        └─BatchSimpleAgg { aggs: [sum(customer.c_balance), count(customer.c_balance)] }
                          └─BatchProject { exprs: [customer.c_balance] }
                            └─BatchFilter { predicate: (customer.c_balance > 0.00:Decimal) AND In(Substr(customer.c_phone, 1:Int32, 1:Int32), '1':Varchar, '2':Varchar, '3':Varchar, '4':Varchar, '5':Varchar, '6':Varchar, '7':Varchar) }
                              └─BatchScan { table: customer, columns: [customer.c_balance, customer.c_phone], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [country, numcust, totacctbal, $expr2(hidden)], stream_key: [$expr2], pk_columns: [$expr2], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr2, count, sum(customer.c_balance), $expr2] }
      └─StreamHashAgg { group_key: [$expr2], aggs: [count, sum(customer.c_balance)] }
        └─StreamExchange { dist: HashShard($expr2) }
          └─StreamProject { exprs: [Substr(customer.c_state, 1:Int32, 1:Int32) as $expr2, customer.c_balance, customer.c_w_id, customer.c_d_id, customer.c_id] }
            └─StreamDynamicFilter { predicate: (customer.c_balance > $expr1), output: [customer.c_state, customer.c_balance, customer.c_w_id, customer.c_d_id, customer.c_id] }
              ├─StreamHashJoin { type: LeftAnti, predicate: customer.c_id = orders.o_c_id AND customer.c_w_id = orders.o_w_id AND customer.c_d_id = orders.o_d_id, output: [customer.c_state, customer.c_balance, customer.c_w_id, customer.c_d_id, customer.c_id] }
              │ ├─StreamExchange { dist: HashShard(customer.c_id, customer.c_w_id, customer.c_d_id) }
              │ │ └─StreamProject { exprs: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state, customer.c_balance] }
              │ │   └─StreamFilter { predicate: In(Substr(customer.c_phone, 1:Int32, 1:Int32), '1':Varchar, '2':Varchar, '3':Varchar, '4':Varchar, '5':Varchar, '6':Varchar, '7':Varchar) }
              │ │     └─StreamTableScan { table: customer, columns: [customer.c_id, customer.c_d_id, customer.c_w_id, customer.c_state, customer.c_balance, customer.c_phone], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
              │ └─StreamExchange { dist: HashShard(orders.o_c_id, orders.o_w_id, orders.o_d_id) }
              │   └─StreamProject { exprs: [orders.o_c_id, orders.o_w_id, orders.o_d_id, orders.o_id] }
              │     └─StreamTableScan { table: orders, columns: [orders.o_d_id, orders.o_w_id, orders.o_c_id, orders.o_id], stream_scan_type: ArrangementBackfill, stream_key: [orders.o_w_id, orders.o_d_id, orders.o_id], pk: [o_w_id, o_d_id, o_id], dist: UpstreamHashShard(orders.o_w_id, orders.o_d_id, orders.o_id) }
              └─StreamExchange { dist: Broadcast }
                └─StreamProject { exprs: [(sum(sum(customer.c_balance)) / sum0(count(customer.c_balance))::Decimal) as $expr1] }
                  └─StreamSimpleAgg { aggs: [sum(sum(customer.c_balance)), sum0(count(customer.c_balance)), count] }
                    └─StreamExchange { dist: Single }
                      └─StreamStatelessSimpleAgg { aggs: [sum(customer.c_balance), count(customer.c_balance)] }
                        └─StreamProject { exprs: [customer.c_balance, customer.c_w_id, customer.c_d_id, customer.c_id] }
                          └─StreamFilter { predicate: (customer.c_balance > 0.00:Decimal) AND In(Substr(customer.c_phone, 1:Int32, 1:Int32), '1':Varchar, '2':Varchar, '3':Varchar, '4':Varchar, '5':Varchar, '6':Varchar, '7':Varchar) }
                            └─StreamTableScan { table: customer, columns: [customer.c_balance, customer.c_w_id, customer.c_d_id, customer.c_id, customer.c_phone], stream_scan_type: ArrangementBackfill, stream_key: [customer.c_w_id, customer.c_d_id, customer.c_id], pk: [c_w_id, c_d_id, c_id], dist: UpstreamHashShard(customer.c_w_id, customer.c_d_id, customer.c_id) }
