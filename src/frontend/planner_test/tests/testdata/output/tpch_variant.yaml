# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    CREATE SOURCE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR,
            s_address VARCHAR,
            s_nationkey INTEGER,
            s_phone VARCHAR,
            s_acctbal NUMERIC,
            s_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE part (
            p_partkey INTEGER,
            p_name VARCHAR,
            p_mfgr VARCHAR,
            p_brand VARCHAR,
            p_type VARCHAR,
            p_size INTEGER,
            p_container VARCHAR,
            p_retailprice NUMERIC,
            p_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE customer (
            c_custkey INTEGER,
            c_name VARCHAR,
            c_address VARCHAR,
            c_nationkey INTEGER,
            c_phone VARCHAR,
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR,
            c_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR,
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR,
            o_clerk VARCHAR,
            o_shippriority INTEGER,
            o_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR,
            l_linestatus VARCHAR,
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR,
            l_shipmode VARCHAR,
            l_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE nation (
            n_nationkey INTEGER,
            n_name VARCHAR,
            n_regionkey INTEGER,
            n_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE region (
            r_regionkey INTEGER,
            r_name VARCHAR,
            r_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;
- id: tpch_q2
  before:
  - create_tables
  sql: |
    select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
    from
        part,
        supplier,
        partsupp,
        nation,
        region
    where
            p_partkey = ps_partkey
            and s_suppkey = ps_suppkey
            and s_nationkey = n_nationkey
            and n_regionkey = r_regionkey
            and ps_supplycost = (
                    select
                            min(ps_supplycost)
                    from
                            partsupp,
                            supplier,
                            nation,
                            region
                    where
                            p_partkey = ps_partkey
                            and s_suppkey = ps_suppkey
                            and s_nationkey = n_nationkey
                            and n_regionkey = r_regionkey
            )
    order by
          s_acctbal desc,
          n_name,
          s_name,
          p_partkey;
  logical_plan: |-
    LogicalProject { exprs: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
    └─LogicalFilter { predicate: (p_partkey = ps_partkey) AND (s_suppkey = ps_suppkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) AND (ps_supplycost = min(ps_supplycost)) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ │ │ ├─LogicalSource { source: part, is_shared: false, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
        │ │ │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │ │ │ └─LogicalSource { source: partsupp, is_shared: false, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
        │ │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        │ └─LogicalSource { source: region, is_shared: false, columns: [r_regionkey, r_name, r_comment, _row_id] }
        └─LogicalProject { exprs: [min(ps_supplycost)] }
          └─LogicalAgg { aggs: [min(ps_supplycost)] }
            └─LogicalProject { exprs: [ps_supplycost] }
              └─LogicalFilter { predicate: (CorrelatedInputRef { index: 0, correlated_id: 1 } = ps_partkey) AND (s_suppkey = ps_suppkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) }
                └─LogicalJoin { type: Inner, on: true, output: all }
                  ├─LogicalJoin { type: Inner, on: true, output: all }
                  │ ├─LogicalJoin { type: Inner, on: true, output: all }
                  │ │ ├─LogicalSource { source: partsupp, is_shared: false, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                  │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                  │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                  └─LogicalSource { source: region, is_shared: false, columns: [r_regionkey, r_name, r_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
    ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
    │ ├─LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [p_partkey, p_mfgr, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
    │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = ps_partkey) AND (ps_supplycost = min(ps_supplycost)), output: [p_partkey, p_mfgr, ps_suppkey] }
    │ │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = ps_partkey), output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost] }
    │ │ │ │ ├─LogicalSource { source: part, is_shared: false, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
    │ │ │ │ └─LogicalSource { source: partsupp, is_shared: false, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
    │ │ │ └─LogicalAgg { group_key: [ps_partkey], aggs: [min(ps_supplycost)] }
    │ │ │   └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [ps_supplycost, ps_partkey] }
    │ │ │     ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [ps_partkey, ps_supplycost, n_regionkey] }
    │ │ │     │ ├─LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [ps_partkey, ps_supplycost, s_nationkey] }
    │ │ │     │ │ ├─LogicalSource { source: partsupp, is_shared: false, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
    │ │ │     │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    │ │ │     │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
    │ │ │     └─LogicalSource { source: region, is_shared: false, columns: [r_regionkey, r_name, r_comment, _row_id] }
    │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
    └─LogicalSource { source: region, is_shared: false, columns: [r_regionkey, r_name, r_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], dist: Single }
    └─BatchSort { order: [s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC] }
      └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
        ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
        │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
        │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │   │ └─BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
        │   │   ├─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
        │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = ps_partkey AND ps_supplycost = min(ps_supplycost), output: [p_partkey, p_mfgr, ps_suppkey] }
        │   │   │   ├─BatchHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost] }
        │   │   │   │ ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
        │   │   │   │ │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
        │   │   │   │ └─BatchExchange { order: [], dist: HashShard(ps_partkey) }
        │   │   │   │   └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
        │   │   │   └─BatchHashAgg { group_key: [ps_partkey], aggs: [min(ps_supplycost)] }
        │   │   │     └─BatchExchange { order: [], dist: HashShard(ps_partkey) }
        │   │   │       └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [ps_supplycost, ps_partkey] }
        │   │   │         ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
        │   │   │         │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_partkey, ps_supplycost, n_regionkey] }
        │   │   │         │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │   │   │         │   │ └─BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey] }
        │   │   │         │   │   ├─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
        │   │   │         │   │   │ └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
        │   │   │         │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │   │   │         │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │   │   │         │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │   │   │         │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        │   │   │         └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
        │   │   │           └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
        │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
          └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), min(ps_supplycost)(hidden), ps_partkey(hidden), _row_id#1(hidden), _row_id#2(hidden), r_regionkey(hidden), _row_id#3(hidden), n_nationkey(hidden), _row_id#4(hidden), s_suppkey(hidden)], stream_key: [p_partkey, min(ps_supplycost), ps_partkey, _row_id, s_suppkey, n_nationkey, r_regionkey, _row_id#1, _row_id#2, _row_id#3, _row_id#4], pk_columns: [s_acctbal, n_name, s_name, p_partkey, min(ps_supplycost), ps_partkey, _row_id, s_suppkey, n_nationkey, r_regionkey, _row_id#1, _row_id#2, _row_id#3, _row_id#4], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(p_partkey, _row_id, min(ps_supplycost), ps_partkey, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, s_suppkey) }
      └─StreamHashJoin { type: Inner, predicate: p_partkey = ps_partkey AND min(ps_supplycost) = ps_supplycost AND ps_partkey = ps_partkey, output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, min(ps_supplycost), ps_partkey, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, s_suppkey] }
        ├─StreamExchange { dist: HashShard(p_partkey, min(ps_supplycost), ps_partkey) }
        │ └─StreamLocalityProvider { locality_columns: [p_partkey, min(ps_supplycost), ps_partkey] }
        │   └─StreamExchange { dist: HashShard(p_partkey, ps_partkey, min(ps_supplycost)) }
        │     └─StreamHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_partkey, min(ps_supplycost), _row_id] }
        │       ├─StreamExchange { dist: HashShard(p_partkey) }
        │       │ └─StreamLocalityProvider { locality_columns: [p_partkey] }
        │       │   └─StreamExchange { dist: HashShard(p_partkey) }
        │       │     └─StreamRowIdGen { row_id_index: 9 }
        │       │       └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
        │       └─StreamExchange { dist: HashShard(ps_partkey) }
        │         └─StreamLocalityProvider { locality_columns: [ps_partkey] }
        │           └─StreamExchange [no_shuffle] { dist: UpstreamHashShard(ps_partkey) }
        │             └─StreamProject { exprs: [ps_partkey, min(ps_supplycost)] }
        │               └─StreamHashAgg [append_only] { group_key: [ps_partkey], aggs: [min(ps_supplycost), count] }
        │                 └─StreamLocalityProvider { locality_columns: [ps_partkey] }
        │                   └─StreamExchange { dist: HashShard(ps_partkey) }
        │                     └─StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_supplycost, ps_partkey, _row_id, _row_id, ps_suppkey, s_nationkey, _row_id, _row_id, r_regionkey] }
        │                       ├─StreamExchange { dist: HashShard(s_nationkey) }
        │                       │ └─StreamLocalityProvider { locality_columns: [s_nationkey] }
        │                       │   └─StreamExchange { dist: HashShard(s_nationkey) }
        │                       │     └─StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id] }
        │                       │       ├─StreamExchange { dist: HashShard(ps_suppkey) }
        │                       │       │ └─StreamLocalityProvider { locality_columns: [ps_suppkey] }
        │                       │       │   └─StreamExchange { dist: HashShard(ps_suppkey) }
        │                       │       │     └─StreamShare { id: 7 }
        │                       │       │       └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
        │                       │       │         └─StreamRowIdGen { row_id_index: 5 }
        │                       │       │           └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
        │                       │       └─StreamExchange { dist: HashShard(s_suppkey) }
        │                       │         └─StreamLocalityProvider { locality_columns: [s_suppkey] }
        │                       │           └─StreamExchange { dist: HashShard(s_suppkey) }
        │                       │             └─StreamShare { id: 13 }
        │                       │               └─StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │                       │                 └─StreamRowIdGen { row_id_index: 7 }
        │                       │                   └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │                       └─StreamExchange { dist: HashShard(n_nationkey) }
        │                         └─StreamLocalityProvider { locality_columns: [n_nationkey] }
        │                           └─StreamExchange { dist: HashShard(n_nationkey) }
        │                             └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] }
        │                               ├─StreamExchange { dist: HashShard(r_regionkey) }
        │                               │ └─StreamLocalityProvider { locality_columns: [r_regionkey] }
        │                               │   └─StreamExchange { dist: HashShard(r_regionkey) }
        │                               │     └─StreamShare { id: 23 }
        │                               │       └─StreamProject { exprs: [r_regionkey, _row_id] }
        │                               │         └─StreamRowIdGen { row_id_index: 3 }
        │                               │           └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
        │                               └─StreamExchange { dist: HashShard(n_regionkey) }
        │                                 └─StreamLocalityProvider { locality_columns: [n_regionkey] }
        │                                   └─StreamExchange { dist: HashShard(n_regionkey) }
        │                                     └─StreamShare { id: 29 }
        │                                       └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
        │                                         └─StreamRowIdGen { row_id_index: 4 }
        │                                           └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─StreamExchange { dist: HashShard(ps_partkey, ps_supplycost, ps_partkey) }
          └─StreamLocalityProvider { locality_columns: [ps_partkey, ps_supplycost, ps_partkey] }
            └─StreamExchange { dist: HashShard(ps_partkey, ps_supplycost) }
              └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = ps_suppkey, output: [n_name, s_name, s_address, s_phone, s_acctbal, s_comment, ps_partkey, ps_supplycost, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, s_suppkey, _row_id] }
                ├─StreamExchange { dist: HashShard(s_suppkey) }
                │ └─StreamLocalityProvider { locality_columns: [s_suppkey] }
                │   └─StreamExchange { dist: HashShard(s_suppkey) }
                │     └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, s_name, s_address, s_phone, s_acctbal, s_comment, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] }
                │       ├─StreamExchange { dist: HashShard(n_nationkey) }
                │       │ └─StreamLocalityProvider { locality_columns: [n_nationkey] }
                │       │   └─StreamExchange { dist: HashShard(n_nationkey) }
                │       │     └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
                │       │       ├─StreamExchange { dist: HashShard(r_regionkey) }
                │       │       │ └─StreamLocalityProvider { locality_columns: [r_regionkey] }
                │       │       │   └─StreamExchange { dist: HashShard(r_regionkey) }
                │       │       │     └─StreamShare { id: 23 }
                │       │       │       └─StreamProject { exprs: [r_regionkey, _row_id] }
                │       │       │         └─StreamRowIdGen { row_id_index: 3 }
                │       │       │           └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                │       │       └─StreamExchange { dist: HashShard(n_regionkey) }
                │       │         └─StreamLocalityProvider { locality_columns: [n_regionkey] }
                │       │           └─StreamExchange { dist: HashShard(n_regionkey) }
                │       │             └─StreamShare { id: 29 }
                │       │               └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                │       │                 └─StreamRowIdGen { row_id_index: 4 }
                │       │                   └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                │       └─StreamExchange { dist: HashShard(s_nationkey) }
                │         └─StreamLocalityProvider { locality_columns: [s_nationkey] }
                │           └─StreamExchange { dist: HashShard(s_nationkey) }
                │             └─StreamShare { id: 13 }
                │               └─StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                │                 └─StreamRowIdGen { row_id_index: 7 }
                │                   └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                └─StreamExchange { dist: HashShard(ps_suppkey) }
                  └─StreamLocalityProvider { locality_columns: [ps_suppkey] }
                    └─StreamExchange { dist: HashShard(ps_suppkey) }
                      └─StreamFilter { predicate: IsNotNull(ps_partkey) }
                        └─StreamShare { id: 7 }
                          └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
                            └─StreamRowIdGen { row_id_index: 5 }
                              └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), min(ps_supplycost)(hidden), ps_partkey(hidden), _row_id#1(hidden), _row_id#2(hidden), r_regionkey(hidden), _row_id#3(hidden), n_nationkey(hidden), _row_id#4(hidden), s_suppkey(hidden)], stream_key: [p_partkey, min(ps_supplycost), ps_partkey, _row_id, s_suppkey, n_nationkey, r_regionkey, _row_id#1, _row_id#2, _row_id#3, _row_id#4], pk_columns: [s_acctbal, n_name, s_name, p_partkey, min(ps_supplycost), ps_partkey, _row_id, s_suppkey, n_nationkey, r_regionkey, _row_id#1, _row_id#2, _row_id#3, _row_id#4], pk_conflict: NoCheck }
    └── StreamExchange Hash([3, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) from 1

    Fragment 1
    StreamHashJoin { type: Inner, predicate: p_partkey = ps_partkey AND min(ps_supplycost) = ps_supplycost AND ps_partkey = ps_partkey, output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, min(ps_supplycost), ps_partkey, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, s_suppkey] } { tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ] }
    ├── StreamExchange Hash([0, 3, 2]) from 2
    └── StreamExchange Hash([6, 7, 6]) from 25

    Fragment 2
    StreamLocalityProvider { locality_columns: [p_partkey, min(ps_supplycost), ps_partkey] } { tables: [ LocalityProviderState: 4, LocalityProviderProgress: 5 ] }
    └── StreamExchange Hash([0, 2, 3]) from 3

    Fragment 3
    StreamHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_partkey, min(ps_supplycost), _row_id] } { tables: [ HashJoinLeft: 6, HashJoinDegreeLeft: 7, HashJoinRight: 8, HashJoinDegreeRight: 9 ] }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([0]) from 6

    Fragment 4
    StreamLocalityProvider { locality_columns: [p_partkey] } { tables: [ LocalityProviderState: 10, LocalityProviderProgress: 11 ] }
    └── StreamExchange Hash([0]) from 5

    Fragment 5
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { tables: [ Source: 12 ] }

    Fragment 6
    StreamLocalityProvider { locality_columns: [ps_partkey] } { tables: [ LocalityProviderState: 13, LocalityProviderProgress: 14 ] }
    └── StreamExchange NoShuffle from 7

    Fragment 7
    StreamProject { exprs: [ps_partkey, min(ps_supplycost)] }
    └── StreamHashAgg [append_only] { group_key: [ps_partkey], aggs: [min(ps_supplycost), count] } { tables: [ HashAggState: 15 ] }
        └── StreamLocalityProvider { locality_columns: [ps_partkey] } { tables: [ LocalityProviderState: 16, LocalityProviderProgress: 17 ] }
            └── StreamExchange Hash([1]) from 8

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_supplycost, ps_partkey, _row_id, _row_id, ps_suppkey, s_nationkey, _row_id, _row_id, r_regionkey] } { tables: [ HashJoinLeft: 18, HashJoinDegreeLeft: 19, HashJoinRight: 20, HashJoinDegreeRight: 21 ] }
    ├── StreamExchange Hash([2]) from 9
    └── StreamExchange Hash([0]) from 17

    Fragment 9
    StreamLocalityProvider { locality_columns: [s_nationkey] } { tables: [ LocalityProviderState: 22, LocalityProviderProgress: 23 ] }
    └── StreamExchange Hash([2]) from 10

    Fragment 10
    StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id] } { tables: [ HashJoinLeft: 24, HashJoinDegreeLeft: 25, HashJoinRight: 26, HashJoinDegreeRight: 27 ] }
    ├── StreamExchange Hash([1]) from 11
    └── StreamExchange Hash([0]) from 14

    Fragment 11
    StreamLocalityProvider { locality_columns: [ps_suppkey] } { tables: [ LocalityProviderState: 28, LocalityProviderProgress: 29 ] }
    └── StreamExchange Hash([1]) from 12

    Fragment 12
    StreamNoOp
    └── StreamExchange NoShuffle from 13

    Fragment 13
    StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
    └── StreamRowIdGen { row_id_index: 5 }
        └── StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] } { tables: [ Source: 30 ] }

    Fragment 14
    StreamLocalityProvider { locality_columns: [s_suppkey] } { tables: [ LocalityProviderState: 31, LocalityProviderProgress: 32 ] }
    └── StreamExchange Hash([0]) from 15

    Fragment 15
    StreamNoOp
    └── StreamExchange NoShuffle from 16

    Fragment 16
    StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    └── StreamRowIdGen { row_id_index: 7 }
        └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 33 ] }

    Fragment 17
    StreamLocalityProvider { locality_columns: [n_nationkey] } { tables: [ LocalityProviderState: 34, LocalityProviderProgress: 35 ] }
    └── StreamExchange Hash([0]) from 18

    Fragment 18
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] } { tables: [ HashJoinLeft: 36, HashJoinDegreeLeft: 37, HashJoinRight: 38, HashJoinDegreeRight: 39 ] }
    ├── StreamExchange Hash([0]) from 19
    └── StreamExchange Hash([2]) from 22

    Fragment 19
    StreamLocalityProvider { locality_columns: [r_regionkey] } { tables: [ LocalityProviderState: 40, LocalityProviderProgress: 41 ] }
    └── StreamExchange Hash([0]) from 20

    Fragment 20
    StreamNoOp
    └── StreamExchange NoShuffle from 21

    Fragment 21
    StreamProject { exprs: [r_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 3 }
        └── StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] } { tables: [ Source: 42 ] }

    Fragment 22
    StreamLocalityProvider { locality_columns: [n_regionkey] } { tables: [ LocalityProviderState: 43, LocalityProviderProgress: 44 ] }
    └── StreamExchange Hash([2]) from 23

    Fragment 23
    StreamNoOp
    └── StreamExchange NoShuffle from 24

    Fragment 24
    StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 45 ] }

    Fragment 25
    StreamLocalityProvider { locality_columns: [ps_partkey, ps_supplycost, ps_partkey] } { tables: [ LocalityProviderState: 46, LocalityProviderProgress: 47 ] }
    └── StreamExchange Hash([6, 7]) from 26

    Fragment 26
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = ps_suppkey, output: [n_name, s_name, s_address, s_phone, s_acctbal, s_comment, ps_partkey, ps_supplycost, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, s_suppkey, _row_id] } { tables: [ HashJoinLeft: 48, HashJoinDegreeLeft: 49, HashJoinRight: 50, HashJoinDegreeRight: 51 ] }
    ├── StreamExchange Hash([1]) from 27
    └── StreamExchange Hash([1]) from 37

    Fragment 27
    StreamLocalityProvider { locality_columns: [s_suppkey] } { tables: [ LocalityProviderState: 52, LocalityProviderProgress: 53 ] }
    └── StreamExchange Hash([1]) from 28

    Fragment 28
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, s_name, s_address, s_phone, s_acctbal, s_comment, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 54, HashJoinDegreeLeft: 55, HashJoinRight: 56, HashJoinDegreeRight: 57 ] }
    ├── StreamExchange Hash([0]) from 29
    └── StreamExchange Hash([3]) from 35

    Fragment 29
    StreamLocalityProvider { locality_columns: [n_nationkey] } { tables: [ LocalityProviderState: 58, LocalityProviderProgress: 59 ] }
    └── StreamExchange Hash([0]) from 30

    Fragment 30
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] } { tables: [ HashJoinLeft: 60, HashJoinDegreeLeft: 61, HashJoinRight: 62, HashJoinDegreeRight: 63 ] }
    ├── StreamExchange Hash([0]) from 31
    └── StreamExchange Hash([2]) from 33

    Fragment 31
    StreamLocalityProvider { locality_columns: [r_regionkey] } { tables: [ LocalityProviderState: 64, LocalityProviderProgress: 65 ] }
    └── StreamExchange Hash([0]) from 32

    Fragment 32
    StreamNoOp
    └── StreamExchange NoShuffle from 21

    Fragment 33
    StreamLocalityProvider { locality_columns: [n_regionkey] } { tables: [ LocalityProviderState: 66, LocalityProviderProgress: 67 ] }
    └── StreamExchange Hash([2]) from 34

    Fragment 34
    StreamNoOp
    └── StreamExchange NoShuffle from 24

    Fragment 35
    StreamLocalityProvider { locality_columns: [s_nationkey] } { tables: [ LocalityProviderState: 68, LocalityProviderProgress: 69 ] }
    └── StreamExchange Hash([3]) from 36

    Fragment 36
    StreamNoOp
    └── StreamExchange NoShuffle from 16

    Fragment 37
    StreamLocalityProvider { locality_columns: [ps_suppkey] } { tables: [ LocalityProviderState: 70, LocalityProviderProgress: 71 ] }
    └── StreamExchange Hash([1]) from 38

    Fragment 38
    StreamFilter { predicate: IsNotNull(ps_partkey) }
    └── StreamExchange NoShuffle from 13

    Table 0 { columns: [ p_partkey, p_mfgr, ps_partkey, min(ps_supplycost), _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 3, 2 ], read pk prefix len hint: 3 }

    Table 1 { columns: [ p_partkey, min(ps_supplycost), ps_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 2 { columns: [ n_name, s_name, s_address, s_phone, s_acctbal, s_comment, ps_partkey, ps_supplycost, _row_id, _row_id_0, r_regionkey, _row_id_1, n_nationkey, s_suppkey, _row_id_2, _rw_timestamp ], primary key: [ $6 ASC, $7 ASC, $6 ASC, $13 ASC, $12 ASC, $10 ASC, $8 ASC, $9 ASC, $11 ASC, $14 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ], distribution key: [ 6, 7, 6 ], read pk prefix len hint: 3 }

    Table 3 { columns: [ ps_partkey, ps_supplycost, ps_partkey_0, s_suppkey, n_nationkey, r_regionkey, _row_id, _row_id_0, _row_id_1, _row_id_2, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 4 { columns: [ p_partkey, p_mfgr, ps_partkey, min(ps_supplycost), _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $2 ASC, $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 2, 3 ], read pk prefix len hint: 0 }

    Table 5 { columns: [ vnode, p_partkey, min(ps_supplycost), ps_partkey, p_partkey_0, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 6 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ p_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ ps_partkey, min(ps_supplycost), _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ ps_partkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 11 { columns: [ vnode, p_partkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 12 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 13 { columns: [ ps_partkey, min(ps_supplycost), _rw_timestamp ], primary key: [ $0 ASC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 14 { columns: [ vnode, ps_partkey, ps_partkey_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 15 { columns: [ ps_partkey, min(ps_supplycost), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ ps_supplycost, ps_partkey, _row_id, _row_id_0, ps_suppkey, s_nationkey, _row_id_1, _row_id_2, r_regionkey, _rw_timestamp ], primary key: [ $1 ASC, $5 ASC, $4 ASC, $2 ASC, $3 ASC, $8 ASC, $6 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 17 { columns: [ vnode, ps_partkey, s_nationkey, ps_suppkey, _row_id, _row_id_0, r_regionkey, _row_id_1, _row_id_2, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 18 { columns: [ ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id_0, _rw_timestamp ], primary key: [ $2 ASC, $4 ASC, $3 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ s_nationkey, ps_suppkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ n_nationkey, r_regionkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id_0, _rw_timestamp ], primary key: [ $2 ASC, $4 ASC, $3 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 0 }

    Table 23 { columns: [ vnode, s_nationkey, ps_suppkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 24 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ ps_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 26 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ s_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 29 { columns: [ vnode, ps_suppkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 30 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 31 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 32 { columns: [ vnode, s_suppkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 33 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 34 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 35 { columns: [ vnode, n_nationkey, r_regionkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 36 { columns: [ r_regionkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 37 { columns: [ r_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 38 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 39 { columns: [ n_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 40 { columns: [ r_regionkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 41 { columns: [ vnode, r_regionkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 42 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 43 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 0 }

    Table 44 { columns: [ vnode, n_regionkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 45 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 46 { columns: [ n_name, s_name, s_address, s_phone, s_acctbal, s_comment, ps_partkey, ps_supplycost, _row_id, _row_id_0, r_regionkey, _row_id_1, n_nationkey, s_suppkey, _row_id_2, _rw_timestamp ], primary key: [ $6 ASC, $7 ASC, $6 ASC, $13 ASC, $12 ASC, $10 ASC, $8 ASC, $9 ASC, $11 ASC, $14 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ], distribution key: [ 6, 7 ], read pk prefix len hint: 0 }

    Table 47 { columns: [ vnode, ps_partkey, ps_supplycost, ps_partkey_0, s_suppkey, n_nationkey, r_regionkey, _row_id, _row_id_0, _row_id_1, _row_id_2, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 48 { columns: [ n_name, s_suppkey, s_name, s_address, s_phone, s_acctbal, s_comment, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1, _rw_timestamp ], primary key: [ $1 ASC, $10 ASC, $9 ASC, $7 ASC, $8 ASC, $11 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 49 { columns: [ s_suppkey, n_nationkey, r_regionkey, _row_id, _row_id_0, _row_id_1, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 50 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 51 { columns: [ ps_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 52 { columns: [ n_name, s_suppkey, s_name, s_address, s_phone, s_acctbal, s_comment, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1, _rw_timestamp ], primary key: [ $1 ASC, $10 ASC, $9 ASC, $7 ASC, $8 ASC, $11 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 53 { columns: [ vnode, s_suppkey, n_nationkey, r_regionkey, _row_id, _row_id_0, _row_id_1, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 54 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 55 { columns: [ n_nationkey, r_regionkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 56 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 57 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 58 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 59 { columns: [ vnode, n_nationkey, r_regionkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 60 { columns: [ r_regionkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 61 { columns: [ r_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 62 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 63 { columns: [ n_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 64 { columns: [ r_regionkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 65 { columns: [ vnode, r_regionkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 66 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 0 }

    Table 67 { columns: [ vnode, n_regionkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 68 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 0 }

    Table 69 { columns: [ vnode, s_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 70 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 71 { columns: [ vnode, ps_suppkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, min(ps_supplycost), ps_partkey, _row_id#1, _row_id#2, r_regionkey, _row_id#3, n_nationkey, _row_id#4, s_suppkey, _rw_timestamp ], primary key: [ $0 DESC, $2 ASC, $1 ASC, $3 ASC, $9 ASC, $10 ASC, $8 ASC, $17 ASC, $15 ASC, $13 ASC, $11 ASC, $12 ASC, $14 ASC, $16 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ], distribution key: [ 3, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ], read pk prefix len hint: 14 }

- id: tpch_q5
  before:
  - create_tables
  sql: |
    select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
    group by
      n_name
    order by
      revenue desc;
  logical_plan: |-
    LogicalProject { exprs: [n_name, sum($expr1)] }
    └─LogicalAgg { group_key: [n_name], aggs: [sum($expr1)] }
      └─LogicalProject { exprs: [n_name, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr1] }
        └─LogicalFilter { predicate: (c_custkey = o_custkey) AND (l_orderkey = o_orderkey) AND (l_suppkey = s_suppkey) AND (c_nationkey = s_nationkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalSource { source: customer, is_shared: false, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
            │ │ │ │ └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
            │ │ │ └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            └─LogicalSource { source: region, is_shared: false, columns: [r_regionkey, r_name, r_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [n_name], aggs: [sum($expr1)] }
    └─LogicalProject { exprs: [n_name, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr1] }
      └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [l_extendedprice, l_discount, n_name] }
        ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_extendedprice, l_discount, n_name, n_regionkey] }
        │ ├─LogicalJoin { type: Inner, on: (l_orderkey = o_orderkey) AND (l_suppkey = s_suppkey), output: [s_nationkey, l_extendedprice, l_discount] }
        │ │ ├─LogicalJoin { type: Inner, on: (c_nationkey = s_nationkey), output: [o_orderkey, s_suppkey, s_nationkey] }
        │ │ │ ├─LogicalJoin { type: Inner, on: (c_custkey = o_custkey), output: [c_nationkey, o_orderkey] }
        │ │ │ │ ├─LogicalSource { source: customer, is_shared: false, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
        │ │ │ │ └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
        │ │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │ │ └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
        │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─LogicalSource { source: region, is_shared: false, columns: [r_regionkey, r_name, r_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [sum($expr1) DESC], dist: Single }
    └─BatchSort { order: [sum($expr1) DESC] }
      └─BatchHashAgg { group_key: [n_name], aggs: [sum($expr1)] }
        └─BatchExchange { order: [], dist: HashShard(n_name) }
          └─BatchProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1] }
            └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [l_extendedprice, l_discount, n_name] }
              ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
              │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_extendedprice, l_discount, n_name, n_regionkey] }
              │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
              │   │ └─BatchHashJoin { type: Inner, predicate: o_orderkey = l_orderkey AND s_suppkey = l_suppkey, output: [s_nationkey, l_extendedprice, l_discount] }
              │   │   ├─BatchExchange { order: [], dist: HashShard(o_orderkey, s_suppkey) }
              │   │   │ └─BatchHashJoin { type: Inner, predicate: c_nationkey = s_nationkey, output: [o_orderkey, s_suppkey, s_nationkey] }
              │   │   │   ├─BatchExchange { order: [], dist: HashShard(c_nationkey) }
              │   │   │   │ └─BatchHashJoin { type: Inner, predicate: c_custkey = o_custkey, output: [c_nationkey, o_orderkey] }
              │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(c_custkey) }
              │   │   │   │   │ └─BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
              │   │   │   │   └─BatchExchange { order: [], dist: HashShard(o_custkey) }
              │   │   │   │     └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              │   │   │   └─BatchExchange { order: [], dist: HashShard(s_nationkey) }
              │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │   │   └─BatchExchange { order: [], dist: HashShard(l_orderkey, l_suppkey) }
              │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
              │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
                └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [revenue, n_name], pk_conflict: NoCheck }
    └─StreamProject { exprs: [n_name, sum($expr1)] }
      └─StreamHashAgg [append_only] { group_key: [n_name], aggs: [sum($expr1), count] }
        └─StreamLocalityProvider { locality_columns: [n_name] }
          └─StreamExchange { dist: HashShard(n_name) }
            └─StreamProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1, _row_id, _row_id, r_regionkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, n_nationkey] }
              └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey AND n_nationkey = c_nationkey, output: [l_extendedprice, l_discount, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey] }
                ├─StreamExchange { dist: HashShard(n_nationkey, n_nationkey) }
                │ └─StreamLocalityProvider { locality_columns: [n_nationkey, n_nationkey] }
                │   └─StreamExchange { dist: HashShard(n_nationkey) }
                │     └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
                │       ├─StreamExchange { dist: HashShard(r_regionkey) }
                │       │ └─StreamLocalityProvider { locality_columns: [r_regionkey] }
                │       │   └─StreamExchange { dist: HashShard(r_regionkey) }
                │       │     └─StreamRowIdGen { row_id_index: 3 }
                │       │       └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                │       └─StreamExchange { dist: HashShard(n_regionkey) }
                │         └─StreamLocalityProvider { locality_columns: [n_regionkey] }
                │           └─StreamExchange { dist: HashShard(n_regionkey) }
                │             └─StreamFilter { predicate: IsNotNull(n_nationkey) }
                │               └─StreamRowIdGen { row_id_index: 4 }
                │                 └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                └─StreamExchange { dist: HashShard(s_nationkey, c_nationkey) }
                  └─StreamLocalityProvider { locality_columns: [s_nationkey, c_nationkey] }
                    └─StreamExchange { dist: HashShard(c_nationkey, s_nationkey) }
                      └─StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey AND c_nationkey = s_nationkey, output: [c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id, o_custkey, o_orderkey, _row_id, _row_id, l_suppkey] }
                        ├─StreamExchange { dist: HashShard(o_orderkey, c_nationkey) }
                        │ └─StreamLocalityProvider { locality_columns: [o_orderkey, c_nationkey] }
                        │   └─StreamExchange { dist: HashShard(o_orderkey, c_nationkey) }
                        │     └─StreamHashJoin [append_only] { type: Inner, predicate: o_custkey = c_custkey, output: [o_orderkey, c_nationkey, _row_id, o_custkey, _row_id] }
                        │       ├─StreamExchange { dist: HashShard(o_custkey) }
                        │       │ └─StreamLocalityProvider { locality_columns: [o_custkey] }
                        │       │   └─StreamExchange { dist: HashShard(o_custkey) }
                        │       │     └─StreamRowIdGen { row_id_index: 9 }
                        │       │       └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                        │       └─StreamExchange { dist: HashShard(c_custkey) }
                        │         └─StreamLocalityProvider { locality_columns: [c_custkey] }
                        │           └─StreamExchange { dist: HashShard(c_custkey) }
                        │             └─StreamRowIdGen { row_id_index: 8 }
                        │               └─StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                        └─StreamExchange { dist: HashShard(l_orderkey, s_nationkey) }
                          └─StreamLocalityProvider { locality_columns: [l_orderkey, s_nationkey] }
                            └─StreamExchange { dist: HashShard(l_orderkey, s_nationkey) }
                              └─StreamHashJoin [append_only] { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id] }
                                ├─StreamExchange { dist: HashShard(l_suppkey) }
                                │ └─StreamLocalityProvider { locality_columns: [l_suppkey] }
                                │   └─StreamExchange { dist: HashShard(l_suppkey) }
                                │     └─StreamRowIdGen { row_id_index: 16 }
                                │       └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                                └─StreamExchange { dist: HashShard(s_suppkey) }
                                  └─StreamLocalityProvider { locality_columns: [s_suppkey] }
                                    └─StreamExchange { dist: HashShard(s_suppkey) }
                                      └─StreamRowIdGen { row_id_index: 7 }
                                        └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [revenue, n_name], pk_conflict: NoCheck }
    └── StreamProject { exprs: [n_name, sum($expr1)] }
        └── StreamHashAgg [append_only] { group_key: [n_name], aggs: [sum($expr1), count] } { tables: [ HashAggState: 0 ] }
            └── StreamLocalityProvider { locality_columns: [n_name] }
                ├── tables: [ LocalityProviderState: 1, LocalityProviderProgress: 2 ]
                └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1, _row_id, _row_id, r_regionkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, n_nationkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey AND n_nationkey = c_nationkey, output: [l_extendedprice, l_discount, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey] }
        ├── tables: [ HashJoinLeft: 3, HashJoinDegreeLeft: 4, HashJoinRight: 5, HashJoinDegreeRight: 6 ]
        ├── StreamExchange Hash([0, 0]) from 2
        └── StreamExchange Hash([3, 0]) from 8

    Fragment 2
    StreamLocalityProvider { locality_columns: [n_nationkey, n_nationkey] } { tables: [ LocalityProviderState: 7, LocalityProviderProgress: 8 ] }
    └── StreamExchange Hash([0]) from 3

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] } { tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ] }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([2]) from 6

    Fragment 4
    StreamLocalityProvider { locality_columns: [r_regionkey] } { tables: [ LocalityProviderState: 13, LocalityProviderProgress: 14 ] }
    └── StreamExchange Hash([0]) from 5

    Fragment 5
    StreamRowIdGen { row_id_index: 3 }
    └── StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] } { tables: [ Source: 15 ] }

    Fragment 6
    StreamLocalityProvider { locality_columns: [n_regionkey] } { tables: [ LocalityProviderState: 16, LocalityProviderProgress: 17 ] }
    └── StreamExchange Hash([2]) from 7

    Fragment 7
    StreamFilter { predicate: IsNotNull(n_nationkey) }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 18 ] }

    Fragment 8
    StreamLocalityProvider { locality_columns: [s_nationkey, c_nationkey] } { tables: [ LocalityProviderState: 19, LocalityProviderProgress: 20 ] }
    └── StreamExchange Hash([0, 3]) from 9

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey AND c_nationkey = s_nationkey, output: [c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id, o_custkey, o_orderkey, _row_id, _row_id, l_suppkey] }
    ├── tables: [ HashJoinLeft: 21, HashJoinDegreeLeft: 22, HashJoinRight: 23, HashJoinDegreeRight: 24 ]
    ├── StreamExchange Hash([0, 1]) from 10
    └── StreamExchange Hash([0, 3]) from 16

    Fragment 10
    StreamLocalityProvider { locality_columns: [o_orderkey, c_nationkey] } { tables: [ LocalityProviderState: 25, LocalityProviderProgress: 26 ] }
    └── StreamExchange Hash([0, 1]) from 11

    Fragment 11
    StreamHashJoin [append_only] { type: Inner, predicate: o_custkey = c_custkey, output: [o_orderkey, c_nationkey, _row_id, o_custkey, _row_id] } { tables: [ HashJoinLeft: 27, HashJoinDegreeLeft: 28, HashJoinRight: 29, HashJoinDegreeRight: 30 ] }
    ├── StreamExchange Hash([1]) from 12
    └── StreamExchange Hash([0]) from 14

    Fragment 12
    StreamLocalityProvider { locality_columns: [o_custkey] } { tables: [ LocalityProviderState: 31, LocalityProviderProgress: 32 ] }
    └── StreamExchange Hash([1]) from 13

    Fragment 13
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 33 ] }

    Fragment 14
    StreamLocalityProvider { locality_columns: [c_custkey] } { tables: [ LocalityProviderState: 34, LocalityProviderProgress: 35 ] }
    └── StreamExchange Hash([0]) from 15

    Fragment 15
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] } { tables: [ Source: 36 ] }

    Fragment 16
    StreamLocalityProvider { locality_columns: [l_orderkey, s_nationkey] } { tables: [ LocalityProviderState: 37, LocalityProviderProgress: 38 ] }
    └── StreamExchange Hash([0, 3]) from 17

    Fragment 17
    StreamHashJoin [append_only] { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id] } { tables: [ HashJoinLeft: 39, HashJoinDegreeLeft: 40, HashJoinRight: 41, HashJoinDegreeRight: 42 ] }
    ├── StreamExchange Hash([2]) from 18
    └── StreamExchange Hash([0]) from 20

    Fragment 18
    StreamLocalityProvider { locality_columns: [l_suppkey] } { tables: [ LocalityProviderState: 43, LocalityProviderProgress: 44 ] }
    └── StreamExchange Hash([2]) from 19

    Fragment 19
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] } { tables: [ Source: 45 ] }

    Fragment 20
    StreamLocalityProvider { locality_columns: [s_suppkey] } { tables: [ LocalityProviderState: 46, LocalityProviderProgress: 47 ] }
    └── StreamExchange Hash([0]) from 21

    Fragment 21
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 48 ] }

    Table 0 { columns: [ n_name, sum($expr1), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ n_name, $expr1, _row_id, _row_id_0, r_regionkey, _row_id_1, _row_id_2, o_custkey, _row_id_3, _row_id_4, l_suppkey, o_orderkey, n_nationkey, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $12 ASC, $12 ASC, $4 ASC, $2 ASC, $3 ASC, $11 ASC, $7 ASC, $5 ASC, $6 ASC, $10 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, n_name, n_nationkey, n_nationkey_0, r_regionkey, _row_id, _row_id_0, o_orderkey, o_custkey, _row_id_1, _row_id_2, l_suppkey, _row_id_3, _row_id_4, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $0 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 0 ], read pk prefix len hint: 2 }

    Table 4 { columns: [ n_nationkey, n_nationkey_0, r_regionkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 5
    ├── columns: [ c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id_0, o_custkey, o_orderkey, _row_id_1, _row_id_2, l_suppkey, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $0 ASC, $7 ASC, $6 ASC, $4 ASC, $5 ASC, $10 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 3, 0 ]
    └── read pk prefix len hint: 2

    Table 6
    ├── columns: [ s_nationkey, c_nationkey, o_orderkey, o_custkey, _row_id, _row_id_0, l_suppkey, _row_id_1, _row_id_2, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC ]
    ├── value indices: [ 9 ]
    ├── distribution key: [ 0, 1 ]
    └── read pk prefix len hint: 2

    Table 7 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $0 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 8 { columns: [ vnode, n_nationkey, n_nationkey_0, r_regionkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 9 { columns: [ r_regionkey, r_name, r_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ r_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ n_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ r_regionkey, r_name, r_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 14 { columns: [ vnode, r_regionkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 15 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 16 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 2 ], read pk prefix len hint: 0 }

    Table 17 { columns: [ vnode, n_regionkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 18 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 19
    ├── columns: [ c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id_0, o_custkey, o_orderkey, _row_id_1, _row_id_2, l_suppkey, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $0 ASC, $7 ASC, $0 ASC, $6 ASC, $4 ASC, $5 ASC, $10 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 0, 3 ]
    └── read pk prefix len hint: 0

    Table 20
    ├── columns: [ vnode, s_nationkey, c_nationkey, o_orderkey, c_nationkey_0, o_custkey, _row_id, _row_id_0, l_suppkey, _row_id_1, _row_id_2, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 21 { columns: [ o_orderkey, c_nationkey, _row_id, o_custkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 22 { columns: [ o_orderkey, c_nationkey, o_custkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 23 { columns: [ l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $5 ASC, $4 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0, 3 ], read pk prefix len hint: 2 }

    Table 24 { columns: [ l_orderkey, s_nationkey, l_suppkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 25 { columns: [ o_orderkey, c_nationkey, _row_id, o_custkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1 ], read pk prefix len hint: 0 }

    Table 26 { columns: [ vnode, o_orderkey, c_nationkey, o_custkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 27
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 28 { columns: [ o_custkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 29 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ c_custkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 31
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 0

    Table 32 { columns: [ vnode, o_custkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 33 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 34 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 35 { columns: [ vnode, c_custkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 36 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 37 { columns: [ l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $5 ASC, $4 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0, 3 ], read pk prefix len hint: 0 }

    Table 38 { columns: [ vnode, l_orderkey, s_nationkey, l_suppkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 39
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 1

    Table 40 { columns: [ l_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 41 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 42 { columns: [ s_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 43
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 0

    Table 44 { columns: [ vnode, l_suppkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 45 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 46 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 47 { columns: [ vnode, s_suppkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 48 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ n_name, revenue, _rw_timestamp ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

- id: tpch_q7
  before:
  - create_tables
  sql: |
    select
      supp_nation,
      cust_nation,
      l_year,
      sum(volume) as revenue
    from
      (
        select
          n1.n_name as supp_nation,
          n2.n_name as cust_nation,
          extract(year from l_shipdate) as l_year,
          l_extendedprice * (1 - l_discount) as volume
        from
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2
        where
          s_suppkey = l_suppkey
          and o_orderkey = l_orderkey
          and c_custkey = o_custkey
          and s_nationkey = n1.n_nationkey
          and c_nationkey = n2.n_nationkey
      ) as shipping
    group by
      supp_nation,
      cust_nation,
      l_year
    order by
      supp_nation,
      cust_nation,
      l_year;
  logical_plan: |-
    LogicalProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
    └─LogicalAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
      └─LogicalProject { exprs: [n_name, n_name, $expr1, $expr2] }
        └─LogicalProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2] }
          └─LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (o_orderkey = l_orderkey) AND (c_custkey = o_custkey) AND (s_nationkey = n_nationkey) AND (c_nationkey = n_nationkey) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │ │ │ │ └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │ │ │ └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              │ │ └─LogicalSource { source: customer, is_shared: false, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
              │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
    └─LogicalProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2] }
      └─LogicalJoin { type: Inner, on: (c_nationkey = n_nationkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name] }
        ├─LogicalJoin { type: Inner, on: (c_custkey = o_custkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, c_nationkey] }
        │ ├─LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, o_custkey] }
        │ │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name] }
        │ │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [s_nationkey, l_orderkey, l_extendedprice, l_discount, l_shipdate] }
        │ │ │ │ ├─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │ │ │ │ └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
        │ │ │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        │ │ └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
        │ └─LogicalSource { source: customer, is_shared: false, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
        └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [n_name ASC, n_name ASC, $expr1 ASC], dist: Single }
    └─BatchSort { order: [n_name ASC, n_name ASC, $expr1 ASC] }
      └─BatchHashAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
        └─BatchExchange { order: [], dist: HashShard(n_name, n_name, $expr1) }
          └─BatchProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2] }
            └─BatchHashJoin { type: Inner, predicate: c_nationkey = n_nationkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name] }
              ├─BatchExchange { order: [], dist: HashShard(c_nationkey) }
              │ └─BatchHashJoin { type: Inner, predicate: o_custkey = c_custkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, c_nationkey] }
              │   ├─BatchExchange { order: [], dist: HashShard(o_custkey) }
              │   │ └─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, o_custkey] }
              │   │   ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
              │   │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name] }
              │   │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
              │   │   │   │ └─BatchHashJoin { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_nationkey, l_orderkey, l_extendedprice, l_discount, l_shipdate] }
              │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(s_suppkey) }
              │   │   │   │   │ └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │   │   │   │   └─BatchExchange { order: [], dist: HashShard(l_suppkey) }
              │   │   │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │   │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
              │   │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              │   │   └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
              │   │     └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              │   └─BatchExchange { order: [], dist: HashShard(c_custkey) }
              │     └─BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
              └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], stream_key: [supp_nation, cust_nation, l_year], pk_columns: [supp_nation, cust_nation, l_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
      └─StreamHashAgg [append_only] { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2), count] }
        └─StreamLocalityProvider { locality_columns: [n_name, n_name, $expr1] }
          └─StreamExchange { dist: HashShard(n_name, n_name, $expr1) }
            └─StreamProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey, l_orderkey] }
              └─StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, l_orderkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey] }
                ├─StreamExchange { dist: HashShard(l_orderkey) }
                │ └─StreamLocalityProvider { locality_columns: [l_orderkey] }
                │   └─StreamExchange { dist: HashShard(l_orderkey) }
                │     └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id, n_nationkey, s_suppkey, _row_id] }
                │       ├─StreamExchange { dist: HashShard(s_suppkey) }
                │       │ └─StreamLocalityProvider { locality_columns: [s_suppkey] }
                │       │   └─StreamExchange { dist: HashShard(s_suppkey) }
                │       │     └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                │       │       ├─StreamExchange { dist: HashShard(n_nationkey) }
                │       │       │ └─StreamLocalityProvider { locality_columns: [n_nationkey] }
                │       │       │   └─StreamExchange { dist: HashShard(n_nationkey) }
                │       │       │     └─StreamShare { id: 3 }
                │       │       │       └─StreamProject { exprs: [n_nationkey, n_name, _row_id] }
                │       │       │         └─StreamRowIdGen { row_id_index: 4 }
                │       │       │           └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                │       │       └─StreamExchange { dist: HashShard(s_nationkey) }
                │       │         └─StreamLocalityProvider { locality_columns: [s_nationkey] }
                │       │           └─StreamExchange { dist: HashShard(s_nationkey) }
                │       │             └─StreamRowIdGen { row_id_index: 7 }
                │       │               └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                │       └─StreamExchange { dist: HashShard(l_suppkey) }
                │         └─StreamLocalityProvider { locality_columns: [l_suppkey] }
                │           └─StreamExchange { dist: HashShard(l_suppkey) }
                │             └─StreamRowIdGen { row_id_index: 16 }
                │               └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                └─StreamExchange { dist: HashShard(o_orderkey) }
                  └─StreamLocalityProvider { locality_columns: [o_orderkey] }
                    └─StreamExchange { dist: HashShard(o_orderkey) }
                      └─StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, o_orderkey, _row_id, _row_id, n_nationkey, c_custkey, _row_id] }
                        ├─StreamExchange { dist: HashShard(c_custkey) }
                        │ └─StreamLocalityProvider { locality_columns: [c_custkey] }
                        │   └─StreamExchange { dist: HashShard(c_custkey) }
                        │     └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [n_name, c_custkey, _row_id, n_nationkey, _row_id] }
                        │       ├─StreamExchange { dist: HashShard(n_nationkey) }
                        │       │ └─StreamLocalityProvider { locality_columns: [n_nationkey] }
                        │       │   └─StreamExchange { dist: HashShard(n_nationkey) }
                        │       │     └─StreamShare { id: 3 }
                        │       │       └─StreamProject { exprs: [n_nationkey, n_name, _row_id] }
                        │       │         └─StreamRowIdGen { row_id_index: 4 }
                        │       │           └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                        │       └─StreamExchange { dist: HashShard(c_nationkey) }
                        │         └─StreamLocalityProvider { locality_columns: [c_nationkey] }
                        │           └─StreamExchange { dist: HashShard(c_nationkey) }
                        │             └─StreamRowIdGen { row_id_index: 8 }
                        │               └─StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                        └─StreamExchange { dist: HashShard(o_custkey) }
                          └─StreamLocalityProvider { locality_columns: [o_custkey] }
                            └─StreamExchange { dist: HashShard(o_custkey) }
                              └─StreamRowIdGen { row_id_index: 9 }
                                └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], stream_key: [supp_nation, cust_nation, l_year], pk_columns: [supp_nation, cust_nation, l_year], pk_conflict: NoCheck }
    └── StreamProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
        └── StreamHashAgg [append_only] { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2), count] } { tables: [ HashAggState: 0 ] }
            └── StreamLocalityProvider { locality_columns: [n_name, n_name, $expr1] } { tables: [ LocalityProviderState: 1, LocalityProviderProgress: 2 ] }
                └── StreamExchange Hash([0, 1, 2]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey, l_orderkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, l_orderkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey] }
        ├── tables: [ HashJoinLeft: 3, HashJoinDegreeLeft: 4, HashJoinRight: 5, HashJoinDegreeRight: 6 ]
        ├── StreamExchange Hash([1]) from 2
        └── StreamExchange Hash([1]) from 13

    Fragment 2
    StreamLocalityProvider { locality_columns: [l_orderkey] } { tables: [ LocalityProviderState: 7, LocalityProviderProgress: 8 ] }
    └── StreamExchange Hash([1]) from 3

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id, n_nationkey, s_suppkey, _row_id] }
    ├── tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ]
    ├── StreamExchange Hash([1]) from 4
    └── StreamExchange Hash([2]) from 11

    Fragment 4
    StreamLocalityProvider { locality_columns: [s_suppkey] } { tables: [ LocalityProviderState: 13, LocalityProviderProgress: 14 ] }
    └── StreamExchange Hash([1]) from 5

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 15, HashJoinDegreeLeft: 16, HashJoinRight: 17, HashJoinDegreeRight: 18 ] }
    ├── StreamExchange Hash([0]) from 6
    └── StreamExchange Hash([3]) from 9

    Fragment 6
    StreamLocalityProvider { locality_columns: [n_nationkey] } { tables: [ LocalityProviderState: 19, LocalityProviderProgress: 20 ] }
    └── StreamExchange Hash([0]) from 7

    Fragment 7
    StreamNoOp
    └── StreamExchange NoShuffle from 8

    Fragment 8
    StreamProject { exprs: [n_nationkey, n_name, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 21 ] }

    Fragment 9
    StreamLocalityProvider { locality_columns: [s_nationkey] } { tables: [ LocalityProviderState: 22, LocalityProviderProgress: 23 ] }
    └── StreamExchange Hash([3]) from 10

    Fragment 10
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 24 ] }

    Fragment 11
    StreamLocalityProvider { locality_columns: [l_suppkey] } { tables: [ LocalityProviderState: 25, LocalityProviderProgress: 26 ] }
    └── StreamExchange Hash([2]) from 12

    Fragment 12
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
        └── tables: [ Source: 27 ]

    Fragment 13
    StreamLocalityProvider { locality_columns: [o_orderkey] } { tables: [ LocalityProviderState: 28, LocalityProviderProgress: 29 ] }
    └── StreamExchange Hash([1]) from 14

    Fragment 14
    StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, o_orderkey, _row_id, _row_id, n_nationkey, c_custkey, _row_id] } { tables: [ HashJoinLeft: 30, HashJoinDegreeLeft: 31, HashJoinRight: 32, HashJoinDegreeRight: 33 ] }
    ├── StreamExchange Hash([1]) from 15
    └── StreamExchange Hash([1]) from 21

    Fragment 15
    StreamLocalityProvider { locality_columns: [c_custkey] } { tables: [ LocalityProviderState: 34, LocalityProviderProgress: 35 ] }
    └── StreamExchange Hash([1]) from 16

    Fragment 16
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [n_name, c_custkey, _row_id, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 36, HashJoinDegreeLeft: 37, HashJoinRight: 38, HashJoinDegreeRight: 39 ] }
    ├── StreamExchange Hash([0]) from 17
    └── StreamExchange Hash([3]) from 19

    Fragment 17
    StreamLocalityProvider { locality_columns: [n_nationkey] } { tables: [ LocalityProviderState: 40, LocalityProviderProgress: 41 ] }
    └── StreamExchange Hash([0]) from 18

    Fragment 18
    StreamNoOp
    └── StreamExchange NoShuffle from 8

    Fragment 19
    StreamLocalityProvider { locality_columns: [c_nationkey] } { tables: [ LocalityProviderState: 42, LocalityProviderProgress: 43 ] }
    └── StreamExchange Hash([3]) from 20

    Fragment 20
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] } { tables: [ Source: 44 ] }

    Fragment 21
    StreamLocalityProvider { locality_columns: [o_custkey] } { tables: [ LocalityProviderState: 45, LocalityProviderProgress: 46 ] }
    └── StreamExchange Hash([1]) from 22

    Fragment 22
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 47 ] }

    Table 0 { columns: [ n_name, n_name_0, $expr1, sum($expr2), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 1
    ├── columns: [ n_name, n_name_0, $expr1, $expr2, _row_id, _row_id_0, n_nationkey, _row_id_1, s_suppkey, _row_id_2, _row_id_3, n_nationkey_0, _row_id_4, c_custkey, l_orderkey, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $14 ASC, $8 ASC, $6 ASC, $4 ASC, $5 ASC, $7 ASC, $13 ASC, $11 ASC, $9 ASC, $10 ASC, $12 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, n_name, n_name_0, $expr1, l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, _row_id_1, c_custkey, n_nationkey_0, _row_id_2, _row_id_3, _row_id_4, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3
    ├── columns: [ n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $8 ASC, $7 ASC, $5 ASC, $6 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 4 { columns: [ l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, _row_id_1, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5
    ├── columns: [ n_name, o_orderkey, _row_id, _row_id_0, n_nationkey, c_custkey, _row_id_1, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $5 ASC, $4 ASC, $2 ASC, $3 ASC, $6 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 6 { columns: [ o_orderkey, c_custkey, n_nationkey, _row_id, _row_id_0, _row_id_1, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7
    ├── columns: [ n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $8 ASC, $7 ASC, $5 ASC, $6 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 0

    Table 8
    ├── columns: [ vnode, l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, _row_id_1, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 9 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ s_suppkey, n_nationkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 1

    Table 12 { columns: [ l_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 14 { columns: [ vnode, s_suppkey, n_nationkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 15 { columns: [ n_nationkey, n_name, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ n_nationkey, n_name, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 20 { columns: [ vnode, n_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 21 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 22 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 0 }

    Table 23 { columns: [ vnode, s_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 24 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 25
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 0

    Table 26 { columns: [ vnode, l_suppkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 27 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 28
    ├── columns: [ n_name, o_orderkey, _row_id, _row_id_0, n_nationkey, c_custkey, _row_id_1, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $5 ASC, $4 ASC, $2 ASC, $3 ASC, $6 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 0

    Table 29
    ├── columns: [ vnode, o_orderkey, c_custkey, n_nationkey, _row_id, _row_id_0, _row_id_1, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 30 { columns: [ n_name, c_custkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 31 { columns: [ c_custkey, n_nationkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 32
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 33 { columns: [ o_custkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 34 { columns: [ n_name, c_custkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 35 { columns: [ vnode, c_custkey, n_nationkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 36 { columns: [ n_nationkey, n_name, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 37 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 38
    ├── columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $8 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
    ├── distribution key: [ 3 ]
    └── read pk prefix len hint: 1

    Table 39 { columns: [ c_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 40 { columns: [ n_nationkey, n_name, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 41 { columns: [ vnode, n_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 42
    ├── columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $8 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
    ├── distribution key: [ 3 ]
    └── read pk prefix len hint: 0

    Table 43 { columns: [ vnode, c_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 44 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 45
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 0

    Table 46 { columns: [ vnode, o_custkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 47 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ supp_nation, cust_nation, l_year, revenue, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

- id: tpch_q8
  before:
  - create_tables
  sql: |
    select
      o_year,
      round(sum(case
        when nation != 'IRAN' then volume
        else 0
      end) / sum(volume), 6) as mkt_share
    from
      (
        select
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) as volume,
          n2.n_name as nation
        from
          part,
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2,
          region
        where
          p_partkey = l_partkey
          and s_suppkey = l_suppkey
          and l_orderkey = o_orderkey
          and o_custkey = c_custkey
          and c_nationkey = n1.n_nationkey
          and n1.n_regionkey = r_regionkey
          and s_nationkey = n2.n_nationkey
      ) as all_nations
    group by
      o_year
    order by
      o_year;
  logical_plan: |-
    LogicalProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
    └─LogicalAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
      └─LogicalProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Int32::Decimal) as $expr3, $expr2] }
        └─LogicalProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2, n_name] }
          └─LogicalFilter { predicate: (p_partkey = l_partkey) AND (s_suppkey = l_suppkey) AND (l_orderkey = o_orderkey) AND (o_custkey = c_custkey) AND (c_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) AND (s_nationkey = n_nationkey) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ │ │ ├─LogicalSource { source: part, is_shared: false, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
              │ │ │ │ │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │ │ │ │ │ └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │ │ │ │ └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              │ │ │ └─LogicalSource { source: customer, is_shared: false, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
              │ │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              └─LogicalSource { source: region, is_shared: false, columns: [r_regionkey, r_name, r_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
    └─LogicalAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
      └─LogicalProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Int32::Decimal) as $expr3, $expr2] }
        └─LogicalProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2, n_name] }
          └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [l_extendedprice, l_discount, o_orderdate, n_name] }
            ├─LogicalJoin { type: Inner, on: (c_nationkey = n_nationkey), output: [l_extendedprice, l_discount, n_name, o_orderdate, n_regionkey] }
            │ ├─LogicalJoin { type: Inner, on: (o_custkey = c_custkey), output: [l_extendedprice, l_discount, n_name, o_orderdate, c_nationkey] }
            │ │ ├─LogicalJoin { type: Inner, on: (l_orderkey = o_orderkey), output: [l_extendedprice, l_discount, n_name, o_custkey, o_orderdate] }
            │ │ │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_extendedprice, l_discount, n_name] }
            │ │ │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [l_orderkey, l_extendedprice, l_discount, s_nationkey] }
            │ │ │ │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = l_partkey), output: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
            │ │ │ │ │ │ ├─LogicalSource { source: part, is_shared: false, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
            │ │ │ │ │ │ └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            │ │ │ │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │ │ │ │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            │ │ │ └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
            │ │ └─LogicalSource { source: customer, is_shared: false, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
            │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            └─LogicalSource { source: region, is_shared: false, columns: [r_regionkey, r_name, r_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [$expr1 ASC], dist: Single }
    └─BatchProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
      └─BatchSort { order: [$expr1 ASC] }
        └─BatchHashAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
          └─BatchExchange { order: [], dist: HashShard($expr1) }
            └─BatchProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Decimal) as $expr3, $expr2] }
              └─BatchProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, n_name] }
                └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [l_extendedprice, l_discount, o_orderdate, n_name] }
                  ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
                  │ └─BatchHashJoin { type: Inner, predicate: c_nationkey = n_nationkey, output: [l_extendedprice, l_discount, n_name, o_orderdate, n_regionkey] }
                  │   ├─BatchExchange { order: [], dist: HashShard(c_nationkey) }
                  │   │ └─BatchHashJoin { type: Inner, predicate: o_custkey = c_custkey, output: [l_extendedprice, l_discount, n_name, o_orderdate, c_nationkey] }
                  │   │   ├─BatchExchange { order: [], dist: HashShard(o_custkey) }
                  │   │   │ └─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, n_name, o_custkey, o_orderdate] }
                  │   │   │   ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
                  │   │   │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_extendedprice, l_discount, n_name] }
                  │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
                  │   │   │   │   │ └─BatchHashJoin { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey] }
                  │   │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(l_suppkey) }
                  │   │   │   │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
                  │   │   │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
                  │   │   │   │   │   │   │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                  │   │   │   │   │   │   └─BatchExchange { order: [], dist: HashShard(l_partkey) }
                  │   │   │   │   │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                  │   │   │   │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
                  │   │   │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                  │   │   │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                  │   │   │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                  │   │   │   └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
                  │   │   │     └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                  │   │   └─BatchExchange { order: [], dist: HashShard(c_custkey) }
                  │   │     └─BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                  │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                  │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                  └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
                    └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [o_year, mkt_share], stream_key: [o_year], pk_columns: [o_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
      └─StreamHashAgg [append_only] { group_key: [$expr1], aggs: [sum($expr3), sum($expr2), count] }
        └─StreamLocalityProvider { locality_columns: [$expr1] }
          └─StreamExchange { dist: HashShard($expr1) }
            └─StreamProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Decimal) as $expr3, $expr2, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
              └─StreamProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
                └─StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [l_extendedprice, l_discount, o_orderdate, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, c_custkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey] }
                  ├─StreamExchange { dist: HashShard(c_custkey) }
                  │ └─StreamLocalityProvider { locality_columns: [c_custkey] }
                  │   └─StreamExchange { dist: HashShard(c_custkey) }
                  │     └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [c_custkey, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] }
                  │       ├─StreamExchange { dist: HashShard(n_nationkey) }
                  │       │ └─StreamLocalityProvider { locality_columns: [n_nationkey] }
                  │       │   └─StreamExchange { dist: HashShard(n_nationkey) }
                  │       │     └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] }
                  │       │       ├─StreamExchange { dist: HashShard(r_regionkey) }
                  │       │       │ └─StreamLocalityProvider { locality_columns: [r_regionkey] }
                  │       │       │   └─StreamExchange { dist: HashShard(r_regionkey) }
                  │       │       │     └─StreamRowIdGen { row_id_index: 3 }
                  │       │       │       └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                  │       │       └─StreamExchange { dist: HashShard(n_regionkey) }
                  │       │         └─StreamLocalityProvider { locality_columns: [n_regionkey] }
                  │       │           └─StreamExchange { dist: HashShard(n_regionkey) }
                  │       │             └─StreamShare { id: 7 }
                  │       │               └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                  │       │                 └─StreamRowIdGen { row_id_index: 4 }
                  │       │                   └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                  │       └─StreamExchange { dist: HashShard(c_nationkey) }
                  │         └─StreamLocalityProvider { locality_columns: [c_nationkey] }
                  │           └─StreamExchange { dist: HashShard(c_nationkey) }
                  │             └─StreamRowIdGen { row_id_index: 8 }
                  │               └─StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                  └─StreamExchange { dist: HashShard(o_custkey) }
                    └─StreamLocalityProvider { locality_columns: [o_custkey] }
                      └─StreamExchange { dist: HashShard(o_custkey) }
                        └─StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, l_orderkey, _row_id] }
                          ├─StreamExchange { dist: HashShard(l_orderkey) }
                          │ └─StreamLocalityProvider { locality_columns: [l_orderkey] }
                          │   └─StreamExchange { dist: HashShard(l_orderkey) }
                          │     └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, p_partkey] }
                          │       ├─StreamExchange { dist: HashShard(s_suppkey) }
                          │       │ └─StreamLocalityProvider { locality_columns: [s_suppkey] }
                          │       │   └─StreamExchange { dist: HashShard(s_suppkey) }
                          │       │     └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                          │       │       ├─StreamExchange { dist: HashShard(n_nationkey) }
                          │       │       │ └─StreamLocalityProvider { locality_columns: [n_nationkey] }
                          │       │       │   └─StreamExchange { dist: HashShard(n_nationkey) }
                          │       │       │     └─StreamShare { id: 7 }
                          │       │       │       └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                          │       │       │         └─StreamRowIdGen { row_id_index: 4 }
                          │       │       │           └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                          │       │       └─StreamExchange { dist: HashShard(s_nationkey) }
                          │       │         └─StreamLocalityProvider { locality_columns: [s_nationkey] }
                          │       │           └─StreamExchange { dist: HashShard(s_nationkey) }
                          │       │             └─StreamRowIdGen { row_id_index: 7 }
                          │       │               └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                          │       └─StreamExchange { dist: HashShard(l_suppkey) }
                          │         └─StreamLocalityProvider { locality_columns: [l_suppkey] }
                          │           └─StreamExchange { dist: HashShard(l_suppkey) }
                          │             └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id] }
                          │               ├─StreamExchange { dist: HashShard(p_partkey) }
                          │               │ └─StreamLocalityProvider { locality_columns: [p_partkey] }
                          │               │   └─StreamExchange { dist: HashShard(p_partkey) }
                          │               │     └─StreamRowIdGen { row_id_index: 9 }
                          │               │       └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                          │               └─StreamExchange { dist: HashShard(l_partkey) }
                          │                 └─StreamLocalityProvider { locality_columns: [l_partkey] }
                          │                   └─StreamExchange { dist: HashShard(l_partkey) }
                          │                     └─StreamRowIdGen { row_id_index: 16 }
                          │                       └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                          └─StreamExchange { dist: HashShard(o_orderkey) }
                            └─StreamLocalityProvider { locality_columns: [o_orderkey] }
                              └─StreamExchange { dist: HashShard(o_orderkey) }
                                └─StreamRowIdGen { row_id_index: 9 }
                                  └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [o_year, mkt_share], stream_key: [o_year], pk_columns: [o_year], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
        └── StreamHashAgg [append_only] { group_key: [$expr1], aggs: [sum($expr3), sum($expr2), count] }
            ├── tables: [ HashAggState: 0 ]
            └── StreamLocalityProvider { locality_columns: [$expr1] }
                ├── tables: [ LocalityProviderState: 1, LocalityProviderProgress: 2 ]
                └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Decimal) as $expr3, $expr2, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
    └── StreamProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
        └── StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [l_extendedprice, l_discount, o_orderdate, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, c_custkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey] }
            ├── tables: [ HashJoinLeft: 3, HashJoinDegreeLeft: 4, HashJoinRight: 5, HashJoinDegreeRight: 6 ]
            ├── StreamExchange Hash([0]) from 2
            └── StreamExchange Hash([3]) from 13

    Fragment 2
    StreamLocalityProvider { locality_columns: [c_custkey] } { tables: [ LocalityProviderState: 7, LocalityProviderProgress: 8 ] }
    └── StreamExchange Hash([0]) from 3

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [c_custkey, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ] }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([3]) from 11

    Fragment 4
    StreamLocalityProvider { locality_columns: [n_nationkey] } { tables: [ LocalityProviderState: 13, LocalityProviderProgress: 14 ] }
    └── StreamExchange Hash([0]) from 5

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] } { tables: [ HashJoinLeft: 15, HashJoinDegreeLeft: 16, HashJoinRight: 17, HashJoinDegreeRight: 18 ] }
    ├── StreamExchange Hash([0]) from 6
    └── StreamExchange Hash([2]) from 8

    Fragment 6
    StreamLocalityProvider { locality_columns: [r_regionkey] } { tables: [ LocalityProviderState: 19, LocalityProviderProgress: 20 ] }
    └── StreamExchange Hash([0]) from 7

    Fragment 7
    StreamRowIdGen { row_id_index: 3 }
    └── StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] } { tables: [ Source: 21 ] }

    Fragment 8
    StreamLocalityProvider { locality_columns: [n_regionkey] } { tables: [ LocalityProviderState: 22, LocalityProviderProgress: 23 ] }
    └── StreamExchange Hash([2]) from 9

    Fragment 9
    StreamNoOp
    └── StreamExchange NoShuffle from 10

    Fragment 10
    StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 24 ] }

    Fragment 11
    StreamLocalityProvider { locality_columns: [c_nationkey] } { tables: [ LocalityProviderState: 25, LocalityProviderProgress: 26 ] }
    └── StreamExchange Hash([3]) from 12

    Fragment 12
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] } { tables: [ Source: 27 ] }

    Fragment 13
    StreamLocalityProvider { locality_columns: [o_custkey] } { tables: [ LocalityProviderState: 28, LocalityProviderProgress: 29 ] }
    └── StreamExchange Hash([3]) from 14

    Fragment 14
    StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, l_orderkey, _row_id] }
    ├── tables: [ HashJoinLeft: 30, HashJoinDegreeLeft: 31, HashJoinRight: 32, HashJoinDegreeRight: 33 ]
    ├── StreamExchange Hash([1]) from 15
    └── StreamExchange Hash([0]) from 29

    Fragment 15
    StreamLocalityProvider { locality_columns: [l_orderkey] } { tables: [ LocalityProviderState: 34, LocalityProviderProgress: 35 ] }
    └── StreamExchange Hash([1]) from 16

    Fragment 16
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, p_partkey] }
    ├── tables: [ HashJoinLeft: 36, HashJoinDegreeLeft: 37, HashJoinRight: 38, HashJoinDegreeRight: 39 ]
    ├── StreamExchange Hash([1]) from 17
    └── StreamExchange Hash([1]) from 23

    Fragment 17
    StreamLocalityProvider { locality_columns: [s_suppkey] } { tables: [ LocalityProviderState: 40, LocalityProviderProgress: 41 ] }
    └── StreamExchange Hash([1]) from 18

    Fragment 18
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 42, HashJoinDegreeLeft: 43, HashJoinRight: 44, HashJoinDegreeRight: 45 ] }
    ├── StreamExchange Hash([0]) from 19
    └── StreamExchange Hash([3]) from 21

    Fragment 19
    StreamLocalityProvider { locality_columns: [n_nationkey] } { tables: [ LocalityProviderState: 46, LocalityProviderProgress: 47 ] }
    └── StreamExchange Hash([0]) from 20

    Fragment 20
    StreamNoOp
    └── StreamExchange NoShuffle from 10

    Fragment 21
    StreamLocalityProvider { locality_columns: [s_nationkey] } { tables: [ LocalityProviderState: 48, LocalityProviderProgress: 49 ] }
    └── StreamExchange Hash([3]) from 22

    Fragment 22
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 50 ] }

    Fragment 23
    StreamLocalityProvider { locality_columns: [l_suppkey] } { tables: [ LocalityProviderState: 51, LocalityProviderProgress: 52 ] }
    └── StreamExchange Hash([1]) from 24

    Fragment 24
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id] } { tables: [ HashJoinLeft: 53, HashJoinDegreeLeft: 54, HashJoinRight: 55, HashJoinDegreeRight: 56 ] }
    ├── StreamExchange Hash([0]) from 25
    └── StreamExchange Hash([1]) from 27

    Fragment 25
    StreamLocalityProvider { locality_columns: [p_partkey] } { tables: [ LocalityProviderState: 57, LocalityProviderProgress: 58 ] }
    └── StreamExchange Hash([0]) from 26

    Fragment 26
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { tables: [ Source: 59 ] }

    Fragment 27
    StreamLocalityProvider { locality_columns: [l_partkey] } { tables: [ LocalityProviderState: 60, LocalityProviderProgress: 61 ] }
    └── StreamExchange Hash([1]) from 28

    Fragment 28
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] } { tables: [ Source: 62 ] }

    Fragment 29
    StreamLocalityProvider { locality_columns: [o_orderkey] } { tables: [ LocalityProviderState: 63, LocalityProviderProgress: 64 ] }
    └── StreamExchange Hash([0]) from 30

    Fragment 30
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 65 ] }

    Table 0 { columns: [ $expr1, sum($expr3), sum($expr2), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ $expr1, $expr3, $expr2, _row_id, _row_id_0, r_regionkey, _row_id_1, n_nationkey, _row_id_2, _row_id_3, n_nationkey_0, _row_id_4, _row_id_5, p_partkey, s_suppkey, _row_id_6, l_orderkey, c_custkey, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $17 ASC, $7 ASC, $5 ASC, $3 ASC, $4 ASC, $6 ASC, $16 ASC, $14 ASC, $10 ASC, $8 ASC, $9 ASC, $13 ASC, $11 ASC, $12 ASC, $15 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, $expr1, c_custkey, n_nationkey, r_regionkey, _row_id, _row_id_0, _row_id_1, l_orderkey, s_suppkey, n_nationkey_0, _row_id_2, _row_id_3, p_partkey, _row_id_4, _row_id_5, _row_id_6, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3 { columns: [ c_custkey, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC, $3 ASC, $1 ASC, $2 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ c_custkey, n_nationkey, r_regionkey, _row_id, _row_id_0, _row_id_1, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5
    ├── columns: [ n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, l_orderkey, _row_id_3, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $12 ASC, $11 ASC, $7 ASC, $5 ASC, $6 ASC, $10 ASC, $8 ASC, $9 ASC, $13 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 3 ]
    └── read pk prefix len hint: 1

    Table 6
    ├── columns: [ o_custkey, l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, p_partkey, _row_id_1, _row_id_2, _row_id_3, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 10 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 7 { columns: [ c_custkey, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC, $3 ASC, $1 ASC, $2 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 8 { columns: [ vnode, c_custkey, n_nationkey, r_regionkey, _row_id, _row_id_0, _row_id_1, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 9 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ n_nationkey, r_regionkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ c_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 14 { columns: [ vnode, n_nationkey, r_regionkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 15 { columns: [ r_regionkey, r_name, r_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ r_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ n_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ r_regionkey, r_name, r_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 20 { columns: [ vnode, r_regionkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 21 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 22 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 0 }

    Table 23 { columns: [ vnode, n_regionkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 24 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 25 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 3 ], read pk prefix len hint: 0 }

    Table 26 { columns: [ vnode, c_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 27 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 28
    ├── columns: [ n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, l_orderkey, _row_id_3, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $12 ASC, $11 ASC, $7 ASC, $5 ASC, $6 ASC, $10 ASC, $8 ASC, $9 ASC, $13 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 3 ]
    └── read pk prefix len hint: 0

    Table 29
    ├── columns: [ vnode, o_custkey, l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, p_partkey, _row_id_1, _row_id_2, _row_id_3, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 30
    ├── columns: [ n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, p_partkey, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $7 ASC, $6 ASC, $4 ASC, $5 ASC, $10 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 31 { columns: [ l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, p_partkey, _row_id_1, _row_id_2, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 32 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 33 { columns: [ o_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 34
    ├── columns: [ n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, p_partkey, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $7 ASC, $6 ASC, $4 ASC, $5 ASC, $10 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 0

    Table 35
    ├── columns: [ vnode, l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, p_partkey, _row_id_1, _row_id_2, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 36 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 37 { columns: [ s_suppkey, n_nationkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 38 { columns: [ l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $5 ASC, $4 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 39 { columns: [ l_suppkey, p_partkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 40 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 41 { columns: [ vnode, s_suppkey, n_nationkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 42 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 43 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 44 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 45 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 46 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 47 { columns: [ vnode, n_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 48 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 0 }

    Table 49 { columns: [ vnode, s_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 50 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 51 { columns: [ l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $5 ASC, $4 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 52 { columns: [ vnode, l_suppkey, p_partkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 53 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 54 { columns: [ p_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 55
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 56 { columns: [ l_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 57 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 58 { columns: [ vnode, p_partkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 59 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 60
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 0

    Table 61 { columns: [ vnode, l_partkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 62 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 63 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 64 { columns: [ vnode, o_orderkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 65 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ o_year, mkt_share, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: tpch_q9
  before:
  - create_tables
  sql: |
    select
      nation,
      o_year,
      round(sum(amount), 2) as sum_profit
    from
      (
        select
          n_name as nation,
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
          part,
          supplier,
          lineitem,
          partsupp,
          orders,
          nation
        where
          s_suppkey = l_suppkey
          and ps_suppkey = l_suppkey
          and ps_partkey = l_partkey
          and p_partkey = l_partkey
          and o_orderkey = l_orderkey
          and s_nationkey = n_nationkey
      ) as profit
    group by
      nation,
      o_year
    order by
      nation,
      o_year desc;
  logical_plan: |-
    LogicalProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
    └─LogicalAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
      └─LogicalProject { exprs: [n_name, $expr1, $expr2] }
        └─LogicalProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Int32::Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
          └─LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (ps_suppkey = l_suppkey) AND (ps_partkey = l_partkey) AND (p_partkey = l_partkey) AND (o_orderkey = l_orderkey) AND (s_nationkey = n_nationkey) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalSource { source: part, is_shared: false, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
              │ │ │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │ │ │ └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │ │ └─LogicalSource { source: partsupp, is_shared: false, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
              │ └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
    └─LogicalAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
      └─LogicalProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Int32::Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
        └─LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name] }
          ├─LogicalJoin { type: Inner, on: (ps_suppkey = l_suppkey) AND (ps_partkey = l_partkey), output: [l_orderkey, l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost] }
          │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, n_name] }
          │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, s_nationkey] }
          │ │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = l_partkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
          │ │ │ │ ├─LogicalSource { source: part, is_shared: false, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
          │ │ │ │ └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
          │ │ │ └─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
          │ │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
          │ └─LogicalSource { source: partsupp, is_shared: false, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
          └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [n_name ASC, $expr1 DESC], dist: Single }
    └─BatchProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
      └─BatchSort { order: [n_name ASC, $expr1 DESC] }
        └─BatchHashAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
          └─BatchExchange { order: [], dist: HashShard(n_name, $expr1) }
            └─BatchProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
              └─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name] }
                ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
                │ └─BatchHashJoin { type: Inner, predicate: l_suppkey = ps_suppkey AND l_partkey = ps_partkey, output: [l_orderkey, l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost] }
                │   ├─BatchExchange { order: [], dist: HashShard(l_partkey, l_suppkey) }
                │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, n_name] }
                │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
                │   │   │ └─BatchHashJoin { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, s_nationkey] }
                │   │   │   ├─BatchExchange { order: [], dist: HashShard(l_suppkey) }
                │   │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
                │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
                │   │   │   │   │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                │   │   │   │   └─BatchExchange { order: [], dist: HashShard(l_partkey) }
                │   │   │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                │   │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
                │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                │   └─BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
                │     └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
                  └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [nation, o_year, sum_profit], stream_key: [nation, o_year], pk_columns: [nation, o_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
      └─StreamHashAgg [append_only] { group_key: [n_name, $expr1], aggs: [sum($expr2), count] }
        └─StreamLocalityProvider { locality_columns: [n_name, $expr1] }
          └─StreamExchange { dist: HashShard(n_name, $expr1) }
            └─StreamProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2, _row_id, _row_id, p_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, ps_suppkey, ps_partkey] }
              └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey AND ps_suppkey = l_suppkey AND ps_partkey = l_partkey AND ps_suppkey = s_suppkey, output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name, _row_id, _row_id, p_partkey, ps_suppkey, ps_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
                ├─StreamExchange { dist: HashShard(p_partkey, ps_suppkey, ps_partkey, ps_suppkey) }
                │ └─StreamLocalityProvider { locality_columns: [p_partkey, ps_suppkey, ps_partkey, ps_suppkey] }
                │   └─StreamExchange { dist: HashShard(p_partkey, ps_partkey, ps_suppkey) }
                │     └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id] }
                │       ├─StreamExchange { dist: HashShard(p_partkey) }
                │       │ └─StreamLocalityProvider { locality_columns: [p_partkey] }
                │       │   └─StreamExchange { dist: HashShard(p_partkey) }
                │       │     └─StreamRowIdGen { row_id_index: 9 }
                │       │       └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                │       └─StreamExchange { dist: HashShard(ps_partkey) }
                │         └─StreamLocalityProvider { locality_columns: [ps_partkey] }
                │           └─StreamExchange { dist: HashShard(ps_partkey) }
                │             └─StreamFilter { predicate: IsNotNull(ps_suppkey) }
                │               └─StreamRowIdGen { row_id_index: 5 }
                │                 └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                └─StreamExchange { dist: HashShard(l_partkey, l_suppkey, l_partkey, s_suppkey) }
                  └─StreamLocalityProvider { locality_columns: [l_partkey, l_suppkey, l_partkey, s_suppkey] }
                    └─StreamExchange { dist: HashShard(s_suppkey, l_partkey, l_suppkey) }
                      └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey] }
                        ├─StreamExchange { dist: HashShard(s_suppkey) }
                        │ └─StreamLocalityProvider { locality_columns: [s_suppkey] }
                        │   └─StreamExchange { dist: HashShard(s_suppkey) }
                        │     └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                        │       ├─StreamExchange { dist: HashShard(n_nationkey) }
                        │       │ └─StreamLocalityProvider { locality_columns: [n_nationkey] }
                        │       │   └─StreamExchange { dist: HashShard(n_nationkey) }
                        │       │     └─StreamRowIdGen { row_id_index: 4 }
                        │       │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                        │       └─StreamExchange { dist: HashShard(s_nationkey) }
                        │         └─StreamLocalityProvider { locality_columns: [s_nationkey] }
                        │           └─StreamExchange { dist: HashShard(s_nationkey) }
                        │             └─StreamRowIdGen { row_id_index: 7 }
                        │               └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                        └─StreamExchange { dist: HashShard(l_suppkey) }
                          └─StreamLocalityProvider { locality_columns: [l_suppkey] }
                            └─StreamExchange { dist: HashShard(l_suppkey) }
                              └─StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id] }
                                ├─StreamExchange { dist: HashShard(o_orderkey) }
                                │ └─StreamLocalityProvider { locality_columns: [o_orderkey] }
                                │   └─StreamExchange { dist: HashShard(o_orderkey) }
                                │     └─StreamRowIdGen { row_id_index: 9 }
                                │       └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                                └─StreamExchange { dist: HashShard(l_orderkey) }
                                  └─StreamLocalityProvider { locality_columns: [l_orderkey] }
                                    └─StreamExchange { dist: HashShard(l_orderkey) }
                                      └─StreamFilter { predicate: IsNotNull(l_partkey) }
                                        └─StreamRowIdGen { row_id_index: 16 }
                                          └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [nation, o_year, sum_profit], stream_key: [nation, o_year], pk_columns: [nation, o_year], pk_conflict: NoCheck }
    └── StreamProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
        └── StreamHashAgg [append_only] { group_key: [n_name, $expr1], aggs: [sum($expr2), count] } { tables: [ HashAggState: 0 ] }
            └── StreamLocalityProvider { locality_columns: [n_name, $expr1] }
                ├── tables: [ LocalityProviderState: 1, LocalityProviderProgress: 2 ]
                └── StreamExchange Hash([0, 1]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2, _row_id, _row_id, p_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, ps_suppkey, ps_partkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey AND ps_suppkey = l_suppkey AND ps_partkey = l_partkey AND ps_suppkey = s_suppkey, output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name, _row_id, _row_id, p_partkey, ps_suppkey, ps_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
        ├── tables: [ HashJoinLeft: 3, HashJoinDegreeLeft: 4, HashJoinRight: 5, HashJoinDegreeRight: 6 ]
        ├── StreamExchange Hash([0, 2, 1, 2]) from 2
        └── StreamExchange Hash([3, 4, 3, 1]) from 8

    Fragment 2
    StreamLocalityProvider { locality_columns: [p_partkey, ps_suppkey, ps_partkey, ps_suppkey] } { tables: [ LocalityProviderState: 7, LocalityProviderProgress: 8 ] }
    └── StreamExchange Hash([0, 1, 2]) from 3

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id] } { tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ] }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([0]) from 6

    Fragment 4
    StreamLocalityProvider { locality_columns: [p_partkey] } { tables: [ LocalityProviderState: 13, LocalityProviderProgress: 14 ] }
    └── StreamExchange Hash([0]) from 5

    Fragment 5
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { tables: [ Source: 15 ] }

    Fragment 6
    StreamLocalityProvider { locality_columns: [ps_partkey] } { tables: [ LocalityProviderState: 16, LocalityProviderProgress: 17 ] }
    └── StreamExchange Hash([0]) from 7

    Fragment 7
    StreamFilter { predicate: IsNotNull(ps_suppkey) }
    └── StreamRowIdGen { row_id_index: 5 }
        └── StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] } { tables: [ Source: 18 ] }

    Fragment 8
    StreamLocalityProvider { locality_columns: [l_partkey, l_suppkey, l_partkey, s_suppkey] } { tables: [ LocalityProviderState: 19, LocalityProviderProgress: 20 ] }
    └── StreamExchange Hash([1, 3, 4]) from 9

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey] } { tables: [ HashJoinLeft: 21, HashJoinDegreeLeft: 22, HashJoinRight: 23, HashJoinDegreeRight: 24 ] }
    ├── StreamExchange Hash([1]) from 10
    └── StreamExchange Hash([2]) from 16

    Fragment 10
    StreamLocalityProvider { locality_columns: [s_suppkey] } { tables: [ LocalityProviderState: 25, LocalityProviderProgress: 26 ] }
    └── StreamExchange Hash([1]) from 11

    Fragment 11
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 27, HashJoinDegreeLeft: 28, HashJoinRight: 29, HashJoinDegreeRight: 30 ] }
    ├── StreamExchange Hash([0]) from 12
    └── StreamExchange Hash([3]) from 14

    Fragment 12
    StreamLocalityProvider { locality_columns: [n_nationkey] } { tables: [ LocalityProviderState: 31, LocalityProviderProgress: 32 ] }
    └── StreamExchange Hash([0]) from 13

    Fragment 13
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 33 ] }

    Fragment 14
    StreamLocalityProvider { locality_columns: [s_nationkey] } { tables: [ LocalityProviderState: 34, LocalityProviderProgress: 35 ] }
    └── StreamExchange Hash([3]) from 15

    Fragment 15
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 36 ] }

    Fragment 16
    StreamLocalityProvider { locality_columns: [l_suppkey] } { tables: [ LocalityProviderState: 37, LocalityProviderProgress: 38 ] }
    └── StreamExchange Hash([2]) from 17

    Fragment 17
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id] } { tables: [ HashJoinLeft: 39, HashJoinDegreeLeft: 40, HashJoinRight: 41, HashJoinDegreeRight: 42 ] }
    ├── StreamExchange Hash([0]) from 18
    └── StreamExchange Hash([0]) from 20

    Fragment 18
    StreamLocalityProvider { locality_columns: [o_orderkey] } { tables: [ LocalityProviderState: 43, LocalityProviderProgress: 44 ] }
    └── StreamExchange Hash([0]) from 19

    Fragment 19
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 45 ] }

    Fragment 20
    StreamLocalityProvider { locality_columns: [l_orderkey] } { tables: [ LocalityProviderState: 46, LocalityProviderProgress: 47 ] }
    └── StreamExchange Hash([0]) from 21

    Fragment 21
    StreamFilter { predicate: IsNotNull(l_partkey) }
    └── StreamRowIdGen { row_id_index: 16 }
        └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] } { tables: [ Source: 48 ] }

    Table 0 { columns: [ n_name, $expr1, sum($expr2), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 1
    ├── columns: [ n_name, $expr1, $expr2, _row_id, _row_id_0, p_partkey, _row_id_1, _row_id_2, n_nationkey, _row_id_3, _row_id_4, o_orderkey, ps_suppkey, ps_partkey, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $5 ASC, $12 ASC, $13 ASC, $12 ASC, $3 ASC, $4 ASC, $8 ASC, $6 ASC, $7 ASC, $11 ASC, $9 ASC, $10 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 0, 1 ]
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, n_name, $expr1, p_partkey, ps_suppkey, ps_partkey, ps_suppkey_0, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, _row_id_3, _row_id_4, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3 { columns: [ p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $2 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0, 2, 1, 2 ], read pk prefix len hint: 4 }

    Table 4 { columns: [ p_partkey, ps_suppkey, ps_partkey, ps_suppkey_0, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0, 1, 2, 3 ], read pk prefix len hint: 4 }

    Table 5
    ├── columns: [ n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC, $3 ASC, $1 ASC, $10 ASC, $8 ASC, $9 ASC, $13 ASC, $11 ASC, $12 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 3, 4, 3, 1 ]
    └── read pk prefix len hint: 4

    Table 6 { columns: [ l_partkey, l_suppkey, l_partkey_0, s_suppkey, n_nationkey, _row_id, _row_id_0, o_orderkey, _row_id_1, _row_id_2, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 0, 1, 2, 3 ], read pk prefix len hint: 4 }

    Table 7 { columns: [ p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $2 ASC, $0 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 0 }

    Table 8 { columns: [ vnode, p_partkey, ps_suppkey, ps_partkey, ps_suppkey_0, p_partkey_0, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 9 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ p_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ ps_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 14 { columns: [ vnode, p_partkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 15 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 16 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 17 { columns: [ vnode, ps_partkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 18 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 19
    ├── columns: [ n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC, $3 ASC, $1 ASC, $1 ASC, $10 ASC, $8 ASC, $9 ASC, $13 ASC, $11 ASC, $12 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 1, 3, 4 ]
    └── read pk prefix len hint: 0

    Table 20 { columns: [ vnode, l_partkey, l_suppkey, l_partkey_0, s_suppkey, s_suppkey_0, n_nationkey, _row_id, _row_id_0, o_orderkey, _row_id_1, _row_id_2, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 21 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ s_suppkey, n_nationkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id_0, _rw_timestamp ], primary key: [ $2 ASC, $7 ASC, $6 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ l_suppkey, o_orderkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 26 { columns: [ vnode, s_suppkey, n_nationkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 27 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 29 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 31 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 32 { columns: [ vnode, n_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 33 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 34 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 0 }

    Table 35 { columns: [ vnode, s_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 36 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 37 { columns: [ o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id_0, _rw_timestamp ], primary key: [ $2 ASC, $7 ASC, $6 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 2 ], read pk prefix len hint: 0 }

    Table 38 { columns: [ vnode, l_suppkey, o_orderkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 39 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 40 { columns: [ o_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 41
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 42 { columns: [ l_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 43 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 44 { columns: [ vnode, o_orderkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 45 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 46
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 0

    Table 47 { columns: [ vnode, l_orderkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 48 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ nation, o_year, sum_profit, _rw_timestamp ], primary key: [ $0 ASC, $1 DESC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

- id: tpch_q20
  before:
  - create_tables
  sql: |
    select
      s_name,
      s_address
    from
      supplier,
      nation
    where
      s_suppkey in (
        select
          ps_suppkey
        from
          partsupp
        where
          ps_partkey in (
            select
              p_partkey
            from
              part
          )
          and ps_availqty > (
            select
              0.5 * sum(l_quantity)
            from
              lineitem
            where
              l_partkey = ps_partkey
              and l_suppkey = ps_suppkey
          )
      )
      and s_nationkey = n_nationkey
    order by
      s_name;
  logical_plan: |-
    LogicalProject { exprs: [s_name, s_address] }
    └─LogicalFilter { predicate: (s_nationkey = n_nationkey) }
      └─LogicalApply { type: LeftSemi, on: (s_suppkey = ps_suppkey), correlated_id: 1 }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─LogicalProject { exprs: [ps_suppkey] }
          └─LogicalFilter { predicate: (ps_availqty::Decimal > $expr1) }
            └─LogicalApply { type: LeftOuter, on: true, correlated_id: 3, max_one_row: true }
              ├─LogicalApply { type: LeftSemi, on: (ps_partkey = p_partkey), correlated_id: 2 }
              │ ├─LogicalSource { source: partsupp, is_shared: false, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
              │ └─LogicalProject { exprs: [p_partkey] }
              │   └─LogicalSource { source: part, is_shared: false, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
              └─LogicalProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr1] }
                └─LogicalAgg { aggs: [sum(l_quantity)] }
                  └─LogicalProject { exprs: [l_quantity] }
                    └─LogicalFilter { predicate: (l_partkey = CorrelatedInputRef { index: 0, correlated_id: 3 }) AND (l_suppkey = CorrelatedInputRef { index: 1, correlated_id: 3 }) }
                      └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (s_suppkey = ps_suppkey), output: [s_name, s_address] }
    ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [s_suppkey, s_name, s_address] }
    │ ├─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
    └─LogicalJoin { type: Inner, on: (ps_partkey = l_partkey) AND (ps_suppkey = l_suppkey) AND ($expr1 > $expr2), output: [ps_suppkey] }
      ├─LogicalProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1] }
      │ └─LogicalJoin { type: LeftSemi, on: (ps_partkey = p_partkey), output: [ps_partkey, ps_suppkey, ps_availqty] }
      │   ├─LogicalSource { source: partsupp, is_shared: false, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
      │   └─LogicalProject { exprs: [p_partkey] }
      │     └─LogicalSource { source: part, is_shared: false, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
      └─LogicalProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr2, l_partkey, l_suppkey] }
        └─LogicalAgg { group_key: [l_partkey, l_suppkey], aggs: [sum(l_quantity)] }
          └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [s_name ASC], dist: Single }
    └─BatchSort { order: [s_name ASC] }
      └─BatchHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address] }
        ├─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address] }
        │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │   │ └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
          └─BatchHashJoin { type: Inner, predicate: ps_partkey = l_partkey AND ps_suppkey = l_suppkey AND ($expr1 > $expr2), output: [ps_suppkey] }
            ├─BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
            │ └─BatchProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1] }
            │   └─BatchHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty] }
            │     ├─BatchExchange { order: [], dist: HashShard(ps_partkey) }
            │     │ └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
            │     └─BatchExchange { order: [], dist: HashShard(p_partkey) }
            │       └─BatchProject { exprs: [p_partkey] }
            │         └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
            └─BatchProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr2, l_partkey, l_suppkey] }
              └─BatchHashAgg { group_key: [l_partkey, l_suppkey], aggs: [sum(l_quantity)] }
                └─BatchExchange { order: [], dist: HashShard(l_partkey, l_suppkey) }
                  └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden), s_nationkey(hidden), s_suppkey(hidden)], stream_key: [s_suppkey, s_nationkey, _row_id, _row_id#1], pk_columns: [s_name, s_suppkey, s_nationkey, _row_id, _row_id#1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(_row_id, _row_id, s_nationkey, s_suppkey) }
      └─StreamHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address, _row_id, _row_id, s_nationkey, s_suppkey] }
        ├─StreamExchange { dist: HashShard(s_suppkey) }
        │ └─StreamLocalityProvider { locality_columns: [s_suppkey] }
        │   └─StreamExchange { dist: HashShard(s_suppkey) }
        │     └─StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id] }
        │       ├─StreamExchange { dist: HashShard(s_nationkey) }
        │       │ └─StreamLocalityProvider { locality_columns: [s_nationkey] }
        │       │   └─StreamExchange { dist: HashShard(s_nationkey) }
        │       │     └─StreamRowIdGen { row_id_index: 7 }
        │       │       └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │       └─StreamExchange { dist: HashShard(n_nationkey) }
        │         └─StreamLocalityProvider { locality_columns: [n_nationkey] }
        │           └─StreamExchange { dist: HashShard(n_nationkey) }
        │             └─StreamRowIdGen { row_id_index: 4 }
        │               └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─StreamExchange { dist: HashShard(ps_suppkey) }
          └─StreamLocalityProvider { locality_columns: [ps_suppkey] }
            └─StreamExchange { dist: HashShard(ps_suppkey) }
              └─StreamProject { exprs: [ps_suppkey, _row_id, ps_partkey, l_partkey, l_suppkey] }
                └─StreamFilter { predicate: ($expr1 > $expr2) }
                  └─StreamHashJoin { type: Inner, predicate: ps_partkey = l_partkey AND ps_suppkey = l_suppkey, output: all }
                    ├─StreamExchange { dist: HashShard(ps_partkey, ps_suppkey) }
                    │ └─StreamLocalityProvider { locality_columns: [ps_partkey, ps_suppkey] }
                    │   └─StreamExchange { dist: HashShard(ps_partkey, ps_suppkey) }
                    │     └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1, _row_id] }
                    │       └─StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] }
                    │         ├─StreamExchange { dist: HashShard(ps_partkey) }
                    │         │ └─StreamLocalityProvider { locality_columns: [ps_partkey] }
                    │         │   └─StreamExchange { dist: HashShard(ps_partkey) }
                    │         │     └─StreamRowIdGen { row_id_index: 5 }
                    │         │       └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                    │         └─StreamExchange { dist: HashShard(p_partkey) }
                    │           └─StreamLocalityProvider { locality_columns: [p_partkey] }
                    │             └─StreamExchange { dist: HashShard(p_partkey) }
                    │               └─StreamProject { exprs: [p_partkey, _row_id] }
                    │                 └─StreamRowIdGen { row_id_index: 9 }
                    │                   └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                    └─StreamExchange { dist: HashShard(l_partkey, l_suppkey) }
                      └─StreamLocalityProvider { locality_columns: [l_partkey, l_suppkey] }
                        └─StreamExchange [no_shuffle] { dist: UpstreamHashShard(l_partkey, l_suppkey) }
                          └─StreamProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr2, l_partkey, l_suppkey] }
                            └─StreamHashAgg [append_only] { group_key: [l_partkey, l_suppkey], aggs: [sum(l_quantity), count] }
                              └─StreamLocalityProvider { locality_columns: [l_partkey, l_suppkey] }
                                └─StreamExchange { dist: HashShard(l_partkey, l_suppkey) }
                                  └─StreamRowIdGen { row_id_index: 16 }
                                    └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden), s_nationkey(hidden), s_suppkey(hidden)], stream_key: [s_suppkey, s_nationkey, _row_id, _row_id#1], pk_columns: [s_name, s_suppkey, s_nationkey, _row_id, _row_id#1], pk_conflict: NoCheck }
    └── StreamExchange Hash([2, 3, 4, 5]) from 1

    Fragment 1
    StreamHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address, _row_id, _row_id, s_nationkey, s_suppkey] } { tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ] }
    ├── StreamExchange Hash([0]) from 2
    └── StreamExchange Hash([0]) from 8

    Fragment 2
    StreamLocalityProvider { locality_columns: [s_suppkey] } { tables: [ LocalityProviderState: 4, LocalityProviderProgress: 5 ] }
    └── StreamExchange Hash([0]) from 3

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id] } { tables: [ HashJoinLeft: 6, HashJoinDegreeLeft: 7, HashJoinRight: 8, HashJoinDegreeRight: 9 ] }
    ├── StreamExchange Hash([3]) from 4
    └── StreamExchange Hash([0]) from 6

    Fragment 4
    StreamLocalityProvider { locality_columns: [s_nationkey] } { tables: [ LocalityProviderState: 10, LocalityProviderProgress: 11 ] }
    └── StreamExchange Hash([3]) from 5

    Fragment 5
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 12 ] }

    Fragment 6
    StreamLocalityProvider { locality_columns: [n_nationkey] } { tables: [ LocalityProviderState: 13, LocalityProviderProgress: 14 ] }
    └── StreamExchange Hash([0]) from 7

    Fragment 7
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 15 ] }

    Fragment 8
    StreamLocalityProvider { locality_columns: [ps_suppkey] } { tables: [ LocalityProviderState: 16, LocalityProviderProgress: 17 ] }
    └── StreamExchange Hash([0]) from 9

    Fragment 9
    StreamProject { exprs: [ps_suppkey, _row_id, ps_partkey, l_partkey, l_suppkey] }
    └── StreamFilter { predicate: ($expr1 > $expr2) }
        └── StreamHashJoin { type: Inner, predicate: ps_partkey = l_partkey AND ps_suppkey = l_suppkey, output: all } { tables: [ HashJoinLeft: 18, HashJoinDegreeLeft: 19, HashJoinRight: 20, HashJoinDegreeRight: 21 ] }
            ├── StreamExchange Hash([0, 1]) from 10
            └── StreamExchange Hash([1, 2]) from 16

    Fragment 10
    StreamLocalityProvider { locality_columns: [ps_partkey, ps_suppkey] } { tables: [ LocalityProviderState: 22, LocalityProviderProgress: 23 ] }
    └── StreamExchange Hash([0, 1]) from 11

    Fragment 11
    StreamProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1, _row_id] }
    └── StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] } { tables: [ HashJoinLeft: 24, HashJoinDegreeLeft: 25, HashJoinRight: 26, HashJoinDegreeRight: 27 ] }
        ├── StreamExchange Hash([0]) from 12
        └── StreamExchange Hash([0]) from 14

    Fragment 12
    StreamLocalityProvider { locality_columns: [ps_partkey] } { tables: [ LocalityProviderState: 28, LocalityProviderProgress: 29 ] }
    └── StreamExchange Hash([0]) from 13

    Fragment 13
    StreamRowIdGen { row_id_index: 5 }
    └── StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] } { tables: [ Source: 30 ] }

    Fragment 14
    StreamLocalityProvider { locality_columns: [p_partkey] } { tables: [ LocalityProviderState: 31, LocalityProviderProgress: 32 ] }
    └── StreamExchange Hash([0]) from 15

    Fragment 15
    StreamProject { exprs: [p_partkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 9 }
        └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { tables: [ Source: 33 ] }

    Fragment 16
    StreamLocalityProvider { locality_columns: [l_partkey, l_suppkey] } { tables: [ LocalityProviderState: 34, LocalityProviderProgress: 35 ] }
    └── StreamExchange NoShuffle from 17

    Fragment 17
    StreamProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr2, l_partkey, l_suppkey] }
    └── StreamHashAgg [append_only] { group_key: [l_partkey, l_suppkey], aggs: [sum(l_quantity), count] } { tables: [ HashAggState: 36 ] }
        └── StreamLocalityProvider { locality_columns: [l_partkey, l_suppkey] } { tables: [ LocalityProviderState: 37, LocalityProviderProgress: 38 ] }
            └── StreamExchange Hash([1, 2]) from 18

    Fragment 18
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
        └── tables: [ Source: 39 ]

    Table 0 { columns: [ s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC, $3 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ s_suppkey, s_nationkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ ps_suppkey, _row_id, ps_partkey, l_partkey, l_suppkey, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ ps_suppkey, ps_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC, $3 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 5 { columns: [ vnode, s_suppkey, s_nationkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 6 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 0 }

    Table 11 { columns: [ vnode, s_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 12 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 13 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 14 { columns: [ vnode, n_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 15 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 16 { columns: [ ps_suppkey, _row_id, ps_partkey, l_partkey, l_suppkey, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $0 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 17 { columns: [ vnode, ps_suppkey, ps_partkey, ps_suppkey_0, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 18 { columns: [ ps_partkey, ps_suppkey, $expr1, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 19 { columns: [ ps_partkey, ps_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 20 { columns: [ $expr2, l_partkey, l_suppkey, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1, 2 ], read pk prefix len hint: 2 }

    Table 21 { columns: [ l_partkey, l_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 22 { columns: [ ps_partkey, ps_suppkey, $expr1, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 0 }

    Table 23 { columns: [ vnode, ps_partkey, ps_suppkey, ps_partkey_0, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 24 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ ps_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 26 { columns: [ p_partkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ p_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 29 { columns: [ vnode, ps_partkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 30 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 31 { columns: [ p_partkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 32 { columns: [ vnode, p_partkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 33 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 34 { columns: [ $expr2, l_partkey, l_suppkey, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1, 2 ], read pk prefix len hint: 0 }

    Table 35 { columns: [ vnode, l_partkey, l_suppkey, l_partkey_0, l_suppkey_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 36 { columns: [ l_partkey, l_suppkey, sum(l_quantity), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 37
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 1, 2 ]
    └── read pk prefix len hint: 0

    Table 38 { columns: [ vnode, l_partkey, l_suppkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 39 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_name, s_address, _row_id, _row_id#1, s_nationkey, s_suppkey, _rw_timestamp ], primary key: [ $0 ASC, $5 ASC, $4 ASC, $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2, 3, 4, 5 ], read pk prefix len hint: 5 }

- id: tpch_q21
  before:
  - create_tables
  sql: |
    select
      s_name,
      count(*) as numwait
    from
      supplier,
      lineitem l1,
      orders,
      nation
    where
      s_suppkey = l1.l_suppkey
      and o_orderkey = l1.l_orderkey
      and l1.l_receiptdate > l1.l_commitdate
      and exists (
        select
          *
        from
          lineitem l2
        where
          l2.l_orderkey = l1.l_orderkey
          and l2.l_suppkey <> l1.l_suppkey
      )
      and not exists (
        select
          *
        from
          lineitem l3
        where
          l3.l_orderkey = l1.l_orderkey
          and l3.l_suppkey <> l1.l_suppkey
          and l3.l_receiptdate > l3.l_commitdate
      )
      and s_nationkey = n_nationkey
    group by
      s_name
    order by
      numwait desc,
      s_name;
  logical_plan: |-
    LogicalProject { exprs: [s_name, count] }
    └─LogicalAgg { group_key: [s_name], aggs: [count] }
      └─LogicalProject { exprs: [s_name] }
        └─LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (o_orderkey = l_orderkey) AND (l_receiptdate > l_commitdate) AND (s_nationkey = n_nationkey) }
          └─LogicalApply { type: LeftAnti, on: true, correlated_id: 2 }
            ├─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │ │ │ │ └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            │ │ │ └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
            │ │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            │ └─LogicalProject { exprs: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
            │   └─LogicalFilter { predicate: (l_orderkey = CorrelatedInputRef { index: 8, correlated_id: 1 }) AND (l_suppkey <> CorrelatedInputRef { index: 10, correlated_id: 1 }) }
            │     └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            └─LogicalProject { exprs: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
              └─LogicalFilter { predicate: (l_orderkey = CorrelatedInputRef { index: 8, correlated_id: 2 }) AND (l_suppkey <> CorrelatedInputRef { index: 10, correlated_id: 2 }) AND (l_receiptdate > l_commitdate) }
                └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [s_name], aggs: [count] }
    └─LogicalJoin { type: LeftAnti, on: (l_orderkey = l_orderkey) AND (l_suppkey <> l_suppkey), output: [s_name] }
      ├─LogicalJoin { type: LeftSemi, on: (l_orderkey = l_orderkey) AND (l_suppkey <> l_suppkey), output: all }
      │ ├─LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [s_name, l_orderkey, l_suppkey] }
      │ │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [s_name, l_orderkey, l_suppkey] }
      │ │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [s_name, s_nationkey, l_orderkey, l_suppkey] }
      │ │ │ │ ├─LogicalSource { source: supplier, is_shared: false, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
      │ │ │ │ └─LogicalFilter { predicate: (l_receiptdate > l_commitdate) }
      │ │ │ │   └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
      │ │ │ └─LogicalSource { source: nation, is_shared: false, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
      │ │ └─LogicalSource { source: orders, is_shared: false, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
      │ └─LogicalProject { exprs: [l_orderkey, l_suppkey] }
      │   └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
      └─LogicalProject { exprs: [l_orderkey, l_suppkey] }
        └─LogicalFilter { predicate: (l_receiptdate > l_commitdate) }
          └─LogicalSource { source: lineitem, is_shared: false, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [count DESC, s_name ASC], dist: Single }
    └─BatchSort { order: [count DESC, s_name ASC] }
      └─BatchHashAgg { group_key: [s_name], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(s_name) }
          └─BatchHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name] }
            ├─BatchHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: all }
            │ ├─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [s_name, l_orderkey, l_suppkey] }
            │ │ ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
            │ │ │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_name, l_orderkey, l_suppkey] }
            │ │ │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
            │ │ │   │ └─BatchHashJoin { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, s_nationkey, l_orderkey, l_suppkey] }
            │ │ │   │   ├─BatchExchange { order: [], dist: HashShard(s_suppkey) }
            │ │ │   │   │ └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │ │ │   │   └─BatchExchange { order: [], dist: HashShard(l_suppkey) }
            │ │ │   │     └─BatchFilter { predicate: (l_receiptdate > l_commitdate) }
            │ │ │   │       └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            │ │ │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
            │ │ │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            │ │ └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
            │ │   └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
            │ └─BatchExchange { order: [], dist: HashShard(l_orderkey) }
            │   └─BatchProject { exprs: [l_orderkey, l_suppkey] }
            │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            └─BatchExchange { order: [], dist: HashShard(l_orderkey) }
              └─BatchProject { exprs: [l_orderkey, l_suppkey] }
                └─BatchFilter { predicate: (l_receiptdate > l_commitdate) }
                  └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: NoCheck }
    └─StreamHashAgg { group_key: [s_name], aggs: [count] }
      └─StreamLocalityProvider { locality_columns: [s_name] }
        └─StreamExchange { dist: HashShard(s_name) }
          └─StreamHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, l_orderkey] }
            ├─StreamExchange { dist: HashShard(l_orderkey) }
            │ └─StreamLocalityProvider { locality_columns: [l_orderkey] }
            │   └─StreamExchange [no_shuffle] { dist: HashShard(l_orderkey) }
            │     └─StreamHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
            │       ├─StreamExchange { dist: HashShard(l_orderkey) }
            │       │ └─StreamLocalityProvider { locality_columns: [l_orderkey] }
            │       │   └─StreamExchange { dist: HashShard(l_orderkey) }
            │       │     └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, o_orderkey] }
            │       │       ├─StreamExchange { dist: HashShard(s_suppkey) }
            │       │       │ └─StreamLocalityProvider { locality_columns: [s_suppkey] }
            │       │       │   └─StreamExchange { dist: HashShard(s_suppkey) }
            │       │       │     └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [s_suppkey, s_name, _row_id, n_nationkey, _row_id] }
            │       │       │       ├─StreamExchange { dist: HashShard(n_nationkey) }
            │       │       │       │ └─StreamLocalityProvider { locality_columns: [n_nationkey] }
            │       │       │       │   └─StreamExchange { dist: HashShard(n_nationkey) }
            │       │       │       │     └─StreamRowIdGen { row_id_index: 4 }
            │       │       │       │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            │       │       │       └─StreamExchange { dist: HashShard(s_nationkey) }
            │       │       │         └─StreamLocalityProvider { locality_columns: [s_nationkey] }
            │       │       │           └─StreamExchange { dist: HashShard(s_nationkey) }
            │       │       │             └─StreamRowIdGen { row_id_index: 7 }
            │       │       │               └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │       │       └─StreamExchange { dist: HashShard(l_suppkey) }
            │       │         └─StreamLocalityProvider { locality_columns: [l_suppkey] }
            │       │           └─StreamExchange { dist: HashShard(l_suppkey) }
            │       │             └─StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id] }
            │       │               ├─StreamExchange { dist: HashShard(o_orderkey) }
            │       │               │ └─StreamLocalityProvider { locality_columns: [o_orderkey] }
            │       │               │   └─StreamExchange { dist: HashShard(o_orderkey) }
            │       │               │     └─StreamRowIdGen { row_id_index: 9 }
            │       │               │       └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
            │       │               └─StreamExchange { dist: HashShard(l_orderkey) }
            │       │                 └─StreamLocalityProvider { locality_columns: [l_orderkey] }
            │       │                   └─StreamExchange { dist: HashShard(l_orderkey) }
            │       │                     └─StreamFilter { predicate: (l_receiptdate > l_commitdate) }
            │       │                       └─StreamShare { id: 19 }
            │       │                         └─StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
            │       │                           └─StreamRowIdGen { row_id_index: 16 }
            │       │                             └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            │       └─StreamExchange { dist: HashShard(l_orderkey) }
            │         └─StreamLocalityProvider { locality_columns: [l_orderkey] }
            │           └─StreamExchange { dist: HashShard(l_orderkey) }
            │             └─StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
            │               └─StreamShare { id: 19 }
            │                 └─StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
            │                   └─StreamRowIdGen { row_id_index: 16 }
            │                     └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            └─StreamExchange { dist: HashShard(l_orderkey) }
              └─StreamLocalityProvider { locality_columns: [l_orderkey] }
                └─StreamExchange { dist: HashShard(l_orderkey) }
                  └─StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
                    └─StreamFilter { predicate: (l_receiptdate > l_commitdate) }
                      └─StreamShare { id: 19 }
                        └─StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
                          └─StreamRowIdGen { row_id_index: 16 }
                            └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: NoCheck }
    └── StreamHashAgg { group_key: [s_name], aggs: [count] } { tables: [ HashAggState: 0 ] }
        └── StreamLocalityProvider { locality_columns: [s_name] }
            ├── tables: [ LocalityProviderState: 1, LocalityProviderProgress: 2 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, l_orderkey] }
    ├── tables: [ HashJoinLeft: 3, HashJoinDegreeLeft: 4, HashJoinRight: 5, HashJoinDegreeRight: 6 ]
    ├── StreamExchange Hash([1]) from 2
    └── StreamExchange Hash([0]) from 21

    Fragment 2
    StreamLocalityProvider { locality_columns: [l_orderkey] } { tables: [ LocalityProviderState: 7, LocalityProviderProgress: 8 ] }
    └── StreamExchange NoShuffle from 3

    Fragment 3
    StreamHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
    ├── tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ]
    ├── StreamExchange Hash([1]) from 4
    └── StreamExchange Hash([0]) from 19

    Fragment 4
    StreamLocalityProvider { locality_columns: [l_orderkey] } { tables: [ LocalityProviderState: 13, LocalityProviderProgress: 14 ] }
    └── StreamExchange Hash([1]) from 5

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, o_orderkey] }
    ├── tables: [ HashJoinLeft: 15, HashJoinDegreeLeft: 16, HashJoinRight: 17, HashJoinDegreeRight: 18 ]
    ├── StreamExchange Hash([0]) from 6
    └── StreamExchange Hash([1]) from 12

    Fragment 6
    StreamLocalityProvider { locality_columns: [s_suppkey] } { tables: [ LocalityProviderState: 19, LocalityProviderProgress: 20 ] }
    └── StreamExchange Hash([0]) from 7

    Fragment 7
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [s_suppkey, s_name, _row_id, n_nationkey, _row_id] }
    ├── tables: [ HashJoinLeft: 21, HashJoinDegreeLeft: 22, HashJoinRight: 23, HashJoinDegreeRight: 24 ]
    ├── StreamExchange Hash([0]) from 8
    └── StreamExchange Hash([3]) from 10

    Fragment 8
    StreamLocalityProvider { locality_columns: [n_nationkey] } { tables: [ LocalityProviderState: 25, LocalityProviderProgress: 26 ] }
    └── StreamExchange Hash([0]) from 9

    Fragment 9
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 27 ] }

    Fragment 10
    StreamLocalityProvider { locality_columns: [s_nationkey] } { tables: [ LocalityProviderState: 28, LocalityProviderProgress: 29 ] }
    └── StreamExchange Hash([3]) from 11

    Fragment 11
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 30 ] }

    Fragment 12
    StreamLocalityProvider { locality_columns: [l_suppkey] } { tables: [ LocalityProviderState: 31, LocalityProviderProgress: 32 ] }
    └── StreamExchange Hash([1]) from 13

    Fragment 13
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id] }
    ├── tables: [ HashJoinLeft: 33, HashJoinDegreeLeft: 34, HashJoinRight: 35, HashJoinDegreeRight: 36 ]
    ├── StreamExchange Hash([0]) from 14
    └── StreamExchange Hash([0]) from 16

    Fragment 14
    StreamLocalityProvider { locality_columns: [o_orderkey] } { tables: [ LocalityProviderState: 37, LocalityProviderProgress: 38 ] }
    └── StreamExchange Hash([0]) from 15

    Fragment 15
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 39 ] }

    Fragment 16
    StreamLocalityProvider { locality_columns: [l_orderkey] } { tables: [ LocalityProviderState: 40, LocalityProviderProgress: 41 ] }
    └── StreamExchange Hash([0]) from 17

    Fragment 17
    StreamFilter { predicate: (l_receiptdate > l_commitdate) }
    └── StreamExchange NoShuffle from 18

    Fragment 18
    StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
    └── StreamRowIdGen { row_id_index: 16 }
        └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            └── tables: [ Source: 42 ]

    Fragment 19
    StreamLocalityProvider { locality_columns: [l_orderkey] } { tables: [ LocalityProviderState: 43, LocalityProviderProgress: 44 ] }
    └── StreamExchange Hash([0]) from 20

    Fragment 20
    StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
    └── StreamExchange NoShuffle from 18

    Fragment 21
    StreamLocalityProvider { locality_columns: [l_orderkey] } { tables: [ LocalityProviderState: 45, LocalityProviderProgress: 46 ] }
    └── StreamExchange Hash([0]) from 22

    Fragment 22
    StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
    └── StreamFilter { predicate: (l_receiptdate > l_commitdate) }
        └── StreamExchange NoShuffle from 18

    Table 0 { columns: [ s_name, count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ s_name, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, l_orderkey, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $8 ASC, $7 ASC, $3 ASC, $1 ASC, $2 ASC, $6 ASC, $4 ASC, $5 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, s_name, l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, o_orderkey, _row_id_1, _row_id_2, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $9 ASC, $5 ASC, $3 ASC, $4 ASC, $8 ASC, $6 ASC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 4
    ├── columns: [ l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, o_orderkey, _row_id_1, _row_id_2, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ]
    ├── value indices: [ 8 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 5 { columns: [ l_orderkey, l_suppkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ l_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $1 ASC, $9 ASC, $5 ASC, $3 ASC, $4 ASC, $8 ASC, $6 ASC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 0

    Table 8
    ├── columns: [ vnode, l_orderkey, l_orderkey_0, s_suppkey, n_nationkey, _row_id, _row_id_0, o_orderkey, _row_id_1, _row_id_2, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 9
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, o_orderkey, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $6 ASC, $5 ASC, $3 ASC, $4 ASC, $9 ASC, $7 ASC, $8 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 10
    ├── columns: [ l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, o_orderkey, _row_id_1, _row_id_2, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ]
    ├── value indices: [ 8 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 11 { columns: [ l_orderkey, l_suppkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ l_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, o_orderkey, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $6 ASC, $5 ASC, $3 ASC, $4 ASC, $9 ASC, $7 ASC, $8 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 0

    Table 14
    ├── columns: [ vnode, l_orderkey, s_suppkey, n_nationkey, _row_id, _row_id_0, o_orderkey, _row_id_1, _row_id_2, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 15 { columns: [ s_suppkey, s_name, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ s_suppkey, n_nationkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ l_suppkey, o_orderkey, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ s_suppkey, s_name, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 20 { columns: [ vnode, s_suppkey, n_nationkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 21 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 26 { columns: [ vnode, n_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 27 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 28 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 0 }

    Table 29 { columns: [ vnode, s_nationkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 30 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 31 { columns: [ l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 0 }

    Table 32 { columns: [ vnode, l_suppkey, o_orderkey, _row_id, _row_id_0, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 33
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 34 { columns: [ o_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 35 { columns: [ l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 36 { columns: [ l_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 37
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 0

    Table 38 { columns: [ vnode, o_orderkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 39 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 40 { columns: [ l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 41 { columns: [ vnode, l_orderkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 42 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 43 { columns: [ l_orderkey, l_suppkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 44 { columns: [ vnode, l_orderkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 45 { columns: [ l_orderkey, l_suppkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 0 }

    Table 46 { columns: [ vnode, l_orderkey, _row_id, backfill_finished, row_count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1, vnode column idx: 0 }

    Table 4294967294 { columns: [ s_name, numwait, _rw_timestamp ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

