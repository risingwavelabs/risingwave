# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    CREATE SOURCE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR,
            s_address VARCHAR,
            s_nationkey INTEGER,
            s_phone VARCHAR,
            s_acctbal NUMERIC,
            s_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE part (
            p_partkey INTEGER,
            p_name VARCHAR,
            p_mfgr VARCHAR,
            p_brand VARCHAR,
            p_type VARCHAR,
            p_size INTEGER,
            p_container VARCHAR,
            p_retailprice NUMERIC,
            p_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE customer (
            c_custkey INTEGER,
            c_name VARCHAR,
            c_address VARCHAR,
            c_nationkey INTEGER,
            c_phone VARCHAR,
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR,
            c_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR,
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR,
            o_clerk VARCHAR,
            o_shippriority INTEGER,
            o_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR,
            l_linestatus VARCHAR,
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR,
            l_shipmode VARCHAR,
            l_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE nation (
            n_nationkey INTEGER,
            n_name VARCHAR,
            n_regionkey INTEGER,
            n_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE region (
            r_regionkey INTEGER,
            r_name VARCHAR,
            r_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;
- id: tpch_q2
  before:
  - create_tables
  sql: |
    select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
    from
        part,
        supplier,
        partsupp,
        nation,
        region
    where
            p_partkey = ps_partkey
            and s_suppkey = ps_suppkey
            and s_nationkey = n_nationkey
            and n_regionkey = r_regionkey
            and ps_supplycost = (
                    select
                            min(ps_supplycost)
                    from
                            partsupp,
                            supplier,
                            nation,
                            region
                    where
                            p_partkey = ps_partkey
                            and s_suppkey = ps_suppkey
                            and s_nationkey = n_nationkey
                            and n_regionkey = r_regionkey
            )
    order by
          s_acctbal desc,
          n_name,
          s_name,
          p_partkey;
  logical_plan: |-
    LogicalProject { exprs: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
    └─LogicalFilter { predicate: (p_partkey = ps_partkey) AND (s_suppkey = ps_suppkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) AND (ps_supplycost = min(ps_supplycost)) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
        │ │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │ │ │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
        │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        │ └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
        └─LogicalProject { exprs: [min(ps_supplycost)] }
          └─LogicalAgg { aggs: [min(ps_supplycost)] }
            └─LogicalProject { exprs: [ps_supplycost] }
              └─LogicalFilter { predicate: (CorrelatedInputRef { index: 0, correlated_id: 1 } = ps_partkey) AND (s_suppkey = ps_suppkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) }
                └─LogicalJoin { type: Inner, on: true, output: all }
                  ├─LogicalJoin { type: Inner, on: true, output: all }
                  │ ├─LogicalJoin { type: Inner, on: true, output: all }
                  │ │ ├─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                  │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                  │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                  └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
    ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
    │ ├─LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [p_partkey, p_mfgr, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
    │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = ps_partkey) AND (ps_supplycost = min(ps_supplycost)), output: [p_partkey, p_mfgr, ps_suppkey] }
    │ │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = ps_partkey), output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost] }
    │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
    │ │ │ │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
    │ │ │ └─LogicalAgg { group_key: [ps_partkey], aggs: [min(ps_supplycost)] }
    │ │ │   └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [ps_supplycost, ps_partkey] }
    │ │ │     ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [ps_partkey, ps_supplycost, n_regionkey] }
    │ │ │     │ ├─LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [ps_partkey, ps_supplycost, s_nationkey] }
    │ │ │     │ │ ├─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
    │ │ │     │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    │ │ │     │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
    │ │ │     └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
    │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
    └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], dist: Single }
    └─BatchSort { order: [s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC] }
      └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
        ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
        │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
        │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │   │ └─BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
        │   │   ├─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
        │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = ps_partkey AND ps_supplycost = min(ps_supplycost), output: [p_partkey, p_mfgr, ps_suppkey] }
        │   │   │   ├─BatchHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost] }
        │   │   │   │ ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
        │   │   │   │ │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
        │   │   │   │ └─BatchExchange { order: [], dist: HashShard(ps_partkey) }
        │   │   │   │   └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
        │   │   │   └─BatchHashAgg { group_key: [ps_partkey], aggs: [min(ps_supplycost)] }
        │   │   │     └─BatchExchange { order: [], dist: HashShard(ps_partkey) }
        │   │   │       └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [ps_supplycost, ps_partkey] }
        │   │   │         ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
        │   │   │         │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_partkey, ps_supplycost, n_regionkey] }
        │   │   │         │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │   │   │         │   │ └─BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey] }
        │   │   │         │   │   ├─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
        │   │   │         │   │   │ └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
        │   │   │         │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │   │   │         │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │   │   │         │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │   │   │         │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        │   │   │         └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
        │   │   │           └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
        │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
          └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), min(ps_supplycost)(hidden), ps_partkey(hidden), _row_id#1(hidden), _row_id#2(hidden), r_regionkey(hidden), _row_id#3(hidden), n_nationkey(hidden), _row_id#4(hidden), s_suppkey(hidden)], stream_key: [_row_id, p_partkey, _row_id#1, _row_id#2, r_regionkey, _row_id#3, n_nationkey, _row_id#4, s_suppkey, min(ps_supplycost), ps_partkey], pk_columns: [s_acctbal, n_name, s_name, p_partkey, _row_id, _row_id#1, _row_id#2, r_regionkey, _row_id#3, n_nationkey, _row_id#4, s_suppkey, min(ps_supplycost), ps_partkey], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(p_partkey, _row_id, min(ps_supplycost), ps_partkey, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, s_suppkey) }
      └─StreamHashJoin { type: Inner, predicate: p_partkey = ps_partkey AND min(ps_supplycost) = ps_supplycost AND ps_partkey = ps_partkey, output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, min(ps_supplycost), ps_partkey, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, s_suppkey] }
        ├─StreamExchange { dist: HashShard(ps_partkey, min(ps_supplycost)) }
        │ └─StreamHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_partkey, min(ps_supplycost), _row_id] }
        │   ├─StreamExchange { dist: HashShard(p_partkey) }
        │   │ └─StreamRowIdGen { row_id_index: 9 }
        │   │   └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
        │   └─StreamProject { exprs: [ps_partkey, min(ps_supplycost)] }
        │     └─StreamHashAgg [append_only] { group_key: [ps_partkey], aggs: [min(ps_supplycost), count] }
        │       └─StreamExchange { dist: HashShard(ps_partkey) }
        │         └─StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_supplycost, ps_partkey, _row_id, _row_id, ps_suppkey, s_nationkey, _row_id, _row_id, r_regionkey] }
        │           ├─StreamExchange { dist: HashShard(s_nationkey) }
        │           │ └─StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id] }
        │           │   ├─StreamExchange { dist: HashShard(ps_suppkey) }
        │           │   │ └─StreamShare { id: 5 }
        │           │   │   └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
        │           │   │     └─StreamRowIdGen { row_id_index: 5 }
        │           │   │       └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
        │           │   └─StreamExchange { dist: HashShard(s_suppkey) }
        │           │     └─StreamShare { id: 9 }
        │           │       └─StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │           │         └─StreamRowIdGen { row_id_index: 7 }
        │           │           └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │           └─StreamExchange { dist: HashShard(n_nationkey) }
        │             └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] }
        │               ├─StreamExchange { dist: HashShard(r_regionkey) }
        │               │ └─StreamShare { id: 15 }
        │               │   └─StreamProject { exprs: [r_regionkey, _row_id] }
        │               │     └─StreamRowIdGen { row_id_index: 3 }
        │               │       └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
        │               └─StreamExchange { dist: HashShard(n_regionkey) }
        │                 └─StreamShare { id: 19 }
        │                   └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
        │                     └─StreamRowIdGen { row_id_index: 4 }
        │                       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─StreamExchange { dist: HashShard(ps_partkey, ps_supplycost) }
          └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = ps_suppkey, output: [n_name, s_name, s_address, s_phone, s_acctbal, s_comment, ps_partkey, ps_supplycost, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, s_suppkey, _row_id] }
            ├─StreamExchange { dist: HashShard(s_suppkey) }
            │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, s_name, s_address, s_phone, s_acctbal, s_comment, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] }
            │   ├─StreamExchange { dist: HashShard(n_nationkey) }
            │   │ └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
            │   │   ├─StreamExchange { dist: HashShard(r_regionkey) }
            │   │   │ └─StreamShare { id: 15 }
            │   │   │   └─StreamProject { exprs: [r_regionkey, _row_id] }
            │   │   │     └─StreamRowIdGen { row_id_index: 3 }
            │   │   │       └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
            │   │   └─StreamExchange { dist: HashShard(n_regionkey) }
            │   │     └─StreamShare { id: 19 }
            │   │       └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
            │   │         └─StreamRowIdGen { row_id_index: 4 }
            │   │           └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            │   └─StreamExchange { dist: HashShard(s_nationkey) }
            │     └─StreamShare { id: 9 }
            │       └─StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │         └─StreamRowIdGen { row_id_index: 7 }
            │           └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            └─StreamExchange { dist: HashShard(ps_suppkey) }
              └─StreamFilter { predicate: IsNotNull(ps_partkey) }
                └─StreamShare { id: 5 }
                  └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
                    └─StreamRowIdGen { row_id_index: 5 }
                      └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), min(ps_supplycost)(hidden), ps_partkey(hidden), _row_id#1(hidden), _row_id#2(hidden), r_regionkey(hidden), _row_id#3(hidden), n_nationkey(hidden), _row_id#4(hidden), s_suppkey(hidden)], stream_key: [_row_id, p_partkey, _row_id#1, _row_id#2, r_regionkey, _row_id#3, n_nationkey, _row_id#4, s_suppkey, min(ps_supplycost), ps_partkey], pk_columns: [s_acctbal, n_name, s_name, p_partkey, _row_id, _row_id#1, _row_id#2, r_regionkey, _row_id#3, n_nationkey, _row_id#4, s_suppkey, min(ps_supplycost), ps_partkey], pk_conflict: NoCheck }
    └── StreamExchange Hash([3, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) from 1

    Fragment 1
    StreamHashJoin { type: Inner, predicate: p_partkey = ps_partkey AND min(ps_supplycost) = ps_supplycost AND ps_partkey = ps_partkey, output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, min(ps_supplycost), ps_partkey, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, s_suppkey] } { tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ] }
    ├── StreamExchange Hash([2, 3]) from 2
    └── StreamExchange Hash([6, 7]) from 15

    Fragment 2
    StreamHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_partkey, min(ps_supplycost), _row_id] } { tables: [ HashJoinLeft: 4, HashJoinDegreeLeft: 5, HashJoinRight: 6, HashJoinDegreeRight: 7 ] }
    ├── StreamExchange Hash([0]) from 3
    └── StreamProject { exprs: [ps_partkey, min(ps_supplycost)] }
        └── StreamHashAgg [append_only] { group_key: [ps_partkey], aggs: [min(ps_supplycost), count] } { tables: [ HashAggState: 9 ] }
            └── StreamExchange Hash([1]) from 4

    Fragment 3
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { tables: [ Source: 8 ] }

    Fragment 4
    StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_supplycost, ps_partkey, _row_id, _row_id, ps_suppkey, s_nationkey, _row_id, _row_id, r_regionkey] } { tables: [ HashJoinLeft: 10, HashJoinDegreeLeft: 11, HashJoinRight: 12, HashJoinDegreeRight: 13 ] }
    ├── StreamExchange Hash([2]) from 5
    └── StreamExchange Hash([0]) from 10

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id] } { tables: [ HashJoinLeft: 14, HashJoinDegreeLeft: 15, HashJoinRight: 16, HashJoinDegreeRight: 17 ] }
    ├── StreamExchange Hash([1]) from 6
    └── StreamExchange Hash([0]) from 8

    Fragment 6
    StreamNoOp
    └── StreamExchange NoShuffle from 7

    Fragment 7
    StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
    └── StreamRowIdGen { row_id_index: 5 }
        └── StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] } { tables: [ Source: 18 ] }

    Fragment 8
    StreamNoOp
    └── StreamExchange NoShuffle from 9

    Fragment 9
    StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    └── StreamRowIdGen { row_id_index: 7 }
        └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 19 ] }

    Fragment 10
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] } { tables: [ HashJoinLeft: 20, HashJoinDegreeLeft: 21, HashJoinRight: 22, HashJoinDegreeRight: 23 ] }
    ├── StreamExchange Hash([0]) from 11
    └── StreamExchange Hash([2]) from 13

    Fragment 11
    StreamNoOp
    └── StreamExchange NoShuffle from 12

    Fragment 12
    StreamProject { exprs: [r_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 3 }
        └── StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] } { tables: [ Source: 24 ] }

    Fragment 13
    StreamNoOp
    └── StreamExchange NoShuffle from 14

    Fragment 14
    StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 25 ] }

    Fragment 15
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = ps_suppkey, output: [n_name, s_name, s_address, s_phone, s_acctbal, s_comment, ps_partkey, ps_supplycost, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, s_suppkey, _row_id] } { tables: [ HashJoinLeft: 26, HashJoinDegreeLeft: 27, HashJoinRight: 28, HashJoinDegreeRight: 29 ] }
    ├── StreamExchange Hash([1]) from 16
    └── StreamExchange Hash([1]) from 21

    Fragment 16
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, s_name, s_address, s_phone, s_acctbal, s_comment, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 30, HashJoinDegreeLeft: 31, HashJoinRight: 32, HashJoinDegreeRight: 33 ] }
    ├── StreamExchange Hash([0]) from 17
    └── StreamExchange Hash([3]) from 20

    Fragment 17
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] } { tables: [ HashJoinLeft: 34, HashJoinDegreeLeft: 35, HashJoinRight: 36, HashJoinDegreeRight: 37 ] }
    ├── StreamExchange Hash([0]) from 18
    └── StreamExchange Hash([2]) from 19

    Fragment 18
    StreamNoOp
    └── StreamExchange NoShuffle from 12

    Fragment 19
    StreamNoOp
    └── StreamExchange NoShuffle from 14

    Fragment 20
    StreamNoOp
    └── StreamExchange NoShuffle from 9

    Fragment 21
    StreamFilter { predicate: IsNotNull(ps_partkey) }
    └── StreamExchange NoShuffle from 7

    Table 0 { columns: [ p_partkey, p_mfgr, ps_partkey, min(ps_supplycost), _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 2, 3 ], read pk prefix len hint: 3 }

    Table 1 { columns: [ p_partkey, min(ps_supplycost), ps_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 2, 1 ], read pk prefix len hint: 3 }

    Table 2 { columns: [ n_name, s_name, s_address, s_phone, s_acctbal, s_comment, ps_partkey, ps_supplycost, _row_id, _row_id_0, r_regionkey, _row_id_1, n_nationkey, s_suppkey, _row_id_2, _rw_timestamp ], primary key: [ $6 ASC, $7 ASC, $6 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC, $14 ASC, $13 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ], distribution key: [ 6, 7 ], read pk prefix len hint: 3 }

    Table 3 { columns: [ ps_partkey, ps_supplycost, ps_partkey_0, _row_id, _row_id_0, r_regionkey, _row_id_1, n_nationkey, _row_id_2, s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 2, 1 ], read pk prefix len hint: 3 }

    Table 4 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ p_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ ps_partkey, min(ps_supplycost), _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ ps_partkey, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 9 { columns: [ ps_partkey, min(ps_supplycost), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id_0, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ s_nationkey, _row_id, _row_id_0, ps_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $3 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ n_nationkey, _row_id, _row_id_0, r_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 14 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ ps_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ s_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ r_regionkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ r_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ n_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 26 { columns: [ n_name, s_suppkey, s_name, s_address, s_phone, s_acctbal, s_comment, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1, _rw_timestamp ], primary key: [ $1 ASC, $7 ASC, $8 ASC, $9 ASC, $11 ASC, $10 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ s_suppkey, _row_id, _row_id_0, r_regionkey, _row_id_1, n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id, _rw_timestamp ], primary key: [ $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 29 { columns: [ ps_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 31 { columns: [ n_nationkey, _row_id, _row_id_0, r_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 32 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 33 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 34 { columns: [ r_regionkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 35 { columns: [ r_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 36 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 37 { columns: [ n_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, min(ps_supplycost), ps_partkey, _row_id#1, _row_id#2, r_regionkey, _row_id#3, n_nationkey, _row_id#4, s_suppkey, _rw_timestamp ], primary key: [ $0 DESC, $2 ASC, $1 ASC, $3 ASC, $8 ASC, $11 ASC, $12 ASC, $13 ASC, $14 ASC, $15 ASC, $16 ASC, $17 ASC, $9 ASC, $10 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ], distribution key: [ 3, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ], read pk prefix len hint: 14 }

- id: tpch_q5
  before:
  - create_tables
  sql: |
    select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
    group by
      n_name
    order by
      revenue desc;
  logical_plan: |-
    LogicalProject { exprs: [n_name, sum($expr1)] }
    └─LogicalAgg { group_key: [n_name], aggs: [sum($expr1)] }
      └─LogicalProject { exprs: [n_name, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr1] }
        └─LogicalFilter { predicate: (c_custkey = o_custkey) AND (l_orderkey = o_orderkey) AND (l_suppkey = s_suppkey) AND (c_nationkey = s_nationkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
            │ │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
            │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [n_name], aggs: [sum($expr1)] }
    └─LogicalProject { exprs: [n_name, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr1] }
      └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [l_extendedprice, l_discount, n_name] }
        ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_extendedprice, l_discount, n_name, n_regionkey] }
        │ ├─LogicalJoin { type: Inner, on: (l_orderkey = o_orderkey) AND (l_suppkey = s_suppkey), output: [s_nationkey, l_extendedprice, l_discount] }
        │ │ ├─LogicalJoin { type: Inner, on: (c_nationkey = s_nationkey), output: [o_orderkey, s_suppkey, s_nationkey] }
        │ │ │ ├─LogicalJoin { type: Inner, on: (c_custkey = o_custkey), output: [c_nationkey, o_orderkey] }
        │ │ │ │ ├─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
        │ │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
        │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
        │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [sum($expr1) DESC], dist: Single }
    └─BatchSort { order: [sum($expr1) DESC] }
      └─BatchHashAgg { group_key: [n_name], aggs: [sum($expr1)] }
        └─BatchExchange { order: [], dist: HashShard(n_name) }
          └─BatchProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1] }
            └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [l_extendedprice, l_discount, n_name] }
              ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
              │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_extendedprice, l_discount, n_name, n_regionkey] }
              │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
              │   │ └─BatchHashJoin { type: Inner, predicate: o_orderkey = l_orderkey AND s_suppkey = l_suppkey, output: [s_nationkey, l_extendedprice, l_discount] }
              │   │   ├─BatchExchange { order: [], dist: HashShard(o_orderkey, s_suppkey) }
              │   │   │ └─BatchHashJoin { type: Inner, predicate: c_nationkey = s_nationkey, output: [o_orderkey, s_suppkey, s_nationkey] }
              │   │   │   ├─BatchExchange { order: [], dist: HashShard(c_nationkey) }
              │   │   │   │ └─BatchHashJoin { type: Inner, predicate: c_custkey = o_custkey, output: [c_nationkey, o_orderkey] }
              │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(c_custkey) }
              │   │   │   │   │ └─BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
              │   │   │   │   └─BatchExchange { order: [], dist: HashShard(o_custkey) }
              │   │   │   │     └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              │   │   │   └─BatchExchange { order: [], dist: HashShard(s_nationkey) }
              │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │   │   └─BatchExchange { order: [], dist: HashShard(l_orderkey, l_suppkey) }
              │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
              │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
                └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [revenue, n_name], pk_conflict: NoCheck }
    └─StreamProject { exprs: [n_name, sum($expr1)] }
      └─StreamHashAgg [append_only] { group_key: [n_name], aggs: [sum($expr1), count] }
        └─StreamExchange { dist: HashShard(n_name) }
          └─StreamProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1, _row_id, _row_id, r_regionkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, n_nationkey] }
            └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey AND n_nationkey = c_nationkey, output: [l_extendedprice, l_discount, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey] }
              ├─StreamExchange { dist: HashShard(n_nationkey, n_nationkey) }
              │ └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
              │   ├─StreamExchange { dist: HashShard(r_regionkey) }
              │   │ └─StreamRowIdGen { row_id_index: 3 }
              │   │   └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
              │   └─StreamExchange { dist: HashShard(n_regionkey) }
              │     └─StreamFilter { predicate: IsNotNull(n_nationkey) }
              │       └─StreamRowIdGen { row_id_index: 4 }
              │         └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              └─StreamExchange { dist: HashShard(c_nationkey, s_nationkey) }
                └─StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey AND c_nationkey = s_nationkey, output: [c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id, o_custkey, o_orderkey, _row_id, _row_id, l_suppkey] }
                  ├─StreamExchange { dist: HashShard(o_orderkey, c_nationkey) }
                  │ └─StreamHashJoin [append_only] { type: Inner, predicate: o_custkey = c_custkey, output: [o_orderkey, c_nationkey, _row_id, o_custkey, _row_id] }
                  │   ├─StreamExchange { dist: HashShard(o_custkey) }
                  │   │ └─StreamRowIdGen { row_id_index: 9 }
                  │   │   └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                  │   └─StreamExchange { dist: HashShard(c_custkey) }
                  │     └─StreamRowIdGen { row_id_index: 8 }
                  │       └─StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                  └─StreamExchange { dist: HashShard(l_orderkey, s_nationkey) }
                    └─StreamHashJoin [append_only] { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id] }
                      ├─StreamExchange { dist: HashShard(l_suppkey) }
                      │ └─StreamRowIdGen { row_id_index: 16 }
                      │   └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                      └─StreamExchange { dist: HashShard(s_suppkey) }
                        └─StreamRowIdGen { row_id_index: 7 }
                          └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [revenue, n_name], pk_conflict: NoCheck }
    └── StreamProject { exprs: [n_name, sum($expr1)] }
        └── StreamHashAgg [append_only] { group_key: [n_name], aggs: [sum($expr1), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1, _row_id, _row_id, r_regionkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, n_nationkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey AND n_nationkey = c_nationkey, output: [l_extendedprice, l_discount, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey] }
        ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
        ├── StreamExchange Hash([0, 0]) from 2
        └── StreamExchange Hash([0, 3]) from 5

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] } { tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ] }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([2]) from 4

    Fragment 3
    StreamRowIdGen { row_id_index: 3 }
    └── StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] } { tables: [ Source: 9 ] }

    Fragment 4
    StreamFilter { predicate: IsNotNull(n_nationkey) }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 10 ] }

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey AND c_nationkey = s_nationkey, output: [c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id, o_custkey, o_orderkey, _row_id, _row_id, l_suppkey] }
    ├── tables: [ HashJoinLeft: 11, HashJoinDegreeLeft: 12, HashJoinRight: 13, HashJoinDegreeRight: 14 ]
    ├── StreamExchange Hash([0, 1]) from 6
    └── StreamExchange Hash([0, 3]) from 9

    Fragment 6
    StreamHashJoin [append_only] { type: Inner, predicate: o_custkey = c_custkey, output: [o_orderkey, c_nationkey, _row_id, o_custkey, _row_id] } { tables: [ HashJoinLeft: 15, HashJoinDegreeLeft: 16, HashJoinRight: 17, HashJoinDegreeRight: 18 ] }
    ├── StreamExchange Hash([1]) from 7
    └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 19 ] }

    Fragment 8
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] } { tables: [ Source: 20 ] }

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id] } { tables: [ HashJoinLeft: 21, HashJoinDegreeLeft: 22, HashJoinRight: 23, HashJoinDegreeRight: 24 ] }
    ├── StreamExchange Hash([2]) from 10
    └── StreamExchange Hash([0]) from 11

    Fragment 10
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] } { tables: [ Source: 25 ] }

    Fragment 11
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 26 ] }

    Table 0 { columns: [ n_name, sum($expr1), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $0 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 0 ], read pk prefix len hint: 2 }

    Table 2 { columns: [ n_nationkey, n_nationkey_0, _row_id, _row_id_0, r_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 1, 0 ], read pk prefix len hint: 2 }

    Table 3
    ├── columns: [ c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id_0, o_custkey, o_orderkey, _row_id_1, _row_id_2, l_suppkey, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $0 ASC, $4 ASC, $5 ASC, $6 ASC, $8 ASC, $9 ASC, $10 ASC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 0, 3 ]
    └── read pk prefix len hint: 2

    Table 4
    ├── columns: [ s_nationkey, c_nationkey, _row_id, _row_id_0, o_custkey, _row_id_1, _row_id_2, l_suppkey, o_orderkey, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC ]
    ├── value indices: [ 9 ]
    ├── distribution key: [ 1, 0 ]
    └── read pk prefix len hint: 2

    Table 5 { columns: [ r_regionkey, r_name, r_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ r_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ n_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 10 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 11 { columns: [ o_orderkey, c_nationkey, _row_id, o_custkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 12 { columns: [ o_orderkey, c_nationkey, _row_id, _row_id_0, o_custkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 13 { columns: [ l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $4 ASC, $6 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0, 3 ], read pk prefix len hint: 2 }

    Table 14 { columns: [ l_orderkey, s_nationkey, _row_id, _row_id_0, l_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 15
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 16 { columns: [ o_custkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ c_custkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 21
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 1

    Table 22 { columns: [ l_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ s_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 26 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ n_name, revenue, _rw_timestamp ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

- id: tpch_q7
  before:
  - create_tables
  sql: |
    select
      supp_nation,
      cust_nation,
      l_year,
      sum(volume) as revenue
    from
      (
        select
          n1.n_name as supp_nation,
          n2.n_name as cust_nation,
          extract(year from l_shipdate) as l_year,
          l_extendedprice * (1 - l_discount) as volume
        from
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2
        where
          s_suppkey = l_suppkey
          and o_orderkey = l_orderkey
          and c_custkey = o_custkey
          and s_nationkey = n1.n_nationkey
          and c_nationkey = n2.n_nationkey
      ) as shipping
    group by
      supp_nation,
      cust_nation,
      l_year
    order by
      supp_nation,
      cust_nation,
      l_year;
  logical_plan: |-
    LogicalProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
    └─LogicalAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
      └─LogicalProject { exprs: [n_name, n_name, $expr1, $expr2] }
        └─LogicalProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2] }
          └─LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (o_orderkey = l_orderkey) AND (c_custkey = o_custkey) AND (s_nationkey = n_nationkey) AND (c_nationkey = n_nationkey) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              │ │ └─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
              │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
    └─LogicalProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2] }
      └─LogicalJoin { type: Inner, on: (c_nationkey = n_nationkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name] }
        ├─LogicalJoin { type: Inner, on: (c_custkey = o_custkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, c_nationkey] }
        │ ├─LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, o_custkey] }
        │ │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name] }
        │ │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [s_nationkey, l_orderkey, l_extendedprice, l_discount, l_shipdate] }
        │ │ │ │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
        │ │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
        │ └─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
        └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [n_name ASC, n_name ASC, $expr1 ASC], dist: Single }
    └─BatchSort { order: [n_name ASC, n_name ASC, $expr1 ASC] }
      └─BatchHashAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
        └─BatchExchange { order: [], dist: HashShard(n_name, n_name, $expr1) }
          └─BatchProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2] }
            └─BatchHashJoin { type: Inner, predicate: c_nationkey = n_nationkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name] }
              ├─BatchExchange { order: [], dist: HashShard(c_nationkey) }
              │ └─BatchHashJoin { type: Inner, predicate: o_custkey = c_custkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, c_nationkey] }
              │   ├─BatchExchange { order: [], dist: HashShard(o_custkey) }
              │   │ └─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, o_custkey] }
              │   │   ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
              │   │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name] }
              │   │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
              │   │   │   │ └─BatchHashJoin { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_nationkey, l_orderkey, l_extendedprice, l_discount, l_shipdate] }
              │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(s_suppkey) }
              │   │   │   │   │ └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │   │   │   │   └─BatchExchange { order: [], dist: HashShard(l_suppkey) }
              │   │   │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │   │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
              │   │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              │   │   └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
              │   │     └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              │   └─BatchExchange { order: [], dist: HashShard(c_custkey) }
              │     └─BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
              └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], stream_key: [supp_nation, cust_nation, l_year], pk_columns: [supp_nation, cust_nation, l_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
      └─StreamHashAgg [append_only] { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2), count] }
        └─StreamExchange { dist: HashShard(n_name, n_name, $expr1) }
          └─StreamProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey, l_orderkey] }
            └─StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, l_orderkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey] }
              ├─StreamExchange { dist: HashShard(l_orderkey) }
              │ └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id, n_nationkey, s_suppkey, _row_id] }
              │   ├─StreamExchange { dist: HashShard(s_suppkey) }
              │   │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
              │   │   ├─StreamExchange { dist: HashShard(n_nationkey) }
              │   │   │ └─StreamShare { id: 3 }
              │   │   │   └─StreamProject { exprs: [n_nationkey, n_name, _row_id] }
              │   │   │     └─StreamRowIdGen { row_id_index: 4 }
              │   │   │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              │   │   └─StreamExchange { dist: HashShard(s_nationkey) }
              │   │     └─StreamRowIdGen { row_id_index: 7 }
              │   │       └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │   └─StreamExchange { dist: HashShard(l_suppkey) }
              │     └─StreamRowIdGen { row_id_index: 16 }
              │       └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              └─StreamExchange { dist: HashShard(o_orderkey) }
                └─StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, o_orderkey, _row_id, _row_id, n_nationkey, c_custkey, _row_id] }
                  ├─StreamExchange { dist: HashShard(c_custkey) }
                  │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [n_name, c_custkey, _row_id, n_nationkey, _row_id] }
                  │   ├─StreamExchange { dist: HashShard(n_nationkey) }
                  │   │ └─StreamShare { id: 3 }
                  │   │   └─StreamProject { exprs: [n_nationkey, n_name, _row_id] }
                  │   │     └─StreamRowIdGen { row_id_index: 4 }
                  │   │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                  │   └─StreamExchange { dist: HashShard(c_nationkey) }
                  │     └─StreamRowIdGen { row_id_index: 8 }
                  │       └─StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                  └─StreamExchange { dist: HashShard(o_custkey) }
                    └─StreamRowIdGen { row_id_index: 9 }
                      └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], stream_key: [supp_nation, cust_nation, l_year], pk_columns: [supp_nation, cust_nation, l_year], pk_conflict: NoCheck }
    └── StreamProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
        └── StreamHashAgg [append_only] { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0, 1, 2]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey, l_orderkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, l_orderkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey] }
        ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
        ├── StreamExchange Hash([1]) from 2
        └── StreamExchange Hash([1]) from 8

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id, n_nationkey, s_suppkey, _row_id] }
    ├── tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ]
    ├── StreamExchange Hash([1]) from 3
    └── StreamExchange Hash([2]) from 7

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ] }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([3]) from 6

    Fragment 4
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 5
    StreamProject { exprs: [n_nationkey, n_name, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 13 ] }

    Fragment 6
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 14 ] }

    Fragment 7
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
        └── tables: [ Source: 15 ]

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, o_orderkey, _row_id, _row_id, n_nationkey, c_custkey, _row_id] } { tables: [ HashJoinLeft: 16, HashJoinDegreeLeft: 17, HashJoinRight: 18, HashJoinDegreeRight: 19 ] }
    ├── StreamExchange Hash([1]) from 9
    └── StreamExchange Hash([1]) from 12

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [n_name, c_custkey, _row_id, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 20, HashJoinDegreeLeft: 21, HashJoinRight: 22, HashJoinDegreeRight: 23 ] }
    ├── StreamExchange Hash([0]) from 10
    └── StreamExchange Hash([3]) from 11

    Fragment 10
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 11
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] } { tables: [ Source: 24 ] }

    Fragment 12
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 25 ] }

    Table 0 { columns: [ n_name, n_name_0, $expr1, sum($expr2), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 1
    ├── columns: [ n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $5 ASC, $6 ASC, $7 ASC, $9 ASC, $8 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 2 { columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3
    ├── columns: [ n_name, o_orderkey, _row_id, _row_id_0, n_nationkey, c_custkey, _row_id_1, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $2 ASC, $3 ASC, $4 ASC, $6 ASC, $5 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 4 { columns: [ o_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, c_custkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 1

    Table 8 { columns: [ l_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ n_nationkey, n_name, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 14 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 15 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 16 { columns: [ n_name, c_custkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ c_custkey, _row_id, _row_id_0, n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 19 { columns: [ o_custkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ n_nationkey, n_name, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22
    ├── columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $8 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
    ├── distribution key: [ 3 ]
    └── read pk prefix len hint: 1

    Table 23 { columns: [ c_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ supp_nation, cust_nation, l_year, revenue, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

- id: tpch_q8
  before:
  - create_tables
  sql: |
    select
      o_year,
      round(sum(case
        when nation != 'IRAN' then volume
        else 0
      end) / sum(volume), 6) as mkt_share
    from
      (
        select
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) as volume,
          n2.n_name as nation
        from
          part,
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2,
          region
        where
          p_partkey = l_partkey
          and s_suppkey = l_suppkey
          and l_orderkey = o_orderkey
          and o_custkey = c_custkey
          and c_nationkey = n1.n_nationkey
          and n1.n_regionkey = r_regionkey
          and s_nationkey = n2.n_nationkey
      ) as all_nations
    group by
      o_year
    order by
      o_year;
  logical_plan: |-
    LogicalProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
    └─LogicalAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
      └─LogicalProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Int32::Decimal) as $expr3, $expr2] }
        └─LogicalProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2, n_name] }
          └─LogicalFilter { predicate: (p_partkey = l_partkey) AND (s_suppkey = l_suppkey) AND (l_orderkey = o_orderkey) AND (o_custkey = c_custkey) AND (c_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) AND (s_nationkey = n_nationkey) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
              │ │ │ │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │ │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │ │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              │ │ │ └─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
              │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
    └─LogicalAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
      └─LogicalProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Int32::Decimal) as $expr3, $expr2] }
        └─LogicalProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2, n_name] }
          └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [l_extendedprice, l_discount, o_orderdate, n_name] }
            ├─LogicalJoin { type: Inner, on: (c_nationkey = n_nationkey), output: [l_extendedprice, l_discount, n_name, o_orderdate, n_regionkey] }
            │ ├─LogicalJoin { type: Inner, on: (o_custkey = c_custkey), output: [l_extendedprice, l_discount, n_name, o_orderdate, c_nationkey] }
            │ │ ├─LogicalJoin { type: Inner, on: (l_orderkey = o_orderkey), output: [l_extendedprice, l_discount, n_name, o_custkey, o_orderdate] }
            │ │ │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_extendedprice, l_discount, n_name] }
            │ │ │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [l_orderkey, l_extendedprice, l_discount, s_nationkey] }
            │ │ │ │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = l_partkey), output: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
            │ │ │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
            │ │ │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            │ │ │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │ │ │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
            │ │ └─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
            │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [$expr1 ASC], dist: Single }
    └─BatchProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
      └─BatchSort { order: [$expr1 ASC] }
        └─BatchHashAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
          └─BatchExchange { order: [], dist: HashShard($expr1) }
            └─BatchProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Decimal) as $expr3, $expr2] }
              └─BatchProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, n_name] }
                └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [l_extendedprice, l_discount, o_orderdate, n_name] }
                  ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
                  │ └─BatchHashJoin { type: Inner, predicate: c_nationkey = n_nationkey, output: [l_extendedprice, l_discount, n_name, o_orderdate, n_regionkey] }
                  │   ├─BatchExchange { order: [], dist: HashShard(c_nationkey) }
                  │   │ └─BatchHashJoin { type: Inner, predicate: o_custkey = c_custkey, output: [l_extendedprice, l_discount, n_name, o_orderdate, c_nationkey] }
                  │   │   ├─BatchExchange { order: [], dist: HashShard(o_custkey) }
                  │   │   │ └─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, n_name, o_custkey, o_orderdate] }
                  │   │   │   ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
                  │   │   │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_extendedprice, l_discount, n_name] }
                  │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
                  │   │   │   │   │ └─BatchHashJoin { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey] }
                  │   │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(l_suppkey) }
                  │   │   │   │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
                  │   │   │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
                  │   │   │   │   │   │   │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                  │   │   │   │   │   │   └─BatchExchange { order: [], dist: HashShard(l_partkey) }
                  │   │   │   │   │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                  │   │   │   │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
                  │   │   │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                  │   │   │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                  │   │   │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                  │   │   │   └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
                  │   │   │     └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                  │   │   └─BatchExchange { order: [], dist: HashShard(c_custkey) }
                  │   │     └─BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                  │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                  │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                  └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
                    └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [o_year, mkt_share], stream_key: [o_year], pk_columns: [o_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
      └─StreamHashAgg [append_only] { group_key: [$expr1], aggs: [sum($expr3), sum($expr2), count] }
        └─StreamExchange { dist: HashShard($expr1) }
          └─StreamProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Decimal) as $expr3, $expr2, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
            └─StreamProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
              └─StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [l_extendedprice, l_discount, o_orderdate, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, c_custkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey] }
                ├─StreamExchange { dist: HashShard(c_custkey) }
                │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [c_custkey, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] }
                │   ├─StreamExchange { dist: HashShard(n_nationkey) }
                │   │ └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] }
                │   │   ├─StreamExchange { dist: HashShard(r_regionkey) }
                │   │   │ └─StreamRowIdGen { row_id_index: 3 }
                │   │   │   └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                │   │   └─StreamExchange { dist: HashShard(n_regionkey) }
                │   │     └─StreamShare { id: 5 }
                │   │       └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                │   │         └─StreamRowIdGen { row_id_index: 4 }
                │   │           └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                │   └─StreamExchange { dist: HashShard(c_nationkey) }
                │     └─StreamRowIdGen { row_id_index: 8 }
                │       └─StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                └─StreamExchange { dist: HashShard(o_custkey) }
                  └─StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, l_orderkey, _row_id] }
                    ├─StreamExchange { dist: HashShard(l_orderkey) }
                    │ └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, p_partkey] }
                    │   ├─StreamExchange { dist: HashShard(s_suppkey) }
                    │   │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                    │   │   ├─StreamExchange { dist: HashShard(n_nationkey) }
                    │   │   │ └─StreamShare { id: 5 }
                    │   │   │   └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                    │   │   │     └─StreamRowIdGen { row_id_index: 4 }
                    │   │   │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                    │   │   └─StreamExchange { dist: HashShard(s_nationkey) }
                    │   │     └─StreamRowIdGen { row_id_index: 7 }
                    │   │       └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                    │   └─StreamExchange { dist: HashShard(l_suppkey) }
                    │     └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id] }
                    │       ├─StreamExchange { dist: HashShard(p_partkey) }
                    │       │ └─StreamRowIdGen { row_id_index: 9 }
                    │       │   └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                    │       └─StreamExchange { dist: HashShard(l_partkey) }
                    │         └─StreamRowIdGen { row_id_index: 16 }
                    │           └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                    └─StreamExchange { dist: HashShard(o_orderkey) }
                      └─StreamRowIdGen { row_id_index: 9 }
                        └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [o_year, mkt_share], stream_key: [o_year], pk_columns: [o_year], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
        └── StreamHashAgg [append_only] { group_key: [$expr1], aggs: [sum($expr3), sum($expr2), count] }
            ├── tables: [ HashAggState: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Decimal) as $expr3, $expr2, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
    └── StreamProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
        └── StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [l_extendedprice, l_discount, o_orderdate, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, c_custkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey] }
            ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
            ├── StreamExchange Hash([0]) from 2
            └── StreamExchange Hash([3]) from 8

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [c_custkey, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ] }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([3]) from 7

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] } { tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ] }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([2]) from 5

    Fragment 4
    StreamRowIdGen { row_id_index: 3 }
    └── StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] } { tables: [ Source: 13 ] }

    Fragment 5
    StreamNoOp
    └── StreamExchange NoShuffle from 6

    Fragment 6
    StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 14 ] }

    Fragment 7
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] } { tables: [ Source: 15 ] }

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, l_orderkey, _row_id] }
    ├── tables: [ HashJoinLeft: 16, HashJoinDegreeLeft: 17, HashJoinRight: 18, HashJoinDegreeRight: 19 ]
    ├── StreamExchange Hash([1]) from 9
    └── StreamExchange Hash([0]) from 16

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, p_partkey] }
    ├── tables: [ HashJoinLeft: 20, HashJoinDegreeLeft: 21, HashJoinRight: 22, HashJoinDegreeRight: 23 ]
    ├── StreamExchange Hash([1]) from 10
    └── StreamExchange Hash([1]) from 13

    Fragment 10
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 24, HashJoinDegreeLeft: 25, HashJoinRight: 26, HashJoinDegreeRight: 27 ] }
    ├── StreamExchange Hash([0]) from 11
    └── StreamExchange Hash([3]) from 12

    Fragment 11
    StreamNoOp
    └── StreamExchange NoShuffle from 6

    Fragment 12
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 28 ] }

    Fragment 13
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id] } { tables: [ HashJoinLeft: 29, HashJoinDegreeLeft: 30, HashJoinRight: 31, HashJoinDegreeRight: 32 ] }
    ├── StreamExchange Hash([0]) from 14
    └── StreamExchange Hash([1]) from 15

    Fragment 14
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { tables: [ Source: 33 ] }

    Fragment 15
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] } { tables: [ Source: 34 ] }

    Fragment 16
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 35 ] }

    Table 0 { columns: [ $expr1, sum($expr3), sum($expr2), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ c_custkey, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ c_custkey, _row_id, _row_id_0, r_regionkey, _row_id_1, n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3
    ├── columns: [ n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, l_orderkey, _row_id_3, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $13 ASC, $12 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 3 ]
    └── read pk prefix len hint: 1

    Table 4
    ├── columns: [ o_custkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, _row_id_3, l_orderkey, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 10 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 5 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $3 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ n_nationkey, _row_id, _row_id_0, r_regionkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ c_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ r_regionkey, r_name, r_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ r_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ n_regionkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 14 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 15 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 16
    ├── columns: [ n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, p_partkey, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $4 ASC, $5 ASC, $6 ASC, $8 ASC, $9 ASC, $10 ASC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 17 { columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ o_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $4 ASC, $6 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ l_suppkey, _row_id, _row_id_0, p_partkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ n_nationkey, n_name, n_regionkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 26 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 29 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ p_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 31
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 32 { columns: [ l_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 33 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 34 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 35 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ o_year, mkt_share, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: tpch_q9
  before:
  - create_tables
  sql: |
    select
      nation,
      o_year,
      round(sum(amount), 2) as sum_profit
    from
      (
        select
          n_name as nation,
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
          part,
          supplier,
          lineitem,
          partsupp,
          orders,
          nation
        where
          s_suppkey = l_suppkey
          and ps_suppkey = l_suppkey
          and ps_partkey = l_partkey
          and p_partkey = l_partkey
          and o_orderkey = l_orderkey
          and s_nationkey = n_nationkey
      ) as profit
    group by
      nation,
      o_year
    order by
      nation,
      o_year desc;
  logical_plan: |-
    LogicalProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
    └─LogicalAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
      └─LogicalProject { exprs: [n_name, $expr1, $expr2] }
        └─LogicalProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Int32::Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
          └─LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (ps_suppkey = l_suppkey) AND (ps_partkey = l_partkey) AND (p_partkey = l_partkey) AND (o_orderkey = l_orderkey) AND (s_nationkey = n_nationkey) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
              │ │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              │ │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
              │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
              └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
    └─LogicalAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
      └─LogicalProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Int32::Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
        └─LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name] }
          ├─LogicalJoin { type: Inner, on: (ps_suppkey = l_suppkey) AND (ps_partkey = l_partkey), output: [l_orderkey, l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost] }
          │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, n_name] }
          │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, s_nationkey] }
          │ │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = l_partkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
          │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
          │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
          │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
          │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
          │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
          └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [n_name ASC, $expr1 DESC], dist: Single }
    └─BatchProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
      └─BatchSort { order: [n_name ASC, $expr1 DESC] }
        └─BatchHashAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
          └─BatchExchange { order: [], dist: HashShard(n_name, $expr1) }
            └─BatchProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
              └─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name] }
                ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
                │ └─BatchHashJoin { type: Inner, predicate: l_suppkey = ps_suppkey AND l_partkey = ps_partkey, output: [l_orderkey, l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost] }
                │   ├─BatchExchange { order: [], dist: HashShard(l_partkey, l_suppkey) }
                │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, n_name] }
                │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
                │   │   │ └─BatchHashJoin { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, s_nationkey] }
                │   │   │   ├─BatchExchange { order: [], dist: HashShard(l_suppkey) }
                │   │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
                │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
                │   │   │   │   │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                │   │   │   │   └─BatchExchange { order: [], dist: HashShard(l_partkey) }
                │   │   │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                │   │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
                │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                │   └─BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
                │     └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
                  └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [nation, o_year, sum_profit], stream_key: [nation, o_year], pk_columns: [nation, o_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
      └─StreamHashAgg [append_only] { group_key: [n_name, $expr1], aggs: [sum($expr2), count] }
        └─StreamExchange { dist: HashShard(n_name, $expr1) }
          └─StreamProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2, _row_id, _row_id, p_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, ps_suppkey, ps_partkey] }
            └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey AND ps_suppkey = l_suppkey AND ps_partkey = l_partkey AND ps_suppkey = s_suppkey, output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name, _row_id, _row_id, p_partkey, ps_suppkey, ps_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
              ├─StreamExchange { dist: HashShard(ps_suppkey) }
              │ └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id] }
              │   ├─StreamExchange { dist: HashShard(p_partkey) }
              │   │ └─StreamRowIdGen { row_id_index: 9 }
              │   │   └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
              │   └─StreamExchange { dist: HashShard(ps_partkey) }
              │     └─StreamFilter { predicate: IsNotNull(ps_suppkey) }
              │       └─StreamRowIdGen { row_id_index: 5 }
              │         └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
              └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey] }
                ├─StreamExchange { dist: HashShard(s_suppkey) }
                │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                │   ├─StreamExchange { dist: HashShard(n_nationkey) }
                │   │ └─StreamRowIdGen { row_id_index: 4 }
                │   │   └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                │   └─StreamExchange { dist: HashShard(s_nationkey) }
                │     └─StreamRowIdGen { row_id_index: 7 }
                │       └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                └─StreamExchange { dist: HashShard(l_suppkey) }
                  └─StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id] }
                    ├─StreamExchange { dist: HashShard(o_orderkey) }
                    │ └─StreamRowIdGen { row_id_index: 9 }
                    │   └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                    └─StreamExchange { dist: HashShard(l_orderkey) }
                      └─StreamFilter { predicate: IsNotNull(l_partkey) }
                        └─StreamRowIdGen { row_id_index: 16 }
                          └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [nation, o_year, sum_profit], stream_key: [nation, o_year], pk_columns: [nation, o_year], pk_conflict: NoCheck }
    └── StreamProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
        └── StreamHashAgg [append_only] { group_key: [n_name, $expr1], aggs: [sum($expr2), count] } { tables: [ HashAggState: 0 ] }
            └── StreamExchange Hash([0, 1]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2, _row_id, _row_id, p_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, ps_suppkey, ps_partkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey AND ps_suppkey = l_suppkey AND ps_partkey = l_partkey AND ps_suppkey = s_suppkey, output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name, _row_id, _row_id, p_partkey, ps_suppkey, ps_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
        ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
        ├── StreamExchange Hash([2]) from 2
        └── StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey] } { tables: [ HashJoinLeft: 11, HashJoinDegreeLeft: 12, HashJoinRight: 13, HashJoinDegreeRight: 14 ] }
            ├── StreamExchange Hash([1]) from 5
            └── StreamExchange Hash([2]) from 8

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id] } { tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ] }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([0]) from 4

    Fragment 3
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { tables: [ Source: 9 ] }

    Fragment 4
    StreamFilter { predicate: IsNotNull(ps_suppkey) }
    └── StreamRowIdGen { row_id_index: 5 }
        └── StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] } { tables: [ Source: 10 ] }

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { tables: [ HashJoinLeft: 15, HashJoinDegreeLeft: 16, HashJoinRight: 17, HashJoinDegreeRight: 18 ] }
    ├── StreamExchange Hash([0]) from 6
    └── StreamExchange Hash([3]) from 7

    Fragment 6
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 19 ] }

    Fragment 7
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 20 ] }

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id] } { tables: [ HashJoinLeft: 21, HashJoinDegreeLeft: 22, HashJoinRight: 23, HashJoinDegreeRight: 24 ] }
    ├── StreamExchange Hash([0]) from 9
    └── StreamExchange Hash([0]) from 10

    Fragment 9
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 25 ] }

    Fragment 10
    StreamFilter { predicate: IsNotNull(l_partkey) }
    └── StreamRowIdGen { row_id_index: 16 }
        └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] } { tables: [ Source: 26 ] }

    Table 0 { columns: [ n_name, $expr1, sum($expr2), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 1 { columns: [ p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $2 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 4 }

    Table 2 { columns: [ p_partkey, ps_suppkey, ps_partkey, ps_suppkey_0, _row_id, _row_id_0, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 3 ], read pk prefix len hint: 4 }

    Table 3
    ├── columns: [ n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC, $3 ASC, $1 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC, $13 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 4

    Table 4 { columns: [ l_partkey, l_suppkey, l_partkey_0, s_suppkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 3 ], read pk prefix len hint: 4 }

    Table 5 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ p_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ ps_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 10 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 11 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id_0, _rw_timestamp ], primary key: [ $2 ASC, $6 ASC, $8 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 14 { columns: [ l_suppkey, _row_id, _row_id_0, o_orderkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 21 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ o_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 24 { columns: [ l_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 26 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ nation, o_year, sum_profit, _rw_timestamp ], primary key: [ $0 ASC, $1 DESC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

- id: tpch_q20
  before:
  - create_tables
  sql: |
    select
      s_name,
      s_address
    from
      supplier,
      nation
    where
      s_suppkey in (
        select
          ps_suppkey
        from
          partsupp
        where
          ps_partkey in (
            select
              p_partkey
            from
              part
          )
          and ps_availqty > (
            select
              0.5 * sum(l_quantity)
            from
              lineitem
            where
              l_partkey = ps_partkey
              and l_suppkey = ps_suppkey
          )
      )
      and s_nationkey = n_nationkey
    order by
      s_name;
  logical_plan: |-
    LogicalProject { exprs: [s_name, s_address] }
    └─LogicalFilter { predicate: (s_nationkey = n_nationkey) }
      └─LogicalApply { type: LeftSemi, on: (s_suppkey = ps_suppkey), correlated_id: 1 }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─LogicalProject { exprs: [ps_suppkey] }
          └─LogicalFilter { predicate: (ps_availqty::Decimal > $expr1) }
            └─LogicalApply { type: LeftOuter, on: true, correlated_id: 3, max_one_row: true }
              ├─LogicalApply { type: LeftSemi, on: (ps_partkey = p_partkey), correlated_id: 2 }
              │ ├─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
              │ └─LogicalProject { exprs: [p_partkey] }
              │   └─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
              └─LogicalProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr1] }
                └─LogicalAgg { aggs: [sum(l_quantity)] }
                  └─LogicalProject { exprs: [l_quantity] }
                    └─LogicalFilter { predicate: (l_partkey = CorrelatedInputRef { index: 0, correlated_id: 3 }) AND (l_suppkey = CorrelatedInputRef { index: 1, correlated_id: 3 }) }
                      └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (s_suppkey = ps_suppkey), output: [s_name, s_address] }
    ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [s_suppkey, s_name, s_address] }
    │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
    └─LogicalJoin { type: Inner, on: (ps_partkey = l_partkey) AND (ps_suppkey = l_suppkey) AND ($expr1 > $expr2), output: [ps_suppkey] }
      ├─LogicalProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1] }
      │ └─LogicalJoin { type: LeftSemi, on: (ps_partkey = p_partkey), output: [ps_partkey, ps_suppkey, ps_availqty] }
      │   ├─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
      │   └─LogicalProject { exprs: [p_partkey] }
      │     └─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
      └─LogicalProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr2, l_partkey, l_suppkey] }
        └─LogicalAgg { group_key: [l_partkey, l_suppkey], aggs: [sum(l_quantity)] }
          └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [s_name ASC], dist: Single }
    └─BatchSort { order: [s_name ASC] }
      └─BatchHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address] }
        ├─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address] }
        │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │   │ └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
          └─BatchHashJoin { type: Inner, predicate: ps_partkey = l_partkey AND ps_suppkey = l_suppkey AND ($expr1 > $expr2), output: [ps_suppkey] }
            ├─BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
            │ └─BatchProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1] }
            │   └─BatchHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty] }
            │     ├─BatchExchange { order: [], dist: HashShard(ps_partkey) }
            │     │ └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
            │     └─BatchExchange { order: [], dist: HashShard(p_partkey) }
            │       └─BatchProject { exprs: [p_partkey] }
            │         └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
            └─BatchProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr2, l_partkey, l_suppkey] }
              └─BatchHashAgg { group_key: [l_partkey, l_suppkey], aggs: [sum(l_quantity)] }
                └─BatchExchange { order: [], dist: HashShard(l_partkey, l_suppkey) }
                  └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden), s_nationkey(hidden), s_suppkey(hidden)], stream_key: [_row_id, _row_id#1, s_nationkey, s_suppkey], pk_columns: [s_name, _row_id, _row_id#1, s_nationkey, s_suppkey], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(_row_id, _row_id, s_nationkey, s_suppkey) }
      └─StreamHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address, _row_id, _row_id, s_nationkey, s_suppkey] }
        ├─StreamExchange { dist: HashShard(s_suppkey) }
        │ └─StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id] }
        │   ├─StreamExchange { dist: HashShard(s_nationkey) }
        │   │ └─StreamRowIdGen { row_id_index: 7 }
        │   │   └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
        │   └─StreamExchange { dist: HashShard(n_nationkey) }
        │     └─StreamRowIdGen { row_id_index: 4 }
        │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
        └─StreamExchange { dist: HashShard(ps_suppkey) }
          └─StreamProject { exprs: [ps_suppkey, _row_id, ps_partkey, l_partkey, l_suppkey] }
            └─StreamFilter { predicate: ($expr1 > $expr2) }
              └─StreamHashJoin { type: Inner, predicate: ps_partkey = l_partkey AND ps_suppkey = l_suppkey, output: all }
                ├─StreamExchange { dist: HashShard(ps_partkey, ps_suppkey) }
                │ └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1, _row_id] }
                │   └─StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] }
                │     ├─StreamExchange { dist: HashShard(ps_partkey) }
                │     │ └─StreamRowIdGen { row_id_index: 5 }
                │     │   └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                │     └─StreamExchange { dist: HashShard(p_partkey) }
                │       └─StreamProject { exprs: [p_partkey, _row_id] }
                │         └─StreamRowIdGen { row_id_index: 9 }
                │           └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                └─StreamProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr2, l_partkey, l_suppkey] }
                  └─StreamHashAgg [append_only] { group_key: [l_partkey, l_suppkey], aggs: [sum(l_quantity), count] }
                    └─StreamExchange { dist: HashShard(l_partkey, l_suppkey) }
                      └─StreamRowIdGen { row_id_index: 16 }
                        └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden), s_nationkey(hidden), s_suppkey(hidden)], stream_key: [_row_id, _row_id#1, s_nationkey, s_suppkey], pk_columns: [s_name, _row_id, _row_id#1, s_nationkey, s_suppkey], pk_conflict: NoCheck }
    └── StreamExchange Hash([2, 3, 4, 5]) from 1

    Fragment 1
    StreamHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address, _row_id, _row_id, s_nationkey, s_suppkey] } { tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ] }
    ├── StreamExchange Hash([0]) from 2
    └── StreamExchange Hash([0]) from 5

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id] } { tables: [ HashJoinLeft: 4, HashJoinDegreeLeft: 5, HashJoinRight: 6, HashJoinDegreeRight: 7 ] }
    ├── StreamExchange Hash([3]) from 3
    └── StreamExchange Hash([0]) from 4

    Fragment 3
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 8 ] }

    Fragment 4
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 9 ] }

    Fragment 5
    StreamProject { exprs: [ps_suppkey, _row_id, ps_partkey, l_partkey, l_suppkey] }
    └── StreamFilter { predicate: ($expr1 > $expr2) }
        └── StreamHashJoin { type: Inner, predicate: ps_partkey = l_partkey AND ps_suppkey = l_suppkey, output: all } { tables: [ HashJoinLeft: 10, HashJoinDegreeLeft: 11, HashJoinRight: 12, HashJoinDegreeRight: 13 ] }
            ├── StreamExchange Hash([0, 1]) from 6
            └── StreamProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr2, l_partkey, l_suppkey] }
                └── StreamHashAgg [append_only] { group_key: [l_partkey, l_suppkey], aggs: [sum(l_quantity), count] } { tables: [ HashAggState: 20 ] }
                    └── StreamExchange Hash([1, 2]) from 9

    Fragment 6
    StreamProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1, _row_id] }
    └── StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] } { tables: [ HashJoinLeft: 14, HashJoinDegreeLeft: 15, HashJoinRight: 16, HashJoinDegreeRight: 17 ] }
        ├── StreamExchange Hash([0]) from 7
        └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamRowIdGen { row_id_index: 5 }
    └── StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] } { tables: [ Source: 18 ] }

    Fragment 8
    StreamProject { exprs: [p_partkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 9 }
        └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { tables: [ Source: 19 ] }

    Fragment 9
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
        └── tables: [ Source: 21 ]

    Table 0 { columns: [ s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ s_suppkey, _row_id, _row_id_0, s_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ ps_suppkey, _row_id, ps_partkey, l_partkey, l_suppkey, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ ps_suppkey, _row_id, ps_partkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 9 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 10 { columns: [ ps_partkey, ps_suppkey, $expr1, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 11 { columns: [ ps_partkey, ps_suppkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 12 { columns: [ $expr2, l_partkey, l_suppkey, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1, 2 ], read pk prefix len hint: 2 }

    Table 13 { columns: [ l_partkey, l_suppkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 14 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ ps_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ p_partkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ p_partkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ l_partkey, l_suppkey, sum(l_quantity), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 21 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_name, s_address, _row_id, _row_id#1, s_nationkey, s_suppkey, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2, 3, 4, 5 ], read pk prefix len hint: 5 }

- id: tpch_q21
  before:
  - create_tables
  sql: |
    select
      s_name,
      count(*) as numwait
    from
      supplier,
      lineitem l1,
      orders,
      nation
    where
      s_suppkey = l1.l_suppkey
      and o_orderkey = l1.l_orderkey
      and l1.l_receiptdate > l1.l_commitdate
      and exists (
        select
          *
        from
          lineitem l2
        where
          l2.l_orderkey = l1.l_orderkey
          and l2.l_suppkey <> l1.l_suppkey
      )
      and not exists (
        select
          *
        from
          lineitem l3
        where
          l3.l_orderkey = l1.l_orderkey
          and l3.l_suppkey <> l1.l_suppkey
          and l3.l_receiptdate > l3.l_commitdate
      )
      and s_nationkey = n_nationkey
    group by
      s_name
    order by
      numwait desc,
      s_name;
  logical_plan: |-
    LogicalProject { exprs: [s_name, count] }
    └─LogicalAgg { group_key: [s_name], aggs: [count] }
      └─LogicalProject { exprs: [s_name] }
        └─LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (o_orderkey = l_orderkey) AND (l_receiptdate > l_commitdate) AND (s_nationkey = n_nationkey) }
          └─LogicalApply { type: LeftAnti, on: true, correlated_id: 2 }
            ├─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
            │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            │ └─LogicalProject { exprs: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
            │   └─LogicalFilter { predicate: (l_orderkey = CorrelatedInputRef { index: 8, correlated_id: 1 }) AND (l_suppkey <> CorrelatedInputRef { index: 10, correlated_id: 1 }) }
            │     └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            └─LogicalProject { exprs: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
              └─LogicalFilter { predicate: (l_orderkey = CorrelatedInputRef { index: 8, correlated_id: 2 }) AND (l_suppkey <> CorrelatedInputRef { index: 10, correlated_id: 2 }) AND (l_receiptdate > l_commitdate) }
                └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [s_name], aggs: [count] }
    └─LogicalJoin { type: LeftAnti, on: (l_orderkey = l_orderkey) AND (l_suppkey <> l_suppkey), output: [s_name] }
      ├─LogicalJoin { type: LeftSemi, on: (l_orderkey = l_orderkey) AND (l_suppkey <> l_suppkey), output: all }
      │ ├─LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [s_name, l_orderkey, l_suppkey] }
      │ │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [s_name, l_orderkey, l_suppkey] }
      │ │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [s_name, s_nationkey, l_orderkey, l_suppkey] }
      │ │ │ │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
      │ │ │ │ └─LogicalFilter { predicate: (l_receiptdate > l_commitdate) }
      │ │ │ │   └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
      │ │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
      │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
      │ └─LogicalProject { exprs: [l_orderkey, l_suppkey] }
      │   └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
      └─LogicalProject { exprs: [l_orderkey, l_suppkey] }
        └─LogicalFilter { predicate: (l_receiptdate > l_commitdate) }
          └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  batch_plan: |-
    BatchExchange { order: [count DESC, s_name ASC], dist: Single }
    └─BatchSort { order: [count DESC, s_name ASC] }
      └─BatchHashAgg { group_key: [s_name], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(s_name) }
          └─BatchHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name] }
            ├─BatchHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: all }
            │ ├─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [s_name, l_orderkey, l_suppkey] }
            │ │ ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
            │ │ │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_name, l_orderkey, l_suppkey] }
            │ │ │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
            │ │ │   │ └─BatchHashJoin { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, s_nationkey, l_orderkey, l_suppkey] }
            │ │ │   │   ├─BatchExchange { order: [], dist: HashShard(s_suppkey) }
            │ │ │   │   │ └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │ │ │   │   └─BatchExchange { order: [], dist: HashShard(l_suppkey) }
            │ │ │   │     └─BatchFilter { predicate: (l_receiptdate > l_commitdate) }
            │ │ │   │       └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            │ │ │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
            │ │ │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            │ │ └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
            │ │   └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
            │ └─BatchExchange { order: [], dist: HashShard(l_orderkey) }
            │   └─BatchProject { exprs: [l_orderkey, l_suppkey] }
            │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            └─BatchExchange { order: [], dist: HashShard(l_orderkey) }
              └─BatchProject { exprs: [l_orderkey, l_suppkey] }
                └─BatchFilter { predicate: (l_receiptdate > l_commitdate) }
                  └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: NoCheck }
    └─StreamHashAgg { group_key: [s_name], aggs: [count] }
      └─StreamExchange { dist: HashShard(s_name) }
        └─StreamHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, l_orderkey] }
          ├─StreamHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
          │ ├─StreamExchange { dist: HashShard(l_orderkey) }
          │ │ └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, o_orderkey] }
          │ │   ├─StreamExchange { dist: HashShard(s_suppkey) }
          │ │   │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [s_suppkey, s_name, _row_id, n_nationkey, _row_id] }
          │ │   │   ├─StreamExchange { dist: HashShard(n_nationkey) }
          │ │   │   │ └─StreamRowIdGen { row_id_index: 4 }
          │ │   │   │   └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
          │ │   │   └─StreamExchange { dist: HashShard(s_nationkey) }
          │ │   │     └─StreamRowIdGen { row_id_index: 7 }
          │ │   │       └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
          │ │   └─StreamExchange { dist: HashShard(l_suppkey) }
          │ │     └─StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id] }
          │ │       ├─StreamExchange { dist: HashShard(o_orderkey) }
          │ │       │ └─StreamRowIdGen { row_id_index: 9 }
          │ │       │   └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
          │ │       └─StreamExchange { dist: HashShard(l_orderkey) }
          │ │         └─StreamFilter { predicate: (l_receiptdate > l_commitdate) }
          │ │           └─StreamShare { id: 11 }
          │ │             └─StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
          │ │               └─StreamRowIdGen { row_id_index: 16 }
          │ │                 └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
          │ └─StreamExchange { dist: HashShard(l_orderkey) }
          │   └─StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
          │     └─StreamShare { id: 11 }
          │       └─StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
          │         └─StreamRowIdGen { row_id_index: 16 }
          │           └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
          └─StreamExchange { dist: HashShard(l_orderkey) }
            └─StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
              └─StreamFilter { predicate: (l_receiptdate > l_commitdate) }
                └─StreamShare { id: 11 }
                  └─StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
                    └─StreamRowIdGen { row_id_index: 16 }
                      └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: NoCheck }
    └── StreamHashAgg { group_key: [s_name], aggs: [count] } { tables: [ HashAggState: 0 ] }
        └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, l_orderkey] }
    ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
    ├── StreamHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
    │   ├── tables: [ HashJoinLeft: 5, HashJoinDegreeLeft: 6, HashJoinRight: 7, HashJoinDegreeRight: 8 ]
    │   ├── StreamExchange Hash([1]) from 2
    │   └── StreamExchange Hash([0]) from 10
    └── StreamExchange Hash([0]) from 11

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, o_orderkey] }
    ├── tables: [ HashJoinLeft: 9, HashJoinDegreeLeft: 10, HashJoinRight: 11, HashJoinDegreeRight: 12 ]
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([1]) from 6

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [s_suppkey, s_name, _row_id, n_nationkey, _row_id] }
    ├── tables: [ HashJoinLeft: 13, HashJoinDegreeLeft: 14, HashJoinRight: 15, HashJoinDegreeRight: 16 ]
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([3]) from 5

    Fragment 4
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { tables: [ Source: 17 ] }

    Fragment 5
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { tables: [ Source: 18 ] }

    Fragment 6
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id] }
    ├── tables: [ HashJoinLeft: 19, HashJoinDegreeLeft: 20, HashJoinRight: 21, HashJoinDegreeRight: 22 ]
    ├── StreamExchange Hash([0]) from 7
    └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { tables: [ Source: 23 ] }

    Fragment 8
    StreamFilter { predicate: (l_receiptdate > l_commitdate) }
    └── StreamExchange NoShuffle from 9

    Fragment 9
    StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
    └── StreamRowIdGen { row_id_index: 16 }
        └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            └── tables: [ Source: 24 ]

    Fragment 10
    StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
    └── StreamExchange NoShuffle from 9

    Fragment 11
    StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
    └── StreamFilter { predicate: (l_receiptdate > l_commitdate) }
        └── StreamExchange NoShuffle from 9

    Table 0 { columns: [ s_name, count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 2
    ├── columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ]
    ├── value indices: [ 8 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 3 { columns: [ l_orderkey, l_suppkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ l_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, o_orderkey, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $3 ASC, $4 ASC, $5 ASC, $7 ASC, $8 ASC, $9 ASC, $6 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 6
    ├── columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ]
    ├── value indices: [ 8 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 7 { columns: [ l_orderkey, l_suppkey, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ l_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ s_suppkey, s_name, _row_id, n_nationkey, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id_0, _rw_timestamp ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ l_suppkey, _row_id, _row_id_0, o_orderkey, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 14 { columns: [ n_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ s_nationkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 18 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 19
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 20 { columns: [ o_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ l_orderkey, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 24 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_name, numwait, _rw_timestamp ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

