# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    CREATE SOURCE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR,
            s_address VARCHAR,
            s_nationkey INTEGER,
            s_phone VARCHAR,
            s_acctbal NUMERIC,
            s_comment VARCHAR
    ) WITH( connector = 'datagen' ) ROW FORMAT JSON;

    CREATE SOURCE part (
            p_partkey INTEGER,
            p_name VARCHAR,
            p_mfgr VARCHAR,
            p_brand VARCHAR,
            p_type VARCHAR,
            p_size INTEGER,
            p_container VARCHAR,
            p_retailprice NUMERIC,
            p_comment VARCHAR
    ) WITH( connector = 'datagen' ) ROW FORMAT JSON;

    CREATE SOURCE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR
    ) WITH( connector = 'datagen' ) ROW FORMAT JSON;

    CREATE SOURCE customer (
            c_custkey INTEGER,
            c_name VARCHAR,
            c_address VARCHAR,
            c_nationkey INTEGER,
            c_phone VARCHAR,
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR,
            c_comment VARCHAR
    ) WITH( connector = 'datagen' ) ROW FORMAT JSON;

    CREATE SOURCE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR,
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR,
            o_clerk VARCHAR,
            o_shippriority INTEGER,
            o_comment VARCHAR
    ) WITH( connector = 'datagen' ) ROW FORMAT JSON;

    CREATE SOURCE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR,
            l_linestatus VARCHAR,
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR,
            l_shipmode VARCHAR,
            l_comment VARCHAR
    ) WITH( connector = 'datagen' ) ROW FORMAT JSON;

    CREATE SOURCE nation (
            n_nationkey INTEGER,
            n_name VARCHAR,
            n_regionkey INTEGER,
            n_comment VARCHAR
    ) WITH( connector = 'datagen' ) ROW FORMAT JSON;

    CREATE SOURCE region (
            r_regionkey INTEGER,
            r_name VARCHAR,
            r_comment VARCHAR
    ) WITH( connector = 'datagen' ) ROW FORMAT JSON;
- id: tpch_q2
  before:
  - create_tables
  sql: |
    select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
    from
        part,
        supplier,
        partsupp,
        nation,
        region
    where
            p_partkey = ps_partkey
            and s_suppkey = ps_suppkey
            and s_nationkey = n_nationkey
            and n_regionkey = r_regionkey
            and ps_supplycost = (
                    select
                            min(ps_supplycost)
                    from
                            partsupp,
                            supplier,
                            nation,
                            region
                    where
                            p_partkey = ps_partkey
                            and s_suppkey = ps_suppkey
                            and s_nationkey = n_nationkey
                            and n_regionkey = r_regionkey
            )
    order by
          s_acctbal desc,
          n_name,
          s_name,
          p_partkey;
  logical_plan: |-
    LogicalProject { exprs: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
    └──LogicalFilter { predicate: (p_partkey = ps_partkey) AND (s_suppkey = ps_suppkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) AND (ps_supplycost = min(ps_supplycost)) }
       └──LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
          ├──LogicalJoin { type: Inner, on: true, output: all }
          │  ├──LogicalJoin { type: Inner, on: true, output: all }
          │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
          │  │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
          │  │  │  │  ├──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  │  │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  │  │  └──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  └──LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
          └──LogicalProject { exprs: [min(ps_supplycost)] }
             └──LogicalAgg { aggs: [min(ps_supplycost)] }
                └──LogicalProject { exprs: [ps_supplycost] }
                   └──LogicalFilter { predicate: (CorrelatedInputRef { index: 0, correlated_id: 1 } = ps_partkey) AND (s_suppkey = ps_suppkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) }
                      └──LogicalJoin { type: Inner, on: true, output: all }
                         ├──LogicalJoin { type: Inner, on: true, output: all }
                         │  ├──LogicalJoin { type: Inner, on: true, output: all }
                         │  │  ├──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
                         │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
                         │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
                         └──LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
    ├──LogicalJoin { type: Inner, on: IsNotDistinctFrom(p_partkey, p_partkey) AND (ps_supplycost = min(ps_supplycost)), output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
    │  ├──LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
    │  │  ├──LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
    │  │  │  ├──LogicalJoin { type: Inner, on: (p_partkey = ps_partkey), output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost] }
    │  │  │  │  ├──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │  │  │  │  └──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │  │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │  │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │  └──LogicalAgg { group_key: [p_partkey], aggs: [min(ps_supplycost)] }
    │     └──LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(p_partkey, ps_partkey), output: [p_partkey, ps_supplycost] }
    │        ├──LogicalAgg { group_key: [p_partkey], aggs: [] }
    │        │  └──LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [p_partkey] }
    │        │     ├──LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [p_partkey, n_regionkey] }
    │        │     │  ├──LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [p_partkey, s_nationkey] }
    │        │     │  │  ├──LogicalJoin { type: Inner, on: (p_partkey = ps_partkey), output: [p_partkey, ps_suppkey] }
    │        │     │  │  │  ├──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │        │     │  │  │  └──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │        │     │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │        │     │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │        │     └──LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │        └──LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [ps_partkey, ps_supplycost] }
    │           ├──LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [ps_partkey, ps_supplycost, n_regionkey] }
    │           │  ├──LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [ps_partkey, ps_supplycost, s_nationkey] }
    │           │  │  ├──LogicalFilter { predicate: IsNotNull(ps_partkey) }
    │           │  │  │  └──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │           │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │           │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │           └──LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
    └──LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], dist: Single }
    └──BatchSort { order: [s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC] }
       └──BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
          ├──BatchExchange { order: [], dist: HashShard(n_regionkey) }
          │  └──BatchHashJoin { type: Inner, predicate: p_partkey IS NOT DISTINCT FROM p_partkey AND ps_supplycost = min(ps_supplycost), output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
          │     ├──BatchExchange { order: [], dist: HashShard(p_partkey) }
          │     │  └──BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
          │     │     ├──BatchExchange { order: [], dist: HashShard(s_nationkey) }
          │     │     │  └──BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
          │     │     │     ├──BatchExchange { order: [], dist: HashShard(ps_suppkey) }
          │     │     │     │  └──BatchHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost] }
          │     │     │     │     ├──BatchExchange { order: [], dist: HashShard(p_partkey) }
          │     │     │     │     │  └──BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
          │     │     │     │     └──BatchExchange { order: [], dist: HashShard(ps_partkey) }
          │     │     │     │        └──BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
          │     │     │     └──BatchExchange { order: [], dist: HashShard(s_suppkey) }
          │     │     │        └──BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
          │     │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
          │     │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
          │     └──BatchHashAgg { group_key: [p_partkey], aggs: [min(ps_supplycost)] }
          │        └──BatchHashJoin { type: LeftOuter, predicate: p_partkey IS NOT DISTINCT FROM ps_partkey, output: [p_partkey, ps_supplycost] }
          │           ├──BatchHashAgg { group_key: [p_partkey], aggs: [] }
          │           │  └──BatchExchange { order: [], dist: HashShard(p_partkey) }
          │           │     └──BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [p_partkey] }
          │           │        ├──BatchExchange { order: [], dist: HashShard(n_regionkey) }
          │           │        │  └──BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [p_partkey, n_regionkey] }
          │           │        │     ├──BatchExchange { order: [], dist: HashShard(s_nationkey) }
          │           │        │     │  └──BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, s_nationkey] }
          │           │        │     │     ├──BatchExchange { order: [], dist: HashShard(ps_suppkey) }
          │           │        │     │     │  └──BatchHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_suppkey] }
          │           │        │     │     │     ├──BatchExchange { order: [], dist: HashShard(p_partkey) }
          │           │        │     │     │     │  └──BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
          │           │        │     │     │     └──BatchExchange { order: [], dist: HashShard(ps_partkey) }
          │           │        │     │     │        └──BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
          │           │        │     │     └──BatchExchange { order: [], dist: HashShard(s_suppkey) }
          │           │        │     │        └──BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
          │           │        │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
          │           │        │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
          │           │        └──BatchExchange { order: [], dist: HashShard(r_regionkey) }
          │           │           └──BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
          │           └──BatchExchange { order: [], dist: HashShard(ps_partkey) }
          │              └──BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [ps_partkey, ps_supplycost] }
          │                 ├──BatchExchange { order: [], dist: HashShard(n_regionkey) }
          │                 │  └──BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_partkey, ps_supplycost, n_regionkey] }
          │                 │     ├──BatchExchange { order: [], dist: HashShard(s_nationkey) }
          │                 │     │  └──BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey] }
          │                 │     │     ├──BatchExchange { order: [], dist: HashShard(ps_suppkey) }
          │                 │     │     │  └──BatchFilter { predicate: IsNotNull(ps_partkey) }
          │                 │     │     │     └──BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
          │                 │     │     └──BatchExchange { order: [], dist: HashShard(s_suppkey) }
          │                 │     │        └──BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
          │                 │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
          │                 │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
          │                 └──BatchExchange { order: [], dist: HashShard(r_regionkey) }
          │                    └──BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
          └──BatchExchange { order: [], dist: HashShard(r_regionkey) }
             └──BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize
    ├──columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), _row_id#1(hidden), r_regionkey(hidden), _row_id#2(hidden), _row_id#3(hidden), _row_id#4(hidden), ps_suppkey(hidden), n_nationkey(hidden), ps_supplycost(hidden), p_partkey#1(hidden)]
    ├──stream_key: [_row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, p_partkey, _row_id#4, ps_suppkey, n_nationkey, p_partkey#1, ps_supplycost]
    ├──pk_columns: [s_acctbal, n_name, s_name, p_partkey, _row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, _row_id#4, ps_suppkey, n_nationkey, p_partkey#1, ps_supplycost]
    ├──pk_conflict: NoCheck
    └──StreamHashJoin { type: Inner, predicate: p_partkey IS NOT DISTINCT FROM p_partkey AND ps_supplycost = min(ps_supplycost), output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, _row_id, r_regionkey, _row_id, _row_id, _row_id, ps_suppkey, n_nationkey, ps_supplycost, p_partkey] }
       ├──StreamExchange { dist: HashShard(p_partkey) }
       │  └──StreamShare { id: 26 }
       │     └──StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, ps_supplycost, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, _row_id, ps_suppkey] }
       │        ├──StreamExchange { dist: HashShard(n_nationkey) }
       │        │  └──StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
       │        │     ├──StreamExchange { dist: HashShard(r_regionkey) }
       │        │     │  └──StreamShare { id: 3 }
       │        │     │     └──StreamProject { exprs: [r_regionkey, _row_id] }
       │        │     │        └──StreamRowIdGen { row_id_index: 3 }
       │        │     │           └──StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
       │        │     └──StreamExchange { dist: HashShard(n_regionkey) }
       │        │        └──StreamShare { id: 7 }
       │        │           └──StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
       │        │              └──StreamRowIdGen { row_id_index: 4 }
       │        │                 └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
       │        └──StreamExchange { dist: HashShard(s_nationkey) }
       │           └──StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _row_id, ps_suppkey, _row_id] }
       │              ├──StreamExchange { dist: HashShard(ps_suppkey) }
       │              │  └──StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost, _row_id, _row_id] }
       │              │     ├──StreamExchange { dist: HashShard(p_partkey) }
       │              │     │  └──StreamRowIdGen { row_id_index: 9 }
       │              │     │     └──StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
       │              │     └──StreamExchange { dist: HashShard(ps_partkey) }
       │              │        └──StreamShare { id: 15 }
       │              │           └──StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
       │              │              └──StreamRowIdGen { row_id_index: 5 }
       │              │                 └──StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
       │              └──StreamExchange { dist: HashShard(s_suppkey) }
       │                 └──StreamShare { id: 21 }
       │                    └──StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
       │                       └──StreamRowIdGen { row_id_index: 7 }
       │                          └──StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
       └──StreamProject { exprs: [p_partkey, min(ps_supplycost)] }
          └──StreamHashAgg { group_key: [p_partkey], aggs: [min(ps_supplycost), count] }
             └──StreamHashJoin { type: LeftOuter, predicate: p_partkey IS NOT DISTINCT FROM ps_partkey, output: [p_partkey, ps_supplycost, _row_id, _row_id, ps_suppkey, _row_id, _row_id, r_regionkey, s_nationkey] }
                ├──StreamAppendOnlyDedup { dedup_cols: [p_partkey] }
                │  └──StreamExchange { dist: HashShard(p_partkey) }
                │     └──StreamProject { exprs: [p_partkey] }
                │        └──StreamShare { id: 26 }
                │           └──StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, ps_supplycost, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, _row_id, ps_suppkey] }
                │              ├──StreamExchange { dist: HashShard(n_nationkey) }
                │              │  └──StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
                │              │     ├──StreamExchange { dist: HashShard(r_regionkey) }
                │              │     │  └──StreamShare { id: 3 }
                │              │     │     └──StreamProject { exprs: [r_regionkey, _row_id] }
                │              │     │        └──StreamRowIdGen { row_id_index: 3 }
                │              │     │           └──StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                │              │     └──StreamExchange { dist: HashShard(n_regionkey) }
                │              │        └──StreamShare { id: 7 }
                │              │           └──StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                │              │              └──StreamRowIdGen { row_id_index: 4 }
                │              │                 └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                │              └──StreamExchange { dist: HashShard(s_nationkey) }
                │                 └──StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _row_id, ps_suppkey, _row_id] }
                │                    ├──StreamExchange { dist: HashShard(ps_suppkey) }
                │                    │  └──StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost, _row_id, _row_id] }
                │                    │     ├──StreamExchange { dist: HashShard(p_partkey) }
                │                    │     │  └──StreamRowIdGen { row_id_index: 9 }
                │                    │     │     └──StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                │                    │     └──StreamExchange { dist: HashShard(ps_partkey) }
                │                    │        └──StreamShare { id: 15 }
                │                    │           └──StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
                │                    │              └──StreamRowIdGen { row_id_index: 5 }
                │                    │                 └──StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                │                    └──StreamExchange { dist: HashShard(s_suppkey) }
                │                       └──StreamShare { id: 21 }
                │                          └──StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                │                             └──StreamRowIdGen { row_id_index: 7 }
                │                                └──StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                └──StreamExchange { dist: HashShard(ps_partkey) }
                   └──StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_partkey, ps_supplycost, _row_id, _row_id, ps_suppkey, s_nationkey, _row_id, _row_id, r_regionkey] }
                      ├──StreamExchange { dist: HashShard(s_nationkey) }
                      │  └──StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id] }
                      │     ├──StreamExchange { dist: HashShard(ps_suppkey) }
                      │     │  └──StreamFilter { predicate: IsNotNull(ps_partkey) }
                      │     │     └──StreamShare { id: 15 }
                      │     │        └──StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
                      │     │           └──StreamRowIdGen { row_id_index: 5 }
                      │     │              └──StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                      │     └──StreamExchange { dist: HashShard(s_suppkey) }
                      │        └──StreamShare { id: 21 }
                      │           └──StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                      │              └──StreamRowIdGen { row_id_index: 7 }
                      │                 └──StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                      └──StreamExchange { dist: HashShard(n_nationkey) }
                         └──StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] }
                            ├──StreamExchange { dist: HashShard(r_regionkey) }
                            │  └──StreamShare { id: 3 }
                            │     └──StreamProject { exprs: [r_regionkey, _row_id] }
                            │        └──StreamRowIdGen { row_id_index: 3 }
                            │           └──StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                            └──StreamExchange { dist: HashShard(n_regionkey) }
                               └──StreamShare { id: 7 }
                                  └──StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                                     └──StreamRowIdGen { row_id_index: 4 }
                                        └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), _row_id#1(hidden), r_regionkey(hidden), _row_id#2(hidden), _row_id#3(hidden), _row_id#4(hidden), ps_suppkey(hidden), n_nationkey(hidden), ps_supplycost(hidden), p_partkey#1(hidden)], stream_key: [_row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, p_partkey, _row_id#4, ps_suppkey, n_nationkey, p_partkey#1, ps_supplycost], pk_columns: [s_acctbal, n_name, s_name, p_partkey, _row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, _row_id#4, ps_suppkey, n_nationkey, p_partkey#1, ps_supplycost], pk_conflict: "NoCheck" }
    ├── materialized table: 4294967294
    └── StreamHashJoin { type: Inner, predicate: p_partkey IS NOT DISTINCT FROM p_partkey AND ps_supplycost = min(ps_supplycost), output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, _row_id, r_regionkey, _row_id, _row_id, _row_id, ps_suppkey, n_nationkey, ps_supplycost, p_partkey] } { left table: 0, right table: 2, left degree table: 1, right degree table: 3 }
        ├── StreamExchange Hash([0]) from 1
        └── StreamProject { exprs: [p_partkey, min(ps_supplycost)] }
            └── StreamHashAgg { group_key: [p_partkey], aggs: [min(ps_supplycost), count] } { result table: 26, state tables: [ 25 ], distinct tables: [] }
                └── StreamHashJoin { type: LeftOuter, predicate: p_partkey IS NOT DISTINCT FROM ps_partkey, output: [p_partkey, ps_supplycost, _row_id, _row_id, ps_suppkey, _row_id, _row_id, r_regionkey, s_nationkey] } { left table: 27, right table: 29, left degree table: 28, right degree table: 30 }
                    ├── StreamAppendOnlyDedup { dedup_cols: [p_partkey] } { state table: 31 }
                    │   └── StreamExchange Hash([0]) from 15
                    └── StreamExchange Hash([0]) from 16

    Fragment 1
    StreamNoOp
    └── StreamExchange NoShuffle from 2

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, ps_supplycost, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, _row_id, ps_suppkey] } { left table: 4, right table: 6, left degree table: 5, right degree table: 7 }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([5]) from 8

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] } { left table: 8, right table: 10, left degree table: 9, right degree table: 11 }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([2]) from 6

    Fragment 4
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 5
    StreamProject { exprs: [r_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 3 }
        └── StreamSource { source: "region", columns: ["r_regionkey", "r_name", "r_comment", "_row_id"] } { source state table: 12 }

    Fragment 6
    StreamNoOp
    └── StreamExchange NoShuffle from 7

    Fragment 7
    StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: "nation", columns: ["n_nationkey", "n_name", "n_regionkey", "n_comment", "_row_id"] } { source state table: 13 }

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _row_id, ps_suppkey, _row_id] } { left table: 14, right table: 16, left degree table: 15, right degree table: 17 }
    ├── StreamExchange Hash([2]) from 9
    └── StreamExchange Hash([0]) from 13

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost, _row_id, _row_id] } { left table: 18, right table: 20, left degree table: 19, right degree table: 21 }
    ├── StreamExchange Hash([0]) from 10
    └── StreamExchange Hash([0]) from 11

    Fragment 10
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: "part", columns: ["p_partkey", "p_name", "p_mfgr", "p_brand", "p_type", "p_size", "p_container", "p_retailprice", "p_comment", "_row_id"] } { source state table: 22 }

    Fragment 11
    StreamNoOp
    └── StreamExchange NoShuffle from 12

    Fragment 12
    StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
    └── StreamRowIdGen { row_id_index: 5 }
        └── StreamSource { source: "partsupp", columns: ["ps_partkey", "ps_suppkey", "ps_availqty", "ps_supplycost", "ps_comment", "_row_id"] } { source state table: 23 }

    Fragment 13
    StreamNoOp
    └── StreamExchange NoShuffle from 14

    Fragment 14
    StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    └── StreamRowIdGen { row_id_index: 7 }
        └── StreamSource { source: "supplier", columns: ["s_suppkey", "s_name", "s_address", "s_nationkey", "s_phone", "s_acctbal", "s_comment", "_row_id"] } { source state table: 24 }

    Fragment 15
    StreamProject { exprs: [p_partkey] }
    └── StreamExchange NoShuffle from 2

    Fragment 16
    StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_partkey, ps_supplycost, _row_id, _row_id, ps_suppkey, s_nationkey, _row_id, _row_id, r_regionkey] } { left table: 32, right table: 34, left degree table: 33, right degree table: 35 }
    ├── StreamExchange Hash([2]) from 17
    └── StreamExchange Hash([0]) from 20

    Fragment 17
    StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id] } { left table: 36, right table: 38, left degree table: 37, right degree table: 39 }
    ├── StreamExchange Hash([1]) from 18
    └── StreamExchange Hash([0]) from 19

    Fragment 18
    StreamFilter { predicate: IsNotNull(ps_partkey) }
    └── StreamExchange NoShuffle from 12

    Fragment 19
    StreamNoOp
    └── StreamExchange NoShuffle from 14

    Fragment 20
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] } { left table: 40, right table: 42, left degree table: 41, right degree table: 43 }
    ├── StreamExchange Hash([0]) from 21
    └── StreamExchange Hash([2]) from 22

    Fragment 21
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 22
    StreamNoOp
    └── StreamExchange NoShuffle from 7

    Table 0 { columns: [ p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, ps_supplycost, n_name, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1, _row_id_2, _row_id_3, ps_suppkey ], primary key: [ $0 ASC, $7 ASC, $9 ASC, $10 ASC, $11 ASC, $13 ASC, $14 ASC, $15 ASC, $16 ASC, $12 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 1 { columns: [ p_partkey, ps_supplycost, _row_id, _row_id_0, r_regionkey, _row_id_1, _row_id_2, _row_id_3, ps_suppkey, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 2 { columns: [ p_partkey, min(ps_supplycost) ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 3 { columns: [ p_partkey, min(ps_supplycost), _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 4 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0 ], primary key: [ $0 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ n_nationkey, _row_id, _row_id_0, r_regionkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _row_id_0, ps_suppkey, _row_id_1 ], primary key: [ $5 ASC, $9 ASC, $10 ASC, $0 ASC, $12 ASC, $11 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ s_nationkey, _row_id, _row_id_0, p_partkey, _row_id_1, ps_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ r_regionkey, _row_id ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ r_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ n_nationkey, n_name, n_regionkey, _row_id ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ n_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 13 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 14 { columns: [ p_partkey, p_mfgr, ps_suppkey, ps_supplycost, _row_id, _row_id_0 ], primary key: [ $2 ASC, $4 ASC, $5 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ ps_suppkey, _row_id, _row_id_0, p_partkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ s_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ p_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ ps_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 23 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 24 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 25 { columns: [ p_partkey, ps_supplycost, _row_id, _row_id_0, ps_suppkey, _row_id_1, _row_id_2, r_regionkey, s_nationkey ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 26 { columns: [ p_partkey, min(ps_supplycost), count ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ p_partkey ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ p_partkey, _degree ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 29 { columns: [ ps_partkey, ps_supplycost, _row_id, _row_id_0, ps_suppkey, s_nationkey, _row_id_1, _row_id_2, r_regionkey ], primary key: [ $0 ASC, $2 ASC, $3 ASC, $4 ASC, $6 ASC, $7 ASC, $8 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ ps_partkey, _row_id, _row_id_0, ps_suppkey, _row_id_1, _row_id_2, r_regionkey, s_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 31 { columns: [ p_partkey ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 32 { columns: [ ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id_0 ], primary key: [ $2 ASC, $3 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 33 { columns: [ s_nationkey, _row_id, _row_id_0, ps_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 34 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0 ], primary key: [ $0 ASC, $1 ASC, $3 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 35 { columns: [ n_nationkey, _row_id, _row_id_0, r_regionkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 36 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id ], primary key: [ $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 37 { columns: [ ps_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 38 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 39 { columns: [ s_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 40 { columns: [ r_regionkey, _row_id ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 41 { columns: [ r_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 42 { columns: [ n_nationkey, n_name, n_regionkey, _row_id ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 43 { columns: [ n_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, _row_id#4, ps_suppkey, n_nationkey, ps_supplycost, p_partkey#1 ], primary key: [ $0 DESC, $2 ASC, $1 ASC, $3 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC, $13 ASC, $14 ASC, $15 ASC, $17 ASC, $16 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ], distribution key: [ 3 ], read pk prefix len hint: 11 }

- id: tpch_q5
  before:
  - create_tables
  sql: |
    select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
    group by
      n_name
    order by
      revenue desc;
  logical_plan: |-
    LogicalProject { exprs: [n_name, sum($expr1)] }
    └──LogicalAgg { group_key: [n_name], aggs: [sum($expr1)] }
       └──LogicalProject { exprs: [n_name, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr1] }
          └──LogicalFilter { predicate: (c_custkey = o_custkey) AND (l_orderkey = o_orderkey) AND (l_suppkey = s_suppkey) AND (c_nationkey = s_nationkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) }
             └──LogicalJoin { type: Inner, on: true, output: all }
                ├──LogicalJoin { type: Inner, on: true, output: all }
                │  ├──LogicalJoin { type: Inner, on: true, output: all }
                │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                │  │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                │  │  │  │  ├──LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
                │  │  │  │  └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
                │  │  │  └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
                │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
                │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
                └──LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [n_name], aggs: [sum($expr1)] }
    └──LogicalProject { exprs: [n_name, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr1] }
       └──LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [l_extendedprice, l_discount, n_name] }
          ├──LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_extendedprice, l_discount, n_name, n_regionkey] }
          │  ├──LogicalJoin { type: Inner, on: (l_orderkey = o_orderkey) AND (l_suppkey = s_suppkey), output: [s_nationkey, l_extendedprice, l_discount] }
          │  │  ├──LogicalJoin { type: Inner, on: (c_nationkey = s_nationkey), output: [o_orderkey, s_suppkey, s_nationkey] }
          │  │  │  ├──LogicalJoin { type: Inner, on: (c_custkey = o_custkey), output: [c_nationkey, o_orderkey] }
          │  │  │  │  ├──LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  │  │  │  └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  │  └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
          └──LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [sum($expr1) DESC], dist: Single }
    └──BatchSort { order: [sum($expr1) DESC] }
       └──BatchHashAgg { group_key: [n_name], aggs: [sum($expr1)] }
          └──BatchExchange { order: [], dist: HashShard(n_name) }
             └──BatchProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1] }
                └──BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [l_extendedprice, l_discount, n_name] }
                   ├──BatchExchange { order: [], dist: HashShard(n_regionkey) }
                   │  └──BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_extendedprice, l_discount, n_name, n_regionkey] }
                   │     ├──BatchExchange { order: [], dist: HashShard(s_nationkey) }
                   │     │  └──BatchHashJoin { type: Inner, predicate: o_orderkey = l_orderkey AND s_suppkey = l_suppkey, output: [s_nationkey, l_extendedprice, l_discount] }
                   │     │     ├──BatchExchange { order: [], dist: HashShard(o_orderkey, s_suppkey) }
                   │     │     │  └──BatchHashJoin { type: Inner, predicate: c_nationkey = s_nationkey, output: [o_orderkey, s_suppkey, s_nationkey] }
                   │     │     │     ├──BatchExchange { order: [], dist: HashShard(c_nationkey) }
                   │     │     │     │  └──BatchHashJoin { type: Inner, predicate: c_custkey = o_custkey, output: [c_nationkey, o_orderkey] }
                   │     │     │     │     ├──BatchExchange { order: [], dist: HashShard(c_custkey) }
                   │     │     │     │     │  └──BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], filter: (None, None) }
                   │     │     │     │     └──BatchExchange { order: [], dist: HashShard(o_custkey) }
                   │     │     │     │        └──BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
                   │     │     │     └──BatchExchange { order: [], dist: HashShard(s_nationkey) }
                   │     │     │        └──BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
                   │     │     └──BatchExchange { order: [], dist: HashShard(l_orderkey, l_suppkey) }
                   │     │        └──BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
                   │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
                   │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
                   └──BatchExchange { order: [], dist: HashShard(r_regionkey) }
                      └──BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [revenue, n_name], pk_conflict: NoCheck }
    └──StreamProject { exprs: [n_name, sum($expr1)] }
       └──StreamHashAgg [append_only] { group_key: [n_name], aggs: [sum($expr1), count] }
          └──StreamExchange { dist: HashShard(n_name) }
             └──StreamProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1, _row_id, _row_id, r_regionkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey, n_nationkey] }
                └──StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey AND n_nationkey = c_nationkey, output: [n_name, l_extendedprice, l_discount, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey] }
                   ├──StreamExchange { dist: HashShard(n_nationkey, n_nationkey) }
                   │  └──StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
                   │     ├──StreamExchange { dist: HashShard(r_regionkey) }
                   │     │  └──StreamRowIdGen { row_id_index: 3 }
                   │     │     └──StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                   │     └──StreamExchange { dist: HashShard(n_regionkey) }
                   │        └──StreamFilter { predicate: (n_nationkey = n_nationkey) }
                   │           └──StreamRowIdGen { row_id_index: 4 }
                   │              └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                   └──StreamExchange { dist: HashShard(c_nationkey, s_nationkey) }
                      └──StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey AND c_nationkey = s_nationkey, output: [c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id, o_custkey, o_orderkey, _row_id, _row_id, l_suppkey] }
                         ├──StreamExchange { dist: HashShard(o_orderkey, c_nationkey) }
                         │  └──StreamHashJoin [append_only] { type: Inner, predicate: o_custkey = c_custkey, output: [o_orderkey, c_nationkey, _row_id, o_custkey, _row_id] }
                         │     ├──StreamExchange { dist: HashShard(o_custkey) }
                         │     │  └──StreamRowIdGen { row_id_index: 9 }
                         │     │     └──StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                         │     └──StreamExchange { dist: HashShard(c_custkey) }
                         │        └──StreamRowIdGen { row_id_index: 8 }
                         │           └──StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                         └──StreamExchange { dist: HashShard(l_orderkey, s_nationkey) }
                            └──StreamHashJoin [append_only] { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id] }
                               ├──StreamExchange { dist: HashShard(l_suppkey) }
                               │  └──StreamRowIdGen { row_id_index: 16 }
                               │     └──StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                               └──StreamExchange { dist: HashShard(s_suppkey) }
                                  └──StreamRowIdGen { row_id_index: 7 }
                                     └──StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [revenue, n_name], pk_conflict: "NoCheck" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [n_name, sum($expr1)] }
        └── StreamHashAgg [append_only] { group_key: [n_name], aggs: [sum($expr1), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1, _row_id, _row_id, r_regionkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey, n_nationkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey AND n_nationkey = c_nationkey, output: [n_name, l_extendedprice, l_discount, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey] }
        ├── left table: 1
        ├── right table: 3
        ├── left degree table: 2
        ├── right degree table: 4
        ├── StreamExchange Hash([0, 0]) from 2
        └── StreamExchange Hash([0, 3]) from 5

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] } { left table: 5, right table: 7, left degree table: 6, right degree table: 8 }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([2]) from 4

    Fragment 3
    StreamRowIdGen { row_id_index: 3 }
    └── StreamSource { source: "region", columns: ["r_regionkey", "r_name", "r_comment", "_row_id"] } { source state table: 9 }

    Fragment 4
    StreamFilter { predicate: (n_nationkey = n_nationkey) }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: "nation", columns: ["n_nationkey", "n_name", "n_regionkey", "n_comment", "_row_id"] } { source state table: 10 }

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey AND c_nationkey = s_nationkey, output: [c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id, o_custkey, o_orderkey, _row_id, _row_id, l_suppkey] }
    ├── left table: 11
    ├── right table: 13
    ├── left degree table: 12
    ├── right degree table: 14
    ├── StreamExchange Hash([0, 1]) from 6
    └── StreamExchange Hash([0, 3]) from 9

    Fragment 6
    StreamHashJoin [append_only] { type: Inner, predicate: o_custkey = c_custkey, output: [o_orderkey, c_nationkey, _row_id, o_custkey, _row_id] } { left table: 15, right table: 17, left degree table: 16, right degree table: 18 }
    ├── StreamExchange Hash([1]) from 7
    └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: "orders", columns: ["o_orderkey", "o_custkey", "o_orderstatus", "o_totalprice", "o_orderdate", "o_orderpriority", "o_clerk", "o_shippriority", "o_comment", "_row_id"] } { source state table: 19 }

    Fragment 8
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: "customer", columns: ["c_custkey", "c_name", "c_address", "c_nationkey", "c_phone", "c_acctbal", "c_mktsegment", "c_comment", "_row_id"] } { source state table: 20 }

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id] } { left table: 21, right table: 23, left degree table: 22, right degree table: 24 }
    ├── StreamExchange Hash([2]) from 10
    └── StreamExchange Hash([0]) from 11

    Fragment 10
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: "lineitem", columns: ["l_orderkey", "l_partkey", "l_suppkey", "l_linenumber", "l_quantity", "l_extendedprice", "l_discount", "l_tax", "l_returnflag", "l_linestatus", "l_shipdate", "l_commitdate", "l_receiptdate", "l_shipinstruct", "l_shipmode", "l_comment", "_row_id"] }
        └── source state table: 25

    Fragment 11
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: "supplier", columns: ["s_suppkey", "s_name", "s_address", "s_nationkey", "s_phone", "s_acctbal", "s_comment", "_row_id"] } { source state table: 26 }

    Table 0 { columns: [ n_name, sum($expr1), count ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0 ], primary key: [ $0 ASC, $0 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 0 ], read pk prefix len hint: 2 }

    Table 2 { columns: [ n_nationkey, n_nationkey_0, _row_id, _row_id_0, r_regionkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 1, 0 ], read pk prefix len hint: 2 }

    Table 3
    ├── columns: [ c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id_0, o_custkey, o_orderkey, _row_id_1, _row_id_2, l_suppkey ]
    ├── primary key: [ $3 ASC, $0 ASC, $4 ASC, $5 ASC, $6 ASC, $8 ASC, $9 ASC, $10 ASC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 0, 3 ]
    └── read pk prefix len hint: 2

    Table 4
    ├── columns: [ s_nationkey, c_nationkey, _row_id, _row_id_0, o_custkey, _row_id_1, _row_id_2, l_suppkey, o_orderkey, _degree ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC ]
    ├── value indices: [ 9 ]
    ├── distribution key: [ 1, 0 ]
    └── read pk prefix len hint: 2

    Table 5 { columns: [ r_regionkey, r_name, r_comment, _row_id ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ r_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id ], primary key: [ $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ n_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 10 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 11 { columns: [ o_orderkey, c_nationkey, _row_id, o_custkey, _row_id_0 ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 12 { columns: [ o_orderkey, c_nationkey, _row_id, _row_id_0, o_custkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 13 { columns: [ l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id_0 ], primary key: [ $0 ASC, $3 ASC, $4 ASC, $6 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0, 3 ], read pk prefix len hint: 2 }

    Table 14 { columns: [ l_orderkey, s_nationkey, _row_id, _row_id_0, l_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 15 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ], primary key: [ $1 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ o_custkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id ], primary key: [ $0 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ c_custkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 21
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 1

    Table 22 { columns: [ l_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ s_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 26 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ n_name, revenue ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: tpch_q7
  before:
  - create_tables
  sql: |
    select
      supp_nation,
      cust_nation,
      l_year,
      sum(volume) as revenue
    from
      (
        select
          n1.n_name as supp_nation,
          n2.n_name as cust_nation,
          extract(year from l_shipdate) as l_year,
          l_extendedprice * (1 - l_discount) as volume
        from
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2
        where
          s_suppkey = l_suppkey
          and o_orderkey = l_orderkey
          and c_custkey = o_custkey
          and s_nationkey = n1.n_nationkey
          and c_nationkey = n2.n_nationkey
      ) as shipping
    group by
      supp_nation,
      cust_nation,
      l_year
    order by
      supp_nation,
      cust_nation,
      l_year;
  logical_plan: |-
    LogicalProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
    └──LogicalAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
       └──LogicalProject { exprs: [n_name, n_name, $expr1, $expr2] }
          └──LogicalProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2] }
             └──LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (o_orderkey = l_orderkey) AND (c_custkey = o_custkey) AND (s_nationkey = n_nationkey) AND (c_nationkey = n_nationkey) }
                └──LogicalJoin { type: Inner, on: true, output: all }
                   ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  │  │  ├──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  │  │  └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  │  └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  └──LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
    └──LogicalProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2] }
       └──LogicalJoin { type: Inner, on: (c_nationkey = n_nationkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name] }
          ├──LogicalJoin { type: Inner, on: (c_custkey = o_custkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, c_nationkey] }
          │  ├──LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, o_custkey] }
          │  │  ├──LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name] }
          │  │  │  ├──LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [s_nationkey, l_orderkey, l_extendedprice, l_discount, l_shipdate] }
          │  │  │  │  ├──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  │  │  │  └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  │  │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  │  └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  └──LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
          └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [n_name ASC, n_name ASC, $expr1 ASC], dist: Single }
    └──BatchSort { order: [n_name ASC, n_name ASC, $expr1 ASC] }
       └──BatchHashAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
          └──BatchExchange { order: [], dist: HashShard(n_name, n_name, $expr1) }
             └──BatchProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2] }
                └──BatchHashJoin { type: Inner, predicate: c_nationkey = n_nationkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name] }
                   ├──BatchExchange { order: [], dist: HashShard(c_nationkey) }
                   │  └──BatchHashJoin { type: Inner, predicate: o_custkey = c_custkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, c_nationkey] }
                   │     ├──BatchExchange { order: [], dist: HashShard(o_custkey) }
                   │     │  └──BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, o_custkey] }
                   │     │     ├──BatchExchange { order: [], dist: HashShard(l_orderkey) }
                   │     │     │  └──BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name] }
                   │     │     │     ├──BatchExchange { order: [], dist: HashShard(s_nationkey) }
                   │     │     │     │  └──BatchHashJoin { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_nationkey, l_orderkey, l_extendedprice, l_discount, l_shipdate] }
                   │     │     │     │     ├──BatchExchange { order: [], dist: HashShard(s_suppkey) }
                   │     │     │     │     │  └──BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
                   │     │     │     │     └──BatchExchange { order: [], dist: HashShard(l_suppkey) }
                   │     │     │     │        └──BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
                   │     │     │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
                   │     │     │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
                   │     │     └──BatchExchange { order: [], dist: HashShard(o_orderkey) }
                   │     │        └──BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
                   │     └──BatchExchange { order: [], dist: HashShard(c_custkey) }
                   │        └──BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], filter: (None, None) }
                   └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
                      └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], stream_key: [supp_nation, cust_nation, l_year], pk_columns: [supp_nation, cust_nation, l_year], pk_conflict: NoCheck }
    └──StreamProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
       └──StreamHashAgg [append_only] { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2), count] }
          └──StreamExchange { dist: HashShard(n_name, n_name, $expr1) }
             └──StreamProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey, l_orderkey] }
                └──StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, l_shipdate, n_name, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, l_orderkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey] }
                   ├──StreamExchange { dist: HashShard(l_orderkey) }
                   │  └──StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id, n_nationkey, s_suppkey, _row_id] }
                   │     ├──StreamExchange { dist: HashShard(s_suppkey) }
                   │     │  └──StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                   │     │     ├──StreamExchange { dist: HashShard(n_nationkey) }
                   │     │     │  └──StreamShare { id: 3 }
                   │     │     │     └──StreamProject { exprs: [n_nationkey, n_name, _row_id] }
                   │     │     │        └──StreamRowIdGen { row_id_index: 4 }
                   │     │     │           └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                   │     │     └──StreamExchange { dist: HashShard(s_nationkey) }
                   │     │        └──StreamRowIdGen { row_id_index: 7 }
                   │     │           └──StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                   │     └──StreamExchange { dist: HashShard(l_suppkey) }
                   │        └──StreamRowIdGen { row_id_index: 16 }
                   │           └──StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                   └──StreamExchange { dist: HashShard(o_orderkey) }
                      └──StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, o_orderkey, _row_id, _row_id, n_nationkey, c_custkey, _row_id] }
                         ├──StreamExchange { dist: HashShard(c_custkey) }
                         │  └──StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [n_name, c_custkey, _row_id, n_nationkey, _row_id] }
                         │     ├──StreamExchange { dist: HashShard(n_nationkey) }
                         │     │  └──StreamShare { id: 3 }
                         │     │     └──StreamProject { exprs: [n_nationkey, n_name, _row_id] }
                         │     │        └──StreamRowIdGen { row_id_index: 4 }
                         │     │           └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                         │     └──StreamExchange { dist: HashShard(c_nationkey) }
                         │        └──StreamRowIdGen { row_id_index: 8 }
                         │           └──StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                         └──StreamExchange { dist: HashShard(o_custkey) }
                            └──StreamRowIdGen { row_id_index: 9 }
                               └──StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], stream_key: [supp_nation, cust_nation, l_year], pk_columns: [supp_nation, cust_nation, l_year], pk_conflict: "NoCheck" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
        └── StreamHashAgg [append_only] { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2), count] } { result table: 0, state tables: [], distinct tables: [] }
            └── StreamExchange Hash([0, 1, 2]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey, l_orderkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, l_shipdate, n_name, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, l_orderkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey] }
        ├── left table: 1
        ├── right table: 3
        ├── left degree table: 2
        ├── right degree table: 4
        ├── StreamExchange Hash([1]) from 2
        └── StreamExchange Hash([1]) from 8

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id, n_nationkey, s_suppkey, _row_id] }
    ├── left table: 5
    ├── right table: 7
    ├── left degree table: 6
    ├── right degree table: 8
    ├── StreamExchange Hash([1]) from 3
    └── StreamExchange Hash([2]) from 7

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { left table: 9, right table: 11, left degree table: 10, right degree table: 12 }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([3]) from 6

    Fragment 4
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 5
    StreamProject { exprs: [n_nationkey, n_name, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: "nation", columns: ["n_nationkey", "n_name", "n_regionkey", "n_comment", "_row_id"] } { source state table: 13 }

    Fragment 6
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: "supplier", columns: ["s_suppkey", "s_name", "s_address", "s_nationkey", "s_phone", "s_acctbal", "s_comment", "_row_id"] } { source state table: 14 }

    Fragment 7
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: "lineitem", columns: ["l_orderkey", "l_partkey", "l_suppkey", "l_linenumber", "l_quantity", "l_extendedprice", "l_discount", "l_tax", "l_returnflag", "l_linestatus", "l_shipdate", "l_commitdate", "l_receiptdate", "l_shipinstruct", "l_shipmode", "l_comment", "_row_id"] }
        └── source state table: 15

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, o_orderkey, _row_id, _row_id, n_nationkey, c_custkey, _row_id] } { left table: 16, right table: 18, left degree table: 17, right degree table: 19 }
    ├── StreamExchange Hash([1]) from 9
    └── StreamExchange Hash([1]) from 12

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [n_name, c_custkey, _row_id, n_nationkey, _row_id] } { left table: 20, right table: 22, left degree table: 21, right degree table: 23 }
    ├── StreamExchange Hash([0]) from 10
    └── StreamExchange Hash([3]) from 11

    Fragment 10
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 11
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: "customer", columns: ["c_custkey", "c_name", "c_address", "c_nationkey", "c_phone", "c_acctbal", "c_mktsegment", "c_comment", "_row_id"] } { source state table: 24 }

    Fragment 12
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: "orders", columns: ["o_orderkey", "o_custkey", "o_orderstatus", "o_totalprice", "o_orderdate", "o_orderpriority", "o_clerk", "o_shippriority", "o_comment", "_row_id"] } { source state table: 25 }

    Table 0 { columns: [ n_name, n_name_0, $expr1, sum($expr2), count ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 1
    ├── columns: [ n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1 ]
    ├── primary key: [ $1 ASC, $5 ASC, $6 ASC, $7 ASC, $9 ASC, $8 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 2 { columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, s_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ n_name, o_orderkey, _row_id, _row_id_0, n_nationkey, c_custkey, _row_id_1 ], primary key: [ $1 ASC, $2 ASC, $3 ASC, $4 ASC, $6 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ o_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, c_custkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 1

    Table 8 { columns: [ l_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ n_nationkey, n_name, _row_id ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 14 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 15 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 16 { columns: [ n_name, c_custkey, _row_id, n_nationkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ c_custkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ], primary key: [ $1 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ o_custkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ n_nationkey, n_name, _row_id ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id ], primary key: [ $3 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ c_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ supp_nation, cust_nation, l_year, revenue ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

- id: tpch_q8
  before:
  - create_tables
  sql: |
    select
      o_year,
      round(sum(case
        when nation != 'IRAN' then volume
        else 0
      end) / sum(volume), 6) as mkt_share
    from
      (
        select
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) as volume,
          n2.n_name as nation
        from
          part,
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2,
          region
        where
          p_partkey = l_partkey
          and s_suppkey = l_suppkey
          and l_orderkey = o_orderkey
          and o_custkey = c_custkey
          and c_nationkey = n1.n_nationkey
          and n1.n_regionkey = r_regionkey
          and s_nationkey = n2.n_nationkey
      ) as all_nations
    group by
      o_year
    order by
      o_year;
  logical_plan: |-
    LogicalProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
    └──LogicalAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
       └──LogicalProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Int32::Decimal) as $expr3, $expr2] }
          └──LogicalProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2, n_name] }
             └──LogicalFilter { predicate: (p_partkey = l_partkey) AND (s_suppkey = l_suppkey) AND (l_orderkey = o_orderkey) AND (o_custkey = c_custkey) AND (c_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) AND (s_nationkey = n_nationkey) }
                └──LogicalJoin { type: Inner, on: true, output: all }
                   ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  │  │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  │  │  │  │  ├──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  │  │  │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  │  │  │  └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  │  │  └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  │  └──LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   └──LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [$expr1, RoundDigit((sum($expr2) / sum($expr3)), 6:Int32) as $expr4] }
    └──LogicalAgg { group_key: [$expr1], aggs: [sum($expr2), sum($expr3)] }
       └──LogicalProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, Case((n_name <> 'IRAN':Varchar), (l_extendedprice * (1:Int32::Decimal - l_discount)), 0:Int32::Decimal) as $expr2, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr3] }
          └──LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [l_extendedprice, l_discount, n_name, o_orderdate] }
             ├──LogicalJoin { type: Inner, on: (c_nationkey = n_nationkey), output: [l_extendedprice, l_discount, n_name, o_orderdate, n_regionkey] }
             │  ├──LogicalJoin { type: Inner, on: (o_custkey = c_custkey), output: [l_extendedprice, l_discount, n_name, o_orderdate, c_nationkey] }
             │  │  ├──LogicalJoin { type: Inner, on: (l_orderkey = o_orderkey), output: [l_extendedprice, l_discount, n_name, o_custkey, o_orderdate] }
             │  │  │  ├──LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_extendedprice, l_discount, n_name] }
             │  │  │  │  ├──LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [l_orderkey, l_extendedprice, l_discount, s_nationkey] }
             │  │  │  │  │  ├──LogicalJoin { type: Inner, on: (p_partkey = l_partkey), output: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
             │  │  │  │  │  │  ├──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  │  │  │  │  │  └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  │  │  │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  │  │  │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  │  │  └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  │  └──LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
             └──LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [$expr1 ASC], dist: Single }
    └──BatchProject { exprs: [$expr1, RoundDigit((sum($expr2) / sum($expr3)), 6:Int32) as $expr4] }
       └──BatchSort { order: [$expr1 ASC] }
          └──BatchHashAgg { group_key: [$expr1], aggs: [sum($expr2), sum($expr3)] }
             └──BatchExchange { order: [], dist: HashShard($expr1) }
                └──BatchProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, Case((n_name <> 'IRAN':Varchar), (l_extendedprice * (1:Decimal - l_discount)), 0:Decimal) as $expr2, (l_extendedprice * (1:Decimal - l_discount)) as $expr3] }
                   └──BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [l_extendedprice, l_discount, n_name, o_orderdate] }
                      ├──BatchExchange { order: [], dist: HashShard(n_regionkey) }
                      │  └──BatchHashJoin { type: Inner, predicate: c_nationkey = n_nationkey, output: [l_extendedprice, l_discount, n_name, o_orderdate, n_regionkey] }
                      │     ├──BatchExchange { order: [], dist: HashShard(c_nationkey) }
                      │     │  └──BatchHashJoin { type: Inner, predicate: o_custkey = c_custkey, output: [l_extendedprice, l_discount, n_name, o_orderdate, c_nationkey] }
                      │     │     ├──BatchExchange { order: [], dist: HashShard(o_custkey) }
                      │     │     │  └──BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, n_name, o_custkey, o_orderdate] }
                      │     │     │     ├──BatchExchange { order: [], dist: HashShard(l_orderkey) }
                      │     │     │     │  └──BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_extendedprice, l_discount, n_name] }
                      │     │     │     │     ├──BatchExchange { order: [], dist: HashShard(s_nationkey) }
                      │     │     │     │     │  └──BatchHashJoin { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey] }
                      │     │     │     │     │     ├──BatchExchange { order: [], dist: HashShard(l_suppkey) }
                      │     │     │     │     │     │  └──BatchHashJoin { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
                      │     │     │     │     │     │     ├──BatchExchange { order: [], dist: HashShard(p_partkey) }
                      │     │     │     │     │     │     │  └──BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
                      │     │     │     │     │     │     └──BatchExchange { order: [], dist: HashShard(l_partkey) }
                      │     │     │     │     │     │        └──BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
                      │     │     │     │     │     └──BatchExchange { order: [], dist: HashShard(s_suppkey) }
                      │     │     │     │     │        └──BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
                      │     │     │     │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
                      │     │     │     │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
                      │     │     │     └──BatchExchange { order: [], dist: HashShard(o_orderkey) }
                      │     │     │        └──BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
                      │     │     └──BatchExchange { order: [], dist: HashShard(c_custkey) }
                      │     │        └──BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], filter: (None, None) }
                      │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
                      │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
                      └──BatchExchange { order: [], dist: HashShard(r_regionkey) }
                         └──BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [o_year, mkt_share], stream_key: [o_year], pk_columns: [o_year], pk_conflict: NoCheck }
    └──StreamProject { exprs: [$expr1, RoundDigit((sum($expr2) / sum($expr3)), 6:Int32) as $expr4] }
       └──StreamHashAgg [append_only] { group_key: [$expr1], aggs: [sum($expr2), sum($expr3), count] }
          └──StreamExchange { dist: HashShard($expr1) }
             └──StreamProject
                ├──exprs:
                │  ┌──Extract('YEAR':Varchar, o_orderdate) as $expr1
                │  ├──Case((n_name <> 'IRAN':Varchar), (l_extendedprice * (1:Decimal - l_discount)), 0:Decimal) as $expr2
                │  ├──(l_extendedprice * (1:Decimal - l_discount)) as $expr3
                │  ├──_row_id
                │  ├──_row_id
                │  ├──r_regionkey
                │  ├──_row_id
                │  ├──n_nationkey
                │  ├──_row_id
                │  ├──_row_id
                │  ├──n_nationkey
                │  ├──_row_id
                │  ├──_row_id
                │  ├──p_partkey
                │  ├──s_suppkey
                │  ├──_row_id
                │  ├──l_orderkey
                │  └──c_custkey
                └──StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, l_extendedprice, l_discount, o_orderdate, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, c_custkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey] }
                   ├──StreamExchange { dist: HashShard(c_custkey) }
                   │  └──StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [c_custkey, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] }
                   │     ├──StreamExchange { dist: HashShard(n_nationkey) }
                   │     │  └──StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] }
                   │     │     ├──StreamExchange { dist: HashShard(r_regionkey) }
                   │     │     │  └──StreamRowIdGen { row_id_index: 3 }
                   │     │     │     └──StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                   │     │     └──StreamExchange { dist: HashShard(n_regionkey) }
                   │     │        └──StreamShare { id: 5 }
                   │     │           └──StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                   │     │              └──StreamRowIdGen { row_id_index: 4 }
                   │     │                 └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                   │     └──StreamExchange { dist: HashShard(c_nationkey) }
                   │        └──StreamRowIdGen { row_id_index: 8 }
                   │           └──StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                   └──StreamExchange { dist: HashShard(o_custkey) }
                      └──StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, l_orderkey, _row_id] }
                         ├──StreamExchange { dist: HashShard(l_orderkey) }
                         │  └──StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, p_partkey] }
                         │     ├──StreamExchange { dist: HashShard(s_suppkey) }
                         │     │  └──StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                         │     │     ├──StreamExchange { dist: HashShard(n_nationkey) }
                         │     │     │  └──StreamShare { id: 5 }
                         │     │     │     └──StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                         │     │     │        └──StreamRowIdGen { row_id_index: 4 }
                         │     │     │           └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                         │     │     └──StreamExchange { dist: HashShard(s_nationkey) }
                         │     │        └──StreamRowIdGen { row_id_index: 7 }
                         │     │           └──StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                         │     └──StreamExchange { dist: HashShard(l_suppkey) }
                         │        └──StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id] }
                         │           ├──StreamExchange { dist: HashShard(p_partkey) }
                         │           │  └──StreamRowIdGen { row_id_index: 9 }
                         │           │     └──StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                         │           └──StreamExchange { dist: HashShard(l_partkey) }
                         │              └──StreamRowIdGen { row_id_index: 16 }
                         │                 └──StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                         └──StreamExchange { dist: HashShard(o_orderkey) }
                            └──StreamRowIdGen { row_id_index: 9 }
                               └──StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [o_year, mkt_share], stream_key: [o_year], pk_columns: [o_year], pk_conflict: "NoCheck" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [$expr1, RoundDigit((sum($expr2) / sum($expr3)), 6:Int32) as $expr4] }
        └── StreamHashAgg [append_only] { group_key: [$expr1], aggs: [sum($expr2), sum($expr3), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, Case((n_name <> 'IRAN':Varchar), (l_extendedprice * (1:Decimal - l_discount)), 0:Decimal) as $expr2, (l_extendedprice * (1:Decimal - l_discount)) as $expr3, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, l_extendedprice, l_discount, o_orderdate, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, c_custkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey] } { left table: 1, right table: 3, left degree table: 2, right degree table: 4 }
        ├── StreamExchange Hash([0]) from 2
        └── StreamExchange Hash([3]) from 8

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [c_custkey, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] } { left table: 5, right table: 7, left degree table: 6, right degree table: 8 }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([3]) from 7

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] } { left table: 9, right table: 11, left degree table: 10, right degree table: 12 }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([2]) from 5

    Fragment 4
    StreamRowIdGen { row_id_index: 3 }
    └── StreamSource { source: "region", columns: ["r_regionkey", "r_name", "r_comment", "_row_id"] } { source state table: 13 }

    Fragment 5
    StreamNoOp
    └── StreamExchange NoShuffle from 6

    Fragment 6
    StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: "nation", columns: ["n_nationkey", "n_name", "n_regionkey", "n_comment", "_row_id"] } { source state table: 14 }

    Fragment 7
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: "customer", columns: ["c_custkey", "c_name", "c_address", "c_nationkey", "c_phone", "c_acctbal", "c_mktsegment", "c_comment", "_row_id"] } { source state table: 15 }

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, l_orderkey, _row_id] } { left table: 16, right table: 18, left degree table: 17, right degree table: 19 }
    ├── StreamExchange Hash([1]) from 9
    └── StreamExchange Hash([0]) from 16

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, p_partkey] } { left table: 20, right table: 22, left degree table: 21, right degree table: 23 }
    ├── StreamExchange Hash([1]) from 10
    └── StreamExchange Hash([1]) from 13

    Fragment 10
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { left table: 24, right table: 26, left degree table: 25, right degree table: 27 }
    ├── StreamExchange Hash([0]) from 11
    └── StreamExchange Hash([3]) from 12

    Fragment 11
    StreamNoOp
    └── StreamExchange NoShuffle from 6

    Fragment 12
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: "supplier", columns: ["s_suppkey", "s_name", "s_address", "s_nationkey", "s_phone", "s_acctbal", "s_comment", "_row_id"] } { source state table: 28 }

    Fragment 13
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id] } { left table: 29, right table: 31, left degree table: 30, right degree table: 32 }
    ├── StreamExchange Hash([0]) from 14
    └── StreamExchange Hash([1]) from 15

    Fragment 14
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: "part", columns: ["p_partkey", "p_name", "p_mfgr", "p_brand", "p_type", "p_size", "p_container", "p_retailprice", "p_comment", "_row_id"] } { source state table: 33 }

    Fragment 15
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: "lineitem", columns: ["l_orderkey", "l_partkey", "l_suppkey", "l_linenumber", "l_quantity", "l_extendedprice", "l_discount", "l_tax", "l_returnflag", "l_linestatus", "l_shipdate", "l_commitdate", "l_receiptdate", "l_shipinstruct", "l_shipmode", "l_comment", "_row_id"] } { source state table: 34 }

    Fragment 16
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: "orders", columns: ["o_orderkey", "o_custkey", "o_orderstatus", "o_totalprice", "o_orderdate", "o_orderpriority", "o_clerk", "o_shippriority", "o_comment", "_row_id"] } { source state table: 35 }

    Table 0 { columns: [ $expr1, sum($expr2), sum($expr3), count ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ c_custkey, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1 ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ c_custkey, _row_id, _row_id_0, r_regionkey, _row_id_1, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3
    ├── columns: [ n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, l_orderkey, _row_id_3 ]
    ├── primary key: [ $3 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $13 ASC, $12 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 3 ]
    └── read pk prefix len hint: 1

    Table 4 { columns: [ o_custkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, _row_id_3, l_orderkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0 ], primary key: [ $0 ASC, $1 ASC, $3 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ n_nationkey, _row_id, _row_id_0, r_regionkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id ], primary key: [ $3 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ c_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ r_regionkey, r_name, r_comment, _row_id ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ r_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ n_nationkey, n_name, n_regionkey, _row_id ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ n_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 14 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 15 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 16 { columns: [ n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, p_partkey ], primary key: [ $1 ASC, $4 ASC, $5 ASC, $6 ASC, $8 ASC, $9 ASC, $10 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ o_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id_0 ], primary key: [ $1 ASC, $4 ASC, $6 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ l_suppkey, _row_id, _row_id_0, p_partkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ n_nationkey, n_name, n_regionkey, _row_id ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 26 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 29 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ p_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 31
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id ]
    ├── primary key: [ $1 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 32 { columns: [ l_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 33 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 34 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 35 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ o_year, mkt_share ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: tpch_q9
  before:
  - create_tables
  sql: |
    select
      nation,
      o_year,
      round(sum(amount), 2) as sum_profit
    from
      (
        select
          n_name as nation,
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
          part,
          supplier,
          lineitem,
          partsupp,
          orders,
          nation
        where
          s_suppkey = l_suppkey
          and ps_suppkey = l_suppkey
          and ps_partkey = l_partkey
          and p_partkey = l_partkey
          and o_orderkey = l_orderkey
          and s_nationkey = n_nationkey
      ) as profit
    group by
      nation,
      o_year
    order by
      nation,
      o_year desc;
  logical_plan: |-
    LogicalProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
    └──LogicalAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
       └──LogicalProject { exprs: [n_name, $expr1, $expr2] }
          └──LogicalProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Int32::Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
             └──LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (ps_suppkey = l_suppkey) AND (ps_partkey = l_partkey) AND (p_partkey = l_partkey) AND (o_orderkey = l_orderkey) AND (s_nationkey = n_nationkey) }
                └──LogicalJoin { type: Inner, on: true, output: all }
                   ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                   │  │  │  │  ├──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  │  └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  │  └──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
    └──LogicalAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
       └──LogicalProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Int32::Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
          └──LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost, o_orderdate] }
             ├──LogicalJoin { type: Inner, on: (ps_suppkey = l_suppkey) AND (ps_partkey = l_partkey), output: [l_orderkey, l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost] }
             │  ├──LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, n_name] }
             │  │  ├──LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, s_nationkey] }
             │  │  │  ├──LogicalJoin { type: Inner, on: (p_partkey = l_partkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
             │  │  │  │  ├──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  │  │  │  └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  │  │  └──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
             │  └──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
             └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [n_name ASC, $expr1 DESC], dist: Single }
    └──BatchProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
       └──BatchSort { order: [n_name ASC, $expr1 DESC] }
          └──BatchHashAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
             └──BatchExchange { order: [], dist: HashShard(n_name, $expr1) }
                └──BatchProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
                   └──BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost, o_orderdate] }
                      ├──BatchExchange { order: [], dist: HashShard(l_orderkey) }
                      │  └──BatchHashJoin { type: Inner, predicate: l_suppkey = ps_suppkey AND l_partkey = ps_partkey, output: [l_orderkey, l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost] }
                      │     ├──BatchExchange { order: [], dist: HashShard(l_partkey, l_suppkey) }
                      │     │  └──BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, n_name] }
                      │     │     ├──BatchExchange { order: [], dist: HashShard(s_nationkey) }
                      │     │     │  └──BatchHashJoin { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, s_nationkey] }
                      │     │     │     ├──BatchExchange { order: [], dist: HashShard(l_suppkey) }
                      │     │     │     │  └──BatchHashJoin { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
                      │     │     │     │     ├──BatchExchange { order: [], dist: HashShard(p_partkey) }
                      │     │     │     │     │  └──BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
                      │     │     │     │     └──BatchExchange { order: [], dist: HashShard(l_partkey) }
                      │     │     │     │        └──BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
                      │     │     │     └──BatchExchange { order: [], dist: HashShard(s_suppkey) }
                      │     │     │        └──BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
                      │     │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
                      │     │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
                      │     └──BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
                      │        └──BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
                      └──BatchExchange { order: [], dist: HashShard(o_orderkey) }
                         └──BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [nation, o_year, sum_profit], stream_key: [nation, o_year], pk_columns: [nation, o_year], pk_conflict: NoCheck }
    └──StreamProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
       └──StreamHashAgg [append_only] { group_key: [n_name, $expr1], aggs: [sum($expr2), count] }
          └──StreamExchange { dist: HashShard(n_name, $expr1) }
             └──StreamProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2, _row_id, _row_id, p_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, ps_suppkey, ps_partkey] }
                └──StreamHashJoin [append_only]
                   ├──type: Inner
                   ├──predicate: p_partkey = l_partkey AND ps_suppkey = l_suppkey AND ps_partkey = l_partkey AND ps_suppkey = s_suppkey
                   ├──output: [ps_supplycost, n_name, o_orderdate, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, p_partkey, ps_suppkey, ps_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey]
                   ├──StreamExchange { dist: HashShard(ps_suppkey) }
                   │  └──StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id] }
                   │     ├──StreamExchange { dist: HashShard(p_partkey) }
                   │     │  └──StreamRowIdGen { row_id_index: 9 }
                   │     │     └──StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                   │     └──StreamExchange { dist: HashShard(ps_partkey) }
                   │        └──StreamFilter { predicate: (ps_suppkey = ps_suppkey) }
                   │           └──StreamRowIdGen { row_id_index: 5 }
                   │              └──StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                   └──StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey] }
                      ├──StreamExchange { dist: HashShard(s_suppkey) }
                      │  └──StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                      │     ├──StreamExchange { dist: HashShard(n_nationkey) }
                      │     │  └──StreamRowIdGen { row_id_index: 4 }
                      │     │     └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                      │     └──StreamExchange { dist: HashShard(s_nationkey) }
                      │        └──StreamRowIdGen { row_id_index: 7 }
                      │           └──StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                      └──StreamExchange { dist: HashShard(l_suppkey) }
                         └──StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id] }
                            ├──StreamExchange { dist: HashShard(o_orderkey) }
                            │  └──StreamRowIdGen { row_id_index: 9 }
                            │     └──StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                            └──StreamExchange { dist: HashShard(l_orderkey) }
                               └──StreamFilter { predicate: (l_partkey = l_partkey) }
                                  └──StreamRowIdGen { row_id_index: 16 }
                                     └──StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [nation, o_year, sum_profit], stream_key: [nation, o_year], pk_columns: [nation, o_year], pk_conflict: "NoCheck" }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
        └── StreamHashAgg [append_only] { group_key: [n_name, $expr1], aggs: [sum($expr2), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── StreamExchange Hash([0, 1]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2, _row_id, _row_id, p_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, ps_suppkey, ps_partkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey AND ps_suppkey = l_suppkey AND ps_partkey = l_partkey AND ps_suppkey = s_suppkey, output: [ps_supplycost, n_name, o_orderdate, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, p_partkey, ps_suppkey, ps_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
        ├── left table: 1
        ├── right table: 3
        ├── left degree table: 2
        ├── right degree table: 4
        ├── StreamExchange Hash([2]) from 2
        └── StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey] } { left table: 11, right table: 13, left degree table: 12, right degree table: 14 }
            ├── StreamExchange Hash([1]) from 5
            └── StreamExchange Hash([2]) from 8

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id] } { left table: 5, right table: 7, left degree table: 6, right degree table: 8 }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([0]) from 4

    Fragment 3
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: "part", columns: ["p_partkey", "p_name", "p_mfgr", "p_brand", "p_type", "p_size", "p_container", "p_retailprice", "p_comment", "_row_id"] } { source state table: 9 }

    Fragment 4
    StreamFilter { predicate: (ps_suppkey = ps_suppkey) }
    └── StreamRowIdGen { row_id_index: 5 }
        └── StreamSource { source: "partsupp", columns: ["ps_partkey", "ps_suppkey", "ps_availqty", "ps_supplycost", "ps_comment", "_row_id"] } { source state table: 10 }

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { left table: 15, right table: 17, left degree table: 16, right degree table: 18 }
    ├── StreamExchange Hash([0]) from 6
    └── StreamExchange Hash([3]) from 7

    Fragment 6
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: "nation", columns: ["n_nationkey", "n_name", "n_regionkey", "n_comment", "_row_id"] } { source state table: 19 }

    Fragment 7
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: "supplier", columns: ["s_suppkey", "s_name", "s_address", "s_nationkey", "s_phone", "s_acctbal", "s_comment", "_row_id"] } { source state table: 20 }

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id] } { left table: 21, right table: 23, left degree table: 22, right degree table: 24 }
    ├── StreamExchange Hash([0]) from 9
    └── StreamExchange Hash([0]) from 10

    Fragment 9
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: "orders", columns: ["o_orderkey", "o_custkey", "o_orderstatus", "o_totalprice", "o_orderdate", "o_orderpriority", "o_clerk", "o_shippriority", "o_comment", "_row_id"] } { source state table: 25 }

    Fragment 10
    StreamFilter { predicate: (l_partkey = l_partkey) }
    └── StreamRowIdGen { row_id_index: 16 }
        └── StreamSource { source: "lineitem", columns: ["l_orderkey", "l_partkey", "l_suppkey", "l_linenumber", "l_quantity", "l_extendedprice", "l_discount", "l_tax", "l_returnflag", "l_linestatus", "l_shipdate", "l_commitdate", "l_receiptdate", "l_shipinstruct", "l_shipmode", "l_comment", "_row_id"] } { source state table: 26 }

    Table 0 { columns: [ n_name, $expr1, sum($expr2), count ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 1 { columns: [ p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id_0 ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $2 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 4 }

    Table 2 { columns: [ p_partkey, ps_suppkey, ps_partkey, ps_suppkey_0, _row_id, _row_id_0, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 3 ], read pk prefix len hint: 4 }

    Table 3
    ├── columns: [ n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey ]
    ├── primary key: [ $3 ASC, $4 ASC, $3 ASC, $1 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC, $13 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 4

    Table 4 { columns: [ l_partkey, l_suppkey, l_partkey_0, s_suppkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 3 ], read pk prefix len hint: 4 }

    Table 5 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ p_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ ps_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 10 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 11 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id_0 ], primary key: [ $2 ASC, $6 ASC, $8 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 14 { columns: [ l_suppkey, _row_id, _row_id_0, o_orderkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 21 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ o_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id ]
    ├── primary key: [ $0 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 24 { columns: [ l_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 26 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ nation, o_year, sum_profit ], primary key: [ $0 ASC, $1 DESC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

- id: tpch_q20
  before:
  - create_tables
  sql: |
    select
      s_name,
      s_address
    from
      supplier,
      nation
    where
      s_suppkey in (
        select
          ps_suppkey
        from
          partsupp
        where
          ps_partkey in (
            select
              p_partkey
            from
              part
          )
          and ps_availqty > (
            select
              0.5 * sum(l_quantity)
            from
              lineitem
            where
              l_partkey = ps_partkey
              and l_suppkey = ps_suppkey
          )
      )
      and s_nationkey = n_nationkey
    order by
      s_name;
  logical_plan: |-
    LogicalProject { exprs: [s_name, s_address] }
    └──LogicalFilter { predicate: (s_nationkey = n_nationkey) }
       └──LogicalApply { type: LeftSemi, on: (s_suppkey = ps_suppkey), correlated_id: 1 }
          ├──LogicalJoin { type: Inner, on: true, output: all }
          │  ├──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
          └──LogicalProject { exprs: [ps_suppkey] }
             └──LogicalFilter { predicate: (ps_availqty::Decimal > $expr1) }
                └──LogicalApply { type: LeftOuter, on: true, correlated_id: 3, max_one_row: true }
                   ├──LogicalApply { type: LeftSemi, on: (ps_partkey = p_partkey), correlated_id: 2 }
                   │  ├──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   │  └──LogicalProject { exprs: [p_partkey] }
                   │     └──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
                   └──LogicalProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr1] }
                      └──LogicalAgg { aggs: [sum(l_quantity)] }
                         └──LogicalProject { exprs: [l_quantity] }
                            └──LogicalFilter { predicate: (l_partkey = CorrelatedInputRef { index: 0, correlated_id: 3 }) AND (l_suppkey = CorrelatedInputRef { index: 1, correlated_id: 3 }) }
                               └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (s_suppkey = ps_suppkey), output: [s_name, s_address] }
    ├──LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [s_suppkey, s_name, s_address] }
    │  ├──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
    └──LogicalJoin { type: Inner, on: IsNotDistinctFrom(ps_partkey, ps_partkey) AND IsNotDistinctFrom(ps_suppkey, ps_suppkey) AND ($expr1 > $expr2), output: [ps_suppkey] }
       ├──LogicalProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1] }
       │  └──LogicalJoin { type: LeftSemi, on: (ps_partkey = p_partkey), output: [ps_partkey, ps_suppkey, ps_availqty] }
       │     ├──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
       │     └──LogicalProject { exprs: [p_partkey] }
       │        └──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
       └──LogicalProject { exprs: [ps_partkey, ps_suppkey, (0.5:Decimal * sum(l_quantity)) as $expr2] }
          └──LogicalAgg { group_key: [ps_partkey, ps_suppkey], aggs: [sum(l_quantity)] }
             └──LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(ps_partkey, l_partkey) AND IsNotDistinctFrom(ps_suppkey, l_suppkey), output: [ps_partkey, ps_suppkey, l_quantity] }
                ├──LogicalAgg { group_key: [ps_partkey, ps_suppkey], aggs: [] }
                │  └──LogicalJoin { type: LeftSemi, on: (ps_partkey = p_partkey), output: [ps_partkey, ps_suppkey] }
                │     ├──LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
                │     └──LogicalProject { exprs: [p_partkey] }
                │        └──LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
                └──LogicalProject { exprs: [l_partkey, l_suppkey, l_quantity] }
                   └──LogicalFilter { predicate: IsNotNull(l_partkey) AND IsNotNull(l_suppkey) }
                      └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [s_name ASC], dist: Single }
    └──BatchSort { order: [s_name ASC] }
       └──BatchHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address] }
          ├──BatchExchange { order: [], dist: HashShard(s_suppkey) }
          │  └──BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address] }
          │     ├──BatchExchange { order: [], dist: HashShard(s_nationkey) }
          │     │  └──BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
          │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
          │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
          └──BatchExchange { order: [], dist: HashShard(ps_suppkey) }
             └──BatchHashJoin { type: Inner, predicate: ps_partkey IS NOT DISTINCT FROM ps_partkey AND ps_suppkey IS NOT DISTINCT FROM ps_suppkey AND ($expr1 > $expr2), output: [ps_suppkey] }
                ├──BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
                │  └──BatchProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1] }
                │     └──BatchHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty] }
                │        ├──BatchExchange { order: [], dist: HashShard(ps_partkey) }
                │        │  └──BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
                │        └──BatchExchange { order: [], dist: HashShard(p_partkey) }
                │           └──BatchProject { exprs: [p_partkey] }
                │              └──BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
                └──BatchProject { exprs: [ps_partkey, ps_suppkey, (0.5:Decimal * sum(l_quantity)) as $expr2] }
                   └──BatchHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [sum(l_quantity)] }
                      └──BatchHashJoin { type: LeftOuter, predicate: ps_partkey IS NOT DISTINCT FROM l_partkey AND ps_suppkey IS NOT DISTINCT FROM l_suppkey, output: [ps_partkey, ps_suppkey, l_quantity] }
                         ├──BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
                         │  └──BatchHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [] }
                         │     └──BatchHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey] }
                         │        ├──BatchExchange { order: [], dist: HashShard(ps_partkey) }
                         │        │  └──BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
                         │        └──BatchExchange { order: [], dist: HashShard(p_partkey) }
                         │           └──BatchProject { exprs: [p_partkey] }
                         │              └──BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
                         └──BatchExchange { order: [], dist: HashShard(l_partkey, l_suppkey) }
                            └──BatchProject { exprs: [l_partkey, l_suppkey, l_quantity] }
                               └──BatchFilter { predicate: IsNotNull(l_partkey) AND IsNotNull(l_suppkey) }
                                  └──BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden), s_nationkey(hidden), s_suppkey(hidden)], stream_key: [_row_id, _row_id#1, s_nationkey, s_suppkey], pk_columns: [s_name, _row_id, _row_id#1, s_nationkey, s_suppkey], pk_conflict: NoCheck }
    └──StreamHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address, _row_id, _row_id, s_nationkey, s_suppkey] }
       ├──StreamExchange { dist: HashShard(s_suppkey) }
       │  └──StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id] }
       │     ├──StreamExchange { dist: HashShard(s_nationkey) }
       │     │  └──StreamRowIdGen { row_id_index: 7 }
       │     │     └──StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
       │     └──StreamExchange { dist: HashShard(n_nationkey) }
       │        └──StreamRowIdGen { row_id_index: 4 }
       │           └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
       └──StreamExchange { dist: HashShard(ps_suppkey) }
          └──StreamProject { exprs: [ps_suppkey, _row_id, ps_partkey, ps_partkey, ps_suppkey] }
             └──StreamFilter { predicate: ($expr1 > $expr2) }
                └──StreamHashJoin { type: Inner, predicate: ps_partkey IS NOT DISTINCT FROM ps_partkey AND ps_suppkey IS NOT DISTINCT FROM ps_suppkey, output: all }
                   ├──StreamExchange { dist: HashShard(ps_partkey, ps_suppkey) }
                   │  └──StreamProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1, _row_id] }
                   │     └──StreamShare { id: 13 }
                   │        └──StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] }
                   │           ├──StreamExchange { dist: HashShard(ps_partkey) }
                   │           │  └──StreamRowIdGen { row_id_index: 5 }
                   │           │     └──StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                   │           └──StreamExchange { dist: HashShard(p_partkey) }
                   │              └──StreamProject { exprs: [p_partkey, _row_id] }
                   │                 └──StreamRowIdGen { row_id_index: 9 }
                   │                    └──StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                   └──StreamProject { exprs: [ps_partkey, ps_suppkey, (0.5:Decimal * sum(l_quantity)) as $expr2] }
                      └──StreamHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [sum(l_quantity), count] }
                         └──StreamHashJoin { type: LeftOuter, predicate: ps_partkey IS NOT DISTINCT FROM l_partkey AND ps_suppkey IS NOT DISTINCT FROM l_suppkey, output: [ps_partkey, ps_suppkey, l_quantity, _row_id] }
                            ├──StreamExchange { dist: HashShard(ps_partkey, ps_suppkey) }
                            │  └──StreamProject { exprs: [ps_partkey, ps_suppkey] }
                            │     └──StreamHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [count] }
                            │        └──StreamShare { id: 13 }
                            │           └──StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] }
                            │              ├──StreamExchange { dist: HashShard(ps_partkey) }
                            │              │  └──StreamRowIdGen { row_id_index: 5 }
                            │              │     └──StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                            │              └──StreamExchange { dist: HashShard(p_partkey) }
                            │                 └──StreamProject { exprs: [p_partkey, _row_id] }
                            │                    └──StreamRowIdGen { row_id_index: 9 }
                            │                       └──StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                            └──StreamExchange { dist: HashShard(l_partkey, l_suppkey) }
                               └──StreamProject { exprs: [l_partkey, l_suppkey, l_quantity, _row_id] }
                                  └──StreamFilter { predicate: IsNotNull(l_partkey) AND IsNotNull(l_suppkey) }
                                     └──StreamRowIdGen { row_id_index: 16 }
                                        └──StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden), s_nationkey(hidden), s_suppkey(hidden)], stream_key: [_row_id, _row_id#1, s_nationkey, s_suppkey], pk_columns: [s_name, _row_id, _row_id#1, s_nationkey, s_suppkey], pk_conflict: "NoCheck" }
    ├── materialized table: 4294967294
    └── StreamHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address, _row_id, _row_id, s_nationkey, s_suppkey] } { left table: 0, right table: 2, left degree table: 1, right degree table: 3 }
        ├── StreamExchange Hash([0]) from 1
        └── StreamExchange Hash([0]) from 4

    Fragment 1
    StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id] } { left table: 4, right table: 6, left degree table: 5, right degree table: 7 }
    ├── StreamExchange Hash([3]) from 2
    └── StreamExchange Hash([0]) from 3

    Fragment 2
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: "supplier", columns: ["s_suppkey", "s_name", "s_address", "s_nationkey", "s_phone", "s_acctbal", "s_comment", "_row_id"] } { source state table: 8 }

    Fragment 3
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: "nation", columns: ["n_nationkey", "n_name", "n_regionkey", "n_comment", "_row_id"] } { source state table: 9 }

    Fragment 4
    StreamProject { exprs: [ps_suppkey, _row_id, ps_partkey, ps_partkey, ps_suppkey] }
    └── StreamFilter { predicate: ($expr1 > $expr2) }
        └── StreamHashJoin { type: Inner, predicate: ps_partkey IS NOT DISTINCT FROM ps_partkey AND ps_suppkey IS NOT DISTINCT FROM ps_suppkey, output: all } { left table: 10, right table: 12, left degree table: 11, right degree table: 13 }
            ├── StreamExchange Hash([0, 1]) from 5
            └── StreamProject { exprs: [ps_partkey, ps_suppkey, (0.5:Decimal * sum(l_quantity)) as $expr2] }
                └── StreamHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [sum(l_quantity), count] } { result table: 20, state tables: [], distinct tables: [] }
                    └── StreamHashJoin { type: LeftOuter, predicate: ps_partkey IS NOT DISTINCT FROM l_partkey AND ps_suppkey IS NOT DISTINCT FROM l_suppkey, output: [ps_partkey, ps_suppkey, l_quantity, _row_id] }
                        ├── left table: 21
                        ├── right table: 23
                        ├── left degree table: 22
                        ├── right degree table: 24
                        ├── StreamExchange Hash([0, 1]) from 9
                        └── StreamExchange Hash([0, 1]) from 10

    Fragment 5
    StreamProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1, _row_id] }
    └── StreamExchange NoShuffle from 6

    Fragment 6
    StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] } { left table: 14, right table: 16, left degree table: 15, right degree table: 17 }
    ├── StreamExchange Hash([0]) from 7
    └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamRowIdGen { row_id_index: 5 }
    └── StreamSource { source: "partsupp", columns: ["ps_partkey", "ps_suppkey", "ps_availqty", "ps_supplycost", "ps_comment", "_row_id"] } { source state table: 18 }

    Fragment 8
    StreamProject { exprs: [p_partkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 9 }
        └── StreamSource { source: "part", columns: ["p_partkey", "p_name", "p_mfgr", "p_brand", "p_type", "p_size", "p_container", "p_retailprice", "p_comment", "_row_id"] } { source state table: 19 }

    Fragment 9
    StreamProject { exprs: [ps_partkey, ps_suppkey] }
    └── StreamHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [count] } { result table: 25, state tables: [], distinct tables: [] }
        └── StreamExchange NoShuffle from 6

    Fragment 10
    StreamProject { exprs: [l_partkey, l_suppkey, l_quantity, _row_id] }
    └── StreamFilter { predicate: IsNotNull(l_partkey) AND IsNotNull(l_suppkey) }
        └── StreamRowIdGen { row_id_index: 16 }
            └── StreamSource { source: "lineitem", columns: ["l_orderkey", "l_partkey", "l_suppkey", "l_linenumber", "l_quantity", "l_extendedprice", "l_discount", "l_tax", "l_returnflag", "l_linestatus", "l_shipdate", "l_commitdate", "l_receiptdate", "l_shipinstruct", "l_shipmode", "l_comment", "_row_id"] }
                └── source state table: 26

    Table 0 { columns: [ s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id_0 ], primary key: [ $0 ASC, $3 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ s_suppkey, _row_id, _row_id_0, s_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ ps_suppkey, _row_id, ps_partkey, ps_partkey_0, ps_suppkey_0 ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ ps_suppkey, _row_id, ps_partkey, ps_partkey_0, ps_suppkey_0, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 9 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 10 { columns: [ ps_partkey, ps_suppkey, $expr1, _row_id ], primary key: [ $0 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 11 { columns: [ ps_partkey, ps_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 12 { columns: [ ps_partkey, ps_suppkey, $expr2 ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 13 { columns: [ ps_partkey, ps_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 14 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ ps_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ p_partkey, _row_id ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ p_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ ps_partkey, ps_suppkey, sum(l_quantity), count ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 21 { columns: [ ps_partkey, ps_suppkey ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 22 { columns: [ ps_partkey, ps_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 23 { columns: [ l_partkey, l_suppkey, l_quantity, _row_id ], primary key: [ $0 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 24 { columns: [ l_partkey, l_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 25 { columns: [ ps_partkey, ps_suppkey, count ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 26 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_name, s_address, _row_id, _row_id#1, s_nationkey, s_suppkey ], primary key: [ $0 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 4 }

- id: tpch_q21
  before:
  - create_tables
  sql: |
    select
      s_name,
      count(*) as numwait
    from
      supplier,
      lineitem l1,
      orders,
      nation
    where
      s_suppkey = l1.l_suppkey
      and o_orderkey = l1.l_orderkey
      and l1.l_receiptdate > l1.l_commitdate
      and exists (
        select
          *
        from
          lineitem l2
        where
          l2.l_orderkey = l1.l_orderkey
          and l2.l_suppkey <> l1.l_suppkey
      )
      and not exists (
        select
          *
        from
          lineitem l3
        where
          l3.l_orderkey = l1.l_orderkey
          and l3.l_suppkey <> l1.l_suppkey
          and l3.l_receiptdate > l3.l_commitdate
      )
      and s_nationkey = n_nationkey
    group by
      s_name
    order by
      numwait desc,
      s_name;
  logical_plan: |-
    LogicalProject { exprs: [s_name, count] }
    └──LogicalAgg { group_key: [s_name], aggs: [count] }
       └──LogicalProject { exprs: [s_name] }
          └──LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (o_orderkey = l_orderkey) AND (l_receiptdate > l_commitdate) AND (s_nationkey = n_nationkey) }
             └──LogicalApply { type: LeftAnti, on: true, correlated_id: 2 }
                ├──LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
                │  ├──LogicalJoin { type: Inner, on: true, output: all }
                │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                │  │  │  ├──LogicalJoin { type: Inner, on: true, output: all }
                │  │  │  │  ├──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
                │  │  │  │  └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
                │  │  │  └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
                │  │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
                │  └──LogicalProject { exprs: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                │     └──LogicalFilter { predicate: (l_orderkey = CorrelatedInputRef { index: 8, correlated_id: 1 }) AND (l_suppkey <> CorrelatedInputRef { index: 10, correlated_id: 1 }) }
                │        └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
                └──LogicalProject { exprs: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                   └──LogicalFilter { predicate: (l_orderkey = CorrelatedInputRef { index: 8, correlated_id: 2 }) AND (l_suppkey <> CorrelatedInputRef { index: 10, correlated_id: 2 }) AND (l_receiptdate > l_commitdate) }
                      └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [s_name], aggs: [count] }
    └──LogicalJoin { type: LeftAnti, on: (l_orderkey = l_orderkey) AND (l_suppkey <> l_suppkey), output: [s_name] }
       ├──LogicalJoin { type: LeftSemi, on: (l_orderkey = l_orderkey) AND (l_suppkey <> l_suppkey), output: all }
       │  ├──LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [s_name, l_orderkey, l_suppkey] }
       │  │  ├──LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [s_name, l_orderkey, l_suppkey] }
       │  │  │  ├──LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [s_name, s_nationkey, l_orderkey, l_suppkey] }
       │  │  │  │  ├──LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
       │  │  │  │  └──LogicalFilter { predicate: (l_receiptdate > l_commitdate) }
       │  │  │  │     └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
       │  │  │  └──LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
       │  │  └──LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
       │  └──LogicalProject { exprs: [l_orderkey, l_suppkey] }
       │     └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
       └──LogicalProject { exprs: [l_orderkey, l_suppkey] }
          └──LogicalFilter { predicate: (l_receiptdate > l_commitdate) }
             └──LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [count DESC, s_name ASC], dist: Single }
    └──BatchSort { order: [count DESC, s_name ASC] }
       └──BatchHashAgg { group_key: [s_name], aggs: [count] }
          └──BatchExchange { order: [], dist: HashShard(s_name) }
             └──BatchHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name] }
                ├──BatchHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: all }
                │  ├──BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [s_name, l_orderkey, l_suppkey] }
                │  │  ├──BatchExchange { order: [], dist: HashShard(l_orderkey) }
                │  │  │  └──BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_name, l_orderkey, l_suppkey] }
                │  │  │     ├──BatchExchange { order: [], dist: HashShard(s_nationkey) }
                │  │  │     │  └──BatchHashJoin { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, s_nationkey, l_orderkey, l_suppkey] }
                │  │  │     │     ├──BatchExchange { order: [], dist: HashShard(s_suppkey) }
                │  │  │     │     │  └──BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
                │  │  │     │     └──BatchExchange { order: [], dist: HashShard(l_suppkey) }
                │  │  │     │        └──BatchFilter { predicate: (l_receiptdate > l_commitdate) }
                │  │  │     │           └──BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
                │  │  │     └──BatchExchange { order: [], dist: HashShard(n_nationkey) }
                │  │  │        └──BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
                │  │  └──BatchExchange { order: [], dist: HashShard(o_orderkey) }
                │  │     └──BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
                │  └──BatchExchange { order: [], dist: HashShard(l_orderkey) }
                │     └──BatchProject { exprs: [l_orderkey, l_suppkey] }
                │        └──BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
                └──BatchExchange { order: [], dist: HashShard(l_orderkey) }
                   └──BatchProject { exprs: [l_orderkey, l_suppkey] }
                      └──BatchFilter { predicate: (l_receiptdate > l_commitdate) }
                         └──BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: NoCheck }
    └──StreamHashAgg { group_key: [s_name], aggs: [count] }
       └──StreamExchange { dist: HashShard(s_name) }
          └──StreamHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, l_orderkey] }
             ├──StreamHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
             │  ├──StreamExchange { dist: HashShard(l_orderkey) }
             │  │  └──StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, o_orderkey] }
             │  │     ├──StreamExchange { dist: HashShard(s_suppkey) }
             │  │     │  └──StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [s_suppkey, s_name, _row_id, n_nationkey, _row_id] }
             │  │     │     ├──StreamExchange { dist: HashShard(n_nationkey) }
             │  │     │     │  └──StreamRowIdGen { row_id_index: 4 }
             │  │     │     │     └──StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
             │  │     │     └──StreamExchange { dist: HashShard(s_nationkey) }
             │  │     │        └──StreamRowIdGen { row_id_index: 7 }
             │  │     │           └──StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
             │  │     └──StreamExchange { dist: HashShard(l_suppkey) }
             │  │        └──StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id] }
             │  │           ├──StreamExchange { dist: HashShard(o_orderkey) }
             │  │           │  └──StreamRowIdGen { row_id_index: 9 }
             │  │           │     └──StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
             │  │           └──StreamExchange { dist: HashShard(l_orderkey) }
             │  │              └──StreamFilter { predicate: (l_receiptdate > l_commitdate) }
             │  │                 └──StreamShare { id: 11 }
             │  │                    └──StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
             │  │                       └──StreamRowIdGen { row_id_index: 16 }
             │  │                          └──StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
             │  └──StreamExchange { dist: HashShard(l_orderkey) }
             │     └──StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
             │        └──StreamShare { id: 11 }
             │           └──StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
             │              └──StreamRowIdGen { row_id_index: 16 }
             │                 └──StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
             └──StreamExchange { dist: HashShard(l_orderkey) }
                └──StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
                   └──StreamFilter { predicate: (l_receiptdate > l_commitdate) }
                      └──StreamShare { id: 11 }
                         └──StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
                            └──StreamRowIdGen { row_id_index: 16 }
                               └──StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: "NoCheck" }
    ├── materialized table: 4294967294
    └── StreamHashAgg { group_key: [s_name], aggs: [count] } { result table: 0, state tables: [], distinct tables: [] }
        └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, l_orderkey] }
    ├── left table: 1
    ├── right table: 3
    ├── left degree table: 2
    ├── right degree table: 4
    ├── StreamHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
    │   ├── left table: 5
    │   ├── right table: 7
    │   ├── left degree table: 6
    │   ├── right degree table: 8
    │   ├── StreamExchange Hash([1]) from 2
    │   └── StreamExchange Hash([0]) from 10
    └── StreamExchange Hash([0]) from 11

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, o_orderkey] }
    ├── left table: 9
    ├── right table: 11
    ├── left degree table: 10
    ├── right degree table: 12
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([1]) from 6

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [s_suppkey, s_name, _row_id, n_nationkey, _row_id] }
    ├── left table: 13
    ├── right table: 15
    ├── left degree table: 14
    ├── right degree table: 16
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([3]) from 5

    Fragment 4
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: "nation", columns: ["n_nationkey", "n_name", "n_regionkey", "n_comment", "_row_id"] } { source state table: 17 }

    Fragment 5
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: "supplier", columns: ["s_suppkey", "s_name", "s_address", "s_nationkey", "s_phone", "s_acctbal", "s_comment", "_row_id"] } { source state table: 18 }

    Fragment 6
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id] }
    ├── left table: 19
    ├── right table: 21
    ├── left degree table: 20
    ├── right degree table: 22
    ├── StreamExchange Hash([0]) from 7
    └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: "orders", columns: ["o_orderkey", "o_custkey", "o_orderstatus", "o_totalprice", "o_orderdate", "o_orderpriority", "o_clerk", "o_shippriority", "o_comment", "_row_id"] }
        └── source state table: 23

    Fragment 8
    StreamFilter { predicate: (l_receiptdate > l_commitdate) }
    └── StreamExchange NoShuffle from 9

    Fragment 9
    StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
    └── StreamRowIdGen { row_id_index: 16 }
        └── StreamSource { source: "lineitem", columns: ["l_orderkey", "l_partkey", "l_suppkey", "l_linenumber", "l_quantity", "l_extendedprice", "l_discount", "l_tax", "l_returnflag", "l_linestatus", "l_shipdate", "l_commitdate", "l_receiptdate", "l_shipinstruct", "l_shipmode", "l_comment", "_row_id"] }
            └── source state table: 24

    Fragment 10
    StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
    └── StreamExchange NoShuffle from 9

    Fragment 11
    StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
    └── StreamFilter { predicate: (l_receiptdate > l_commitdate) }
        └── StreamExchange NoShuffle from 9

    Table 0 { columns: [ s_name, count ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey ]
    ├── primary key: [ $1 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 2 { columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ l_orderkey, l_suppkey, _row_id ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ l_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, o_orderkey ]
    ├── primary key: [ $1 ASC, $3 ASC, $4 ASC, $5 ASC, $7 ASC, $8 ASC, $9 ASC, $6 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 6 { columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ l_orderkey, l_suppkey, _row_id ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ l_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ s_suppkey, s_name, _row_id, n_nationkey, _row_id_0 ], primary key: [ $0 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ l_suppkey, _row_id, _row_id_0, o_orderkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 14 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 18 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 19 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ o_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ l_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 24 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_name, numwait ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

