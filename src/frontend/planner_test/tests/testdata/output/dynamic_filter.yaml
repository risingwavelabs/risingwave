# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    create table t1 (v1 int);
    create table t2 (v2 int);
- name: With Simple Agg on inner side
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: (t1.v1 > max(t2.v2)), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.v1 > max(max(t2.v2))), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [max(max(t2.v2))] }
          └─StreamSimpleAgg { aggs: [max(max(t2.v2)), count] }
            └─StreamExchange { dist: Single }
              └─StreamHashAgg { group_key: [_vnode], aggs: [max(t2.v2), count] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: |
    With Top-1 on inner side
  before:
  - create_tables
  sql: |
    with max_v2 as (select v2 max from t2 order by max desc limit 1) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: (t1.v1 > t2.v2), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalTopN { order: [t2.v2 DESC], limit: 1, offset: 0 }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.v1 > t2.v2), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [t2.v2] }
          └─StreamTopN { order: [t2.v2 DESC], limit: 1, offset: 0 }
            └─StreamExchange { dist: Single }
              └─StreamGroupTopN { order: [t2.v2 DESC], limit: 1, offset: 0, group_key: [_vnode] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: |
    With Limit-1 on inner side
  before:
  - create_tables
  sql: |
    with limit_v2 as (select v2 from t2 limit 1) select v1 from t1, limit_v2 where v1 > v2;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: (t1.v1 > t2.v2), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalLimit { limit: 1, offset: 0 }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.v1 > t2.v2), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [t2.v2] }
          └─StreamTopN { order: [t2.v2 ASC], limit: 1, offset: 0 }
            └─StreamExchange { dist: Single }
              └─StreamGroupTopN { order: [t2.v2 ASC], limit: 1, offset: 0, group_key: [_vnode] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: With Simple Agg upstream materialized view on inner side
  before:
  - create_tables
  sql: |
    create materialized view max_v2 as select max(v2) max from t2;
    select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: (t1.v1 > max_v2.max), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalScan { table: max_v2, columns: [max_v2.max], cardinality: 0..=1 }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.v1 > max_v2.max), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamTableScan { table: max_v2, columns: [max_v2.max], stream_scan_type: ArrangementBackfill, stream_key: [], pk: [], dist: Single }
- name: |
    Output indices of Dynamic Filter
    TODO: currently implemented by adding a Project, https://github.com/risingwavelabs/risingwave/issues/3419
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1 from t1, max_v2 where v1 + v1 > max;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: ($expr1 > max(t2.v2)), output: [t1.v1] }
    ├─LogicalProject { exprs: [t1.v1, (t1.v1 + t1.v1) as $expr1] }
    │ └─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.v1, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > max(max(t2.v2))), output: [t1.v1, $expr1, t1._row_id] }
        ├─StreamProject { exprs: [t1.v1, (t1.v1 + t1.v1) as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [max(max(t2.v2))] }
            └─StreamSimpleAgg { aggs: [max(max(t2.v2)), count] }
              └─StreamExchange { dist: Single }
                └─StreamHashAgg { group_key: [_vnode], aggs: [max(t2.v2), count] }
                  └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                    └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Ensure error on multiple rows on inner side
  before:
  - create_tables
  sql: |
    with max_v2 as (select v2 max from t2 order by v2 desc limit 2) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: (t1.v1 > t2.v2), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalTopN { order: [t2.v2 DESC], limit: 2, offset: 0 }
      └─LogicalProject { exprs: [t2.v2, t2.v2] }
        └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_error: |-
    Not supported: streaming nested-loop join
    HINT: The non-equal join in the query requires a nested-loop join executor, which could be very expensive to run. Consider rewriting the query to use dynamic filter as a substitute if possible.
    See also: https://docs.risingwave.com/docs/current/sql-pattern-dynamic-filters/
- name: Ensure error on output columns from inner
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1, max from t1, max_v2 where v1 > max;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: (t1.v1 > max(t2.v2)), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_error: |-
    Not supported: streaming nested-loop join
    HINT: The non-equal join in the query requires a nested-loop join executor, which could be very expensive to run. Consider rewriting the query to use dynamic filter as a substitute if possible.
    See also: https://docs.risingwave.com/docs/current/sql-pattern-dynamic-filters/
- name: Use Inner Join for equi condition
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1, max from t1, max_v2 where v1 = max;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: (t1.v1 = max(t2.v2)), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, max, t1._row_id(hidden)], stream_key: [t1._row_id, v1], pk_columns: [t1._row_id, v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.v1, t1._row_id) }
      └─StreamHashJoin { type: Inner, predicate: t1.v1 = max(max(t2.v2)), output: [t1.v1, max(max(t2.v2)), t1._row_id] }
        ├─StreamExchange { dist: HashShard(t1.v1) }
        │ └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard(max(max(t2.v2))) }
          └─StreamProject { exprs: [max(max(t2.v2))] }
            └─StreamSimpleAgg { aggs: [max(max(t2.v2)), count] }
              └─StreamExchange { dist: Single }
                └─StreamHashAgg { group_key: [_vnode], aggs: [max(t2.v2), count] }
                  └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                    └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Dynamic filter join on unequal types
  sql: |
    create table t1 (v1 int);
    create table t2 (v2 bigint);
    with max_v2 as (select max(v2) max from t2) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: ($expr1 > max(t2.v2)), output: [t1.v1] }
    ├─LogicalProject { exprs: [t1.v1, t1.v1::Int64 as $expr1] }
    │ └─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.v1, t1._row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > max(max(t2.v2))), output: [t1.v1, $expr1, t1._row_id] }
        ├─StreamProject { exprs: [t1.v1, t1.v1::Int64 as $expr1, t1._row_id] }
        │ └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [max(max(t2.v2))] }
            └─StreamSimpleAgg { aggs: [max(max(t2.v2)), count] }
              └─StreamExchange { dist: Single }
                └─StreamHashAgg { group_key: [_vnode], aggs: [max(t2.v2), count] }
                  └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                    └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Dynamic filter on semi join
  sql: |
    create table t1 (v1 int);
    create table t2 (v2 int);
    with max_v2 as (select max(v2) max from t2) select v1 from t1 where exists (select * from max_v2 where v1 > max);
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.v1 > max(max(t2.v2))), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [max(max(t2.v2))] }
          └─StreamSimpleAgg { aggs: [max(max(t2.v2)), count] }
            └─StreamExchange { dist: Single }
              └─StreamHashAgg { group_key: [_vnode], aggs: [max(t2.v2), count] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Complex expression on RHS of condition will still result in dynamic filter
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1 from t1, max_v2 where v1 > 2 * max;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: (t1.v1 > $expr1), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalProject { exprs: [(2:Int32 * max(t2.v2)) as $expr1] }
      └─LogicalAgg { aggs: [max(t2.v2)] }
        └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.v1 > $expr1), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [(2:Int32 * max(max(t2.v2))) as $expr1] }
          └─StreamSimpleAgg { aggs: [max(max(t2.v2)), count] }
            └─StreamExchange { dist: Single }
              └─StreamHashAgg { group_key: [_vnode], aggs: [max(t2.v2), count] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: two predicate on the same subquery
  before:
  - create_tables
  sql: |
    with cte as (select max(v2) max from t2) select * from t1 where v1 > (select max from cte) AND v1 < (select max+5 from cte);
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: Inner, on: (t1.v1 < $expr1), output: [t1.v1] }
    ├─LogicalJoin { type: Inner, on: (t1.v1 > max(t2.v2)), output: [t1.v1] }
    │ ├─LogicalScan { table: t1, columns: [t1.v1] }
    │ └─LogicalShare { id: 2 }
    │   └─LogicalAgg { aggs: [max(t2.v2)] }
    │     └─LogicalScan { table: t2, columns: [t2.v2] }
    └─LogicalProject { exprs: [(max(t2.v2) + 5:Int32) as $expr1] }
      └─LogicalShare { id: 2 }
        └─LogicalAgg { aggs: [max(t2.v2)] }
          └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (t1.v1 < $expr1), output: [t1.v1, t1._row_id] }
      ├─StreamDynamicFilter { predicate: (t1.v1 > max(max(t2.v2))), output: [t1.v1, t1._row_id] }
      │ ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
      │ └─StreamExchange { dist: Broadcast }
      │   └─StreamShare { id: 6 }
      │     └─StreamProject { exprs: [max(max(t2.v2))] }
      │       └─StreamSimpleAgg { aggs: [max(max(t2.v2)), count] }
      │         └─StreamExchange { dist: Single }
      │           └─StreamHashAgg { group_key: [_vnode], aggs: [max(t2.v2), count] }
      │             └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
      │               └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [(max(max(t2.v2)) + 5:Int32) as $expr1] }
          └─StreamShare { id: 6 }
            └─StreamProject { exprs: [max(max(t2.v2))] }
              └─StreamSimpleAgg { aggs: [max(max(t2.v2)), count] }
                └─StreamExchange { dist: Single }
                  └─StreamHashAgg { group_key: [_vnode], aggs: [max(t2.v2), count] }
                    └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                      └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
