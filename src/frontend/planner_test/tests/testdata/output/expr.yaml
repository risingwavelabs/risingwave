# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: bind typed literal - int
  sql: |
    select int '1';
  logical_plan: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bind typed literal - bool
  sql: |
    SELECT bool 't'
  logical_plan: |-
    LogicalProject { exprs: [true:Boolean] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    values(must_be_unimplemented_func(1));
  binder_error: |
    Failed to bind expression: must_be_unimplemented_func(1)

    Caused by:
      function must_be_unimplemented_func(integer) does not exist
- sql: |
    values(cast(1 as bigint));
  batch_plan: 'BatchValues { rows: [[1:Int64]] }'
- sql: |
    values(not true);
  batch_plan: 'BatchValues { rows: [[false:Boolean]] }'
- sql: |
    create table t ();
    select (((((false is not true) is true) is not false) is false) is not null) is null from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [false:Boolean] }
      └─BatchScan { table: t, columns: [], distribution: SomeShard }
- name: bind between
  sql: |
    SELECT 1 between 2 and 3
  logical_plan: |-
    LogicalProject { exprs: [((1:Int32 >= 2:Int32) AND (1:Int32 <= 3:Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: null eq null
  sql: |
    SELECT null = null;
  logical_plan: |-
    LogicalProject { exprs: [(null:Varchar = null:Varchar) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: null lt null
  sql: |
    SELECT null < null;
  logical_plan: |-
    LogicalProject { exprs: [(null:Varchar < null:Varchar) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: hex bitwise-or bin
  sql: |
    SELECT 0x25 | 0b110;
  logical_plan: |-
    LogicalProject { exprs: [(37:Int32 | 6:Int32) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bind is distinct from
  sql: |
    SELECT 1 IS DISTINCT FROM 2
  logical_plan: |-
    LogicalProject { exprs: [IsDistinctFrom(1:Int32, 2:Int32) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bind is not distinct from
  sql: |
    SELECT 1 IS NOT DISTINCT FROM 2
  logical_plan: |-
    LogicalProject { exprs: [IsNotDistinctFrom(1:Int32, 2:Int32) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: in-list with aligned types
  sql: |
    SELECT 1::real in (3, 1.0, 2);
  batch_plan: 'BatchValues { rows: [[true:Boolean]] }'
- name: not in-list with aligned types
  sql: |
    SELECT 1::real not in (3, 1.0, 2);
  batch_plan: 'BatchValues { rows: [[false:Boolean]] }'
- name: in-list with misaligned types
  sql: |
    SELECT true in (3, 1.0, 2);
  binder_error: |
    Failed to bind expression: true IN (3, 1.0, 2)

    Caused by:
      Bind error: types Boolean and Int32 cannot be matched
- name: in-list with non-const - agg
  sql: |
    create table t (v1 int);
    SELECT 1 in (3, 0.5*2, min(v1)) from t;
  batch_plan: |-
    BatchProject { exprs: [(true:Boolean OR (1:Int32 = min(min(t.v1)))) as $expr1] }
    └─BatchSimpleAgg { aggs: [min(min(t.v1))] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchSimpleAgg { aggs: [min(t.v1)] }
          └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: in-list with non-const - scalar subquery
  sql: |
    create table t (v1 int);
    create table b (b1 int, b2 int);
    SELECT b2 from b where 1 in (3, 1.0, (select min(v1) from t));
  batch_plan: |-
    BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
    ├─BatchExchange { order: [], dist: Single }
    │ └─BatchScan { table: b, columns: [b.b2], distribution: SomeShard }
    └─BatchValues { rows: [[]] }
- name: in-list with non-const - correlated ref
  sql: |
    create table t (v1 int);
    create table b (b1 int, b2 int);
    SELECT b2 from b where exists (select 2 from t where v1 in (3, 1.0, b1));
  logical_plan: |-
    LogicalProject { exprs: [b.b2] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalScan { table: b, columns: [b.b1, b.b2, b._row_id, b._rw_timestamp] }
      └─LogicalProject { exprs: [2:Int32] }
        └─LogicalFilter { predicate: (In(t.v1::Decimal, 3:Int32::Decimal, 1.0:Decimal) OR (t.v1 = CorrelatedInputRef { index: 0, correlated_id: 1 })) }
          └─LogicalScan { table: t, columns: [t.v1, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchNestedLoopJoin { type: LeftSemi, predicate: (In(t.v1::Decimal, 3:Decimal, 1.0:Decimal) OR (t.v1 = b.b1)), output: [b.b2] }
    ├─BatchExchange { order: [], dist: Single }
    │ └─BatchScan { table: b, columns: [b.b1, b.b2], distribution: SomeShard }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.v1, t.v1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    select +1.0, -2.0;
  batch_plan: 'BatchValues { rows: [[1.0:Decimal, -2.0:Decimal]] }'
- sql: |
    values(round(42.4382, 2));
  batch_plan: 'BatchValues { rows: [[42.44:Decimal]] }'
- sql: |
    values(round(42.4382));
  batch_plan: 'BatchValues { rows: [[42:Decimal]] }'
- sql: |
    values(round(42));
  batch_plan: 'BatchValues { rows: [[42:Float64]] }'
- sql: |
    values(round(42, 2));
  batch_plan: 'BatchValues { rows: [[42:Decimal]] }'
- sql: |
    values(round(true));
  binder_error: |
    Failed to bind expression: round(true)

    Caused by:
      function round(boolean) does not exist
- sql: |
    -- Single quoted literal can be treated as number without error.
    values(round('123'));
  batch_plan: 'BatchValues { rows: [[123:Float64]] }'
- sql: |
    -- When it is invalid, PostgreSQL reports error during explain, but we have to wait until execution as of now. #4235
    values(round('abc'));
- sql: |
    values(extract(hour from timestamp '2001-02-16 20:38:40'));
  batch_plan: 'BatchValues { rows: [[20:Decimal]] }'
- sql: |
    values('Postgres' not like 'Post%');
  batch_plan: 'BatchValues { rows: [[false:Boolean]] }'
- sql: |
    values(1 not like 1.23);
  binder_error: |
    Failed to bind expression: 1 NOT LIKE 1.23

    Caused by:
      function like(integer, numeric) does not exist
- sql: |
    select length(trim(trailing '1' from '12'))+length(trim(leading '2' from '23'))+length(trim(both '3' from '34'));
  batch_plan: 'BatchValues { rows: [[4:Int32]] }'
- sql: |
    select position('123' in replace('1','1','2')) where '12' like '%1';
  batch_plan: 'BatchValues { rows: [] }'
- name: case searched form with else
  sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2 else 0.0 end) as expr from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), 1:Decimal, (t.v1 = 2:Int32), 2:Decimal, 0.0:Decimal) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Case((t.v1 = 1:Int32), 1:Decimal, (t.v1 = 2:Int32), 2:Decimal, 0.0:Decimal) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: case searched form without else
  sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2.1 end) from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), 1:Decimal, (t.v1 = 2:Int32), 2.1:Decimal) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: case simple form
  sql: |
    create table t (v1 int);
    select (case v1 when 1 then 1 when 2.0 then 2 else 0.0 end) from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), 1:Decimal, (t.v1::Decimal = 2.0:Decimal), 2:Decimal, 0.0:Decimal) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: case misaligned result types
  sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2 else true end) from t;
  binder_error: |
    Failed to bind expression: (CASE WHEN v1 = 1 THEN 1 WHEN v1 = 2 THEN 2 ELSE true END)

    Caused by:
      Bind error: types Int32 and Boolean cannot be matched
- name: case misaligned value types
  sql: |
    create table t (v1 int);
    select (case v1 when 1 then 1 when true then 2 else 0.0 end) from t;
  binder_error: |
    Failed to bind expression: (CASE v1 WHEN 1 THEN 1 WHEN true THEN 2 ELSE 0.0 END)

    Caused by:
      function equal(integer, boolean) does not exist
- sql: |
    create table t (v1 int);
    select nullif(v1, 1) as expr from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), null:Int32, t.v1) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Case((t.v1 = 1:Int32), null:Int32, t.v1) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int);
    select nullif(v1, 1, 2) from t;
  binder_error: |
    Failed to bind expression: nullif(v1, 1, 2)

    Caused by:
      Bind error: Function `nullif` must contain 2 arguments
- sql: |
    create table t (v1 int);
    select nullif(v1, true) from t;
  binder_error: |
    Failed to bind expression: nullif(v1, true)

    Caused by:
      function equal(integer, boolean) does not exist
- sql: |
    create table t (v1 int);
    select coalesce(v1, 1) as expr from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Coalesce(t.v1, 1:Int32) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Coalesce(t.v1, 1:Int32) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int);
    select coalesce(v1, 1.2) from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Coalesce(t.v1::Decimal, 1.2:Decimal) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    create table t (v1 int);
    select coalesce() from t;
  binder_error: |
    Failed to bind expression: coalesce()

    Caused by:
      Bind error: Function `coalesce` takes at least 1 arguments (0 given)
- sql: |
    create table t (v1 int);
    select coalesce(1,true) from t;
  binder_error: |
    Failed to bind expression: coalesce(1, true)

    Caused by:
      Bind error: types Int32 and Boolean cannot be matched
- sql: |
    create table t (v1 varchar);
    select concat_ws(v1, 1) as expr from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs(t.v1, '1':Varchar) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [ConcatWs(t.v1, '1':Varchar) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 varchar);
    select concat_ws(v1, 1.2) from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs(t.v1, '1.2':Varchar) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    create table t (v1 int);
    select concat_ws(v1, 1.2) from t;
  binder_error: |
    Failed to bind expression: concat_ws(v1, 1.2)

    Caused by:
      cannot cast type "integer" to "character varying" in Implicit context
- sql: |
    create table t (v1 int);
    select concat_ws() from t;
  binder_error: |
    Failed to bind expression: concat_ws()

    Caused by:
      Bind error: Function `concat_ws` takes at least 2 arguments (0 given)
- sql: |
    create table t (v1 varchar, v2 int, v3 float);
    select concat(v1, v2, v3, 1) as expr from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs('':Varchar, t.v1, t.v2::Varchar, t.v3::Varchar, '1':Varchar) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1, t.v2, t.v3], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [ConcatWs('':Varchar, t.v1, t.v2::Varchar, t.v3::Varchar, '1':Varchar) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 float);
    select concat(v1) from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs('':Varchar, t.v1::Varchar) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    create table t (v1 int);
    select concat() from t;
  binder_error: |
    Failed to bind expression: concat()

    Caused by:
      Bind error: Function `concat` takes at least 1 arguments (0 given)
- sql: |
    select concat(':', true);
  batch_plan: 'BatchValues { rows: [['':t'':Varchar]] }'
- sql: |
    select ':' || true;
  batch_plan: 'BatchValues { rows: [['':true'':Varchar]] }'
- sql: |
    select substr('hello', NULL);
  batch_plan: 'BatchValues { rows: [[null:Varchar]] }'
- sql: |
    select substr(NULL, 1);
  batch_plan: 'BatchValues { rows: [[null:Varchar]] }'
- sql: |
    select pg_typeof('123');
  batch_plan: 'BatchValues { rows: [[''unknown'':Varchar]] }'
- sql: |
    select pg_typeof(round(null));
  batch_plan: 'BatchValues { rows: [[''double precision'':Varchar]] }'
- sql: |
    select pg_typeof(row(true, 1, 'hello'));
  batch_plan: 'BatchValues { rows: [[''record'':Varchar]] }'
- sql: |
    select pg_typeof(array[1, 2]);
  batch_plan: 'BatchValues { rows: [[''integer[]'':Varchar]] }'
- sql: |
    select pg_typeof(array[array[1, 2], array[3, 4]]);
  batch_plan: 'BatchValues { rows: [[''integer[][]'':Varchar]] }'
- sql: |
    select 1 = SOME(1);
  binder_error: |
    Failed to bind expression: 1 = SOME(1)

    Caused by:
      Bind error: op SOME/ANY/ALL (array) requires array on right side
- sql: |
    select 1 < SOME(null);
  logical_plan: |-
    LogicalProject { exprs: [Some((1:Int32 < null:List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ANY(null);
  logical_plan: |-
    LogicalProject { exprs: [Some((1:Int32 < null:List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ALL(null);
  logical_plan: |-
    LogicalProject { exprs: [All((1:Int32 < null:List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ALL('{2,3}');
  logical_plan: |-
    LogicalProject { exprs: [All((1:Int32 < ARRAY[2, 3]:List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < SOME(null::integer[]);
  logical_plan: |-
    LogicalProject { exprs: [Some((1:Int32 < null:List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < SOME(null::varchar[]);
  binder_error: |
    Failed to bind expression: 1 < SOME(CAST(NULL AS CHARACTER VARYING[]))

    Caused by:
      function less_than(integer, character varying) does not exist
- sql: |
    select 1 < SOME(null::date);
  binder_error: |
    Failed to bind expression: 1 < SOME(CAST(NULL AS DATE))

    Caused by:
      Bind error: op SOME/ANY/ALL (array) requires array on right side
- name: array/struct on left not supported yet 5808
  sql: |
    select array[1] < SOME(null);
  binder_error: |
    Failed to bind expression: ARRAY[1] < SOME(NULL)

    Caused by:
      Bind error: array/struct on left are not supported yet
- name: array of array/struct on right not supported yet 5808
  sql: |
    select null < SOME(array[array[1]]);
  binder_error: |
    Failed to bind expression: NULL < SOME(ARRAY[ARRAY[1]])

    Caused by:
      Bind error: array of array/struct on right are not supported yet
- sql: |
    select 1 < SOME(array[null]::integer[]);
  logical_plan: |-
    LogicalProject { exprs: [Some((1:Int32 < Array(null:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < SOME(array[1, 2]);
  logical_plan: |-
    LogicalProject { exprs: [Some((1:Int32 < Array(1:Int32, 2:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < SOME((select array[1]) || array[2]);
  logical_plan: |-
    LogicalProject { exprs: [Some((1:Int32 < ArrayCat($expr1, Array(2:Int32)))) as $expr2] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalProject { exprs: [Array(1:Int32) as $expr1] }
        └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |-
    BatchProject { exprs: [Some((1:Int32 < ArrayCat($expr10009, ARRAY[2]:List(Int32)))) as $expr1] }
    └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
      ├─BatchValues { rows: [[]] }
      └─BatchValues { rows: [[ARRAY[1]:List(Int32)]] }
- sql: |
    select 1 < ALL(array[null]::integer[]);
  logical_plan: |-
    LogicalProject { exprs: [All((1:Int32 < Array(null:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ALL(array[1, 2]);
  logical_plan: |-
    LogicalProject { exprs: [All((1:Int32 < Array(1:Int32, 2:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ALL((select array[1]) || array[2]);
  logical_plan: |-
    LogicalProject { exprs: [All((1:Int32 < ArrayCat($expr1, Array(2:Int32)))) as $expr2] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalProject { exprs: [Array(1:Int32) as $expr1] }
        └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |-
    BatchProject { exprs: [All((1:Int32 < ArrayCat($expr10009, ARRAY[2]:List(Int32)))) as $expr1] }
    └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
      ├─BatchValues { rows: [[]] }
      └─BatchValues { rows: [[ARRAY[1]:List(Int32)]] }
- name: now expression
  sql: |
    create table t (v1 timestamp with time zone);
    select * from t where v1 >= now();
  logical_plan: |-
    LogicalProject { exprs: [t.v1] }
    └─LogicalFilter { predicate: (t.v1 >= Now) }
      └─LogicalScan { table: t, columns: [t.v1, t._row_id, t._rw_timestamp] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck, watermark_columns: [v1] }
    └─StreamDynamicFilter { predicate: (t.v1 >= now), output_watermarks: [[t.v1]], output: [t.v1, t._row_id], cleaned_by_watermark: true }
      ├─StreamTableScan { table: t, columns: [t.v1, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamNow { output: [now] }
- name: now expression with proj
  sql: |
    create table t (v1 timestamp with time zone);
    select * from t where v1 >= now() - INTERVAL '2' SECOND;
  logical_plan: |-
    LogicalProject { exprs: [t.v1] }
    └─LogicalFilter { predicate: (t.v1 >= (Now - '00:00:02':Interval)) }
      └─LogicalScan { table: t, columns: [t.v1, t._row_id, t._rw_timestamp] }
  stream_plan: |-
    StreamMaterialize { columns: [v1, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck, watermark_columns: [v1] }
    └─StreamDynamicFilter { predicate: (t.v1 >= $expr1), output_watermarks: [[t.v1]], output: [t.v1, t._row_id], cleaned_by_watermark: true }
      ├─StreamTableScan { table: t, columns: [t.v1, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:00:02':Interval, 'UTC':Varchar) as $expr1], output_watermarks: [[$expr1]] }
          └─StreamNow { output: [now] }
- name: and of two now expression condition
  sql: |
    create table t (v1 timestamp with time zone, v2 timestamp with time zone);
    select * from t where v1 >= now() and v2 >= now();
  stream_plan: |-
    StreamMaterialize { columns: [v1, v2, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck, watermark_columns: [v2] }
    └─StreamDynamicFilter { predicate: (t.v2 >= now), output_watermarks: [[t.v2]], output: [t.v1, t.v2, t._row_id], cleaned_by_watermark: true }
      ├─StreamDynamicFilter { predicate: (t.v1 >= now), output_watermarks: [[t.v1]], output: [t.v1, t.v2, t._row_id], cleaned_by_watermark: true }
      │ ├─StreamTableScan { table: t, columns: [t.v1, t.v2, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
      │ └─StreamExchange { dist: Broadcast }
      │   └─StreamNow { output: [now] }
      └─StreamExchange { dist: Broadcast }
        └─StreamNow { output: [now] }
- name: or of two now expression condition
  sql: |
    create table t (v1 timestamp with time zone, v2 timestamp with time zone);
    select * from t where v1 >= now() or v2 >= now();
  stream_error: Conditions containing now must be in the form of `input_expr cmp now_expr` or `now_expr cmp input_expr`, where `input_expr` references a column and contains no `now()`, and `now_expr` is a non-decreasing expression contains `now()`.
- name: now inside HAVING clause
  sql: |
    create table t (v1 timestamp with time zone, v2 int);
    select max(v1) as max_time from t group by v2 having max(v1) >= now();
  stream_plan: |-
    StreamMaterialize { columns: [max_time, t.v2(hidden)], stream_key: [t.v2], pk_columns: [t.v2], pk_conflict: NoCheck, watermark_columns: [max_time] }
    └─StreamProject { exprs: [max(t.v1), t.v2], output_watermarks: [[max(t.v1)]] }
      └─StreamDynamicFilter { predicate: (max(t.v1) >= now), output_watermarks: [[max(t.v1)]], output: [t.v2, max(t.v1)], cleaned_by_watermark: true }
        ├─StreamProject { exprs: [t.v2, max(t.v1)] }
        │ └─StreamHashAgg { group_key: [t.v2], aggs: [max(t.v1), count] }
        │   └─StreamExchange { dist: HashShard(t.v2) }
        │     └─StreamTableScan { table: t, columns: [t.v1, t.v2, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: forbid now in group by for stream
  sql: |
    create table t (v1 timestamp with time zone, v2 int);
    select sum(v2) as sum_v2 from t group by v1 >= now();
  stream_error: |
    Failed to bind expression: v1 >= now()

    Caused by:
      Invalid input syntax: For streaming queries, `NOW()` function is only allowed in `WHERE`, `HAVING`, `ON` and `FROM`. Found in clause: Some(GroupBy). Please please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: forbid now in select for stream
  sql: |
    create table t (v1 timestamp with time zone, v2 timestamp with time zone);
    select now() as n, * from t where v1 >= now();
  stream_error: |
    Failed to bind expression: now()

    Caused by:
      Invalid input syntax: For streaming queries, `NOW()` function is only allowed in `WHERE`, `HAVING`, `ON` and `FROM`. Found in clause: None. Please please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: forbid now in agg filter for stream
  sql: |
    create table t (v1 timestamp with time zone, v2 int);
    select sum(v2) filter (where v1 >= now()) as sum_v2 from t;
  stream_error: |
    Failed to bind expression: sum(v2) FILTER (WHERE v1 >= now())

    Caused by:
      Invalid input syntax: For streaming queries, `NOW()` function is only allowed in `WHERE`, `HAVING`, `ON` and `FROM`. Found in clause: Some(Filter). Please please refer to https://www.risingwave.dev/docs/current/sql-pattern-temporal-filters/ for more information
- name: typo pg_teminate_backend
  sql: |
    select pg_teminate_backend(1);
  binder_error: |
    Failed to bind expression: pg_teminate_backend(1)

    Caused by:
      function pg_teminate_backend(integer) does not exist, do you mean pg_terminate_backend
- name: regression (#7571) - literal debug display for array with NULL values
  sql: |
    select ARRAY[1, null] t;
  logical_plan: |-
    LogicalProject { exprs: [Array(1:Int32, null:Int32) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: regression (#7641) -fuzzing test failed at Bind error,types Boolean and Varchar cannot be matched
  sql: |
    select false >= 'LN1O0QP1yi' NOT IN (md5('4SeUPZhUbH'))
  batch_plan: 'BatchValues { rows: [[false:Boolean]] }'
- name: const_eval of const expr
  sql: |
    create table t(v1 int);
    select 1 + 2 + v1 from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [(3:Int32 + t.v1) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: const_eval of division by 0 error
  sql: select 1 / 0 t1;
  batch_error: |
    Expr error

    Caused by these errors (recent errors listed first):
      1: error while evaluating expression `general_div('1', '0')`
      2: Division by zero
- sql: |
    select * from abs(-1);
  batch_plan: 'BatchValues { rows: [[1:Int32]] }'
  stream_plan: |-
    StreamMaterialize { columns: [abs, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamValues { rows: [[1:Int32, 0:Int64]] }
- sql: |
    select * from range(1,2);
  batch_plan: |-
    BatchProject { exprs: [Range(1:Int32, 2:Int32)] }
    └─BatchProjectSet { select_list: [Range(1:Int32, 2:Int32)] }
      └─BatchValues { rows: [[]] }
  stream_plan: |-
    StreamMaterialize { columns: [range, _row_id(hidden), projected_row_id(hidden)], stream_key: [_row_id, projected_row_id], pk_columns: [_row_id, projected_row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Range(1:Int32, 2:Int32), _row_id, projected_row_id] }
      └─StreamProjectSet { select_list: [Range(1:Int32, 2:Int32), $0] }
        └─StreamValues { rows: [[0:Int64]] }
- sql: |
    select * from max();
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in FROM'
- sql: |
    create table t (k int, j jsonb);
    select a * k + b from t, jsonb_populate_record(null::struct<a int, b int>, j);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [((Field($expr1, 0:Int32) * t.k) + Field($expr1, 1:Int32)) as $expr2] }
      └─BatchHashJoin { type: Inner, predicate: t.j IS NOT DISTINCT FROM t.j, output: all }
        ├─BatchExchange { order: [], dist: HashShard(t.j) }
        │ └─BatchScan { table: t, columns: [t.k, t.j], distribution: SomeShard }
        └─BatchExchange { order: [], dist: HashShard(t.j) }
          └─BatchProject { exprs: [t.j, JsonbPopulateRecord(null:Struct(StructType { fields: [("a", Int32), ("b", Int32)] }), t.j) as $expr1] }
            └─BatchNestedLoopJoin { type: Inner, predicate: true, output: all }
              ├─BatchExchange { order: [], dist: Single }
              │ └─BatchHashAgg { group_key: [t.j], aggs: [] }
              │   └─BatchExchange { order: [], dist: HashShard(t.j) }
              │     └─BatchScan { table: t, columns: [t.j], distribution: SomeShard }
              └─BatchValues { rows: [[]] }
- name: Grafana issue-10134
  sql: |
    SELECT * FROM
    generate_series(
      array_lower(string_to_array(current_setting('search_path'),','),1),
      array_upper(string_to_array(current_setting('search_path'),','),1)
    ) as i,
    string_to_array(current_setting('search_path'),',') s
  batch_plan: |-
    BatchNestedLoopJoin { type: Inner, predicate: true, output: [GenerateSeries(1:Int32, 2:Int32), ] }
    ├─BatchProjectSet { select_list: [GenerateSeries(1:Int32, 2:Int32)] }
    │ └─BatchValues { rows: [[]] }
    └─BatchValues { rows: [[ARRAY["$user",  public]:List(Varchar)]] }
  stream_error: |-
    Not supported: streaming nested-loop join
    HINT: The non-equal join in the query requires a nested-loop join executor, which could be very expensive to run. Consider rewriting the query to use dynamic filter as a substitute if possible.
    See also: https://docs.risingwave.com/docs/current/sql-pattern-dynamic-filters/
- name: without variadic keyword
  sql: |
    create table t(a varchar, b varchar);
    select concat_ws(',', a, b) from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs(',':Varchar, t.a, t.b) as $expr1] }
      └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
- name: with variadic keyword
  sql: |
    create table t(a varchar, b varchar);
    select concat_ws(',', variadic array[a, b]) from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWsVariadic(',':Varchar, Array(t.a, t.b)) as $expr1] }
      └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
