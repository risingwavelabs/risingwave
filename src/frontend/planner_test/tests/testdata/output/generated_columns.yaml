# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: table with generated columns
  sql: |
    explain create table t1 (v1 int as v2-1, v2 int, v3 int as v2+1);
  explain_output: |
    StreamMaterialize { columns: [v1, v2, v3, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: Overwrite }
    └─StreamRowIdGen { row_id_index: 3 }
      └─StreamUnion { all: true }
        ├─StreamExchange { dist: HashShard(_row_id) }
        │ └─StreamProject { exprs: [(v2 - 1:Int32) as $expr1, v2, (v2 + 1:Int32) as $expr2, _row_id] }
        │   └─StreamDml { columns: [v2, _row_id] }
        │     └─StreamSource
        └─StreamUpstreamSinkUnion
- name: source with generated columns
  sql: |
    create source s1 (v1 int as v2-1, v2 int, v3 int as v2+1) with (connector = 'kinesis') FORMAT PLAIN ENCODE JSON;
    select v3 from s1
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [(v2 + 1:Int32) as $expr1] }
      └─BatchSource { source: s1, columns: [v2, _row_id] }
- name: select proctime()
  sql: |
    select proctime();
  binder_error: |
    Failed to bind expression: proctime()

    Caused by:
      Invalid input syntax: Function `PROCTIME()` is only allowed in CREATE TABLE/SOURCE. Is `NOW()` what you want?
- name: proctime cast to with timezone
  sql: |
    explain create table t1 (proc_time TIMESTAMPTZ AS proctime());
  explain_output: |
    StreamMaterialize { columns: [proc_time, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: Overwrite, watermark_columns: [proc_time] }
    └─StreamRowIdGen { row_id_index: 1 }
      └─StreamUnion { all: true, output_watermarks: [[$expr1]] }
        ├─StreamExchange { dist: HashShard(_row_id) }
        │ └─StreamProject { exprs: [Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │   └─StreamDml { columns: [_row_id] }
        │     └─StreamSource
        └─StreamUpstreamSinkUnion
- name: proctime cast to without timezone
  sql: |
    explain create table t1 (proc_time TIMESTAMP AS proctime());
  explain_output: |
    StreamMaterialize { columns: [proc_time, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: Overwrite, watermark_columns: [proc_time] }
    └─StreamRowIdGen { row_id_index: 1 }
      └─StreamUnion { all: true, output_watermarks: [[$expr1]] }
        ├─StreamExchange { dist: HashShard(_row_id) }
        │ └─StreamProject { exprs: [AtTimeZone(Proctime, 'UTC':Varchar) as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │   └─StreamDml { columns: [_row_id] }
        │     └─StreamSource
        └─StreamUpstreamSinkUnion
- name: watermark on generated column
  sql: |
    explain create table t (v int, w int as v+1, watermark for w as w) append only
  explain_output: |
    StreamMaterialize { columns: [v, w, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck, watermark_columns: [w] }
    └─StreamRowIdGen { row_id_index: 2 }
      └─StreamWatermarkFilter { watermark_descs: [Desc { column: $expr1, expr: $expr1 }], output_watermarks: [[$expr1]] }
        └─StreamUnion { all: true }
          ├─StreamExchange [no_shuffle] { dist: SomeShard }
          │ └─StreamProject { exprs: [v, (v + 1:Int32) as $expr1, _row_id] }
          │   └─StreamDml { columns: [v, _row_id] }
          │     └─StreamSource
          └─StreamUpstreamSinkUnion
