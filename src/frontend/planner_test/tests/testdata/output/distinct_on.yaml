# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t1 (k int, v int) append only;
    select distinct on (k) k + v as sum from t1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr1] }
      └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t1.k] }
        └─BatchExchange { order: [], dist: HashShard(t1.k) }
          └─BatchProject { exprs: [(t1.k + t1.v) as $expr1, t1.k] }
            └─BatchScan { table: t1, columns: [t1.k, t1.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [sum, t1.k(hidden)], stream_key: [t1.k], pk_columns: [t1.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, t1.k] }
      └─StreamAppendOnlyDedup { dedup_cols: [t1.k] }
        └─StreamExchange { dist: HashShard(t1.k) }
          └─StreamProject { exprs: [(t1.k + t1.v) as $expr1, t1.k, t1._row_id] }
            └─StreamTableScan { table: t1, columns: [t1.k, t1.v, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
- sql: |
    create table t2 (k int, v int);
    select distinct on (k) k + v as sum from t2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr1] }
      └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t2.k] }
        └─BatchExchange { order: [], dist: HashShard(t2.k) }
          └─BatchProject { exprs: [(t2.k + t2.v) as $expr1, t2.k] }
            └─BatchScan { table: t2, columns: [t2.k, t2.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [sum, t2.k(hidden)], stream_key: [t2.k], pk_columns: [t2.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, t2.k] }
      └─StreamGroupTopN { order: [], limit: 1, offset: 0, group_key: [t2.k] }
        └─StreamExchange { dist: HashShard(t2.k) }
          └─StreamProject { exprs: [(t2.k + t2.v) as $expr1, t2.k, t2._row_id] }
            └─StreamTableScan { table: t2, columns: [t2.k, t2.v, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- sql: |
    create table t (a int, b int, c int);
    select distinct on (foo, b) a as foo, b from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.a, t.b] }
      └─BatchExchange { order: [], dist: HashShard(t.a, t.b) }
        └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [foo, b, t._row_id(hidden)], stream_key: [foo, b], pk_columns: [foo, b], pk_conflict: NoCheck }
    └─StreamGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.a, t.b] }
      └─StreamExchange { dist: HashShard(t.a, t.b) }
        └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (a int, b int, c int);
    select distinct on (2) a as foo, b from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.b] }
      └─BatchExchange { order: [], dist: HashShard(t.b) }
        └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [foo, b, t._row_id(hidden)], stream_key: [b], pk_columns: [b], pk_conflict: NoCheck }
    └─StreamGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.b] }
      └─StreamExchange { dist: HashShard(t.b) }
        └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t1(a int, b int, c int, k int);
    create table t2(k int);
    select distinct on (a) * from t2 join t1 on t1.k = t2.k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t1.a] }
      └─BatchExchange { order: [], dist: HashShard(t1.a) }
        └─BatchHashJoin { type: Inner, predicate: t2.k = t1.k, output: all }
          ├─BatchExchange { order: [], dist: HashShard(t2.k) }
          │ └─BatchScan { table: t2, columns: [t2.k], distribution: SomeShard }
          └─BatchExchange { order: [], dist: HashShard(t1.k) }
            └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c, t1.k], distribution: SomeShard }
- sql: |
    create table t1(a int, b int, c int, k int);
    create table t2(k int);
    select distinct on (3) * from t2 join t1 on t1.k = t2.k;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t1.b] }
      └─BatchExchange { order: [], dist: HashShard(t1.b) }
        └─BatchHashJoin { type: Inner, predicate: t2.k = t1.k, output: all }
          ├─BatchExchange { order: [], dist: HashShard(t2.k) }
          │ └─BatchScan { table: t2, columns: [t2.k], distribution: SomeShard }
          └─BatchExchange { order: [], dist: HashShard(t1.k) }
            └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c, t1.k], distribution: SomeShard }
- sql: |
    CREATE TABLE secret_one (
      field_one character varying,
      field_two timestamp with time zone,
      field_three character varying,
      field_four double precision,
      field_five boolean
    );
    SELECT DISTINCT ON (window_start) * FROM  TUMBLE(secret_one, field_two, INTERVAL '1' minute);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [$expr1] }
      └─BatchExchange { order: [], dist: HashShard($expr1) }
        └─BatchProject { exprs: [secret_one.field_one, secret_one.field_two, secret_one.field_three, secret_one.field_four, secret_one.field_five, $expr1, AddWithTimeZone($expr1, '00:01:00':Interval, 'UTC':Varchar) as $expr2] }
          └─BatchProject { exprs: [secret_one.field_one, secret_one.field_two, secret_one.field_three, secret_one.field_four, secret_one.field_five, TumbleStart(secret_one.field_two, '00:01:00':Interval) as $expr1] }
            └─BatchScan { table: secret_one, columns: [secret_one.field_one, secret_one.field_two, secret_one.field_three, secret_one.field_four, secret_one.field_five], distribution: SomeShard }
- sql: |
    create table t (a int, b int, c int);
    select distinct on (4) * from t;
  binder_error: 'Invalid input syntax: Invalid ordinal number in DISTINCT ON: 4'
- sql: |
    create table t (a int, b int, c int);
    WITH s AS (SELECT DISTINCT ON (a+1) true as id, * FROM t) SELECT a,b,c from s;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [t.a, t.b, t.c] }
      └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [$expr1] }
        └─BatchExchange { order: [], dist: HashShard($expr1) }
          └─BatchProject { exprs: [t.a, t.b, t.c, (t.a + 1:Int32) as $expr1] }
            └─BatchScan { table: t, columns: [t.a, t.b, t.c], distribution: SomeShard }
- sql: |
    create table t (a int, b int, c int);
    select count(*) from (select distinct on(a) * from t);
  logical_plan: |-
    LogicalProject { exprs: [count] }
    └─LogicalAgg { aggs: [count] }
      └─LogicalProject { exprs: [] }
        └─LogicalDedup { dedup_cols: [t.a] }
          └─LogicalProject { exprs: [t.a, t.b, t.c] }
            └─LogicalScan { table: t, columns: [t.a, t.b, t.c, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum0(count)] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count] }
        └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.a] }
          └─BatchExchange { order: [], dist: HashShard(t.a) }
            └─BatchScan { table: t, columns: [t.a], distribution: SomeShard }
- sql: |
    create table t (a int, b int, c int);
    select count(*) from (select distinct on(b) * from t);
  logical_plan: |-
    LogicalProject { exprs: [count] }
    └─LogicalAgg { aggs: [count] }
      └─LogicalProject { exprs: [] }
        └─LogicalDedup { dedup_cols: [t.b] }
          └─LogicalProject { exprs: [t.a, t.b, t.c] }
            └─LogicalScan { table: t, columns: [t.a, t.b, t.c, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum0(count)] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count] }
        └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.b] }
          └─BatchExchange { order: [], dist: HashShard(t.b) }
            └─BatchScan { table: t, columns: [t.b], distribution: SomeShard }
- sql: |
    create table t (a int, b int, c int);
    select count(*) from (select distinct on(a,b) * from t);
  logical_plan: |-
    LogicalProject { exprs: [count] }
    └─LogicalAgg { aggs: [count] }
      └─LogicalProject { exprs: [] }
        └─LogicalDedup { dedup_cols: [t.a, t.b] }
          └─LogicalProject { exprs: [t.a, t.b, t.c] }
            └─LogicalScan { table: t, columns: [t.a, t.b, t.c, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchSimpleAgg { aggs: [sum0(count)] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count] }
        └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.a, t.b] }
          └─BatchExchange { order: [], dist: HashShard(t.a, t.b) }
            └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
