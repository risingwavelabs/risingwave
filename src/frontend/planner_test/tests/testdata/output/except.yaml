# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create table t2 (a int, b numeric, c bigint);
    select * from t1 except all select * from t2;
  binder_error: |-
    Feature is not yet implemented: EXCEPT all
    No tracking issue yet. Feel free to submit a feature request at https://github.com/risingwavelabs/risingwave/issues/new?labels=type%2Ffeature&template=feature_request.yml
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create table t2 (a int, b numeric, c bigint);
    select * from t1 except select * from t2;
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [t1.a, t1.b, t1.c], aggs: [] }
    └─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(t1.a, t2.a) AND IsNotDistinctFrom(t1.b, t2.b) AND IsNotDistinctFrom(t1.c, t2.c), output: all }
      ├─LogicalScan { table: t1, columns: [t1.a, t1.b, t1.c] }
      └─LogicalScan { table: t2, columns: [t2.a, t2.b, t2.c] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashAgg { group_key: [t1.a, t1.b, t1.c], aggs: [] }
      └─BatchHashJoin { type: LeftAnti, predicate: t1.a IS NOT DISTINCT FROM t2.a AND t1.b IS NOT DISTINCT FROM t2.b AND t1.c IS NOT DISTINCT FROM t2.c, output: all }
        ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b, t1.c) }
        │ └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c], distribution: SomeShard }
        └─BatchExchange { order: [], dist: HashShard(t2.a, t2.b, t2.c) }
          └─BatchScan { table: t2, columns: [t2.a, t2.b, t2.c], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a, b, c], stream_key: [a, b, c], pk_columns: [a, b, c], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.a, t1.b, t1.c], noop_update_hint: true }
      └─StreamHashAgg { group_key: [t1.a, t1.b, t1.c], aggs: [count] }
        └─StreamHashJoin { type: LeftAnti, predicate: t1.a IS NOT DISTINCT FROM t2.a AND t1.b IS NOT DISTINCT FROM t2.b AND t1.c IS NOT DISTINCT FROM t2.c, output: all }
          ├─StreamExchange { dist: HashShard(t1.a, t1.b, t1.c) }
          │ └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1.c, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          └─StreamExchange { dist: HashShard(t2.a, t2.b, t2.c) }
            └─StreamTableScan { table: t2, columns: [t2.a, t2.b, t2.c, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a, b, c], stream_key: [a, b, c], pk_columns: [a, b, c], pk_conflict: NoCheck }
    └── StreamProject { exprs: [t1.a, t1.b, t1.c], noop_update_hint: true }
        └── StreamHashAgg { group_key: [t1.a, t1.b, t1.c], aggs: [count] } { tables: [ HashAggState: 0 ] }
            └── StreamHashJoin { type: LeftAnti, predicate: t1.a IS NOT DISTINCT FROM t2.a AND t1.b IS NOT DISTINCT FROM t2.b AND t1.c IS NOT DISTINCT FROM t2.c, output: all }
                ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
                ├── StreamExchange Hash([0, 1, 2]) from 1
                └── StreamExchange Hash([0, 1, 2]) from 2

    Fragment 1
    StreamTableScan { table: t1, columns: [t1.a, t1.b, t1.c, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
    ├── tables: [ StreamScan: 5 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 2
    StreamTableScan { table: t2, columns: [t2.a, t2.b, t2.c, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
    ├── tables: [ StreamScan: 6 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ t1_a, t1_b, t1_c, count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 1
    ├── columns: [ t1_a, t1_b, t1_c, t1__row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 3

    Table 2
    ├── columns: [ t1_a, t1_b, t1_c, t1__row_id, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ]
    ├── value indices: [ 4 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 3

    Table 3
    ├── columns: [ t2_a, t2_b, t2_c, t2__row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 3

    Table 4
    ├── columns: [ t2_a, t2_b, t2_c, t2__row_id, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ]
    ├── value indices: [ 4 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 3

    Table 5
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 6
    ├── columns: [ vnode, _row_id, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ a, b, c, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

- sql: |
    create table t1 (a int, b numeric, c bigint, primary key(a));
    create table t2 (a int, b numeric, c bigint, primary key(a));
    select * from t1 except select * from t2;
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [t1.a], aggs: [internal_last_seen_value(t1.b), internal_last_seen_value(t1.c)] }
    └─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(t1.a, t2.a) AND IsNotDistinctFrom(t1.b, t2.b) AND IsNotDistinctFrom(t1.c, t2.c), output: all }
      ├─LogicalScan { table: t1, columns: [t1.a, t1.b, t1.c] }
      └─LogicalScan { table: t2, columns: [t2.a, t2.b, t2.c] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashAgg { group_key: [t1.a], aggs: [internal_last_seen_value(t1.b), internal_last_seen_value(t1.c)] }
      └─BatchLookupJoin { type: LeftAnti, predicate: t1.a IS NOT DISTINCT FROM t2.a AND t1.b IS NOT DISTINCT FROM t2.b AND t1.c IS NOT DISTINCT FROM t2.c, output: all, lookup table: t2 }
        └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
          └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c], distribution: UpstreamHashShard(t1.a) }
  stream_plan: |-
    StreamMaterialize { columns: [a, b, c], stream_key: [a], pk_columns: [a], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.a, internal_last_seen_value(t1.b), internal_last_seen_value(t1.c)] }
      └─StreamHashAgg { group_key: [t1.a], aggs: [internal_last_seen_value(t1.b), internal_last_seen_value(t1.c), count] }
        └─StreamExchange { dist: HashShard(t1.a) }
          └─StreamHashJoin { type: LeftAnti, predicate: t1.a IS NOT DISTINCT FROM t2.a AND t1.b IS NOT DISTINCT FROM t2.b AND t1.c IS NOT DISTINCT FROM t2.c, output: all }
            ├─StreamExchange { dist: HashShard(t1.a, t1.b, t1.c) }
            │ └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1.c], stream_scan_type: ArrangementBackfill, stream_key: [t1.a], pk: [a], dist: UpstreamHashShard(t1.a) }
            └─StreamExchange { dist: HashShard(t2.a, t2.b, t2.c) }
              └─StreamTableScan { table: t2, columns: [t2.a, t2.b, t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.a], pk: [a], dist: UpstreamHashShard(t2.a) }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [a, b, c], stream_key: [a], pk_columns: [a], pk_conflict: NoCheck }
    └── StreamProject { exprs: [t1.a, internal_last_seen_value(t1.b), internal_last_seen_value(t1.c)] }
        └── StreamHashAgg { group_key: [t1.a], aggs: [internal_last_seen_value(t1.b), internal_last_seen_value(t1.c), count] }
            ├── tables: [ HashAggState: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamHashJoin { type: LeftAnti, predicate: t1.a IS NOT DISTINCT FROM t2.a AND t1.b IS NOT DISTINCT FROM t2.b AND t1.c IS NOT DISTINCT FROM t2.c, output: all }
    ├── tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ]
    ├── StreamExchange Hash([0, 1, 2]) from 2
    └── StreamExchange Hash([0, 1, 2]) from 3

    Fragment 2
    StreamTableScan { table: t1, columns: [t1.a, t1.b, t1.c], stream_scan_type: ArrangementBackfill, stream_key: [t1.a], pk: [a], dist: UpstreamHashShard(t1.a) }
    ├── tables: [ StreamScan: 5 ]
    ├── Upstream
    └── BatchPlanNode

    Fragment 3
    StreamTableScan { table: t2, columns: [t2.a, t2.b, t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.a], pk: [a], dist: UpstreamHashShard(t2.a) }
    ├── tables: [ StreamScan: 6 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0
    ├── columns: [ t1_a, internal_last_seen_value(t1_b), internal_last_seen_value(t1_c), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1
    ├── columns: [ t1_a, t1_b, t1_c, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 3

    Table 2
    ├── columns: [ t1_a, t1_b, t1_c, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 3 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 3

    Table 3
    ├── columns: [ t2_a, t2_b, t2_c, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 3

    Table 4
    ├── columns: [ t2_a, t2_b, t2_c, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 3 ]
    ├── distribution key: [ 0, 1, 2 ]
    └── read pk prefix len hint: 3

    Table 5
    ├── columns: [ vnode, a, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 6
    ├── columns: [ vnode, a, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294
    ├── columns: [ a, b, c, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

- sql: |
    create table t1 (a int, b numeric, c bigint);
    create table t2 (a int, b numeric, c bigint);
    (select * from t1 limit 1) except (select * from t2 limit 1);
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [t1.a, t1.b, t1.c], aggs: [] }
    └─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(t1.a, t2.a) AND IsNotDistinctFrom(t1.b, t2.b) AND IsNotDistinctFrom(t1.c, t2.c), output: all }
      ├─LogicalLimit { limit: 1, offset: 0 }
      │ └─LogicalScan { table: t1, columns: [t1.a, t1.b, t1.c] }
      └─LogicalLimit { limit: 1, offset: 0 }
        └─LogicalScan { table: t2, columns: [t2.a, t2.b, t2.c] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashAgg { group_key: [t1.a, t1.b, t1.c], aggs: [] }
      └─BatchHashJoin { type: LeftAnti, predicate: t1.a IS NOT DISTINCT FROM t2.a AND t1.b IS NOT DISTINCT FROM t2.b AND t1.c IS NOT DISTINCT FROM t2.c, output: all }
        ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b, t1.c) }
        │ └─BatchLimit { limit: 1, offset: 0 }
        │   └─BatchExchange { order: [], dist: Single, sequential: true }
        │     └─BatchLimit { limit: 1, offset: 0 }
        │       └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c], limit: 1, distribution: SomeShard }
        └─BatchExchange { order: [], dist: HashShard(t2.a, t2.b, t2.c) }
          └─BatchLimit { limit: 1, offset: 0 }
            └─BatchExchange { order: [], dist: Single, sequential: true }
              └─BatchLimit { limit: 1, offset: 0 }
                └─BatchScan { table: t2, columns: [t2.a, t2.b, t2.c], limit: 1, distribution: SomeShard }
- sql: |
    create table t1 (a int, b numeric, c bigint);
    create table t2 (a int, b numeric, c bigint);
    select a from ((select * from t1 limit 1) except (select * from t2 limit 1)) T;
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [t1.a] }
    └─LogicalAgg { group_key: [t1.a, t1.b, t1.c], aggs: [] }
      └─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(t1.a, t2.a) AND IsNotDistinctFrom(t1.b, t2.b) AND IsNotDistinctFrom(t1.c, t2.c), output: all }
        ├─LogicalLimit { limit: 1, offset: 0 }
        │ └─LogicalScan { table: t1, columns: [t1.a, t1.b, t1.c] }
        └─LogicalLimit { limit: 1, offset: 0 }
          └─LogicalScan { table: t2, columns: [t2.a, t2.b, t2.c] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [t1.a] }
      └─BatchHashAgg { group_key: [t1.a, t1.b, t1.c], aggs: [] }
        └─BatchHashJoin { type: LeftAnti, predicate: t1.a IS NOT DISTINCT FROM t2.a AND t1.b IS NOT DISTINCT FROM t2.b AND t1.c IS NOT DISTINCT FROM t2.c, output: all }
          ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b, t1.c) }
          │ └─BatchLimit { limit: 1, offset: 0 }
          │   └─BatchExchange { order: [], dist: Single, sequential: true }
          │     └─BatchLimit { limit: 1, offset: 0 }
          │       └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c], limit: 1, distribution: SomeShard }
          └─BatchExchange { order: [], dist: HashShard(t2.a, t2.b, t2.c) }
            └─BatchLimit { limit: 1, offset: 0 }
              └─BatchExchange { order: [], dist: Single, sequential: true }
                └─BatchLimit { limit: 1, offset: 0 }
                  └─BatchScan { table: t2, columns: [t2.a, t2.b, t2.c], limit: 1, distribution: SomeShard }
- sql: |
    select 1 except select 2 except select 3 except select 4 except select 5 except select 5
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [1:Int32], aggs: [] }
    └─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(1:Int32, 5:Int32), output: all }
      ├─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(1:Int32, 5:Int32), output: all }
      │ ├─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(1:Int32, 4:Int32), output: all }
      │ │ ├─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(1:Int32, 3:Int32), output: all }
      │ │ │ ├─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(1:Int32, 2:Int32), output: all }
      │ │ │ │ ├─LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [1:Int32:Int32] } }
      │ │ │ │ └─LogicalValues { rows: [[2:Int32]], schema: Schema { fields: [2:Int32:Int32] } }
      │ │ │ └─LogicalValues { rows: [[3:Int32]], schema: Schema { fields: [3:Int32:Int32] } }
      │ │ └─LogicalValues { rows: [[4:Int32]], schema: Schema { fields: [4:Int32:Int32] } }
      │ └─LogicalValues { rows: [[5:Int32]], schema: Schema { fields: [5:Int32:Int32] } }
      └─LogicalValues { rows: [[5:Int32]], schema: Schema { fields: [5:Int32:Int32] } }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashAgg { group_key: [1:Int32], aggs: [] }
      └─BatchHashJoin { type: LeftAnti, predicate: 1:Int32 IS NOT DISTINCT FROM 5:Int32, output: all }
        ├─BatchHashJoin { type: LeftAnti, predicate: 1:Int32 IS NOT DISTINCT FROM 5:Int32, output: all }
        │ ├─BatchHashJoin { type: LeftAnti, predicate: 1:Int32 IS NOT DISTINCT FROM 4:Int32, output: all }
        │ │ ├─BatchHashJoin { type: LeftAnti, predicate: 1:Int32 IS NOT DISTINCT FROM 3:Int32, output: all }
        │ │ │ ├─BatchHashJoin { type: LeftAnti, predicate: 1:Int32 IS NOT DISTINCT FROM 2:Int32, output: all }
        │ │ │ │ ├─BatchExchange { order: [], dist: HashShard(1:Int32) }
        │ │ │ │ │ └─BatchValues { rows: [[1:Int32]] }
        │ │ │ │ └─BatchExchange { order: [], dist: HashShard(2:Int32) }
        │ │ │ │   └─BatchValues { rows: [[2:Int32]] }
        │ │ │ └─BatchExchange { order: [], dist: HashShard(3:Int32) }
        │ │ │   └─BatchValues { rows: [[3:Int32]] }
        │ │ └─BatchExchange { order: [], dist: HashShard(4:Int32) }
        │ │   └─BatchValues { rows: [[4:Int32]] }
        │ └─BatchExchange { order: [], dist: HashShard(5:Int32) }
        │   └─BatchValues { rows: [[5:Int32]] }
        └─BatchExchange { order: [], dist: HashShard(5:Int32) }
          └─BatchValues { rows: [[5:Int32]] }
- sql: |
    select 1 except (select 2 except select 1);
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [1:Int32], aggs: [] }
    └─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(1:Int32, 2:Int32), output: all }
      ├─LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [1:Int32:Int32] } }
      └─LogicalAgg { group_key: [2:Int32], aggs: [] }
        └─LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(2:Int32, 1:Int32), output: all }
          ├─LogicalValues { rows: [[2:Int32]], schema: Schema { fields: [2:Int32:Int32] } }
          └─LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [1:Int32:Int32] } }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashAgg { group_key: [1:Int32], aggs: [] }
      └─BatchHashJoin { type: LeftAnti, predicate: 1:Int32 IS NOT DISTINCT FROM 2:Int32, output: all }
        ├─BatchExchange { order: [], dist: HashShard(1:Int32) }
        │ └─BatchValues { rows: [[1:Int32]] }
        └─BatchHashAgg { group_key: [2:Int32], aggs: [] }
          └─BatchHashJoin { type: LeftAnti, predicate: 2:Int32 IS NOT DISTINCT FROM 1:Int32, output: all }
            ├─BatchExchange { order: [], dist: HashShard(2:Int32) }
            │ └─BatchValues { rows: [[2:Int32]] }
            └─BatchExchange { order: [], dist: HashShard(1:Int32) }
              └─BatchValues { rows: [[1:Int32]] }
