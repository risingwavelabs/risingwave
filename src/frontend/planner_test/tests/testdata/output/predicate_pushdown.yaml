# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Always false should not be pushed below SimpleAgg
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int);
    select min(v1) from t having false;
  logical_plan: |
    LogicalProject { exprs: [min(t.v1)] }
    └─LogicalFilter { predicate: false:Boolean }
      └─LogicalAgg { aggs: [min(t.v1)] }
        └─LogicalProject { exprs: [t.v1] }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalValues { rows: [], schema: Schema { fields: [min(t.v1):Int32] } }
- name: filter should not transpose limit
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int);
    with cte as (select * from t limit 10) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
      └─LogicalShare { id = 3 }
        └─LogicalLimit { limit: 10, offset: 0 }
          └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
            └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
    └─LogicalLimit { limit: 10, offset: 0 }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4] }
- name: filter should not transpose TopN
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int);
    with cte as (select * from t order by v1 limit 10 ) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
      └─LogicalShare { id = 3 }
        └─LogicalTopN { order: "[t.v1 ASC]", limit: 10, offset: 0 }
          └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
            └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
    └─LogicalTopN { order: "[t.v1 ASC]", limit: 10, offset: 0 }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4] }
- name: filter hop transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select * from hop(t, ts, interval '1' day, interval '3' day))
    select * from cte
    where v1=10 AND v2=20 AND v3=30 AND ts >= date '1997-07-01'
    AND window_start >= date '1997-07-02' AND window_end >= date '1997-07-03'
    AND window_start >= ts + interval '1' day AND window_end > ts + interval '4' day;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, t.ts, window_start, window_end] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (t.ts >= '1997-07-01':Date) AND (window_start >= '1997-07-02':Date) AND (window_end >= '1997-07-03':Date) AND (window_start >= (t.ts + '1 day':Interval)) AND (window_end > (t.ts + '4 days':Interval)) }
      └─LogicalShare { id = 4 }
        └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, t.ts, window_start, window_end] }
          └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: all }
            └─LogicalFilter { predicate: IsNotNull(t.ts) }
              └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalFilter { predicate: (window_start >= '1997-07-02':Date) AND (window_end >= '1997-07-03':Date) AND (window_start >= (t.ts + '1 day':Interval)) AND (window_end > (t.ts + '4 days':Interval)) }
    └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: all }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts], predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (t.ts >= '1997-07-01':Date) AND IsNotNull(t.ts) }
- name: filter hop transpose with non-trivial output-indices
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select window_end, v4, v2 from hop(t, ts, interval '1' day, interval '3' day))
    select * from cte where window_end > date '2022-01-01' AND v4=10 AND v2 > 20
  logical_plan: |
    LogicalProject { exprs: [window_end, t.v4, t.v2] }
    └─LogicalFilter { predicate: (window_end > '2022-01-01':Date) AND (t.v4 = 10:Int32) AND (t.v2 > 20:Int32) }
      └─LogicalShare { id = 4 }
        └─LogicalProject { exprs: [window_end, t.v4, t.v2] }
          └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: all }
            └─LogicalFilter { predicate: IsNotNull(t.ts) }
              └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalProject { exprs: [window_end, t.v4, t.v2] }
    └─LogicalFilter { predicate: (window_end > '2022-01-01':Date) }
      └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: [t.v2, t.v4, window_end] }
        └─LogicalScan { table: t, columns: [t.v2, t.v4, t.ts], predicate: (t.v4 = 10:Int32) AND (t.v2 > 20:Int32) AND IsNotNull(t.ts) }
- name: filter union transpose
  sql: |
    create table t1 (v1 int, v2 int, v3 int);
    create table t2 (v1 int, v2 int, v3 int);
    with cte as (select * from t1 union all select * from t2) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t1.v3] }
    └─LogicalFilter { predicate: (t1.v1 = 10:Int32) AND (t1.v2 = 20:Int32) AND (t1.v3 = 30:Int32) }
      └─LogicalShare { id = 4 }
        └─LogicalUnion { all: true }
          ├─LogicalProject { exprs: [t1.v1, t1.v2, t1.v3] }
          | └─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1.v3, t1._row_id] }
          └─LogicalProject { exprs: [t2.v1, t2.v2, t2.v3] }
            └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2.v3, t2._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalUnion { all: true }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1.v3], predicate: (t1.v1 = 10:Int32) AND (t1.v2 = 20:Int32) AND (t1.v3 = 30:Int32) }
    └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2.v3], predicate: (t2.v1 = 10:Int32) AND (t2.v2 = 20:Int32) AND (t2.v3 = 30:Int32) }
- name: filter project transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select v1,v2,v3,v4,v1+v2 as expr_a, v3*v4 as expr_b from t) select * from cte where expr_a>10 AND v1=10 AND v2=20 AND v3=30 AND expr_a > expr_b AND expr_a > v1;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, $expr1, $expr2] }
    └─LogicalFilter { predicate: ($expr1 > 10:Int32) AND (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND ($expr1 > $expr2) AND ($expr1 > t.v1) }
      └─LogicalShare { id = 2 }
        └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, (t.v1 + t.v2) as $expr1, (t.v3 * t.v4) as $expr2] }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, (t.v1 + t.v2) as $expr1, (t.v3 * t.v4) as $expr2] }
    └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4], predicate: ((t.v1 + t.v2) > 10:Int32) AND (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND ((t.v1 + t.v2) > (t.v3 * t.v4)) AND ((t.v1 + t.v2) > t.v1) }
- name: filter agg transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select v1, v2, v3, count(*) as cnt, count(1) as cnt2 from t group by v1, v2, v3) select * from cte where v1=10 AND v2=20 AND v3=30 AND cnt > v1 AND v2 > v3 AND cnt > cnt2;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, count, count(1:Int32)] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (count > t.v1) AND (t.v2 > t.v3) AND (count > count(1:Int32)) }
      └─LogicalShare { id = 4 }
        └─LogicalProject { exprs: [t.v1, t.v2, t.v3, count, count(1:Int32)] }
          └─LogicalAgg { group_key: [t.v1, t.v2, t.v3], aggs: [count, count(1:Int32)] }
            └─LogicalProject { exprs: [t.v1, t.v2, t.v3, 1:Int32] }
              └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalFilter { predicate: (count > t.v1) AND (count > count(1:Int32)) }
    └─LogicalAgg { group_key: [t.v1, t.v2, t.v3], aggs: [count, count(1:Int32)] }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, 1:Int32] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3], predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (t.v2 > t.v3) }
- name: filter project set transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, arr int[]);
    with cte as (select v1, v2, v3, unnest(arr) as arr_unnested from t) select * from cte where v1=10 AND v2=20 AND v3=30 AND arr_unnested=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, Unnest($3)] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (Unnest($3) = 30:Int32) }
      └─LogicalShare { id = 3 }
        └─LogicalProject { exprs: [t.v1, t.v2, t.v3, Unnest($3)] }
          └─LogicalProjectSet { select_list: [$0, $1, $2, Unnest($3)] }
            └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.arr, t._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, Unnest($3)] }
    └─LogicalFilter { predicate: (Unnest($3) = 30:Int32) }
      └─LogicalProjectSet { select_list: [$0, $1, $2, Unnest($3)] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.arr], predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
- name: filter inner join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 cross join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalShare { id = 3 }
        └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
            └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalJoin { type: Inner, on: true, output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalScan { table: t2, columns: [t2.v3, t2.v4], predicate: IsNull(t2.v3) AND IsNull(t2.v4) }
- name: filter left join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 left join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalShare { id = 3 }
        └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
          └─LogicalJoin { type: LeftOuter, on: true, output: all }
            ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
            └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalFilter { predicate: IsNull(t2.v3) AND IsNull(t2.v4) }
    └─LogicalJoin { type: LeftOuter, on: true, output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
      └─LogicalScan { table: t2, columns: [t2.v3, t2.v4] }
- name: filter right join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 right join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalShare { id = 3 }
        └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
          └─LogicalJoin { type: RightOuter, on: true, output: all }
            ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
            └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalJoin { type: LeftOuter, on: true, output: [t1.v1, t1.v2, t2.v3, t2.v4] }
      ├─LogicalScan { table: t2, columns: [t2.v3, t2.v4], predicate: IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
- name: filter full outer join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 full outer join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalShare { id = 3 }
        └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
          └─LogicalJoin { type: FullOuter, on: true, output: all }
            ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
            └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
    └─LogicalJoin { type: FullOuter, on: true, output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
      └─LogicalScan { table: t2, columns: [t2.v3, t2.v4] }
- name: filter semi join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    with cte as (select * from t1 where exists (select * from t2)) select * from cte where v1 is null AND v2 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
      └─LogicalShare { id = 4 }
        └─LogicalProject { exprs: [t1.v1, t1.v2] }
          └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
            ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
            └─LogicalProject { exprs: [t2.v1, t2.v2] }
              └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalJoin { type: LeftSemi, on: true, output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalScan { table: t2, columns: [] }
- name: filter anti join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    with cte as (select * from t1 where not exists (select * from t2)) select * from cte where v1 is null AND v2 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
      └─LogicalShare { id = 4 }
        └─LogicalProject { exprs: [t1.v1, t1.v2] }
          └─LogicalApply { type: LeftAnti, on: true, correlated_id: 1 }
            ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
            └─LogicalProject { exprs: [t2.v1, t2.v2] }
              └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id] }
  optimized_logical_plan_for_batch: |
    LogicalJoin { type: LeftAnti, on: true, output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalScan { table: t2, columns: [] }
- name: now() pushdown with delta expression
  sql: |
    create table t1(v1 timestamp with time zone);
    create table t2(v2 timestamp with time zone);
    select * from t1 cross join t2 where v1 = v2 and v1 > now() + '1 hr';
  optimized_logical_plan_for_batch: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1], predicate: (t1.v1 > ('2021-04-01 00:00:00+00:00':Timestamptz + '01:00:00':Interval)) }
    └─LogicalScan { table: t2, columns: [t2.v2], predicate: (t2.v2 > ('2021-04-01 00:00:00+00:00':Timestamptz + '01:00:00':Interval)) }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, v1], pk_columns: [t1._row_id, t2._row_id, v1], pk_conflict: "NoCheck" }
    └─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v2, output: [t1.v1, t2.v2, t1._row_id, t2._row_id] }
      ├─StreamExchange { dist: HashShard(t1.v1) }
      | └─StreamDynamicFilter { predicate: (t1.v1 > $expr1), output_watermarks: [t1.v1], output: ["t1.v1", "t1._row_id"] }
      |   ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      |   └─StreamExchange { dist: Broadcast }
      |     └─StreamProject { exprs: [(AtTimeZone((AtTimeZone(now, 'UTC':Varchar) + '00:00:00':Interval), 'UTC':Varchar) + '01:00:00':Interval) as $expr1], output_watermarks: [$expr1] }
      |       └─StreamNow { output: ["now"] }
      └─StreamExchange { dist: HashShard(t2.v2) }
        └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: now() in a complex cmp expr does not get pushed down
  sql: |
    create table t1(v1 timestamp with time zone);
    create table t2(v2 timestamp with time zone, v3 interval);
    select * from t1, t2 where v1 = v2 and v1 > now() + v3;
  optimized_logical_plan_for_batch: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) AND (t1.v1 > $expr1), output: [t1.v1, t2.v2, t2.v3] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalProject { exprs: [t2.v2, t2.v3, ('2021-04-01 00:00:00+00:00':Timestamptz + t2.v3) as $expr1] }
      └─LogicalScan { table: t2, columns: [t2.v2, t2.v3] }
  stream_error: 'internal error: Conditions containing now must be of the form `input_expr cmp now() [+- const_expr]` or `now() [+- const_expr] cmp input_expr`, where `input_expr` references a column and contains no `now()`.'
- name: now() in complex cmp expr pushed onto join ON clause results in dynamic filter
  sql: |
    create table t1(v1 timestamp with time zone);
    create table t2(v2 timestamp with time zone, v3 interval);
    select * from t1 cross join t2 where v1 = v2 and v1 > now() + v3;
  optimized_logical_plan_for_batch: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) AND (t1.v1 > $expr1), output: [t1.v1, t2.v2, t2.v3] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalProject { exprs: [t2.v2, t2.v3, ('2021-04-01 00:00:00+00:00':Timestamptz + t2.v3) as $expr1] }
      └─LogicalScan { table: t2, columns: [t2.v2, t2.v3] }
  stream_error: 'internal error: Conditions containing now must be of the form `input_expr cmp now() [+- const_expr]` or `now() [+- const_expr] cmp input_expr`, where `input_expr` references a column and contains no `now()`.'
- name: now() does not get pushed to scan, but others do
  sql: |
    create table t1(v1 timestamp with time zone, v2 int);
    select * from t1 where v1 > now() + '30 min' and v2 > 5;
  optimized_logical_plan_for_batch: |
    LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: (t1.v1 > ('2021-04-01 00:00:00+00:00':Timestamptz + '00:30:00':Interval)) AND (t1.v2 > 5:Int32) }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, t1._row_id(hidden)], stream_key: [t1._row_id], pk_columns: [t1._row_id], pk_conflict: "NoCheck", watermark_columns: [v1] }
    └─StreamDynamicFilter { predicate: (t1.v1 > $expr1), output_watermarks: [t1.v1], output: ["t1.v1", "t1.v2", "t1._row_id"] }
      ├─StreamFilter { predicate: (t1.v2 > 5:Int32) }
      | └─StreamTableScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [(AtTimeZone((AtTimeZone(now, 'UTC':Varchar) + '00:00:00':Interval), 'UTC':Varchar) + '00:30:00':Interval) as $expr1], output_watermarks: [$expr1] }
          └─StreamNow { output: ["now"] }
- name: eq-predicate derived condition other side pushdown in inner join
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    select * from t1 cross join t2 where t1.v1 = t2.v1 and t1.v1 > 1000;
  optimized_logical_plan_for_batch: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v1), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: (t1.v1 > 1000:Int32) }
    └─LogicalScan { table: t2, columns: [t2.v1, t2.v2], predicate: (t2.v1 > 1000:Int32) }
- name: eq-predicate derived condition other side pushdown in semi join
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    select * from t1 where exists (select * from t2 where t1.v1 = t2.v1 and t2.v1 < 2000) and t1.v1 > 1000;
  optimized_logical_plan_for_batch: |
    LogicalJoin { type: LeftSemi, on: (t1.v1 = t2.v1), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: (t1.v1 > 1000:Int32) }
    └─LogicalScan { table: t2, columns: [t2.v1], predicate: (t2.v1 > 1000:Int32) AND (t2.v1 < 2000:Int32) }
- name: eq-predicate derived condition other side pushdown in outer join
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    select * from t1 left join t2 on t1.v1 = t2.v1 where t2.v1 is not null and t1.v1 + 5 is not null;
  optimized_logical_plan_for_batch: |
    LogicalFilter { predicate: IsNotNull(t2.v1) }
    └─LogicalJoin { type: LeftOuter, on: (t1.v1 = t2.v1), output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNotNull((t1.v1 + 5:Int32)) }
      └─LogicalScan { table: t2, columns: [t2.v1, t2.v2], predicate: IsNotNull((t2.v1 + 5:Int32)) }
- name: eq-predicate derived condition is banned for impure function e.g. `now()`
  sql: |
    create table t1(v1 timestamp with time zone);
    create table t2(v2 timestamp with time zone);
    select * from t1 cross join t2 where v1 = v2 and v1 > now();
  optimized_logical_plan_for_batch: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1], predicate: (t1.v1 > '2021-04-01 00:00:00+00:00':Timestamptz) }
    └─LogicalScan { table: t2, columns: [t2.v2], predicate: (t2.v2 > '2021-04-01 00:00:00+00:00':Timestamptz) }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, t1._row_id(hidden), t2._row_id(hidden)], stream_key: [t1._row_id, t2._row_id, v1], pk_columns: [t1._row_id, t2._row_id, v1], pk_conflict: "NoCheck" }
    └─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v2, output: [t1.v1, t2.v2, t1._row_id, t2._row_id] }
      ├─StreamExchange { dist: HashShard(t1.v1) }
      | └─StreamDynamicFilter { predicate: (t1.v1 > now), output_watermarks: [t1.v1], output: ["t1.v1", "t1._row_id"] }
      |   ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      |   └─StreamExchange { dist: Broadcast }
      |     └─StreamNow { output: ["now"] }
      └─StreamExchange { dist: HashShard(t2.v2) }
        └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
