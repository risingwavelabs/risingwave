# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x > (select 1.5 * min(x) from t2 where t1.y=t2.y and t2.y = 1000)
  logical_plan: |-
    LogicalProject { exprs: [t1.x, t1.y] }
    └─LogicalFilter { predicate: (t1.x::Decimal > $expr1) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
        └─LogicalProject { exprs: [(1.5:Decimal * min(t2.x)::Decimal) as $expr1] }
          └─LogicalAgg { aggs: [min(t2.x)] }
            └─LogicalProject { exprs: [t2.x] }
              └─LogicalFilter { predicate: (CorrelatedInputRef { index: 1, correlated_id: 1 } = t2.y) AND (t2.y = 1000:Int32) }
                └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: (t1.y = t2.y) AND ($expr1 > $expr2), output: [t1.x, t1.y] }
    ├─LogicalProject { exprs: [t1.x, t1.y, t1.x::Decimal as $expr1] }
    │ └─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [(1.5:Decimal * min(t2.x)::Decimal) as $expr2, t2.y] }
      └─LogicalAgg { group_key: [t2.y], aggs: [min(t2.x)] }
        └─LogicalScan { table: t2, columns: [t2.x, t2.y], predicate: (t2.y = 1000:Int32) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x>(select min(x) from t2 where t2.y = (select t1.y))
  logical_plan: |-
    LogicalProject { exprs: [t1.x, t1.y] }
    └─LogicalFilter { predicate: (t1.x > min(t2.x)) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
        └─LogicalProject { exprs: [min(t2.x)] }
          └─LogicalAgg { aggs: [min(t2.x)] }
            └─LogicalProject { exprs: [t2.x] }
              └─LogicalFilter { predicate: (t2.y = $expr1) }
                └─LogicalApply { type: LeftOuter, on: true, correlated_id: 2, max_one_row: true }
                  ├─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
                  └─LogicalProject { exprs: [CorrelatedInputRef { index: 1, correlated_id: 1 } as $expr1] }
                    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where x>(select min(x) from t2 where t1.y=t2.y and t1.x=(select max(x) from t3, (select 1) as dummy where t3.y=t1.y))
  logical_plan: |-
    LogicalProject { exprs: [t1.x, t1.y] }
    └─LogicalFilter { predicate: (t1.x > min(t2.x)) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
        └─LogicalProject { exprs: [min(t2.x)] }
          └─LogicalAgg { aggs: [min(t2.x)] }
            └─LogicalProject { exprs: [t2.x] }
              └─LogicalFilter { predicate: (CorrelatedInputRef { index: 1, correlated_id: 1 } = t2.y) AND (CorrelatedInputRef { index: 0, correlated_id: 1 } = max(t3.x)) }
                └─LogicalApply { type: LeftOuter, on: true, correlated_id: 2, max_one_row: true }
                  ├─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
                  └─LogicalProject { exprs: [max(t3.x)] }
                    └─LogicalAgg { aggs: [max(t3.x)] }
                      └─LogicalProject { exprs: [t3.x] }
                        └─LogicalFilter { predicate: (t3.y = CorrelatedInputRef { index: 1, correlated_id: 1 }) }
                          └─LogicalJoin { type: Inner, on: true, output: all }
                            ├─LogicalScan { table: t3, columns: [t3.x, t3.y, t3._row_id, t3._rw_timestamp] }
                            └─LogicalProject { exprs: [1:Int32] }
                              └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where exists(select * from t2 where y = 100 and t1.x = t2.x and x = 1000 and t1.y = t2.y);
  logical_plan: |-
    LogicalProject { exprs: [t1.x, t1.y] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.x, t2.y] }
        └─LogicalFilter { predicate: (t2.y = 100:Int32) AND (CorrelatedInputRef { index: 0, correlated_id: 1 } = t2.x) AND (t2.x = 1000:Int32) AND (CorrelatedInputRef { index: 1, correlated_id: 1 } = t2.y) }
          └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.x = t2.x) AND (t1.y = t2.y), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalScan { table: t2, columns: [t2.x, t2.y], predicate: (t2.y = 100:Int32) AND (t2.x = 1000:Int32) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x > (select 1.5 * min(x) from t2 where t1.y = t2.y);
  logical_plan: |-
    LogicalProject { exprs: [t1.x, t1.y] }
    └─LogicalFilter { predicate: (t1.x::Decimal > $expr1) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
        └─LogicalProject { exprs: [(1.5:Decimal * min(t2.x)::Decimal) as $expr1] }
          └─LogicalAgg { aggs: [min(t2.x)] }
            └─LogicalProject { exprs: [t2.x] }
              └─LogicalFilter { predicate: (CorrelatedInputRef { index: 1, correlated_id: 1 } = t2.y) }
                └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: (t1.y = t2.y) AND ($expr1 > $expr2), output: [t1.x, t1.y] }
    ├─LogicalProject { exprs: [t1.x, t1.y, t1.x::Decimal as $expr1] }
    │ └─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [(1.5:Decimal * min(t2.x)::Decimal) as $expr2, t2.y] }
      └─LogicalAgg { group_key: [t2.y], aggs: [min(t2.x)] }
        └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x > (select count(*) from t2 where t1.y = t2.y);
  logical_plan: |-
    LogicalProject { exprs: [t1.x, t1.y] }
    └─LogicalFilter { predicate: (t1.x > count) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
        └─LogicalProject { exprs: [count] }
          └─LogicalAgg { aggs: [count] }
            └─LogicalProject { exprs: [] }
              └─LogicalFilter { predicate: (CorrelatedInputRef { index: 1, correlated_id: 1 } = t2.y) }
                └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: IsNotDistinctFrom(t1.y, t1.y) AND ($expr1 > count(1:Int32)), output: [t1.x, t1.y] }
    ├─LogicalProject { exprs: [t1.x, t1.y, t1.x::Int64 as $expr1] }
    │ └─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalAgg { group_key: [t1.y], aggs: [count(1:Int32)] }
      └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(t1.y, t2.y), output: [t1.y, 1:Int32] }
        ├─LogicalAgg { group_key: [t1.y], aggs: [] }
        │ └─LogicalScan { table: t1, columns: [t1.y] }
        └─LogicalProject { exprs: [t2.y, 1:Int32] }
          └─LogicalScan { table: t2, columns: [t2.y], predicate: IsNotNull(t2.y) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x > (select count(*) + count(*) from t2 where t1.y = t2.y);
  logical_plan: |-
    LogicalProject { exprs: [t1.x, t1.y] }
    └─LogicalFilter { predicate: (t1.x > $expr1) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
        └─LogicalProject { exprs: [(count + count) as $expr1] }
          └─LogicalAgg { aggs: [count] }
            └─LogicalProject { exprs: [] }
              └─LogicalFilter { predicate: (CorrelatedInputRef { index: 1, correlated_id: 1 } = t2.y) }
                └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: IsNotDistinctFrom(t1.y, t1.y) AND ($expr1 > $expr2), output: [t1.x, t1.y] }
    ├─LogicalProject { exprs: [t1.x, t1.y, t1.x::Int64 as $expr1] }
    │ └─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [t1.y, (count(1:Int32) + count(1:Int32)) as $expr2] }
      └─LogicalAgg { group_key: [t1.y], aggs: [count(1:Int32)] }
        └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(t1.y, t2.y), output: [t1.y, 1:Int32] }
          ├─LogicalAgg { group_key: [t1.y], aggs: [] }
          │ └─LogicalScan { table: t1, columns: [t1.y] }
          └─LogicalProject { exprs: [t2.y, 1:Int32] }
            └─LogicalScan { table: t2, columns: [t2.y], predicate: IsNotNull(t2.y) }
- name: 'Like `count(*)`, SimpleAgg also need to rewrite `array_agg` for the extra null row due to outer join #14735'
  sql: |
    create table t1(a int, b int);
    select a, (select array_agg(t1.a) filter (where t1.a is distinct from 1) from t1 where t1.a <> t.b) from t1 as t order by 1;
  logical_plan: |-
    LogicalProject { exprs: [t1.a, array_agg(t1.a) filter(IsDistinctFrom(t1.a, 1:Int32))] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalScan { table: t1, columns: [t1.a, t1.b, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [array_agg(t1.a) filter(IsDistinctFrom(t1.a, 1:Int32))] }
        └─LogicalAgg { aggs: [array_agg(t1.a) filter(IsDistinctFrom(t1.a, 1:Int32))] }
          └─LogicalProject { exprs: [t1.a] }
            └─LogicalFilter { predicate: (t1.a <> CorrelatedInputRef { index: 1, correlated_id: 1 }) }
              └─LogicalScan { table: t1, columns: [t1.a, t1.b, t1._row_id, t1._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(t1.b, t1.b), output: [t1.a, array_agg(t1.a) filter(IsDistinctFrom(t1.a, 1:Int32) AND IsNotNull(1:Int32))] }
    ├─LogicalScan { table: t1, columns: [t1.a, t1.b] }
    └─LogicalAgg { group_key: [t1.b], aggs: [array_agg(t1.a) filter(IsDistinctFrom(t1.a, 1:Int32) AND IsNotNull(1:Int32))] }
      └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(t1.b, t1.b), output: [t1.b, t1.a, 1:Int32] }
        ├─LogicalAgg { group_key: [t1.b], aggs: [] }
        │ └─LogicalScan { table: t1, columns: [t1.b] }
        └─LogicalProject { exprs: [t1.b, t1.a, 1:Int32] }
          └─LogicalJoin { type: Inner, on: (t1.a <> t1.b), output: all }
            ├─LogicalAgg { group_key: [t1.b], aggs: [] }
            │ └─LogicalScan { table: t1, columns: [t1.b] }
            └─LogicalScan { table: t1, columns: [t1.a] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y from t2 where t1.x = t2.x);
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalApply { type: LeftSemi, on: (t1.y = t2.y), correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.y] }
        └─LogicalFilter { predicate: (CorrelatedInputRef { index: 0, correlated_id: 1 } = t2.x) }
          └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.y = t2.y) AND (t1.x = t2.x), output: [t1.x] }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [t2.y, t2.x] }
      └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y not in (select y from t2 where t1.x = t2.x);
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y from t2 where t1.x + t2.x = 100 and t1.y = 1000);
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalApply { type: LeftSemi, on: (t1.y = t2.y), correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.y] }
        └─LogicalFilter { predicate: ((CorrelatedInputRef { index: 0, correlated_id: 1 } + t2.x) = 100:Int32) AND (CorrelatedInputRef { index: 1, correlated_id: 1 } = 1000:Int32) }
          └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.y = t2.y) AND ((t1.x + t2.x) = 100:Int32), output: [t1.x] }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y], predicate: (t1.y = 1000:Int32) }
    └─LogicalProject { exprs: [t2.y, t2.x] }
      └─LogicalScan { table: t2, columns: [t2.x, t2.y], predicate: (t2.y = 1000:Int32) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y from t2 where t1.x > t2.x + 1000);
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalApply { type: LeftSemi, on: (t1.y = t2.y), correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.y] }
        └─LogicalFilter { predicate: (CorrelatedInputRef { index: 0, correlated_id: 1 } > (t2.x + 1000:Int32)) }
          └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.y = t2.y) AND (t1.x > $expr1), output: [t1.x] }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [t2.y, (t2.x + 1000:Int32) as $expr1] }
      └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y, x from t2 where t1.x > t2.x + 1000);
  binder_error: |
    Failed to bind expression: y IN (SELECT y, x FROM t2 WHERE t1.x > t2.x + 1000)

    Caused by:
      Bind error: Subquery must return only one column
- name: correlated outer subquery with an uncorrelated inner subquery
  sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select x from t1 where y in (select x from t2 where t2.y = t1.y and x > (select min(x) from t3));
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalApply { type: LeftSemi, on: (t1.y = t2.x), correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.x] }
        └─LogicalFilter { predicate: (t2.y = CorrelatedInputRef { index: 1, correlated_id: 1 }) AND (t2.x > min(t3.x)) }
          └─LogicalApply { type: LeftOuter, on: true, correlated_id: 2, max_one_row: true }
            ├─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
            └─LogicalProject { exprs: [min(t3.x)] }
              └─LogicalAgg { aggs: [min(t3.x)] }
                └─LogicalProject { exprs: [t3.x] }
                  └─LogicalScan { table: t3, columns: [t3.x, t3.y, t3._row_id, t3._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.y = t2.x) AND (t2.y = t1.y), output: [t1.x] }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: Inner, on: (t2.x > min(t3.x)), output: [t2.x, t2.y] }
      ├─LogicalScan { table: t2, columns: [t2.x, t2.y] }
      └─LogicalAgg { aggs: [min(t3.x)] }
        └─LogicalScan { table: t3, columns: [t3.x] }
- name: correlated inner subquery with depth = 2
  sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select x from t1 where y in (select x from t2 where y in (select y from t3 where t1.y = t3.y));
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalApply { type: LeftSemi, on: (t1.y = t2.x), correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.x] }
        └─LogicalApply { type: LeftSemi, on: (t2.y = t3.y), correlated_id: 2 }
          ├─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
          └─LogicalProject { exprs: [t3.y] }
            └─LogicalFilter { predicate: (CorrelatedInputRef { index: 1, correlated_id: 1 } = t3.y) }
              └─LogicalScan { table: t3, columns: [t3.x, t3.y, t3._row_id, t3._rw_timestamp] }
- name: uncorrelated outer subquery with a correlated inner subquery
  sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select x from t1 where y in (select x from t2 where y in (select y from t3 where t2.y = t3.y));
  logical_plan: |-
    LogicalProject { exprs: [t1.x] }
    └─LogicalApply { type: LeftSemi, on: (t1.y = t2.x), correlated_id: 1 }
      ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
      └─LogicalProject { exprs: [t2.x] }
        └─LogicalApply { type: LeftSemi, on: (t2.y = t3.y), correlated_id: 2 }
          ├─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id, t2._rw_timestamp] }
          └─LogicalProject { exprs: [t3.y] }
            └─LogicalFilter { predicate: (CorrelatedInputRef { index: 1, correlated_id: 2 } = t3.y) }
              └─LogicalScan { table: t3, columns: [t3.x, t3.y, t3._row_id, t3._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.y = t2.x), output: [t1.x] }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: LeftSemi, on: (t2.y = t3.y) AND (t2.y = t3.y), output: [t2.x] }
      ├─LogicalScan { table: t2, columns: [t2.x, t2.y] }
      └─LogicalProject { exprs: [t3.y, t3.y] }
        └─LogicalScan { table: t3, columns: [t3.y] }
- name: correlated agg column in SELECT
  sql: |
    create table t (v1 int, v2 int);
    select min(v1), (select max(v2)) from t;
  planner_error: |-
    Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/2275
- name: correlated group column in SELECT
  sql: |
    create table t (v1 int, v2 int);
    select min(v1), (select v2) from t group by v2;
  planner_error: |-
    Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/2275
- name: correlated non-group column in SELECT
  sql: |
    create table t (v1 int, v2 int);
    select min(v1), (select v2) from t;
  planner_error: |-
    Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/2275
- name: correlated agg column in HAVING
  sql: |
    create table t (v1 int, v2 int);
    select 1 from t having min(v1) > (select max(v2));
  planner_error: |-
    Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/2275
- name: correlated group column in HAVING
  sql: |
    create table t (v1 int, v2 int);
    select 1 from t group by v2 having min(v1) > (select v2);
  planner_error: |-
    Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/2275
- name: correlated non-group column in HAVING
  sql: |
    create table t (v1 int, v2 int);
    select 1 from t having min(v1) > (select v2);
  planner_error: |-
    Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/2275
- name: correlated agg column belongs to outer query
  sql: |
    create table t (v1 int, v2 int);
    create table t2 (v3 int, v4 int);
    select
      min(v1),
      (select max(v2) + v3 from t2)  -- access to v3 is ok
    from t;
  planner_error: |-
    Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/2275
- name: uncorrelated subquery in HAVING
  sql: |
    create table a (a1 int, a2 int);
    create table b (b1 int, b2 int);
    create table c (c1 int, c2 int);
    select 1 from a having exists (
      select 1 from b where exists (
        select b1 from c
      )
    );
  logical_plan: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalAgg { aggs: [] }
      │ └─LogicalProject { exprs: [] }
      │   └─LogicalScan { table: a, columns: [a.a1, a.a2, a._row_id, a._rw_timestamp] }
      └─LogicalProject { exprs: [1:Int32] }
        └─LogicalApply { type: LeftSemi, on: true, correlated_id: 2 }
          ├─LogicalScan { table: b, columns: [b.b1, b.b2, b._row_id, b._rw_timestamp] }
          └─LogicalProject { exprs: [CorrelatedInputRef { index: 0, correlated_id: 2 } as $expr1] }
            └─LogicalScan { table: c, columns: [c.c1, c.c2, c._row_id, c._rw_timestamp] }
- name: correlated column with depth=2 in HAVING
  sql: |
    create table a (a1 int, a2 int);
    create table b (b1 int, b2 int);
    create table c (c1 int, c2 int);
    select 1 from a having exists (
      select 1 from b where exists (
        select a1 from c
      )
    );
  planner_error: |-
    Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/2275
- name: correlated column with depth>1 in HAVING
  sql: |
    create table a (a1 int, a2 int);
    create table b (b1 int, b2 int);
    create table c (c1 int, c2 int);
    select 1 from a where exists (
      select 1 from b having exists (
        select a1 from c
      )
    );
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [1:Int32] }
    └─LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(a.a1, a.a1), output: [] }
      ├─LogicalScan { table: a, columns: [a.a1] }
      └─LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(a.a1, a.a1), output: all }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalAgg { group_key: [a.a1], aggs: [] }
        │ │ └─LogicalScan { table: a, columns: [a.a1] }
        │ └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
        └─LogicalJoin { type: Inner, on: true, output: all }
          ├─LogicalAgg { group_key: [a.a1], aggs: [] }
          │ └─LogicalScan { table: a, columns: [a.a1] }
          └─LogicalScan { table: c, columns: [] }
- sql: |
    create table a (a1 int, a2 int);
    create table b (b1 int, b2 int);
    create table c (c1 int, c2 int);
    select 1 from a where exists (select (select a1 from c ), min(b1) from b );
  optimizer_error: 'internal error: Scalar subquery might produce more than one row.'
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select t2.x, (select x from t1 where t1.y = t2.y) from t2 where x > 100 order by t2.x limit 100;
  optimizer_error: 'internal error: Scalar subquery might produce more than one row.'
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where exists(select x from t2 where t1.x = t2.x and t1.y = t2.y)
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.x = t2.x) AND (t1.y = t2.y), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1, t2 where exists(select x from t3 where t3.x = t1.x and t3.y <> t2.y);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t3.x = t1.x) AND (t3.y <> t2.y), output: all }
    ├─LogicalJoin { type: Inner, on: true, output: all }
    │ ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    │ └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
    └─LogicalScan { table: t3, columns: [t3.x, t3.y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1, t2 where exists(select x from t3 where t3.x = t2.y and t3.y = t1.x);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t3.x = t2.y) AND (t3.y = t1.x), output: all }
    ├─LogicalJoin { type: Inner, on: true, output: all }
    │ ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    │ └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
    └─LogicalScan { table: t3, columns: [t3.x, t3.y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    create table t4(x int, y int, z int);
    select * from t1, t2, t3 where exists(select x from t4 where t4.x = t2.y and t4.y = t1.x and t4.z = t3.x);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t4.x = t2.y) AND (t4.y = t1.x) AND (t4.z = t3.x), output: all }
    ├─LogicalJoin { type: Inner, on: true, output: all }
    │ ├─LogicalJoin { type: Inner, on: true, output: all }
    │ │ ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    │ │ └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
    │ └─LogicalScan { table: t3, columns: [t3.x, t3.y] }
    └─LogicalScan { table: t4, columns: [t4.x, t4.y, t4.z] }
- sql: |
    create table a(a1 int, a2 int, a3 int);
    create table b(b1 int, b2 int, b3 int);
    create table c(c1 int, c2 int, c3 int);
    select count(*) from a, b where a3 = b2 and 3 = (select count(*) from c where b2 = c2 and a3 = c3);
  logical_plan: |-
    LogicalProject { exprs: [count] }
    └─LogicalAgg { aggs: [count] }
      └─LogicalProject { exprs: [] }
        └─LogicalFilter { predicate: (a.a3 = b.b2) AND (3:Int32 = count) }
          └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalScan { table: a, columns: [a.a1, a.a2, a.a3, a._row_id, a._rw_timestamp] }
            │ └─LogicalScan { table: b, columns: [b.b1, b.b2, b.b3, b._row_id, b._rw_timestamp] }
            └─LogicalProject { exprs: [count] }
              └─LogicalAgg { aggs: [count] }
                └─LogicalProject { exprs: [] }
                  └─LogicalFilter { predicate: (CorrelatedInputRef { index: 6, correlated_id: 1 } = c.c2) AND (CorrelatedInputRef { index: 2, correlated_id: 1 } = c.c3) }
                    └─LogicalScan { table: c, columns: [c.c1, c.c2, c.c3, c._row_id, c._rw_timestamp] }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { aggs: [count] }
    └─LogicalJoin { type: Inner, on: IsNotDistinctFrom(a.a3, internal_last_seen_value(a.a3)) AND IsNotDistinctFrom(b.b2, b.b2), output: [] }
      ├─LogicalJoin { type: Inner, on: (a.a3 = b.b2), output: all }
      │ ├─LogicalScan { table: a, columns: [a.a3] }
      │ └─LogicalScan { table: b, columns: [b.b2] }
      └─LogicalFilter { predicate: (3:Int32 = count(1:Int32)) }
        └─LogicalAgg { group_key: [internal_last_seen_value(a.a3), b.b2], aggs: [count(1:Int32)] }
          └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(internal_last_seen_value(a.a3), c.c3) AND IsNotDistinctFrom(b.b2, c.c2), output: [internal_last_seen_value(a.a3), b.b2, 1:Int32] }
            ├─LogicalAgg { group_key: [b.b2], aggs: [internal_last_seen_value(a.a3)] }
            │ └─LogicalJoin { type: Inner, on: (a.a3 = b.b2), output: all }
            │   ├─LogicalScan { table: a, columns: [a.a3] }
            │   └─LogicalScan { table: b, columns: [b.b2] }
            └─LogicalProject { exprs: [c.c3, c.c2, 1:Int32] }
              └─LogicalScan { table: c, columns: [c.c2, c.c3], predicate: (c.c3 = c.c2) AND IsNotNull(c.c3) AND IsNotNull(c.c2) }
- sql: |
    create table a(x int, y int, z int);
    create table b(x int, y int, z int);
    select count(*) from a where a.x=3 and a.y = (select count(*) from b where b.z = a.z and a.x = 3);
  optimized_logical_plan_for_batch: |-
    LogicalAgg { aggs: [count] }
    └─LogicalJoin { type: Inner, on: IsNotDistinctFrom(a.x, a.x) AND IsNotDistinctFrom(a.z, a.z) AND ($expr1 = count(1:Int32)), output: [] }
      ├─LogicalProject { exprs: [a.x, a.z, a.y::Int64 as $expr1] }
      │ └─LogicalScan { table: a, columns: [a.x, a.y, a.z], predicate: (a.x = 3:Int32) }
      └─LogicalAgg { group_key: [a.x, a.z], aggs: [count(1:Int32)] }
        └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(a.x, a.x) AND IsNotDistinctFrom(a.z, a.z), output: [a.x, a.z, 1:Int32] }
          ├─LogicalAgg { group_key: [a.x, a.z], aggs: [] }
          │ └─LogicalScan { table: a, columns: [a.x, a.z], predicate: (a.x = 3:Int32) }
          └─LogicalProject { exprs: [a.x, a.z, 1:Int32] }
            └─LogicalJoin { type: Inner, on: (b.z = a.z), output: [a.x, a.z] }
              ├─LogicalAgg { group_key: [a.x, a.z], aggs: [] }
              │ └─LogicalScan { table: a, columns: [a.x, a.z], predicate: (a.x = 3:Int32) }
              └─LogicalScan { table: b, columns: [b.z] }
- sql: |
    create table a(x int, y int, z int);
    create table b(x int, y int, z int);
    select count(*) from a where a.x=3 and a.y = (select count(*) from b where b.z = a.z);
  optimized_logical_plan_for_batch: |-
    LogicalAgg { aggs: [count] }
    └─LogicalJoin { type: Inner, on: IsNotDistinctFrom(a.z, a.z) AND ($expr1 = count(1:Int32)), output: [] }
      ├─LogicalProject { exprs: [a.z, a.y::Int64 as $expr1] }
      │ └─LogicalScan { table: a, output_columns: [a.y, a.z], required_columns: [a.y, a.z, a.x], predicate: (a.x = 3:Int32) }
      └─LogicalAgg { group_key: [a.z], aggs: [count(1:Int32)] }
        └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(a.z, b.z), output: [a.z, 1:Int32] }
          ├─LogicalAgg { group_key: [a.z], aggs: [] }
          │ └─LogicalScan { table: a, output_columns: [a.z], required_columns: [a.z, a.x], predicate: (a.x = 3:Int32) }
          └─LogicalProject { exprs: [b.z, 1:Int32] }
            └─LogicalScan { table: b, columns: [b.z], predicate: IsNotNull(b.z) }
- sql: |
    create table a(x int, y varchar, z int);
    create table b(x varchar, y int, z int);
    select count(*) from a where a.y = (select string_agg(x, ',' order by x) from b where b.z = a.z);
  optimized_logical_plan_for_batch: |-
    LogicalAgg { aggs: [count] }
    └─LogicalJoin { type: Inner, on: (a.z = b.z) AND (a.y = string_agg(b.x, ',':Varchar order_by(b.x ASC))), output: [] }
      ├─LogicalScan { table: a, columns: [a.y, a.z] }
      └─LogicalAgg { group_key: [b.z], aggs: [string_agg(b.x, ',':Varchar order_by(b.x ASC))] }
        └─LogicalProject { exprs: [b.x, ',':Varchar, b.z] }
          └─LogicalScan { table: b, columns: [b.x, b.z] }
- sql: |
    create table a(x int, y int, z int);
    create table b(x int, y int, z int);
    select count(*) from a where a.y = (select count(distinct x) from b where b.z = a.z);
  optimized_logical_plan_for_batch: |-
    LogicalAgg { aggs: [count] }
    └─LogicalJoin { type: Inner, on: IsNotDistinctFrom(a.z, a.z) AND ($expr1 = count(b.x)), output: [] }
      ├─LogicalProject { exprs: [a.z, a.y::Int64 as $expr1] }
      │ └─LogicalScan { table: a, columns: [a.y, a.z] }
      └─LogicalAgg { group_key: [a.z], aggs: [count(b.x)] }
        └─LogicalAgg { group_key: [a.z, b.x], aggs: [] }
          └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(a.z, b.z), output: [a.z, b.x] }
            ├─LogicalAgg { group_key: [a.z], aggs: [] }
            │ └─LogicalScan { table: a, columns: [a.z] }
            └─LogicalProject { exprs: [b.z, b.x] }
              └─LogicalScan { table: b, columns: [b.x, b.z], predicate: IsNotNull(b.z) }
- sql: |
    create table a(x int, y int, z int);
    create table b(x int, y int, z int);
    select count(*) from a where a.y = (select count(x) filter(where x < 100) from b where b.z = a.z);
  optimized_logical_plan_for_batch: |-
    LogicalAgg { aggs: [count] }
    └─LogicalJoin { type: Inner, on: IsNotDistinctFrom(a.z, a.z) AND ($expr1 = count(b.x) filter((b.x < 100:Int32))), output: [] }
      ├─LogicalProject { exprs: [a.z, a.y::Int64 as $expr1] }
      │ └─LogicalScan { table: a, columns: [a.y, a.z] }
      └─LogicalAgg { group_key: [a.z], aggs: [count(b.x) filter((b.x < 100:Int32))] }
        └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(a.z, b.z), output: [a.z, b.x] }
          ├─LogicalAgg { group_key: [a.z], aggs: [] }
          │ └─LogicalScan { table: a, columns: [a.z] }
          └─LogicalProject { exprs: [b.z, b.x] }
            └─LogicalScan { table: b, columns: [b.x, b.z], predicate: IsNotNull(b.z) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where exists(select x from t2 where t1.x = t2.x and t2.y in (select t3.y from t3 where t1.x = t3.x));
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.x, t2.x), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: LeftSemi, on: (t2.y = t3.y) AND IsNotDistinctFrom(t2.x, t3.x), output: [t2.x] }
      ├─LogicalScan { table: t2, columns: [t2.x, t2.y], predicate: IsNotNull(t2.x) }
      └─LogicalScan { table: t3, columns: [t3.x, t3.y], predicate: IsNotNull(t3.x) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where exists(select t2.x from t2 join t3 on t2.x = t3.x and t1.y = t2.y and t1.y = t3.y);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.y, t2.y), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: Inner, on: (t2.x = t3.x) AND IsNotDistinctFrom(t2.y, t3.y), output: [t2.y] }
      ├─LogicalScan { table: t2, columns: [t2.x, t2.y], predicate: IsNotNull(t2.y) }
      └─LogicalScan { table: t3, columns: [t3.x, t3.y], predicate: IsNotNull(t3.y) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where t1.y in (select t1.y from t2 where t1.x = t2.x);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.y = t1.y) AND IsNotDistinctFrom(t1.x, t1.x) AND IsNotDistinctFrom(t1.y, t1.y), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [t1.x, t1.y, t1.y] }
      └─LogicalJoin { type: Inner, on: (t1.x = t2.x), output: [t1.x, t1.y] }
        ├─LogicalAgg { group_key: [t1.x, t1.y], aggs: [] }
        │ └─LogicalScan { table: t1, columns: [t1.x, t1.y] }
        └─LogicalScan { table: t2, columns: [t2.x] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where not exists(select x from t2 where t1.x = t2.x and t2.y not in (select t3.y from t3 where t1.x = t3.x));
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftAnti, on: IsNotDistinctFrom(t1.x, t2.x), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: LeftAnti, on: (t2.y = t3.y) AND IsNotDistinctFrom(t2.x, t3.x), output: [t2.x] }
      ├─LogicalScan { table: t2, columns: [t2.x, t2.y], predicate: IsNotNull(t2.x) }
      └─LogicalScan { table: t3, columns: [t3.x, t3.y], predicate: IsNotNull(t3.x) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where exists(select t2.x from t2 left join t3 on t2.x = t3.x and t1.y = t2.y and t1.y = t3.y);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.y, t1.y), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: LeftOuter, on: (t2.x = t3.x) AND IsNotDistinctFrom(t1.y, t3.y) AND (t1.y = t2.y), output: [t1.y] }
      ├─LogicalJoin { type: Inner, on: true, output: all }
      │ ├─LogicalAgg { group_key: [t1.y], aggs: [] }
      │ │ └─LogicalScan { table: t1, columns: [t1.y] }
      │ └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
      └─LogicalProject { exprs: [t3.y, t3.x] }
        └─LogicalScan { table: t3, columns: [t3.x, t3.y], predicate: IsNotNull(t3.y) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where exists(select t2.x from t2 right join t3 on t2.x = t3.x and t1.y = t2.y and t1.y = t3.y);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.y, t2.y), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: LeftOuter, on: (t2.x = t3.x) AND (t2.y = t3.y) AND IsNotDistinctFrom(t2.y, t1.y), output: [t2.y] }
      ├─LogicalJoin { type: Inner, on: true, output: all }
      │ ├─LogicalAgg { group_key: [t1.y], aggs: [] }
      │ │ └─LogicalScan { table: t1, columns: [t1.y] }
      │ └─LogicalScan { table: t3, columns: [t3.x, t3.y] }
      └─LogicalProject { exprs: [t2.y, t2.x] }
        └─LogicalScan { table: t2, columns: [t2.x, t2.y], predicate: IsNotNull(t2.y) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where exists(select t2.x from t2 full join t3 on t2.x = t3.x and t1.y = t2.y and t1.y = t3.y);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.y, t1.y), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: FullOuter, on: (t2.x = t3.x) AND (t1.y = t3.y) AND IsNotDistinctFrom(t1.y, t1.y) AND (t1.y = t2.y), output: [t1.y] }
      ├─LogicalJoin { type: Inner, on: true, output: all }
      │ ├─LogicalAgg { group_key: [t1.y], aggs: [] }
      │ │ └─LogicalScan { table: t1, columns: [t1.y] }
      │ └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
      └─LogicalJoin { type: Inner, on: true, output: all }
        ├─LogicalAgg { group_key: [t1.y], aggs: [] }
        │ └─LogicalScan { table: t1, columns: [t1.y] }
        └─LogicalScan { table: t3, columns: [t3.x, t3.y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where exists(select x from t2 where t1.x = t2.x and t2.y in (select t3.y + t2.y from t3 where t1.x = t3.x));
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.x, t2.x), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: LeftSemi, on: (t2.y = $expr1) AND IsNotDistinctFrom(t2.y, t2.y) AND IsNotDistinctFrom(t2.x, t3.x), output: [t2.x] }
      ├─LogicalScan { table: t2, columns: [t2.x, t2.y], predicate: IsNotNull(t2.x) }
      └─LogicalProject { exprs: [t3.x, t2.y, (t3.y + t2.y) as $expr1] }
        └─LogicalJoin { type: Inner, on: true, output: [t3.x, t2.y, t3.y] }
          ├─LogicalAgg { group_key: [t2.y], aggs: [] }
          │ └─LogicalScan { table: t2, columns: [t2.y] }
          └─LogicalScan { table: t3, columns: [t3.x, t3.y], predicate: IsNotNull(t3.x) }
- sql: |
    create table t1 (a int, b int);
    create table t2 (b int, c int);
    select a, (select t1.a), c from t1, t2 where t1.b = t2.b order by c;
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(t1.a, t1.a), output: [t1.a, t1.a, t2.c] }
    ├─LogicalJoin { type: Inner, on: (t1.b = t2.b), output: [t1.a, t2.c] }
    │ ├─LogicalScan { table: t1, columns: [t1.a, t1.b] }
    │ └─LogicalScan { table: t2, columns: [t2.b, t2.c] }
    └─LogicalProject { exprs: [t1.a, t1.a] }
      └─LogicalAgg { group_key: [t1.a], aggs: [] }
        └─LogicalScan { table: t1, columns: [t1.a] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where exists(select t3.x from (select x,y from t2 where t1.y = t2.y) t2 join t3 on t2.x = t3.x);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.y, t2.y), output: all }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalJoin { type: Inner, on: (t2.x = t3.x), output: [t2.y] }
      ├─LogicalScan { table: t2, columns: [t2.x, t2.y], predicate: IsNotNull(t2.y) }
      └─LogicalScan { table: t3, columns: [t3.x] }
- sql: |
    create table a (a1 int, a2 int);
    create table b (b1 int, b2 int);
    select * from a where a1 = (select min(b1) from (select * from b where b2 = a2) as z);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: IsNotDistinctFrom(a.a2, a.a2) AND (a.a1 = min(b.b1)), output: [a.a1, a.a2] }
    ├─LogicalScan { table: a, columns: [a.a1, a.a2] }
    └─LogicalAgg { group_key: [a.a2], aggs: [min(b.b1)] }
      └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(a.a2, b.b2), output: [a.a2, b.b1] }
        ├─LogicalAgg { group_key: [a.a2], aggs: [] }
        │ └─LogicalScan { table: a, columns: [a.a2] }
        └─LogicalProject { exprs: [b.b2, b.b1] }
          └─LogicalScan { table: b, columns: [b.b1, b.b2], predicate: IsNotNull(b.b2) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where exists(select * from t2 where t1.x = t2.x order by x limit 1);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: LeftSemi, predicate: t1.x IS NOT DISTINCT FROM t2.x, output: all }
      ├─BatchExchange { order: [], dist: HashShard(t1.x) }
      │ └─BatchScan { table: t1, columns: [t1.x, t1.y], distribution: SomeShard }
      └─BatchProject { exprs: [t2.x] }
        └─BatchGroupTopN { order: [t2.x ASC], limit: 1, offset: 0, group_key: [t2.x] }
          └─BatchExchange { order: [], dist: HashShard(t2.x) }
            └─BatchProject { exprs: [t2.x, t2.x] }
              └─BatchFilter { predicate: IsNotNull(t2.x) }
                └─BatchScan { table: t2, columns: [t2.x], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t1._row_id(hidden)], stream_key: [t1._row_id, x], pk_columns: [t1._row_id, x], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.x, t1._row_id) }
      └─StreamHashJoin { type: LeftSemi, predicate: t1.x IS NOT DISTINCT FROM t2.x, output: all }
        ├─StreamExchange { dist: HashShard(t1.x) }
        │ └─StreamTableScan { table: t1, columns: [t1.x, t1.y, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamProject { exprs: [t2.x] }
          └─StreamGroupTopN { order: [t2.x ASC], limit: 1, offset: 0, group_key: [t2.x] }
            └─StreamExchange { dist: HashShard(t2.x) }
              └─StreamProject { exprs: [t2.x, t2.x, t2._row_id] }
                └─StreamFilter { predicate: IsNotNull(t2.x) }
                  └─StreamTableScan { table: t2, columns: [t2.x, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select t1.x, (select y from t2 where t2.y = t1.y) from t1;
  optimizer_error: 'internal error: Scalar subquery might produce more than one row.'
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select t1.x, (select y from t2 where t2._row_id = t1._row_id) from t1;
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: (t2._row_id = t1._row_id), output: [t1.x, t2.y] }
    ├─LogicalScan { table: t1, columns: [t1.x, t1._row_id] }
    └─LogicalScan { table: t2, columns: [t2.y, t2._row_id] }
- name: issue 4762 correlated input in agg order by
  sql: |
    CREATE TABLE strings(v1 VARCHAR);
    SELECT (SELECT STRING_AGG(v1, ',' ORDER BY t.v1) FROM strings) FROM strings AS t;
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(strings.v1, strings.v1), output: [string_agg(strings.v1, ',':Varchar order_by(strings.v1 ASC))] }
    ├─LogicalScan { table: strings, columns: [strings.v1] }
    └─LogicalAgg { group_key: [strings.v1], aggs: [string_agg(strings.v1, ',':Varchar order_by(strings.v1 ASC))] }
      └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(strings.v1, strings.v1), output: [strings.v1, strings.v1, ',':Varchar, strings.v1] }
        ├─LogicalAgg { group_key: [strings.v1], aggs: [] }
        │ └─LogicalScan { table: strings, columns: [strings.v1] }
        └─LogicalProject { exprs: [strings.v1, strings.v1, ',':Varchar, strings.v1] }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalAgg { group_key: [strings.v1], aggs: [] }
            │ └─LogicalScan { table: strings, columns: [strings.v1] }
            └─LogicalScan { table: strings, columns: [strings.v1] }
- name: issue 4762 correlated input in agg filter
  sql: |
    CREATE TABLE strings(v1 VARCHAR);
    SELECT (SELECT STRING_AGG(v1, ',') FILTER (WHERE v1 < t.v1) FROM strings) FROM strings AS t;
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(strings.v1, strings.v1), output: [string_agg(strings.v1, ',':Varchar) filter((strings.v1 < strings.v1))] }
    ├─LogicalScan { table: strings, columns: [strings.v1] }
    └─LogicalAgg { group_key: [strings.v1], aggs: [string_agg(strings.v1, ',':Varchar) filter((strings.v1 < strings.v1))] }
      └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(strings.v1, strings.v1), output: [strings.v1, strings.v1, ',':Varchar] }
        ├─LogicalAgg { group_key: [strings.v1], aggs: [] }
        │ └─LogicalScan { table: strings, columns: [strings.v1] }
        └─LogicalProject { exprs: [strings.v1, strings.v1, ',':Varchar] }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalAgg { group_key: [strings.v1], aggs: [] }
            │ └─LogicalScan { table: strings, columns: [strings.v1] }
            └─LogicalScan { table: strings, columns: [strings.v1] }
- name: issue 7574 correlated input in agg filter in having
  sql: |
    CREATE TABLE strings(v1 VARCHAR);
    SELECT (SELECT 1 FROM strings HAVING COUNT(v1) FILTER (WHERE t.v1 < 'b') > 2) FROM strings AS t;
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(strings.v1, strings.v1), output: [1:Int32] }
    ├─LogicalScan { table: strings, columns: [strings.v1] }
    └─LogicalProject { exprs: [strings.v1, 1:Int32] }
      └─LogicalFilter { predicate: (count(strings.v1) filter((strings.v1 < 'b':Varchar)) > 2:Int32) }
        └─LogicalAgg { group_key: [strings.v1], aggs: [count(strings.v1) filter((strings.v1 < 'b':Varchar))] }
          └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(strings.v1, strings.v1), output: [strings.v1, strings.v1] }
            ├─LogicalAgg { group_key: [strings.v1], aggs: [] }
            │ └─LogicalScan { table: strings, columns: [strings.v1] }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalAgg { group_key: [strings.v1], aggs: [] }
              │ └─LogicalScan { table: strings, columns: [strings.v1] }
              └─LogicalScan { table: strings, columns: [strings.v1] }
- name: Existential join on outer join with correlated condition
  sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(a varchar, z int);
    select x from t1 where y in (select y from t3 full join t2 where t1.x = t2.x and z IS NOT DISTINCT FROM t2.x);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.y = t2.y) AND (t1.x = t2.x), output: [t1.x] }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [t2.y, t2.x] }
      └─LogicalFilter { predicate: IsNotDistinctFrom(t3.z, t2.x) }
        └─LogicalJoin { type: FullOuter, on: true, output: all }
          ├─LogicalScan { table: t3, columns: [t3.z] }
          └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
- name: Correlated condition in RHS of right outer join
  sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(a varchar, z int);
    select x from t1 where y in (select y from t3 right join t2 where t1.x = t2.x and z IS NOT DISTINCT FROM t2.x);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (t1.y = t2.y) AND (t1.x = t2.x), output: [t1.x] }
    ├─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [t2.y, t2.x] }
      └─LogicalFilter { predicate: IsNotDistinctFrom(t3.z, t2.x) }
        └─LogicalJoin { type: LeftOuter, on: true, output: [t3.z, t2.x, t2.y] }
          ├─LogicalScan { table: t2, columns: [t2.x, t2.y] }
          └─LogicalScan { table: t3, columns: [t3.z] }
- name: A correlated subquery contains union
  sql: |
    create table t1 (a int, b int);
    create table t2 (c int, d int);
    create table t3 (e int, f int);
    select * from t1 where exists (select * from t2 where t2.c = t1.a union all select * from t3 where t3.f = t1.b);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.a, t1.a) AND IsNotDistinctFrom(t1.b, t1.b), output: all }
    ├─LogicalScan { table: t1, columns: [t1.a, t1.b] }
    └─LogicalUnion { all: true }
      ├─LogicalJoin { type: Inner, on: (t2.c = t1.a), output: [t1.a, t1.b] }
      │ ├─LogicalAgg { group_key: [t1.a, t1.b], aggs: [] }
      │ │ └─LogicalScan { table: t1, columns: [t1.a, t1.b] }
      │ └─LogicalScan { table: t2, columns: [t2.c] }
      └─LogicalJoin { type: Inner, on: (t3.f = t1.b), output: [t1.a, t1.b] }
        ├─LogicalAgg { group_key: [t1.a, t1.b], aggs: [] }
        │ └─LogicalScan { table: t1, columns: [t1.a, t1.b] }
        └─LogicalScan { table: t3, columns: [t3.f] }
- name: A correlated subquery contains distinct on
  sql: |
    create table t1 (a int, b int);
    create table t2 (c int, d int);
    select * from t2 where exists (select distinct on(a) a from t1 where b = d);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t2.d, t1.b), output: all }
    ├─LogicalScan { table: t2, columns: [t2.c, t2.d] }
    └─LogicalProject { exprs: [t1.b] }
      └─LogicalDedup { dedup_cols: [t1.b, t1.a] }
        └─LogicalProject { exprs: [t1.b, t1.a] }
          └─LogicalScan { table: t1, columns: [t1.a, t1.b], predicate: IsNotNull(t1.b) }
- name: Separate the project from joins before pushing the apply operator down joins. https://github.com/risingwavelabs/risingwave/issues/10662
  sql: |
    create table t1 (a int, b int, other int);
    create table t2 (c int, d int, other int);
    create table t3 (e int, f int, other int);
    select * from t1 where exists (select t2.d, t3.f from t2 join t3 on t2.c = t3.e and t1.a = t2.c and t1.b = t3.e);
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.a, t2.c) AND IsNotDistinctFrom(t1.b, t2.c), output: all }
    ├─LogicalScan { table: t1, columns: [t1.a, t1.b, t1.other] }
    └─LogicalProject { exprs: [t2.c, t2.c] }
      └─LogicalJoin { type: Inner, on: (t2.c = t3.e) AND IsNotDistinctFrom(t2.c, t3.e), output: all }
        ├─LogicalScan { table: t2, columns: [t2.c], predicate: IsNotNull(t2.c) }
        └─LogicalScan { table: t3, columns: [t3.e], predicate: IsNotNull(t3.e) }
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(t1.a, t2.c) AND IsNotDistinctFrom(t1.b, t2.c), output: all }
    ├─LogicalScan { table: t1, columns: [t1.a, t1.b, t1.other] }
    └─LogicalProject { exprs: [t2.c, t2.c] }
      └─LogicalJoin { type: Inner, on: (t2.c = t3.e) AND IsNotDistinctFrom(t2.c, t3.e), output: all }
        ├─LogicalScan { table: t2, columns: [t2.c], predicate: IsNotNull(t2.c) }
        └─LogicalScan { table: t3, columns: [t3.e], predicate: IsNotNull(t3.e) }
- name: test ApplyTopNTransposeRule case 1
  sql: |
    create table t1 (v1 int, k1 int);
    create table t2 (v2 int, k2 int);
    select * from t1 where v1 in ( select v2 from t2 where k2 = k1 order by v2 limit 1);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: LeftSemi, predicate: t1.v1 = t2.v2 AND t1.k1 IS NOT DISTINCT FROM t2.k2, output: all }
      ├─BatchExchange { order: [], dist: HashShard(t1.k1) }
      │ └─BatchScan { table: t1, columns: [t1.v1, t1.k1], distribution: SomeShard }
      └─BatchGroupTopN { order: [t2.v2 ASC], limit: 1, offset: 0, group_key: [t2.k2] }
        └─BatchExchange { order: [], dist: HashShard(t2.k2) }
          └─BatchProject { exprs: [t2.k2, t2.v2] }
            └─BatchFilter { predicate: IsNotNull(t2.k2) }
              └─BatchScan { table: t2, columns: [t2.v2, t2.k2], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [v1, k1, t1._row_id(hidden)], stream_key: [t1._row_id, v1, k1], pk_columns: [t1._row_id, v1, k1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.v1, t1.k1, t1._row_id) }
      └─StreamHashJoin { type: LeftSemi, predicate: t1.v1 = t2.v2 AND t1.k1 IS NOT DISTINCT FROM t2.k2, output: all }
        ├─StreamExchange { dist: HashShard(t1.k1) }
        │ └─StreamTableScan { table: t1, columns: [t1.v1, t1.k1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamGroupTopN { order: [t2.v2 ASC], limit: 1, offset: 0, group_key: [t2.k2] }
          └─StreamExchange { dist: HashShard(t2.k2) }
            └─StreamProject { exprs: [t2.k2, t2.v2, t2._row_id] }
              └─StreamFilter { predicate: IsNotNull(t2.k2) }
                └─StreamTableScan { table: t2, columns: [t2.v2, t2.k2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: test ApplyTopNTransposeRule case 2
  sql: |
    create table t1 (v1 int, k1 int);
    create table t2 (v2 int, k2 int);
    select * from t1 where v1 in ( select v2 from t2 order by v2 limit 1);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: LeftSemi, predicate: t1.v1 = t2.v2, output: all }
      ├─BatchExchange { order: [], dist: HashShard(t1.v1) }
      │ └─BatchScan { table: t1, columns: [t1.v1, t1.k1], distribution: SomeShard }
      └─BatchExchange { order: [], dist: HashShard(t2.v2) }
        └─BatchTopN { order: [t2.v2 ASC], limit: 1, offset: 0 }
          └─BatchExchange { order: [], dist: Single }
            └─BatchTopN { order: [t2.v2 ASC], limit: 1, offset: 0 }
              └─BatchScan { table: t2, columns: [t2.v2], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [v1, k1, t1._row_id(hidden)], stream_key: [t1._row_id, v1], pk_columns: [t1._row_id, v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.v1, t1._row_id) }
      └─StreamHashJoin { type: LeftSemi, predicate: t1.v1 = t2.v2, output: all }
        ├─StreamExchange { dist: HashShard(t1.v1) }
        │ └─StreamTableScan { table: t1, columns: [t1.v1, t1.k1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard(t2.v2) }
          └─StreamProject { exprs: [t2.v2, t2._row_id] }
            └─StreamTopN { order: [t2.v2 ASC], limit: 1, offset: 0 }
              └─StreamExchange { dist: Single }
                └─StreamGroupTopN { order: [t2.v2 ASC], limit: 1, offset: 0, group_key: [_vnode] }
                  └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id) as _vnode] }
                    └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: test ApplyLimitTransposeRule case 1
  sql: |
    create table t1 (v1 int, k1 int);
    create table t2 (v2 int, k2 int);
    select * from t1 where v1 in ( select v2 from t2 where k2 = k1 limit 1);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: LeftSemi, predicate: t1.v1 = t2.v2 AND t1.k1 IS NOT DISTINCT FROM t2.k2, output: all }
      ├─BatchExchange { order: [], dist: HashShard(t1.k1) }
      │ └─BatchScan { table: t1, columns: [t1.v1, t1.k1], distribution: SomeShard }
      └─BatchGroupTopN { order: [t2.k2 ASC], limit: 1, offset: 0, group_key: [t2.k2] }
        └─BatchExchange { order: [], dist: HashShard(t2.k2) }
          └─BatchProject { exprs: [t2.k2, t2.v2] }
            └─BatchFilter { predicate: IsNotNull(t2.k2) }
              └─BatchScan { table: t2, columns: [t2.v2, t2.k2], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [v1, k1, t1._row_id(hidden)], stream_key: [t1._row_id, v1, k1], pk_columns: [t1._row_id, v1, k1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.v1, t1.k1, t1._row_id) }
      └─StreamHashJoin { type: LeftSemi, predicate: t1.v1 = t2.v2 AND t1.k1 IS NOT DISTINCT FROM t2.k2, output: all }
        ├─StreamExchange { dist: HashShard(t1.k1) }
        │ └─StreamTableScan { table: t1, columns: [t1.v1, t1.k1, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamGroupTopN { order: [t2.k2 ASC], limit: 1, offset: 0, group_key: [t2.k2] }
          └─StreamExchange { dist: HashShard(t2.k2) }
            └─StreamProject { exprs: [t2.k2, t2.v2, t2._row_id] }
              └─StreamFilter { predicate: IsNotNull(t2.k2) }
                └─StreamTableScan { table: t2, columns: [t2.v2, t2.k2, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: test correlated input ref predicate and share operator
  sql: |
    create table t (a int, b int, c int);
    create table dl(c1 int, c2 int);
    create table di(d1 int, d2 int);
    select (select 1 from t, di where t.a = dl.c1 and t.b = di.d1 limit 1) name, (select 1 from t, di where t.a = dl.c2 and t.c = di.d2 limit 1) name2 from dl;
  optimized_logical_plan_for_stream: |-
    LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(dl.c1, dl.c1) AND IsNotDistinctFrom(dl.c2, dl.c2), output: [1:Int32, 1:Int32] }
    ├─LogicalScan { table: dl, columns: [dl.c1, dl.c2] }
    └─LogicalJoin { type: Inner, on: IsNotDistinctFrom(dl.c1, dl.c1) AND IsNotDistinctFrom(dl.c2, dl.c2), output: [dl.c1, dl.c2, 1:Int32, 1:Int32] }
      ├─LogicalTopN { order: [dl.c1 ASC], limit: 1, offset: 0, group_key: [dl.c1, dl.c2] }
      │ └─LogicalProject { exprs: [dl.c1, dl.c2, 1:Int32] }
      │   └─LogicalJoin { type: Inner, on: (t.a = dl.c1), output: [dl.c1, dl.c2] }
      │     ├─LogicalAgg { group_key: [dl.c1, dl.c2], aggs: [] }
      │     │ └─LogicalScan { table: dl, columns: [dl.c1, dl.c2] }
      │     └─LogicalFilter { predicate: (t.b = di.d1) }
      │       └─LogicalShare { id: 3 }
      │         └─LogicalJoin { type: Inner, on: ((t.b = di.d1) OR (t.c = di.d2)), output: all }
      │           ├─LogicalScan { table: t, columns: [t.a, t.b, t.c] }
      │           └─LogicalScan { table: di, columns: [di.d1, di.d2] }
      └─LogicalTopN { order: [dl.c1 ASC], limit: 1, offset: 0, group_key: [dl.c1, dl.c2] }
        └─LogicalProject { exprs: [dl.c1, dl.c2, 1:Int32] }
          └─LogicalJoin { type: Inner, on: (t.a = dl.c2), output: [dl.c1, dl.c2] }
            ├─LogicalAgg { group_key: [dl.c1, dl.c2], aggs: [] }
            │ └─LogicalScan { table: dl, columns: [dl.c1, dl.c2] }
            └─LogicalFilter { predicate: (t.c = di.d2) }
              └─LogicalShare { id: 3 }
                └─LogicalJoin { type: Inner, on: ((t.b = di.d1) OR (t.c = di.d2)), output: all }
                  ├─LogicalScan { table: t, columns: [t.a, t.b, t.c] }
                  └─LogicalScan { table: di, columns: [di.d1, di.d2] }
- name: correlated array subquery
  sql: |
    create table t1 (a int, b int);
    create table t2 (c int, d int);
    select Array(select c from t2 where b = d) arr from t1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: LeftOuter, predicate: t1.b IS NOT DISTINCT FROM t1.b, output: [$expr1] }
      ├─BatchExchange { order: [], dist: HashShard(t1.b) }
      │ └─BatchScan { table: t1, columns: [t1.b], distribution: SomeShard }
      └─BatchProject { exprs: [t1.b, Coalesce(array_agg(t2.c) filter(IsNotNull(1:Int32)), ARRAY[]:List(Int32)) as $expr1] }
        └─BatchHashAgg { group_key: [t1.b], aggs: [array_agg(t2.c) filter(IsNotNull(1:Int32))] }
          └─BatchHashJoin { type: LeftOuter, predicate: t1.b IS NOT DISTINCT FROM t2.d, output: [t1.b, t2.c, 1:Int32] }
            ├─BatchHashAgg { group_key: [t1.b], aggs: [] }
            │ └─BatchExchange { order: [], dist: HashShard(t1.b) }
            │   └─BatchScan { table: t1, columns: [t1.b], distribution: SomeShard }
            └─BatchExchange { order: [], dist: HashShard(t2.d) }
              └─BatchProject { exprs: [t2.d, t2.c, 1:Int32] }
                └─BatchFilter { predicate: IsNotNull(t2.d) }
                  └─BatchScan { table: t2, columns: [t2.c, t2.d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [arr, t1._row_id(hidden), t1.b(hidden), t1.b#1(hidden)], stream_key: [t1._row_id, t1.b], pk_columns: [t1._row_id, t1.b], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1._row_id, t1.b) }
      └─StreamHashJoin { type: LeftOuter, predicate: t1.b IS NOT DISTINCT FROM t1.b, output: [$expr1, t1._row_id, t1.b, t1.b] }
        ├─StreamExchange { dist: HashShard(t1.b) }
        │ └─StreamTableScan { table: t1, columns: [t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamProject { exprs: [t1.b, Coalesce(array_agg(t2.c) filter(IsNotNull(1:Int32)), ARRAY[]:List(Int32)) as $expr1] }
          └─StreamHashAgg { group_key: [t1.b], aggs: [array_agg(t2.c) filter(IsNotNull(1:Int32)), count] }
            └─StreamHashJoin { type: LeftOuter, predicate: t1.b IS NOT DISTINCT FROM t2.d, output: [t1.b, t2.c, 1:Int32, t2._row_id] }
              ├─StreamProject { exprs: [t1.b], noop_update_hint: true }
              │ └─StreamHashAgg { group_key: [t1.b], aggs: [count] }
              │   └─StreamExchange { dist: HashShard(t1.b) }
              │     └─StreamTableScan { table: t1, columns: [t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              └─StreamExchange { dist: HashShard(t2.d) }
                └─StreamProject { exprs: [t2.d, t2.c, 1:Int32, t2._row_id] }
                  └─StreamFilter { predicate: IsNotNull(t2.d) }
                    └─StreamTableScan { table: t2, columns: [t2.c, t2.d, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: correlated array subquery \du
  sql: |
    SELECT r.rolname, r.rolsuper, r.rolinherit,
      r.rolcreaterole, r.rolcreatedb, r.rolcanlogin,
      r.rolconnlimit, r.rolvaliduntil,
      ARRAY(SELECT b.rolname
            FROM pg_catalog.pg_auth_members m
            JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
            WHERE m.member = r.oid) as memberof
    , r.rolreplication
    , r.rolbypassrls
    FROM pg_catalog.pg_roles r
    WHERE r.rolname !~ '^pg_'
    ORDER BY 1;
  batch_plan: |-
    BatchExchange { order: [rw_users.name ASC], dist: Single }
    └─BatchProject { exprs: [rw_users.name, rw_users.is_super, true:Boolean, rw_users.create_user, rw_users.create_db, rw_users.can_login, -1:Int32, null:Timestamptz, $expr1, true:Boolean, true:Boolean] }
      └─BatchSort { order: [rw_users.name ASC] }
        └─BatchHashJoin { type: LeftOuter, predicate: rw_users.id IS NOT DISTINCT FROM rw_users.id, output: all }
          ├─BatchExchange { order: [], dist: HashShard(rw_users.id) }
          │ └─BatchFilter { predicate: Not(RegexpEq(rw_users.name, '^pg_':Varchar)) }
          │   └─BatchScan { table: rw_users, columns: [rw_users.id, rw_users.name, rw_users.is_super, rw_users.create_db, rw_users.create_user, rw_users.can_login], distribution: Single }
          └─BatchProject { exprs: [rw_users.id, Coalesce(array_agg(rw_users.name) filter(IsNotNull(1:Int32)), ARRAY[]:List(Varchar)) as $expr1] }
            └─BatchHashAgg { group_key: [rw_users.id], aggs: [array_agg(rw_users.name) filter(IsNotNull(1:Int32))] }
              └─BatchHashJoin { type: LeftOuter, predicate: rw_users.id IS NOT DISTINCT FROM rw_users.id, output: [rw_users.id, rw_users.name, 1:Int32] }
                ├─BatchHashAgg { group_key: [rw_users.id], aggs: [] }
                │ └─BatchExchange { order: [], dist: HashShard(rw_users.id) }
                │   └─BatchProject { exprs: [rw_users.id] }
                │     └─BatchFilter { predicate: Not(RegexpEq(rw_users.name, '^pg_':Varchar)) }
                │       └─BatchScan { table: rw_users, columns: [rw_users.id, rw_users.name], distribution: Single }
                └─BatchExchange { order: [], dist: HashShard(rw_users.id) }
                  └─BatchProject { exprs: [rw_users.id, rw_users.name, 1:Int32] }
                    └─BatchHashJoin { type: Inner, predicate: null:Int32 = rw_users.id, output: [rw_users.id, rw_users.name] }
                      ├─BatchExchange { order: [], dist: HashShard(null:Int32) }
                      │ └─BatchProject { exprs: [rw_users.id, null:Int32] }
                      │   └─BatchNestedLoopJoin { type: Inner, predicate: true, output: all }
                      │     ├─BatchExchange { order: [], dist: Single }
                      │     │ └─BatchHashAgg { group_key: [rw_users.id], aggs: [] }
                      │     │   └─BatchExchange { order: [], dist: HashShard(rw_users.id) }
                      │     │     └─BatchValues { rows: [] }
                      │     └─BatchFilter { predicate: false:Boolean }
                      │       └─BatchValues { rows: [] }
                      └─BatchExchange { order: [], dist: HashShard(rw_users.id) }
                        └─BatchScan { table: rw_users, columns: [rw_users.id, rw_users.name], distribution: Single }
- name: correlated array subquery (issue 14423)
  sql: |
    CREATE TABLE array_types ( x BIGINT[] );
    SELECT array(
      ((((((
        select t0.x
      ))))))
    )
    FROM array_types AS t0;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: LeftOuter, predicate: array_types.x IS NOT DISTINCT FROM array_types.x, output: [$expr1] }
      ├─BatchExchange { order: [], dist: HashShard(array_types.x) }
      │ └─BatchScan { table: array_types, columns: [array_types.x], distribution: SomeShard }
      └─BatchProject { exprs: [array_types.x, Coalesce(array_agg(array_types.x) filter(IsNotNull(1:Int32)), ARRAY[]:List(List(Int64))) as $expr1] }
        └─BatchHashAgg { group_key: [array_types.x], aggs: [array_agg(array_types.x) filter(IsNotNull(1:Int32))] }
          └─BatchHashJoin { type: LeftOuter, predicate: array_types.x IS NOT DISTINCT FROM array_types.x, output: [array_types.x, array_types.x, 1:Int32] }
            ├─BatchHashAgg { group_key: [array_types.x], aggs: [] }
            │ └─BatchExchange { order: [], dist: HashShard(array_types.x) }
            │   └─BatchScan { table: array_types, columns: [array_types.x], distribution: SomeShard }
            └─BatchExchange { order: [], dist: HashShard(array_types.x) }
              └─BatchProject { exprs: [array_types.x, array_types.x, 1:Int32] }
                └─BatchHashAgg { group_key: [array_types.x], aggs: [] }
                  └─BatchExchange { order: [], dist: HashShard(array_types.x) }
                    └─BatchScan { table: array_types, columns: [array_types.x], distribution: SomeShard }
- name: a case can't be optimized by PullUpCorrelatedPredicateAggRule
  sql: |
    CREATE TABLE T (A INT, B INT);
    CREATE TABLE T2 (C INT, D INT);
    SELECT * FROM T
    -- count is not null-propagating
    WHERE T.A > (SELECT COUNT(*) FROM T2 WHERE B = D);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t.b IS NOT DISTINCT FROM t.b AND ($expr1 > count(1:Int32)), output: [t.a, t.b] }
      ├─BatchExchange { order: [], dist: HashShard(t.b) }
      │ └─BatchProject { exprs: [t.a, t.b, t.a::Int64 as $expr1] }
      │   └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
      └─BatchHashAgg { group_key: [t.b], aggs: [count(1:Int32)] }
        └─BatchHashJoin { type: LeftOuter, predicate: t.b IS NOT DISTINCT FROM t2.d, output: [t.b, 1:Int32] }
          ├─BatchHashAgg { group_key: [t.b], aggs: [] }
          │ └─BatchExchange { order: [], dist: HashShard(t.b) }
          │   └─BatchScan { table: t, columns: [t.b], distribution: SomeShard }
          └─BatchExchange { order: [], dist: HashShard(t2.d) }
            └─BatchProject { exprs: [t2.d, 1:Int32] }
              └─BatchFilter { predicate: IsNotNull(t2.d) }
                └─BatchScan { table: t2, columns: [t2.d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a, b, t._row_id(hidden), t.b(hidden)], stream_key: [t._row_id, b], pk_columns: [t._row_id, b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t.a, t.b, t._row_id, t.b] }
      └─StreamFilter { predicate: ($expr1 > count(1:Int32)) }
        └─StreamHashJoin { type: Inner, predicate: t.b IS NOT DISTINCT FROM t.b, output: all }
          ├─StreamExchange { dist: HashShard(t.b) }
          │ └─StreamProject { exprs: [t.a, t.b, t.a::Int64 as $expr1, t._row_id] }
          │   └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
          └─StreamProject { exprs: [t.b, count(1:Int32)] }
            └─StreamHashAgg { group_key: [t.b], aggs: [count(1:Int32), count] }
              └─StreamHashJoin { type: LeftOuter, predicate: t.b IS NOT DISTINCT FROM t2.d, output: [t.b, 1:Int32, t2._row_id] }
                ├─StreamProject { exprs: [t.b], noop_update_hint: true }
                │ └─StreamHashAgg { group_key: [t.b], aggs: [count] }
                │   └─StreamExchange { dist: HashShard(t.b) }
                │     └─StreamTableScan { table: t, columns: [t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
                └─StreamExchange { dist: HashShard(t2.d) }
                  └─StreamProject { exprs: [t2.d, 1:Int32, t2._row_id] }
                    └─StreamFilter { predicate: IsNotNull(t2.d) }
                      └─StreamTableScan { table: t2, columns: [t2.d, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: a case could be optimized by PullUpCorrelatedPredicateAggRule
  sql: |
    CREATE TABLE T (A INT, B INT);
    CREATE TABLE T2 (C INT, D INT);
    SELECT * FROM T
    -- avg is null-propagating
    WHERE T.A > (SELECT avg(c) FROM T2 WHERE B = D);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t.b = t2.d AND ($expr1 > $expr2), output: [t.a, t.b] }
      ├─BatchExchange { order: [], dist: HashShard(t.b) }
      │ └─BatchProject { exprs: [t.a, t.b, t.a::Decimal as $expr1] }
      │   └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
      └─BatchProject { exprs: [(sum(t2.c)::Decimal / count(t2.c)::Decimal) as $expr2, t2.d] }
        └─BatchHashAgg { group_key: [t2.d], aggs: [sum(t2.c), count(t2.c)] }
          └─BatchExchange { order: [], dist: HashShard(t2.d) }
            └─BatchScan { table: t2, columns: [t2.c, t2.d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a, b, t._row_id(hidden), t2.d(hidden)], stream_key: [t._row_id, b], pk_columns: [t._row_id, b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t.a, t.b, t._row_id, t2.d] }
      └─StreamFilter { predicate: ($expr1 > $expr2) }
        └─StreamHashJoin { type: Inner, predicate: t.b = t2.d, output: all }
          ├─StreamExchange { dist: HashShard(t.b) }
          │ └─StreamProject { exprs: [t.a, t.b, t.a::Decimal as $expr1, t._row_id] }
          │   └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
          └─StreamProject { exprs: [(sum(t2.c)::Decimal / count(t2.c)::Decimal) as $expr2, t2.d] }
            └─StreamHashAgg { group_key: [t2.d], aggs: [sum(t2.c), count(t2.c), count] }
              └─StreamExchange { dist: HashShard(t2.d) }
                └─StreamTableScan { table: t2, columns: [t2.c, t2.d, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: a case can't be optimized by PullUpCorrelatedPredicateAggRule
  sql: |
    CREATE TABLE T (A INT, B INT);
    CREATE TABLE T2 (C INT, D INT);
    SELECT * FROM T
    -- Coalesce is not null-propagating
    WHERE T.A > (SELECT coalesce(avg(c), 114514) FROM T2 WHERE B = D);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t.b IS NOT DISTINCT FROM t.b AND ($expr1 > $expr2), output: [t.a, t.b] }
      ├─BatchExchange { order: [], dist: HashShard(t.b) }
      │ └─BatchProject { exprs: [t.a, t.b, t.a::Decimal as $expr1] }
      │   └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
      └─BatchProject { exprs: [t.b, Coalesce((sum(t2.c)::Decimal / count(t2.c)::Decimal), 114514:Decimal) as $expr2] }
        └─BatchHashAgg { group_key: [t.b], aggs: [sum(t2.c), count(t2.c)] }
          └─BatchHashJoin { type: LeftOuter, predicate: t.b IS NOT DISTINCT FROM t2.d, output: [t.b, t2.c] }
            ├─BatchHashAgg { group_key: [t.b], aggs: [] }
            │ └─BatchExchange { order: [], dist: HashShard(t.b) }
            │   └─BatchScan { table: t, columns: [t.b], distribution: SomeShard }
            └─BatchExchange { order: [], dist: HashShard(t2.d) }
              └─BatchProject { exprs: [t2.d, t2.c] }
                └─BatchFilter { predicate: IsNotNull(t2.d) }
                  └─BatchScan { table: t2, columns: [t2.c, t2.d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a, b, t._row_id(hidden), t.b(hidden)], stream_key: [t._row_id, b], pk_columns: [t._row_id, b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t.a, t.b, t._row_id, t.b] }
      └─StreamFilter { predicate: ($expr1 > $expr2) }
        └─StreamHashJoin { type: Inner, predicate: t.b IS NOT DISTINCT FROM t.b, output: all }
          ├─StreamExchange { dist: HashShard(t.b) }
          │ └─StreamProject { exprs: [t.a, t.b, t.a::Decimal as $expr1, t._row_id] }
          │   └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
          └─StreamProject { exprs: [t.b, Coalesce((sum(t2.c)::Decimal / count(t2.c)::Decimal), 114514:Decimal) as $expr2] }
            └─StreamHashAgg { group_key: [t.b], aggs: [sum(t2.c), count(t2.c), count] }
              └─StreamHashJoin { type: LeftOuter, predicate: t.b IS NOT DISTINCT FROM t2.d, output: [t.b, t2.c, t2._row_id] }
                ├─StreamProject { exprs: [t.b], noop_update_hint: true }
                │ └─StreamHashAgg { group_key: [t.b], aggs: [count] }
                │   └─StreamExchange { dist: HashShard(t.b) }
                │     └─StreamTableScan { table: t, columns: [t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
                └─StreamExchange { dist: HashShard(t2.d) }
                  └─StreamProject { exprs: [t2.d, t2.c, t2._row_id] }
                    └─StreamFilter { predicate: IsNotNull(t2.d) }
                      └─StreamTableScan { table: t2, columns: [t2.c, t2.d, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: a case can't be optimized by PullUpCorrelatedPredicateAggRule
  sql: |
    CREATE TABLE T (A INT, B INT);
    CREATE TABLE T2 (C INT, D INT);
    SELECT * FROM T
    -- Can apply if any of the conjunction is null
    WHERE null AND T.A > (SELECT coalesce(avg(c), 114514) FROM T2 WHERE B = D);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t.b = t2.d AND ($expr1 > $expr2), output: [t.a, t.b] }
      ├─BatchExchange { order: [], dist: HashShard(t.b) }
      │ └─BatchProject { exprs: [t.a, t.b, t.a::Decimal as $expr1] }
      │   └─BatchFilter { predicate: null:Boolean }
      │     └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
      └─BatchProject { exprs: [Coalesce((sum(t2.c)::Decimal / count(t2.c)::Decimal), 114514:Decimal) as $expr2, t2.d] }
        └─BatchHashAgg { group_key: [t2.d], aggs: [sum(t2.c), count(t2.c)] }
          └─BatchExchange { order: [], dist: HashShard(t2.d) }
            └─BatchFilter { predicate: null:Boolean }
              └─BatchScan { table: t2, columns: [t2.c, t2.d], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [a, b, t._row_id(hidden), t2.d(hidden)], stream_key: [t._row_id, b], pk_columns: [t._row_id, b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t.a, t.b, t._row_id, t2.d] }
      └─StreamFilter { predicate: ($expr1 > $expr2) }
        └─StreamHashJoin { type: Inner, predicate: t.b = t2.d, output: all }
          ├─StreamExchange { dist: HashShard(t.b) }
          │ └─StreamProject { exprs: [t.a, t.b, t.a::Decimal as $expr1, t._row_id] }
          │   └─StreamFilter { predicate: null:Boolean }
          │     └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
          └─StreamProject { exprs: [Coalesce((sum(t2.c)::Decimal / count(t2.c)::Decimal), 114514:Decimal) as $expr2, t2.d] }
            └─StreamHashAgg { group_key: [t2.d], aggs: [sum(t2.c), count(t2.c), count] }
              └─StreamExchange { dist: HashShard(t2.d) }
                └─StreamFilter { predicate: null:Boolean }
                  └─StreamTableScan { table: t2, columns: [t2.c, t2.d, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: improve multi scalar subqueries optimization time. issue 16952. case 1.
  sql: |
    create table t1(a int, b int);
    create table t2(c int primary key, d int);
    select
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col1,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col2,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col3,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col4,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col5,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col6,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col7,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col8,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col9,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col10,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col11,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col12,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col13,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col14,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col15,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col16,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col17,
    COALESCE((SELECT b FROM t2 WHERE t1.a = t2.c), 0) col18
    from t1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Coalesce(t1.b, 0:Int32) as $expr1, Coalesce(t1.b, 0:Int32) as $expr2, Coalesce(t1.b, 0:Int32) as $expr3, Coalesce(t1.b, 0:Int32) as $expr4, Coalesce(t1.b, 0:Int32) as $expr5, Coalesce(t1.b, 0:Int32) as $expr6, Coalesce(t1.b, 0:Int32) as $expr7, Coalesce(t1.b, 0:Int32) as $expr8, Coalesce(t1.b, 0:Int32) as $expr9, Coalesce(t1.b, 0:Int32) as $expr10, Coalesce(t1.b, 0:Int32) as $expr11, Coalesce(t1.b, 0:Int32) as $expr12, Coalesce(t1.b, 0:Int32) as $expr13, Coalesce(t1.b, 0:Int32) as $expr14, Coalesce(t1.b, 0:Int32) as $expr15, Coalesce(t1.b, 0:Int32) as $expr16, Coalesce(t1.b, 0:Int32) as $expr17, Coalesce(t1.b, 0:Int32) as $expr18] }
      └─BatchHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b] }
        ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
        │ └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
        └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          └─BatchProject { exprs: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b] }
            └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
              └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │     └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: all }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b], lookup table: t2 }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │     └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │         └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │       │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │       │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  │       └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │         └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │           └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                    └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                      └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, col11, col12, col13, col14, col15, col16, col17, col18, t1._row_id(hidden), t1.b(hidden), t1.a(hidden), t1.a#1(hidden), t1.a#2(hidden), t1.a#3(hidden), t1.a#4(hidden), t1.a#5(hidden), t1.a#6(hidden), t1.a#7(hidden), t1.a#8(hidden), t1.a#9(hidden), t1.a#10(hidden), t1.a#11(hidden), t1.a#12(hidden), t1.a#13(hidden), t1.a#14(hidden), t1.a#15(hidden), t1.a#16(hidden), t1.a#17(hidden), t1.b#1(hidden)], stream_key: [t1._row_id, t1.b, t1.a, t1.a#1, t1.a#2, t1.a#3, t1.a#4, t1.a#5, t1.a#6, t1.a#7, t1.a#8, t1.a#9, t1.a#10, t1.a#11, t1.a#12, t1.a#13, t1.a#14, t1.a#15, t1.a#16, t1.a#17, t1.b#1], pk_columns: [t1._row_id, t1.b, t1.a, t1.a#1, t1.a#2, t1.a#3, t1.a#4, t1.a#5, t1.a#6, t1.a#7, t1.a#8, t1.a#9, t1.a#10, t1.a#11, t1.a#12, t1.a#13, t1.a#14, t1.a#15, t1.a#16, t1.a#17, t1.b#1], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Coalesce(t1.b, 0:Int32) as $expr1, Coalesce(t1.b, 0:Int32) as $expr2, Coalesce(t1.b, 0:Int32) as $expr3, Coalesce(t1.b, 0:Int32) as $expr4, Coalesce(t1.b, 0:Int32) as $expr5, Coalesce(t1.b, 0:Int32) as $expr6, Coalesce(t1.b, 0:Int32) as $expr7, Coalesce(t1.b, 0:Int32) as $expr8, Coalesce(t1.b, 0:Int32) as $expr9, Coalesce(t1.b, 0:Int32) as $expr10, Coalesce(t1.b, 0:Int32) as $expr11, Coalesce(t1.b, 0:Int32) as $expr12, Coalesce(t1.b, 0:Int32) as $expr13, Coalesce(t1.b, 0:Int32) as $expr14, Coalesce(t1.b, 0:Int32) as $expr15, Coalesce(t1.b, 0:Int32) as $expr16, Coalesce(t1.b, 0:Int32) as $expr17, Coalesce(t1.b, 0:Int32) as $expr18, t1._row_id, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
      └─StreamHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1._row_id, t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a] }
        ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
        │ └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          └─StreamProject { exprs: [t1.a, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a] }
            └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              ├─StreamExchange { dist: HashShard(t1.a) }
              │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: [t1.a, t1.b, t1.a, t2.c] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t1.a, t1.b] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: all }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   ├─StreamExchange { dist: HashShard(t1.a) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │   │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   │   │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │   │   │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │   │   │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │   │   │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              │   │   └─StreamExchange { dist: HashShard(t2.c) }
              │   │     └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
              │   └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
              │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
              │       └─StreamExchange { dist: HashShard(t1.a, t1.b) }
              │         └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              └─StreamExchange { dist: HashShard(t2.c) }
                └─StreamTableScan { table: t2, columns: [t2.c], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
- name: improve multi scalar subqueries optimization time. issue 16952. case 2.
  sql: |
    create table t1(a int, b int);
    create table t2(c int primary key, d int);
    create table t3(e int, f int);
    create table t4(g int, h int);
    create table t5(i int, j int);
    create table t6(k int, l int);
    select
    COALESCE((SELECT sum(d) FROM t2 left join t3 on e = a and f = c left join t4 on g = a and h = c left join t5 on i = a and j = c WHERE t1.a = t2.c and t1.a = t2.c and j in (select k from t6 where b = l) ), 0) col1,
    COALESCE((SELECT sum(d) FROM t2 left join t3 on e = a and f = c left join t4 on g = a and h = c left join t5 on i = a and j = c WHERE t1.a = t2.c and t1.a = t2.c and j in (select k from t6 where b = l) ), 0) col2,
    COALESCE((SELECT sum(d) FROM t2 left join t3 on e = a and f = c left join t4 on g = a and h = c left join t5 on i = a and j = c WHERE t1.a = t2.c and t1.a = t2.c and j in (select k from t6 where b = l) ), 0) col3,
    COALESCE((SELECT sum(d) FROM t2 left join t3 on e = a and f = c left join t4 on g = a and h = c left join t5 on i = a and j = c WHERE t1.a = t2.c and t1.a = t2.c and j in (select k from t6 where b = l) ), 0) col4,
    COALESCE((SELECT sum(d) FROM t2 left join t3 on e = a and f = c left join t4 on g = a and h = c left join t5 on i = a and j = c WHERE t1.a = t2.c and t1.a = t2.c and j in (select k from t6 where b = l) ), 0) col5,
    COALESCE((SELECT sum(d) FROM t2 left join t3 on e = a and f = c left join t4 on g = a and h = c left join t5 on i = a and j = c WHERE t1.a = t2.c and t1.a = t2.c and j in (select k from t6 where b = l) ), 0) col6
    from t1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Coalesce(sum(t2.d), 0:Int64) as $expr1, Coalesce(sum(t2.d), 0:Int64) as $expr2, Coalesce(sum(t2.d), 0:Int64) as $expr3, Coalesce(sum(t2.d), 0:Int64) as $expr4, Coalesce(sum(t2.d), 0:Int64) as $expr5, Coalesce(sum(t2.d), 0:Int64) as $expr6] }
      └─BatchHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d)] }
        ├─BatchExchange { order: [], dist: HashShard(t1.b) }
        │ └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
        └─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d)] }
          ├─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d)] }
          │ ├─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d)] }
          │ │ ├─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, sum(t2.d), sum(t2.d), sum(t2.d)] }
          │ │ │ ├─BatchHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, sum(t2.d), sum(t2.d)] }
          │ │ │ │ ├─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d)] }
          │ │ │ │ │ └─BatchHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │ │ │ │ │   ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │ │ │ │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │ │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │ │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │ │   └─BatchHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │ │ │ │ │     ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │ │ │ │     │ └─BatchHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j] }
          │ │ │ │ │     │   ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │ │ │ │ │     │   │ ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │ │ │ │ │     │   │ │ ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │ │ │     │   │ │ │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: all, lookup table: t2 }
          │ │ │ │ │     │   │ │ │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
          │ │ │ │ │     │   │ │ │     └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │ │     │   │ │ │       └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │ │     │   │ │ │         └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │ │     │   │ │ └─BatchHashJoin { type: Inner, predicate: t1.a = t3.e AND t1.a = t3.f, output: [t1.a, t1.b, t3.f] }
          │ │ │ │ │     │   │ │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │ │ │     │   │ │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │ │     │   │ │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │ │     │   │ │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │ │     │   │ │   └─BatchExchange { order: [], dist: HashShard(t3.e, t3.f) }
          │ │ │ │ │     │   │ │     └─BatchScan { table: t3, columns: [t3.e, t3.f], distribution: SomeShard }
          │ │ │ │ │     │   │ └─BatchHashJoin { type: Inner, predicate: t1.a = t4.g AND t1.a = t4.h, output: [t1.a, t1.b, t4.h] }
          │ │ │ │ │     │   │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │ │ │     │   │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │ │     │   │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │ │     │   │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │ │     │   │   └─BatchExchange { order: [], dist: HashShard(t4.g, t4.h) }
          │ │ │ │ │     │   │     └─BatchScan { table: t4, columns: [t4.g, t4.h], distribution: SomeShard }
          │ │ │ │ │     │   └─BatchHashJoin { type: Inner, predicate: t1.a = t5.i AND t1.a = t5.j, output: [t1.a, t1.b, t5.j] }
          │ │ │ │ │     │     ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │ │ │     │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │ │     │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │ │     │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │ │     │     └─BatchExchange { order: [], dist: HashShard(t5.i, t5.j) }
          │ │ │ │ │     │       └─BatchScan { table: t5, columns: [t5.i, t5.j], distribution: SomeShard }
          │ │ │ │ │     └─BatchHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k] }
          │ │ │ │ │       ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │ │ │ │       │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │ │       │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │ │       │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │ │       └─BatchExchange { order: [], dist: HashShard(t6.l) }
          │ │ │ │ │         └─BatchScan { table: t6, columns: [t6.k, t6.l], distribution: SomeShard }
          │ │ │ │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d)] }
          │ │ │ │   └─BatchHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │ │ │ │     ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │ │ │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │     └─BatchHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │ │ │ │       ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │ │ │       │ └─BatchHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j] }
          │ │ │ │       │   ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │ │ │ │       │   │ ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │ │ │ │       │   │ │ ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │ │       │   │ │ │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: all, lookup table: t2 }
          │ │ │ │       │   │ │ │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
          │ │ │ │       │   │ │ │     └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │       │   │ │ │       └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │       │   │ │ │         └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │       │   │ │ └─BatchHashJoin { type: Inner, predicate: t1.a = t3.e AND t1.a = t3.f, output: [t1.a, t1.b, t3.f] }
          │ │ │ │       │   │ │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │ │       │   │ │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │       │   │ │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │       │   │ │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │       │   │ │   └─BatchExchange { order: [], dist: HashShard(t3.e, t3.f) }
          │ │ │ │       │   │ │     └─BatchScan { table: t3, columns: [t3.e, t3.f], distribution: SomeShard }
          │ │ │ │       │   │ └─BatchHashJoin { type: Inner, predicate: t1.a = t4.g AND t1.a = t4.h, output: [t1.a, t1.b, t4.h] }
          │ │ │ │       │   │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │ │       │   │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │       │   │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │       │   │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │       │   │   └─BatchExchange { order: [], dist: HashShard(t4.g, t4.h) }
          │ │ │ │       │   │     └─BatchScan { table: t4, columns: [t4.g, t4.h], distribution: SomeShard }
          │ │ │ │       │   └─BatchHashJoin { type: Inner, predicate: t1.a = t5.i AND t1.a = t5.j, output: [t1.a, t1.b, t5.j] }
          │ │ │ │       │     ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │ │       │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │       │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │       │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │       │     └─BatchExchange { order: [], dist: HashShard(t5.i, t5.j) }
          │ │ │ │       │       └─BatchScan { table: t5, columns: [t5.i, t5.j], distribution: SomeShard }
          │ │ │ │       └─BatchHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k] }
          │ │ │ │         ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │ │ │         │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │ │         │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │ │         │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │ │         └─BatchExchange { order: [], dist: HashShard(t6.l) }
          │ │ │ │           └─BatchScan { table: t6, columns: [t6.k, t6.l], distribution: SomeShard }
          │ │ │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d)] }
          │ │ │   └─BatchHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │ │ │     ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │ │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │     └─BatchHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │ │ │       ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │ │       │ └─BatchHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j] }
          │ │ │       │   ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │ │ │       │   │ ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │ │ │       │   │ │ ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │       │   │ │ │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: all, lookup table: t2 }
          │ │ │       │   │ │ │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
          │ │ │       │   │ │ │     └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │       │   │ │ │       └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │       │   │ │ │         └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │       │   │ │ └─BatchHashJoin { type: Inner, predicate: t1.a = t3.e AND t1.a = t3.f, output: [t1.a, t1.b, t3.f] }
          │ │ │       │   │ │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │       │   │ │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │       │   │ │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │       │   │ │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │       │   │ │   └─BatchExchange { order: [], dist: HashShard(t3.e, t3.f) }
          │ │ │       │   │ │     └─BatchScan { table: t3, columns: [t3.e, t3.f], distribution: SomeShard }
          │ │ │       │   │ └─BatchHashJoin { type: Inner, predicate: t1.a = t4.g AND t1.a = t4.h, output: [t1.a, t1.b, t4.h] }
          │ │ │       │   │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │       │   │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │       │   │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │       │   │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │       │   │   └─BatchExchange { order: [], dist: HashShard(t4.g, t4.h) }
          │ │ │       │   │     └─BatchScan { table: t4, columns: [t4.g, t4.h], distribution: SomeShard }
          │ │ │       │   └─BatchHashJoin { type: Inner, predicate: t1.a = t5.i AND t1.a = t5.j, output: [t1.a, t1.b, t5.j] }
          │ │ │       │     ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │ │       │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │       │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │       │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │       │     └─BatchExchange { order: [], dist: HashShard(t5.i, t5.j) }
          │ │ │       │       └─BatchScan { table: t5, columns: [t5.i, t5.j], distribution: SomeShard }
          │ │ │       └─BatchHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k] }
          │ │ │         ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │ │         │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │ │         │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │ │         │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │ │         └─BatchExchange { order: [], dist: HashShard(t6.l) }
          │ │ │           └─BatchScan { table: t6, columns: [t6.k, t6.l], distribution: SomeShard }
          │ │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d)] }
          │ │   └─BatchHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │ │     ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │     └─BatchHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │ │       ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │       │ └─BatchHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j] }
          │ │       │   ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │ │       │   │ ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │ │       │   │ │ ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │       │   │ │ │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: all, lookup table: t2 }
          │ │       │   │ │ │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
          │ │       │   │ │ │     └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │       │   │ │ │       └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │       │   │ │ │         └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │       │   │ │ └─BatchHashJoin { type: Inner, predicate: t1.a = t3.e AND t1.a = t3.f, output: [t1.a, t1.b, t3.f] }
          │ │       │   │ │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │       │   │ │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │       │   │ │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │       │   │ │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │       │   │ │   └─BatchExchange { order: [], dist: HashShard(t3.e, t3.f) }
          │ │       │   │ │     └─BatchScan { table: t3, columns: [t3.e, t3.f], distribution: SomeShard }
          │ │       │   │ └─BatchHashJoin { type: Inner, predicate: t1.a = t4.g AND t1.a = t4.h, output: [t1.a, t1.b, t4.h] }
          │ │       │   │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │       │   │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │       │   │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │       │   │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │       │   │   └─BatchExchange { order: [], dist: HashShard(t4.g, t4.h) }
          │ │       │   │     └─BatchScan { table: t4, columns: [t4.g, t4.h], distribution: SomeShard }
          │ │       │   └─BatchHashJoin { type: Inner, predicate: t1.a = t5.i AND t1.a = t5.j, output: [t1.a, t1.b, t5.j] }
          │ │       │     ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │ │       │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │       │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │       │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │       │     └─BatchExchange { order: [], dist: HashShard(t5.i, t5.j) }
          │ │       │       └─BatchScan { table: t5, columns: [t5.i, t5.j], distribution: SomeShard }
          │ │       └─BatchHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k] }
          │ │         ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │ │         │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │ │         │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │ │         │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │ │         └─BatchExchange { order: [], dist: HashShard(t6.l) }
          │ │           └─BatchScan { table: t6, columns: [t6.k, t6.l], distribution: SomeShard }
          │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d)] }
          │   └─BatchHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │     ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │     └─BatchHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
          │       ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │       │ └─BatchHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j] }
          │       │   ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │       │   │ ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
          │       │   │ │ ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │       │   │ │ │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: all, lookup table: t2 }
          │       │   │ │ │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
          │       │   │ │ │     └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │       │   │ │ │       └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │       │   │ │ │         └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │       │   │ │ └─BatchHashJoin { type: Inner, predicate: t1.a = t3.e AND t1.a = t3.f, output: [t1.a, t1.b, t3.f] }
          │       │   │ │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │       │   │ │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │       │   │ │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │       │   │ │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │       │   │ │   └─BatchExchange { order: [], dist: HashShard(t3.e, t3.f) }
          │       │   │ │     └─BatchScan { table: t3, columns: [t3.e, t3.f], distribution: SomeShard }
          │       │   │ └─BatchHashJoin { type: Inner, predicate: t1.a = t4.g AND t1.a = t4.h, output: [t1.a, t1.b, t4.h] }
          │       │   │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │       │   │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │       │   │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │       │   │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │       │   │   └─BatchExchange { order: [], dist: HashShard(t4.g, t4.h) }
          │       │   │     └─BatchScan { table: t4, columns: [t4.g, t4.h], distribution: SomeShard }
          │       │   └─BatchHashJoin { type: Inner, predicate: t1.a = t5.i AND t1.a = t5.j, output: [t1.a, t1.b, t5.j] }
          │       │     ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
          │       │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │       │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │       │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │       │     └─BatchExchange { order: [], dist: HashShard(t5.i, t5.j) }
          │       │       └─BatchScan { table: t5, columns: [t5.i, t5.j], distribution: SomeShard }
          │       └─BatchHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k] }
          │         ├─BatchExchange { order: [], dist: HashShard(t1.b) }
          │         │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
          │         │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
          │         │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
          │         └─BatchExchange { order: [], dist: HashShard(t6.l) }
          │           └─BatchScan { table: t6, columns: [t6.k, t6.l], distribution: SomeShard }
          └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d)] }
            └─BatchHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
              ├─BatchExchange { order: [], dist: HashShard(t1.b) }
              │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
              │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
              │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
              └─BatchHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d] }
                ├─BatchExchange { order: [], dist: HashShard(t1.b) }
                │ └─BatchHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j] }
                │   ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
                │   │ ├─BatchHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d] }
                │   │ │ ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
                │   │ │ │ └─BatchLookupJoin { type: Inner, predicate: t1.a = t2.c, output: all, lookup table: t2 }
                │   │ │ │   └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
                │   │ │ │     └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                │   │ │ │       └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                │   │ │ │         └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                │   │ │ └─BatchHashJoin { type: Inner, predicate: t1.a = t3.e AND t1.a = t3.f, output: [t1.a, t1.b, t3.f] }
                │   │ │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
                │   │ │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                │   │ │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                │   │ │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                │   │ │   └─BatchExchange { order: [], dist: HashShard(t3.e, t3.f) }
                │   │ │     └─BatchScan { table: t3, columns: [t3.e, t3.f], distribution: SomeShard }
                │   │ └─BatchHashJoin { type: Inner, predicate: t1.a = t4.g AND t1.a = t4.h, output: [t1.a, t1.b, t4.h] }
                │   │   ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
                │   │   │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                │   │   │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                │   │   │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                │   │   └─BatchExchange { order: [], dist: HashShard(t4.g, t4.h) }
                │   │     └─BatchScan { table: t4, columns: [t4.g, t4.h], distribution: SomeShard }
                │   └─BatchHashJoin { type: Inner, predicate: t1.a = t5.i AND t1.a = t5.j, output: [t1.a, t1.b, t5.j] }
                │     ├─BatchExchange { order: [], dist: HashShard(t1.a, t1.a) }
                │     │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                │     │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                │     │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                │     └─BatchExchange { order: [], dist: HashShard(t5.i, t5.j) }
                │       └─BatchScan { table: t5, columns: [t5.i, t5.j], distribution: SomeShard }
                └─BatchHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k] }
                  ├─BatchExchange { order: [], dist: HashShard(t1.b) }
                  │ └─BatchHashAgg { group_key: [t1.a, t1.b], aggs: [] }
                  │   └─BatchExchange { order: [], dist: HashShard(t1.a, t1.b) }
                  │     └─BatchScan { table: t1, columns: [t1.a, t1.b], distribution: SomeShard }
                  └─BatchExchange { order: [], dist: HashShard(t6.l) }
                    └─BatchScan { table: t6, columns: [t6.k, t6.l], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [col1, col2, col3, col4, col5, col6, t1._row_id(hidden), t1.a(hidden), t1.b(hidden), t1.a#1(hidden), t1.b#1(hidden)], stream_key: [t1._row_id, t1.a, t1.b, t1.a#1, t1.b#1], pk_columns: [t1._row_id, t1.a, t1.b, t1.a#1, t1.b#1], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Coalesce(sum(t2.d), 0:Int64) as $expr1, Coalesce(sum(t2.d), 0:Int64) as $expr2, Coalesce(sum(t2.d), 0:Int64) as $expr3, Coalesce(sum(t2.d), 0:Int64) as $expr4, Coalesce(sum(t2.d), 0:Int64) as $expr5, Coalesce(sum(t2.d), 0:Int64) as $expr6, t1._row_id, t1.a, t1.b, t1.a, t1.b] }
      └─StreamHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), t1._row_id, t1.a, t1.b, t1.a, t1.b, t1.a, t1.b] }
        ├─StreamExchange { dist: HashShard(t1.b) }
        │ └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), t1.a, t1.b, t1.a, t1.b] }
          ├─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [sum(t2.d), t1.a, t1.b, sum(t2.d), sum(t2.d), sum(t2.d), sum(t2.d), t1.a, t1.b, t1.a, t1.b] }
          │ ├─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [sum(t2.d), t1.a, t1.b, sum(t2.d), sum(t2.d), sum(t2.d), t1.a, t1.b, t1.a, t1.b] }
          │ │ ├─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [sum(t2.d), t1.a, t1.b, sum(t2.d), sum(t2.d), t1.a, t1.b, t1.a, t1.b] }
          │ │ │ ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │ │ └─StreamHashJoin { type: Inner, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [sum(t2.d), t1.a, t1.b, sum(t2.d), t1.a, t1.b] }
          │ │ │ │   ├─StreamProject { exprs: [t1.a, t1.b, sum(t2.d)] }
          │ │ │ │   │ └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d), count] }
          │ │ │ │   │   └─StreamHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t1.a, t1.b, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │ │ │ │   │     ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │ │   │     │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │   │     │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │   │     │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │   │     │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │   │     └─StreamHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │ │ │ │   │       ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │ │   │       │ └─StreamHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j, t3._row_id, t2.c, t4._row_id, t1.a, t1.b, t5._row_id] }
          │ │ │ │   │       │   ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t3._row_id, t1.a, t1.b, t4._row_id] }
          │ │ │ │   │       │   │ ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t1.a, t1.b, t3._row_id] }
          │ │ │ │   │       │   │ │ ├─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: all }
          │ │ │ │   │       │   │ │ │ ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │ │   │       │   │ │ │ │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │   │       │   │ │ │ │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │   │       │   │ │ │ │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │   │       │   │ │ │ │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │   │       │   │ │ │ └─StreamExchange { dist: HashShard(t2.c) }
          │ │ │ │   │       │   │ │ │   └─StreamTableScan { table: t2, columns: [t2.c, t2.d], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
          │ │ │ │   │       │   │ │ └─StreamHashJoin { type: Inner, predicate: t1.a = t3.e, output: [t1.a, t1.b, t3.f, t3._row_id] }
          │ │ │ │   │       │   │ │   ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │ │   │       │   │ │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │   │       │   │ │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │   │       │   │ │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │   │       │   │ │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │   │       │   │ │   └─StreamExchange { dist: HashShard(t3.e) }
          │ │ │ │   │       │   │ │     └─StreamTableScan { table: t3, columns: [t3.e, t3.f, t3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t3._row_id], pk: [_row_id], dist: UpstreamHashShard(t3._row_id) }
          │ │ │ │   │       │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t4.g, output: [t1.a, t1.b, t4.h, t4._row_id] }
          │ │ │ │   │       │   │   ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │ │   │       │   │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │   │       │   │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │   │       │   │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │   │       │   │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │   │       │   │   └─StreamExchange { dist: HashShard(t4.g) }
          │ │ │ │   │       │   │     └─StreamTableScan { table: t4, columns: [t4.g, t4.h, t4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t4._row_id], pk: [_row_id], dist: UpstreamHashShard(t4._row_id) }
          │ │ │ │   │       │   └─StreamHashJoin { type: Inner, predicate: t1.a = t5.i, output: [t1.a, t1.b, t5.j, t5._row_id] }
          │ │ │ │   │       │     ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │ │   │       │     │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │   │       │     │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │   │       │     │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │   │       │     │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │   │       │     └─StreamExchange { dist: HashShard(t5.i) }
          │ │ │ │   │       │       └─StreamTableScan { table: t5, columns: [t5.i, t5.j, t5._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t5._row_id], pk: [_row_id], dist: UpstreamHashShard(t5._row_id) }
          │ │ │ │   │       └─StreamHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k, t6._row_id] }
          │ │ │ │   │         ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │ │   │         │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │   │         │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │   │         │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │   │         │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │   │         └─StreamExchange { dist: HashShard(t6.l) }
          │ │ │ │   │           └─StreamTableScan { table: t6, columns: [t6.k, t6.l, t6._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t6._row_id], pk: [_row_id], dist: UpstreamHashShard(t6._row_id) }
          │ │ │ │   └─StreamProject { exprs: [t1.a, t1.b, sum(t2.d)] }
          │ │ │ │     └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d), count] }
          │ │ │ │       └─StreamHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t1.a, t1.b, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │ │ │ │         ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │ │         │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │         │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │         │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │         │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │         └─StreamHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │ │ │ │           ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │ │           │ └─StreamHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j, t3._row_id, t2.c, t4._row_id, t1.a, t1.b, t5._row_id] }
          │ │ │ │           │   ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t3._row_id, t1.a, t1.b, t4._row_id] }
          │ │ │ │           │   │ ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t1.a, t1.b, t3._row_id] }
          │ │ │ │           │   │ │ ├─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: all }
          │ │ │ │           │   │ │ │ ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │ │           │   │ │ │ │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │           │   │ │ │ │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │           │   │ │ │ │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │           │   │ │ │ │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │           │   │ │ │ └─StreamExchange { dist: HashShard(t2.c) }
          │ │ │ │           │   │ │ │   └─StreamTableScan { table: t2, columns: [t2.c, t2.d], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
          │ │ │ │           │   │ │ └─StreamHashJoin { type: Inner, predicate: t1.a = t3.e, output: [t1.a, t1.b, t3.f, t3._row_id] }
          │ │ │ │           │   │ │   ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │ │           │   │ │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │           │   │ │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │           │   │ │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │           │   │ │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │           │   │ │   └─StreamExchange { dist: HashShard(t3.e) }
          │ │ │ │           │   │ │     └─StreamTableScan { table: t3, columns: [t3.e, t3.f, t3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t3._row_id], pk: [_row_id], dist: UpstreamHashShard(t3._row_id) }
          │ │ │ │           │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t4.g, output: [t1.a, t1.b, t4.h, t4._row_id] }
          │ │ │ │           │   │   ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │ │           │   │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │           │   │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │           │   │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │           │   │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │           │   │   └─StreamExchange { dist: HashShard(t4.g) }
          │ │ │ │           │   │     └─StreamTableScan { table: t4, columns: [t4.g, t4.h, t4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t4._row_id], pk: [_row_id], dist: UpstreamHashShard(t4._row_id) }
          │ │ │ │           │   └─StreamHashJoin { type: Inner, predicate: t1.a = t5.i, output: [t1.a, t1.b, t5.j, t5._row_id] }
          │ │ │ │           │     ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │ │           │     │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │           │     │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │           │     │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │           │     │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │           │     └─StreamExchange { dist: HashShard(t5.i) }
          │ │ │ │           │       └─StreamTableScan { table: t5, columns: [t5.i, t5.j, t5._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t5._row_id], pk: [_row_id], dist: UpstreamHashShard(t5._row_id) }
          │ │ │ │           └─StreamHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k, t6._row_id] }
          │ │ │ │             ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │ │             │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │ │             │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │ │             │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │ │             │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │ │             └─StreamExchange { dist: HashShard(t6.l) }
          │ │ │ │               └─StreamTableScan { table: t6, columns: [t6.k, t6.l, t6._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t6._row_id], pk: [_row_id], dist: UpstreamHashShard(t6._row_id) }
          │ │ │ └─StreamProject { exprs: [t1.a, t1.b, sum(t2.d)] }
          │ │ │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d), count] }
          │ │ │     └─StreamHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t1.a, t1.b, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │ │ │       ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │       │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │       │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │       │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │       │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │       └─StreamHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │ │ │         ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │         │ └─StreamHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j, t3._row_id, t2.c, t4._row_id, t1.a, t1.b, t5._row_id] }
          │ │ │         │   ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t3._row_id, t1.a, t1.b, t4._row_id] }
          │ │ │         │   │ ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t1.a, t1.b, t3._row_id] }
          │ │ │         │   │ │ ├─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: all }
          │ │ │         │   │ │ │ ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │         │   │ │ │ │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │         │   │ │ │ │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │         │   │ │ │ │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │         │   │ │ │ │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │         │   │ │ │ └─StreamExchange { dist: HashShard(t2.c) }
          │ │ │         │   │ │ │   └─StreamTableScan { table: t2, columns: [t2.c, t2.d], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
          │ │ │         │   │ │ └─StreamHashJoin { type: Inner, predicate: t1.a = t3.e, output: [t1.a, t1.b, t3.f, t3._row_id] }
          │ │ │         │   │ │   ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │         │   │ │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │         │   │ │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │         │   │ │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │         │   │ │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │         │   │ │   └─StreamExchange { dist: HashShard(t3.e) }
          │ │ │         │   │ │     └─StreamTableScan { table: t3, columns: [t3.e, t3.f, t3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t3._row_id], pk: [_row_id], dist: UpstreamHashShard(t3._row_id) }
          │ │ │         │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t4.g, output: [t1.a, t1.b, t4.h, t4._row_id] }
          │ │ │         │   │   ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │         │   │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │         │   │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │         │   │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │         │   │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │         │   │   └─StreamExchange { dist: HashShard(t4.g) }
          │ │ │         │   │     └─StreamTableScan { table: t4, columns: [t4.g, t4.h, t4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t4._row_id], pk: [_row_id], dist: UpstreamHashShard(t4._row_id) }
          │ │ │         │   └─StreamHashJoin { type: Inner, predicate: t1.a = t5.i, output: [t1.a, t1.b, t5.j, t5._row_id] }
          │ │ │         │     ├─StreamExchange { dist: HashShard(t1.a) }
          │ │ │         │     │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │         │     │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │         │     │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │         │     │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │         │     └─StreamExchange { dist: HashShard(t5.i) }
          │ │ │         │       └─StreamTableScan { table: t5, columns: [t5.i, t5.j, t5._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t5._row_id], pk: [_row_id], dist: UpstreamHashShard(t5._row_id) }
          │ │ │         └─StreamHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k, t6._row_id] }
          │ │ │           ├─StreamExchange { dist: HashShard(t1.b) }
          │ │ │           │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │ │           │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │ │           │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │ │           │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │ │           └─StreamExchange { dist: HashShard(t6.l) }
          │ │ │             └─StreamTableScan { table: t6, columns: [t6.k, t6.l, t6._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t6._row_id], pk: [_row_id], dist: UpstreamHashShard(t6._row_id) }
          │ │ └─StreamProject { exprs: [t1.a, t1.b, sum(t2.d)] }
          │ │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d), count] }
          │ │     └─StreamHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t1.a, t1.b, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │ │       ├─StreamExchange { dist: HashShard(t1.b) }
          │ │       │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │       │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │       │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │       │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │       └─StreamHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │ │         ├─StreamExchange { dist: HashShard(t1.b) }
          │ │         │ └─StreamHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j, t3._row_id, t2.c, t4._row_id, t1.a, t1.b, t5._row_id] }
          │ │         │   ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t3._row_id, t1.a, t1.b, t4._row_id] }
          │ │         │   │ ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t1.a, t1.b, t3._row_id] }
          │ │         │   │ │ ├─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: all }
          │ │         │   │ │ │ ├─StreamExchange { dist: HashShard(t1.a) }
          │ │         │   │ │ │ │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │         │   │ │ │ │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │         │   │ │ │ │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │         │   │ │ │ │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │         │   │ │ │ └─StreamExchange { dist: HashShard(t2.c) }
          │ │         │   │ │ │   └─StreamTableScan { table: t2, columns: [t2.c, t2.d], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
          │ │         │   │ │ └─StreamHashJoin { type: Inner, predicate: t1.a = t3.e, output: [t1.a, t1.b, t3.f, t3._row_id] }
          │ │         │   │ │   ├─StreamExchange { dist: HashShard(t1.a) }
          │ │         │   │ │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │         │   │ │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │         │   │ │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │         │   │ │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │         │   │ │   └─StreamExchange { dist: HashShard(t3.e) }
          │ │         │   │ │     └─StreamTableScan { table: t3, columns: [t3.e, t3.f, t3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t3._row_id], pk: [_row_id], dist: UpstreamHashShard(t3._row_id) }
          │ │         │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t4.g, output: [t1.a, t1.b, t4.h, t4._row_id] }
          │ │         │   │   ├─StreamExchange { dist: HashShard(t1.a) }
          │ │         │   │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │         │   │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │         │   │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │         │   │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │         │   │   └─StreamExchange { dist: HashShard(t4.g) }
          │ │         │   │     └─StreamTableScan { table: t4, columns: [t4.g, t4.h, t4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t4._row_id], pk: [_row_id], dist: UpstreamHashShard(t4._row_id) }
          │ │         │   └─StreamHashJoin { type: Inner, predicate: t1.a = t5.i, output: [t1.a, t1.b, t5.j, t5._row_id] }
          │ │         │     ├─StreamExchange { dist: HashShard(t1.a) }
          │ │         │     │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │         │     │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │         │     │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │         │     │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │         │     └─StreamExchange { dist: HashShard(t5.i) }
          │ │         │       └─StreamTableScan { table: t5, columns: [t5.i, t5.j, t5._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t5._row_id], pk: [_row_id], dist: UpstreamHashShard(t5._row_id) }
          │ │         └─StreamHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k, t6._row_id] }
          │ │           ├─StreamExchange { dist: HashShard(t1.b) }
          │ │           │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │ │           │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │ │           │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │ │           │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │ │           └─StreamExchange { dist: HashShard(t6.l) }
          │ │             └─StreamTableScan { table: t6, columns: [t6.k, t6.l, t6._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t6._row_id], pk: [_row_id], dist: UpstreamHashShard(t6._row_id) }
          │ └─StreamProject { exprs: [t1.a, t1.b, sum(t2.d)] }
          │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d), count] }
          │     └─StreamHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t1.a, t1.b, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │       ├─StreamExchange { dist: HashShard(t1.b) }
          │       │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │       │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │       │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │       │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │       └─StreamHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
          │         ├─StreamExchange { dist: HashShard(t1.b) }
          │         │ └─StreamHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j, t3._row_id, t2.c, t4._row_id, t1.a, t1.b, t5._row_id] }
          │         │   ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t3._row_id, t1.a, t1.b, t4._row_id] }
          │         │   │ ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t1.a, t1.b, t3._row_id] }
          │         │   │ │ ├─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: all }
          │         │   │ │ │ ├─StreamExchange { dist: HashShard(t1.a) }
          │         │   │ │ │ │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │         │   │ │ │ │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │         │   │ │ │ │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │         │   │ │ │ │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │         │   │ │ │ └─StreamExchange { dist: HashShard(t2.c) }
          │         │   │ │ │   └─StreamTableScan { table: t2, columns: [t2.c, t2.d], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
          │         │   │ │ └─StreamHashJoin { type: Inner, predicate: t1.a = t3.e, output: [t1.a, t1.b, t3.f, t3._row_id] }
          │         │   │ │   ├─StreamExchange { dist: HashShard(t1.a) }
          │         │   │ │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │         │   │ │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │         │   │ │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │         │   │ │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │         │   │ │   └─StreamExchange { dist: HashShard(t3.e) }
          │         │   │ │     └─StreamTableScan { table: t3, columns: [t3.e, t3.f, t3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t3._row_id], pk: [_row_id], dist: UpstreamHashShard(t3._row_id) }
          │         │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t4.g, output: [t1.a, t1.b, t4.h, t4._row_id] }
          │         │   │   ├─StreamExchange { dist: HashShard(t1.a) }
          │         │   │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │         │   │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │         │   │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │         │   │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │         │   │   └─StreamExchange { dist: HashShard(t4.g) }
          │         │   │     └─StreamTableScan { table: t4, columns: [t4.g, t4.h, t4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t4._row_id], pk: [_row_id], dist: UpstreamHashShard(t4._row_id) }
          │         │   └─StreamHashJoin { type: Inner, predicate: t1.a = t5.i, output: [t1.a, t1.b, t5.j, t5._row_id] }
          │         │     ├─StreamExchange { dist: HashShard(t1.a) }
          │         │     │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │         │     │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │         │     │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │         │     │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │         │     └─StreamExchange { dist: HashShard(t5.i) }
          │         │       └─StreamTableScan { table: t5, columns: [t5.i, t5.j, t5._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t5._row_id], pk: [_row_id], dist: UpstreamHashShard(t5._row_id) }
          │         └─StreamHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k, t6._row_id] }
          │           ├─StreamExchange { dist: HashShard(t1.b) }
          │           │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
          │           │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
          │           │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
          │           │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
          │           └─StreamExchange { dist: HashShard(t6.l) }
          │             └─StreamTableScan { table: t6, columns: [t6.k, t6.l, t6._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t6._row_id], pk: [_row_id], dist: UpstreamHashShard(t6._row_id) }
          └─StreamProject { exprs: [t1.a, t1.b, sum(t2.d)] }
            └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [sum(t2.d), count] }
              └─StreamHashJoin { type: LeftOuter, predicate: t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t1.a, t1.b, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
                ├─StreamExchange { dist: HashShard(t1.b) }
                │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
                │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
                │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
                │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
                └─StreamHashJoin { type: LeftSemi, predicate: t5.j = t6.k AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t3._row_id, t2.c, t4._row_id, t5._row_id, t5.j] }
                  ├─StreamExchange { dist: HashShard(t1.b) }
                  │ └─StreamHashJoin { type: LeftOuter, predicate: t2.c = t5.j AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.d, t5.j, t3._row_id, t2.c, t4._row_id, t1.a, t1.b, t5._row_id] }
                  │   ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t4.h AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t3._row_id, t1.a, t1.b, t4._row_id] }
                  │   │ ├─StreamHashJoin { type: LeftOuter, predicate: t2.c = t3.f AND t1.a IS NOT DISTINCT FROM t1.a AND t1.b IS NOT DISTINCT FROM t1.b, output: [t1.a, t1.b, t2.c, t2.d, t1.a, t1.b, t3._row_id] }
                  │   │ │ ├─StreamHashJoin { type: Inner, predicate: t1.a = t2.c, output: all }
                  │   │ │ │ ├─StreamExchange { dist: HashShard(t1.a) }
                  │   │ │ │ │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
                  │   │ │ │ │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
                  │   │ │ │ │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
                  │   │ │ │ │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
                  │   │ │ │ └─StreamExchange { dist: HashShard(t2.c) }
                  │   │ │ │   └─StreamTableScan { table: t2, columns: [t2.c, t2.d], stream_scan_type: ArrangementBackfill, stream_key: [t2.c], pk: [c], dist: UpstreamHashShard(t2.c) }
                  │   │ │ └─StreamHashJoin { type: Inner, predicate: t1.a = t3.e, output: [t1.a, t1.b, t3.f, t3._row_id] }
                  │   │ │   ├─StreamExchange { dist: HashShard(t1.a) }
                  │   │ │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
                  │   │ │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
                  │   │ │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
                  │   │ │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
                  │   │ │   └─StreamExchange { dist: HashShard(t3.e) }
                  │   │ │     └─StreamTableScan { table: t3, columns: [t3.e, t3.f, t3._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t3._row_id], pk: [_row_id], dist: UpstreamHashShard(t3._row_id) }
                  │   │ └─StreamHashJoin { type: Inner, predicate: t1.a = t4.g, output: [t1.a, t1.b, t4.h, t4._row_id] }
                  │   │   ├─StreamExchange { dist: HashShard(t1.a) }
                  │   │   │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
                  │   │   │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
                  │   │   │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
                  │   │   │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
                  │   │   └─StreamExchange { dist: HashShard(t4.g) }
                  │   │     └─StreamTableScan { table: t4, columns: [t4.g, t4.h, t4._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t4._row_id], pk: [_row_id], dist: UpstreamHashShard(t4._row_id) }
                  │   └─StreamHashJoin { type: Inner, predicate: t1.a = t5.i, output: [t1.a, t1.b, t5.j, t5._row_id] }
                  │     ├─StreamExchange { dist: HashShard(t1.a) }
                  │     │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
                  │     │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
                  │     │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
                  │     │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
                  │     └─StreamExchange { dist: HashShard(t5.i) }
                  │       └─StreamTableScan { table: t5, columns: [t5.i, t5.j, t5._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t5._row_id], pk: [_row_id], dist: UpstreamHashShard(t5._row_id) }
                  └─StreamHashJoin { type: Inner, predicate: t1.b = t6.l, output: [t1.a, t1.b, t6.k, t6._row_id] }
                    ├─StreamExchange { dist: HashShard(t1.b) }
                    │ └─StreamProject { exprs: [t1.a, t1.b], noop_update_hint: true }
                    │   └─StreamHashAgg { group_key: [t1.a, t1.b], aggs: [count] }
                    │     └─StreamExchange { dist: HashShard(t1.a, t1.b) }
                    │       └─StreamTableScan { table: t1, columns: [t1.a, t1.b, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
                    └─StreamExchange { dist: HashShard(t6.l) }
                      └─StreamTableScan { table: t6, columns: [t6.k, t6.l, t6._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t6._row_id], pk: [_row_id], dist: UpstreamHashShard(t6._row_id) }
- name: improve join transpose rule to handle join with output indices
  sql: |
    with rawdata as (
      select 'first' as w, '{"x":{"value":123},"y":{"value":[1,2,3]},"z":{"value":[{"a":4,"b":5},{"a":6,"b":7}]}}'::jsonb as rawjson
      union all
      select 'second', '{"x":{"value":456},"y":{"value":[7,8,9]},"z":{"value":[{"a":0,"b":1},{"a":2,"b":3}]}}'::jsonb
    )
    select
      array(
        select
          array(
            select 1
            from jsonb_array_elements(
              case
                when jsonb_typeof(o.value->'value') = 'array' then o.value->'value'
                else '[]'::jsonb
              end
            ) with ordinality as x(v, i), jsonb_each (
              case
                when jsonb_typeof(v) = 'object' then v
                else '{}'::jsonb
              end
            ) as j
        )
        from jsonb_each(rawjson) AS o
        where jsonb_typeof(o.value) = 'object' and o.value ? 'value'
      ) as kv
    from rawdata
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom('{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, '{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb), output: [$expr6] }
    ├─LogicalValues { rows: [['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], ['{"x": {"value": 456}, "y": {"value": [7, 8, 9]}, "z": {"value": [{"a": 0, "b": 1}, {"a": 2, "b": 3}]}}':Jsonb]], schema: Schema { fields: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb:Jsonb] } }
    └─LogicalProject { exprs: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, Coalesce(array_agg($expr5) filter(IsNotNull(1:Int32)), ARRAY[]:List(List(Int32))) as $expr6] }
      └─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], aggs: [array_agg($expr5) filter(IsNotNull(1:Int32))] }
        └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom('{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, '{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb), output: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr5, 1:Int32] }
          ├─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], aggs: [] }
          │ └─LogicalValues { rows: [['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], ['{"x": {"value": 456}, "y": {"value": [7, 8, 9]}, "z": {"value": [{"a": 0, "b": 1}, {"a": 2, "b": 3}]}}':Jsonb]], schema: Schema { fields: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb:Jsonb] } }
          └─LogicalProject { exprs: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr5, 1:Int32] }
            └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom($expr1, $expr2) AND IsNotDistinctFrom('{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, '{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb), output: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr5] }
              ├─LogicalProject { exprs: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, Field(JsonbEach($0), 1:Int32) as $expr1] }
              │ └─LogicalFilter { predicate: (JsonbTypeof(Field(JsonbEach($0), 1:Int32)) = 'object':Varchar) AND JsonbExists(Field(JsonbEach($0), 1:Int32), 'value':Varchar) }
              │   └─LogicalProjectSet { select_list: [$0, JsonbEach($0)] }
              │     └─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], aggs: [] }
              │       └─LogicalValues { rows: [['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], ['{"x": {"value": 456}, "y": {"value": [7, 8, 9]}, "z": {"value": [{"a": 0, "b": 1}, {"a": 2, "b": 3}]}}':Jsonb]], schema: Schema { fields: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb:Jsonb] } }
              └─LogicalProject { exprs: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr2, Coalesce(array_agg(1:Int32) filter(IsNotNull(1:Int32)), ARRAY[]:List(Int32)) as $expr5] }
                └─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr2], aggs: [array_agg(1:Int32) filter(IsNotNull(1:Int32))] }
                  └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom($expr2, $expr3) AND IsNotDistinctFrom('{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, '{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb), output: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr2, 1:Int32, 1:Int32] }
                    ├─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr2], aggs: [] }
                    │ └─LogicalProject { exprs: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, Field(JsonbEach($0), 1:Int32) as $expr2] }
                    │   └─LogicalFilter { predicate: (JsonbTypeof(Field(JsonbEach($0), 1:Int32)) = 'object':Varchar) AND JsonbExists(Field(JsonbEach($0), 1:Int32), 'value':Varchar) }
                    │     └─LogicalProjectSet { select_list: [$0, JsonbEach($0)] }
                    │       └─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], aggs: [] }
                    │         └─LogicalValues { rows: [['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], ['{"x": {"value": 456}, "y": {"value": [7, 8, 9]}, "z": {"value": [{"a": 0, "b": 1}, {"a": 2, "b": 3}]}}':Jsonb]], schema: Schema { fields: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb:Jsonb] } }
                    └─LogicalProject { exprs: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr3, 1:Int32, 1:Int32] }
                      └─LogicalJoin { type: Inner, on: IsNotDistinctFrom(JsonbArrayElements(Case((JsonbTypeof(JsonbAccess($1, 'value':Varchar)) = 'array':Varchar), JsonbAccess($1, 'value':Varchar), '[]':Jsonb)), JsonbArrayElements(Case((JsonbTypeof(JsonbAccess($1, 'value':Varchar)) = 'array':Varchar), JsonbAccess($1, 'value':Varchar), '[]':Jsonb))) AND IsNotDistinctFrom($expr3, $expr4) AND IsNotDistinctFrom('{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, '{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb), output: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr3] }
                        ├─LogicalProjectSet { select_list: [$0, $1, JsonbArrayElements(Case((JsonbTypeof(JsonbAccess($1, 'value':Varchar)) = 'array':Varchar), JsonbAccess($1, 'value':Varchar), '[]':Jsonb))] }
                        │ └─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr3], aggs: [] }
                        │   └─LogicalProject { exprs: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, Field(JsonbEach($0), 1:Int32) as $expr3] }
                        │     └─LogicalFilter { predicate: (JsonbTypeof(Field(JsonbEach($0), 1:Int32)) = 'object':Varchar) AND JsonbExists(Field(JsonbEach($0), 1:Int32), 'value':Varchar) }
                        │       └─LogicalProjectSet { select_list: [$0, JsonbEach($0)] }
                        │         └─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], aggs: [] }
                        │           └─LogicalValues { rows: [['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], ['{"x": {"value": 456}, "y": {"value": [7, 8, 9]}, "z": {"value": [{"a": 0, "b": 1}, {"a": 2, "b": 3}]}}':Jsonb]], schema: Schema { fields: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb:Jsonb] } }
                        └─LogicalProjectSet { select_list: [$0, $1, $2, JsonbEach(Case((JsonbTypeof($2) = 'object':Varchar), $2, '{}':Jsonb))] }
                          └─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr4, JsonbArrayElements(Case((JsonbTypeof(JsonbAccess($1, 'value':Varchar)) = 'array':Varchar), JsonbAccess($1, 'value':Varchar), '[]':Jsonb))], aggs: [] }
                            └─LogicalProjectSet { select_list: [$0, $1, JsonbArrayElements(Case((JsonbTypeof(JsonbAccess($1, 'value':Varchar)) = 'array':Varchar), JsonbAccess($1, 'value':Varchar), '[]':Jsonb))] }
                              └─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, $expr4], aggs: [] }
                                └─LogicalProject { exprs: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb, Field(JsonbEach($0), 1:Int32) as $expr4] }
                                  └─LogicalFilter { predicate: (JsonbTypeof(Field(JsonbEach($0), 1:Int32)) = 'object':Varchar) AND JsonbExists(Field(JsonbEach($0), 1:Int32), 'value':Varchar) }
                                    └─LogicalProjectSet { select_list: [$0, JsonbEach($0)] }
                                      └─LogicalAgg { group_key: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], aggs: [] }
                                        └─LogicalValues { rows: [['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb], ['{"x": {"value": 456}, "y": {"value": [7, 8, 9]}, "z": {"value": [{"a": 0, "b": 1}, {"a": 2, "b": 3}]}}':Jsonb]], schema: Schema { fields: ['{"x": {"value": 123}, "y": {"value": [1, 2, 3]}, "z": {"value": [{"a": 4, "b": 5}, {"a": 6, "b": 7}]}}':Jsonb:Jsonb] } }
- name: subquery with CTE
  sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where t1.x = ( with cte as (select * from t2 where t2.y = t1.y)  select x from cte limit 1);
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t1.y IS NOT DISTINCT FROM t2.y AND t1.x = t2.x, output: [t1.x, t1.y] }
      ├─BatchExchange { order: [], dist: HashShard(t1.y) }
      │ └─BatchScan { table: t1, columns: [t1.x, t1.y], distribution: SomeShard }
      └─BatchGroupTopN { order: [t2.y ASC], limit: 1, offset: 0, group_key: [t2.y] }
        └─BatchExchange { order: [], dist: HashShard(t2.y) }
          └─BatchProject { exprs: [t2.y, t2.x] }
            └─BatchFilter { predicate: IsNotNull(t2.y) }
              └─BatchScan { table: t2, columns: [t2.x, t2.y], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t1._row_id(hidden), t2.y(hidden)], stream_key: [t1._row_id, y, x], pk_columns: [t1._row_id, y, x], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t1.x, t1.y, t1._row_id) }
      └─StreamHashJoin { type: Inner, predicate: t1.y IS NOT DISTINCT FROM t2.y AND t1.x = t2.x, output: [t1.x, t1.y, t1._row_id, t2.y] }
        ├─StreamExchange { dist: HashShard(t1.y) }
        │ └─StreamTableScan { table: t1, columns: [t1.x, t1.y, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamGroupTopN { order: [t2.y ASC], limit: 1, offset: 0, group_key: [t2.y] }
          └─StreamExchange { dist: HashShard(t2.y) }
            └─StreamProject { exprs: [t2.y, t2.x, t2._row_id] }
              └─StreamFilter { predicate: IsNotNull(t2.y) }
                └─StreamTableScan { table: t2, columns: [t2.x, t2.y, t2._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t2._row_id], pk: [_row_id], dist: UpstreamHashShard(t2._row_id) }
- name: subqueries in case when exprs
  sql: "WITH input AS (\n    SELECT\n        'Empty JSON item' AS test_case,\n        ('{}'::JSONB) AS item\n)\n\nSELECT\n    test_case,\n\n    CASE\n\t    WHEN JSONB_PATH_QUERY_FIRST(JSONB_PATH_QUERY_FIRST(item, '$.binary_set_attribute'), '$.BS') IS NULL THEN NULL\n        ELSE ARRAY(\n            SELECT parsed_item\n            FROM (\n                SELECT DECODE(((nested_item) #>> '{}'), 'base64') AS parsed_item\n                FROM (\n                    SELECT nested_item\n                    FROM JSONB_ARRAY_ELEMENTS(JSONB_PATH_QUERY_FIRST((JSONB_PATH_QUERY_FIRST(item, '$.binary_set_attribute')), '$.BS'))\n                    AS t(nested_item)\n                )\n            )\n            ORDER BY parsed_item\n        )\n    END AS binary_set_attribute,\n\n    CASE\n        WHEN JSONB_PATH_QUERY_FIRST(JSONB_PATH_QUERY_FIRST(item, '$.number_set_attribute'), '$.NS') IS NULL THEN NULL\n        ELSE ARRAY(\n            SELECT parsed_item\n            FROM (\n                SELECT CAST(nested_item #>> '{}' AS BIGINT) AS parsed_item\n                FROM (\n    \t\t\t\tSELECT nested_item\n    \t\t\t\tFROM JSONB_ARRAY_ELEMENTS(JSONB_PATH_QUERY_FIRST((JSONB_PATH_QUERY_FIRST(item, '$.number_set_attribute')), '$.NS'))\n    \t\t\t\tAS t(nested_item)\n\t\t\t\t)\n            )\n            ORDER BY parsed_item\n        )\n    END AS number_set_attribute,\n\n    CASE\n\t    WHEN JSONB_PATH_QUERY_FIRST((JSONB_PATH_QUERY_FIRST(item, '$.float_set_attribute')), '$.NS') IS NULL THEN NULL\n        ELSE ARRAY(\n            SELECT parsed_item\n            FROM (\n                SELECT CAST(nested_item #>> '{}' AS FLOAT)\n                AS parsed_item\n                FROM (\n    \t\t\t\tSELECT nested_item\n\t\t\t\t    FROM JSONB_ARRAY_ELEMENTS(JSONB_PATH_QUERY_FIRST((JSONB_PATH_QUERY_FIRST(item, '$.float_set_attribute')), '$.NS'))\n    \t\t\t\tAS t(nested_item)\n\t\t\t\t)\n            )\n            ORDER BY parsed_item\n        )\n    END AS float_set_attribute,\n\n    CASE\n\t    WHEN JSONB_PATH_QUERY_FIRST((JSONB_PATH_QUERY_FIRST(item, '$.string_set_attribute')), '$.SS') IS NULL THEN NULL\n        ELSE ARRAY(\n            SELECT parsed_item\n            FROM (\n                SELECT nested_item #>> '{}' AS parsed_item\n                FROM (\n    \t\t\t\tSELECT nested_item\n    \t\t\t\tFROM JSONB_ARRAY_ELEMENTS(JSONB_PATH_QUERY_FIRST((JSONB_PATH_QUERY_FIRST(item, '$.string_set_attribute')), '$.SS'))\n    \t\t\t\tAS t(nested_item)\n\t\t\t\t)\n            )\n            ORDER BY parsed_item\n        )\n    END AS string_set_attribute\nFROM input\n"
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: ['Empty JSON item':Varchar, Case(IsNull(JsonbPathQueryFirst(JsonbPathQueryFirst('{}':Jsonb, '$.binary_set_attribute':Varchar), '$.BS':Varchar)), null:List(Bytea), $expr5) as $expr9, Case(IsNull(JsonbPathQueryFirst(JsonbPathQueryFirst('{}':Jsonb, '$.number_set_attribute':Varchar), '$.NS':Varchar)), null:List(Int64), $expr6) as $expr10, Case(IsNull(JsonbPathQueryFirst(JsonbPathQueryFirst('{}':Jsonb, '$.float_set_attribute':Varchar), '$.NS':Varchar)), null:List(Float64), $expr7) as $expr11, Case(IsNull(JsonbPathQueryFirst(JsonbPathQueryFirst('{}':Jsonb, '$.string_set_attribute':Varchar), '$.SS':Varchar)), null:List(Varchar), $expr8) as $expr12] }
      └─BatchHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['Empty JSON item':Varchar, '{}':Jsonb, $expr5, $expr6, $expr7, $expr8] }
        ├─BatchExchange { order: [], dist: HashShard('{}':Jsonb) }
        │ └─BatchValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb]] }
        └─BatchProject { exprs: ['{}':Jsonb, Coalesce(array_agg($expr1 order_by($expr1 ASC)) filter(IsNotNull(1:Int32)), ARRAY[]:List(Bytea)) as $expr5, Coalesce(array_agg($expr2 order_by($expr2 ASC)) filter(IsNotNull(1:Int32)), ARRAY[]:List(Int64)) as $expr6, Coalesce(array_agg($expr3 order_by($expr3 ASC)) filter(IsNotNull(1:Int32)), ARRAY[]:List(Float64)) as $expr7, Coalesce(array_agg($expr4 order_by($expr4 ASC)) filter(IsNotNull(1:Int32)), ARRAY[]:List(Varchar)) as $expr8] }
          └─BatchHashJoin { type: Inner, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: all }
            ├─BatchHashJoin { type: Inner, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: all }
            │ ├─BatchHashJoin { type: Inner, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: all }
            │ │ ├─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [array_agg($expr1 order_by($expr1 ASC)) filter(IsNotNull(1:Int32))] }
            │ │ │ └─BatchHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['{}':Jsonb, $expr1, 1:Int32] }
            │ │ │   ├─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [] }
            │ │ │   │ └─BatchExchange { order: [], dist: HashShard('{}':Jsonb) }
            │ │ │   │   └─BatchValues { rows: [['{}':Jsonb]] }
            │ │ │   └─BatchProject { exprs: ['{}':Jsonb, Decode(JsonbExtractPathTextVariadic(JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.binary_set_attribute':Varchar), '$.BS':Varchar)), ARRAY[]:List(Varchar)), 'base64':Varchar) as $expr1, 1:Int32] }
            │ │ │     └─BatchProjectSet { select_list: [$0, JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.binary_set_attribute':Varchar), '$.BS':Varchar))] }
            │ │ │       └─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [] }
            │ │ │         └─BatchExchange { order: [], dist: HashShard('{}':Jsonb) }
            │ │ │           └─BatchValues { rows: [['{}':Jsonb]] }
            │ │ └─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [array_agg($expr2 order_by($expr2 ASC)) filter(IsNotNull(1:Int32))] }
            │ │   └─BatchHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['{}':Jsonb, $expr2, 1:Int32] }
            │ │     ├─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [] }
            │ │     │ └─BatchExchange { order: [], dist: HashShard('{}':Jsonb) }
            │ │     │   └─BatchValues { rows: [['{}':Jsonb]] }
            │ │     └─BatchProject { exprs: ['{}':Jsonb, JsonbExtractPathTextVariadic(JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.number_set_attribute':Varchar), '$.NS':Varchar)), ARRAY[]:List(Varchar))::Int64 as $expr2, 1:Int32] }
            │ │       └─BatchProjectSet { select_list: [$0, JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.number_set_attribute':Varchar), '$.NS':Varchar))] }
            │ │         └─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [] }
            │ │           └─BatchExchange { order: [], dist: HashShard('{}':Jsonb) }
            │ │             └─BatchValues { rows: [['{}':Jsonb]] }
            │ └─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [array_agg($expr3 order_by($expr3 ASC)) filter(IsNotNull(1:Int32))] }
            │   └─BatchHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['{}':Jsonb, $expr3, 1:Int32] }
            │     ├─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [] }
            │     │ └─BatchExchange { order: [], dist: HashShard('{}':Jsonb) }
            │     │   └─BatchValues { rows: [['{}':Jsonb]] }
            │     └─BatchProject { exprs: ['{}':Jsonb, JsonbExtractPathTextVariadic(JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.float_set_attribute':Varchar), '$.NS':Varchar)), ARRAY[]:List(Varchar))::Float64 as $expr3, 1:Int32] }
            │       └─BatchProjectSet { select_list: [$0, JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.float_set_attribute':Varchar), '$.NS':Varchar))] }
            │         └─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [] }
            │           └─BatchExchange { order: [], dist: HashShard('{}':Jsonb) }
            │             └─BatchValues { rows: [['{}':Jsonb]] }
            └─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [array_agg($expr4 order_by($expr4 ASC)) filter(IsNotNull(1:Int32))] }
              └─BatchHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['{}':Jsonb, $expr4, 1:Int32] }
                ├─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [] }
                │ └─BatchExchange { order: [], dist: HashShard('{}':Jsonb) }
                │   └─BatchValues { rows: [['{}':Jsonb]] }
                └─BatchProject { exprs: ['{}':Jsonb, JsonbExtractPathTextVariadic(JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.string_set_attribute':Varchar), '$.SS':Varchar)), ARRAY[]:List(Varchar)) as $expr4, 1:Int32] }
                  └─BatchProjectSet { select_list: [$0, JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.string_set_attribute':Varchar), '$.SS':Varchar))] }
                    └─BatchHashAgg { group_key: ['{}':Jsonb], aggs: [] }
                      └─BatchExchange { order: [], dist: HashShard('{}':Jsonb) }
                        └─BatchValues { rows: [['{}':Jsonb]] }
  stream_plan: |-
    StreamMaterialize { columns: [test_case, binary_set_attribute, number_set_attribute, float_set_attribute, string_set_attribute, _row_id(hidden), '{}':Jsonb(hidden), '{}':Jsonb#1(hidden)], stream_key: [_row_id, '{}':Jsonb, '{}':Jsonb#1], pk_columns: [_row_id, '{}':Jsonb, '{}':Jsonb#1], pk_conflict: NoCheck }
    └─StreamProject { exprs: ['Empty JSON item':Varchar, Case(IsNull(JsonbPathQueryFirst(JsonbPathQueryFirst('{}':Jsonb, '$.binary_set_attribute':Varchar), '$.BS':Varchar)), null:List(Bytea), $expr5) as $expr9, Case(IsNull(JsonbPathQueryFirst(JsonbPathQueryFirst('{}':Jsonb, '$.number_set_attribute':Varchar), '$.NS':Varchar)), null:List(Int64), $expr6) as $expr10, Case(IsNull(JsonbPathQueryFirst(JsonbPathQueryFirst('{}':Jsonb, '$.float_set_attribute':Varchar), '$.NS':Varchar)), null:List(Float64), $expr7) as $expr11, Case(IsNull(JsonbPathQueryFirst(JsonbPathQueryFirst('{}':Jsonb, '$.string_set_attribute':Varchar), '$.SS':Varchar)), null:List(Varchar), $expr8) as $expr12, _row_id, '{}':Jsonb, '{}':Jsonb] }
      └─StreamHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['Empty JSON item':Varchar, '{}':Jsonb, $expr5, $expr6, $expr7, $expr8, _row_id, '{}':Jsonb, '{}':Jsonb] }
        ├─StreamExchange { dist: HashShard('{}':Jsonb) }
        │ └─StreamShare { id: 1 }
        │   └─StreamValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb, 0:Int64]] }
        └─StreamProject { exprs: ['{}':Jsonb, Coalesce(array_agg($expr2 order_by($expr2 ASC)) filter(IsNotNull(1:Int32)), ARRAY[]:List(Bytea)) as $expr5, Coalesce(array_agg($expr3 order_by($expr3 ASC)) filter(IsNotNull(1:Int32)), ARRAY[]:List(Int64)) as $expr6, Coalesce(array_agg($expr4 order_by($expr4 ASC)) filter(IsNotNull(1:Int32)), ARRAY[]:List(Float64)) as $expr7, Coalesce(array_agg($expr1 order_by($expr1 ASC)) filter(IsNotNull(1:Int32)), ARRAY[]:List(Varchar)) as $expr8, '{}':Jsonb] }
          └─StreamHashJoin { type: Inner, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['{}':Jsonb, array_agg($expr2 order_by($expr2 ASC)) filter(IsNotNull(1:Int32)), array_agg($expr3 order_by($expr3 ASC)) filter(IsNotNull(1:Int32)), array_agg($expr4 order_by($expr4 ASC)) filter(IsNotNull(1:Int32)), array_agg($expr1 order_by($expr1 ASC)) filter(IsNotNull(1:Int32)), '{}':Jsonb, '{}':Jsonb] }
            ├─StreamHashJoin { type: Inner, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: [array_agg($expr1 order_by($expr1 ASC)) filter(IsNotNull(1:Int32)), '{}':Jsonb, array_agg($expr2 order_by($expr2 ASC)) filter(IsNotNull(1:Int32)), array_agg($expr3 order_by($expr3 ASC)) filter(IsNotNull(1:Int32)), '{}':Jsonb, '{}':Jsonb] }
            │ ├─StreamExchange { dist: HashShard('{}':Jsonb) }
            │ │ └─StreamHashJoin { type: Inner, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: [array_agg($expr1 order_by($expr1 ASC)) filter(IsNotNull(1:Int32)), '{}':Jsonb, array_agg($expr2 order_by($expr2 ASC)) filter(IsNotNull(1:Int32)), '{}':Jsonb] }
            │ │   ├─StreamProject { exprs: ['{}':Jsonb, array_agg($expr1 order_by($expr1 ASC)) filter(IsNotNull(1:Int32))] }
            │ │   │ └─StreamHashAgg { group_key: ['{}':Jsonb], aggs: [array_agg($expr1 order_by($expr1 ASC)) filter(IsNotNull(1:Int32)), count] }
            │ │   │   └─StreamHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['{}':Jsonb, $expr1, 1:Int32, '{}':Jsonb, projected_row_id] }
            │ │   │     ├─StreamAppendOnlyDedup { dedup_cols: ['{}':Jsonb] }
            │ │   │     │ └─StreamExchange { dist: HashShard('{}':Jsonb) }
            │ │   │     │   └─StreamProject { exprs: ['{}':Jsonb] }
            │ │   │     │     └─StreamShare { id: 1 }
            │ │   │     │       └─StreamValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb, 0:Int64]] }
            │ │   │     └─StreamProject { exprs: ['{}':Jsonb, JsonbExtractPathTextVariadic(JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.string_set_attribute':Varchar), '$.SS':Varchar)), ARRAY[]:List(Varchar)) as $expr1, 1:Int32, projected_row_id], noop_update_hint: true }
            │ │   │       └─StreamProjectSet { select_list: [$0, JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.string_set_attribute':Varchar), '$.SS':Varchar))] }
            │ │   │         └─StreamAppendOnlyDedup { dedup_cols: ['{}':Jsonb] }
            │ │   │           └─StreamExchange { dist: HashShard('{}':Jsonb) }
            │ │   │             └─StreamProject { exprs: ['{}':Jsonb] }
            │ │   │               └─StreamShare { id: 1 }
            │ │   │                 └─StreamValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb, 0:Int64]] }
            │ │   └─StreamProject { exprs: ['{}':Jsonb, array_agg($expr2 order_by($expr2 ASC)) filter(IsNotNull(1:Int32))] }
            │ │     └─StreamHashAgg { group_key: ['{}':Jsonb], aggs: [array_agg($expr2 order_by($expr2 ASC)) filter(IsNotNull(1:Int32)), count] }
            │ │       └─StreamHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['{}':Jsonb, $expr2, 1:Int32, '{}':Jsonb, projected_row_id] }
            │ │         ├─StreamAppendOnlyDedup { dedup_cols: ['{}':Jsonb] }
            │ │         │ └─StreamExchange { dist: HashShard('{}':Jsonb) }
            │ │         │   └─StreamProject { exprs: ['{}':Jsonb] }
            │ │         │     └─StreamShare { id: 1 }
            │ │         │       └─StreamValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb, 0:Int64]] }
            │ │         └─StreamProject { exprs: ['{}':Jsonb, Decode(JsonbExtractPathTextVariadic(JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.binary_set_attribute':Varchar), '$.BS':Varchar)), ARRAY[]:List(Varchar)), 'base64':Varchar) as $expr2, 1:Int32, projected_row_id] }
            │ │           └─StreamProjectSet { select_list: [$0, JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.binary_set_attribute':Varchar), '$.BS':Varchar))] }
            │ │             └─StreamAppendOnlyDedup { dedup_cols: ['{}':Jsonb] }
            │ │               └─StreamExchange { dist: HashShard('{}':Jsonb) }
            │ │                 └─StreamProject { exprs: ['{}':Jsonb] }
            │ │                   └─StreamShare { id: 1 }
            │ │                     └─StreamValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb, 0:Int64]] }
            │ └─StreamProject { exprs: ['{}':Jsonb, array_agg($expr3 order_by($expr3 ASC)) filter(IsNotNull(1:Int32))] }
            │   └─StreamHashAgg { group_key: ['{}':Jsonb], aggs: [array_agg($expr3 order_by($expr3 ASC)) filter(IsNotNull(1:Int32)), count] }
            │     └─StreamHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['{}':Jsonb, $expr3, 1:Int32, '{}':Jsonb, projected_row_id] }
            │       ├─StreamAppendOnlyDedup { dedup_cols: ['{}':Jsonb] }
            │       │ └─StreamExchange { dist: HashShard('{}':Jsonb) }
            │       │   └─StreamProject { exprs: ['{}':Jsonb] }
            │       │     └─StreamShare { id: 1 }
            │       │       └─StreamValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb, 0:Int64]] }
            │       └─StreamProject { exprs: ['{}':Jsonb, JsonbExtractPathTextVariadic(JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.number_set_attribute':Varchar), '$.NS':Varchar)), ARRAY[]:List(Varchar))::Int64 as $expr3, 1:Int32, projected_row_id] }
            │         └─StreamProjectSet { select_list: [$0, JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.number_set_attribute':Varchar), '$.NS':Varchar))] }
            │           └─StreamAppendOnlyDedup { dedup_cols: ['{}':Jsonb] }
            │             └─StreamExchange { dist: HashShard('{}':Jsonb) }
            │               └─StreamProject { exprs: ['{}':Jsonb] }
            │                 └─StreamShare { id: 1 }
            │                   └─StreamValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb, 0:Int64]] }
            └─StreamProject { exprs: ['{}':Jsonb, array_agg($expr4 order_by($expr4 ASC)) filter(IsNotNull(1:Int32))] }
              └─StreamHashAgg { group_key: ['{}':Jsonb], aggs: [array_agg($expr4 order_by($expr4 ASC)) filter(IsNotNull(1:Int32)), count] }
                └─StreamHashJoin { type: LeftOuter, predicate: '{}':Jsonb IS NOT DISTINCT FROM '{}':Jsonb, output: ['{}':Jsonb, $expr4, 1:Int32, '{}':Jsonb, projected_row_id] }
                  ├─StreamAppendOnlyDedup { dedup_cols: ['{}':Jsonb] }
                  │ └─StreamExchange { dist: HashShard('{}':Jsonb) }
                  │   └─StreamProject { exprs: ['{}':Jsonb] }
                  │     └─StreamShare { id: 1 }
                  │       └─StreamValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb, 0:Int64]] }
                  └─StreamProject { exprs: ['{}':Jsonb, JsonbExtractPathTextVariadic(JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.float_set_attribute':Varchar), '$.NS':Varchar)), ARRAY[]:List(Varchar))::Float64 as $expr4, 1:Int32, projected_row_id] }
                    └─StreamProjectSet { select_list: [$0, JsonbArrayElements(JsonbPathQueryFirst(JsonbPathQueryFirst($0, '$.float_set_attribute':Varchar), '$.NS':Varchar))] }
                      └─StreamAppendOnlyDedup { dedup_cols: ['{}':Jsonb] }
                        └─StreamExchange { dist: HashShard('{}':Jsonb) }
                          └─StreamProject { exprs: ['{}':Jsonb] }
                            └─StreamShare { id: 1 }
                              └─StreamValues { rows: [['Empty JSON item':Varchar, '{}':Jsonb, 0:Int64]] }
