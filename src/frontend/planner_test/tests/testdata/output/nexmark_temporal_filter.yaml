# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_sources
  sql: |
    CREATE SOURCE nexmark (
      event_type BIGINT,
      person STRUCT<"id" BIGINT,
                    "name" VARCHAR,
                    "email_address" VARCHAR,
                    "credit_card" VARCHAR,
                    "city" VARCHAR,
                    "state" VARCHAR,
                    "date_time" TIMESTAMP,
                    "extra" VARCHAR>,
      auction STRUCT<"id" BIGINT,
                     "item_name" VARCHAR,
                     "description" VARCHAR,
                     "initial_bid" BIGINT,
                     "reserve" BIGINT,
                     "date_time" TIMESTAMP,
                     "expires" TIMESTAMP,
                     "seller" BIGINT,
                     "category" BIGINT,
                     "extra" VARCHAR>,
      bid STRUCT<"auction" BIGINT,
                 "bidder" BIGINT,
                 "price" BIGINT,
                 "channel" VARCHAR,
                 "url" VARCHAR,
                 "date_time" TIMESTAMP,
                 "extra" VARCHAR>,
      p_time TIMESTAMPTZ as proctime(),
    ) WITH (
      connector = 'nexmark',
      nexmark.split.num = '2',
      nexmark.min.event.gap.in.ns = '100'
    );

    CREATE VIEW PERSON as select (person).* from nexmark where event_type = 0;
    CREATE VIEW AUCTION as select (auction).* from nexmark where event_type = 1;
    CREATE VIEW BID as select (bid).*, p_time from nexmark where event_type = 2
      AND now() - interval '5' minute < p_time;
- id: nexmark_q0
  before:
  - create_sources
  sql: |
    SELECT auction, bidder, price, date_time FROM bid;
  stream_plan: |-
    StreamMaterialize { columns: [auction, bidder, price, date_time, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 5:Int32) as $expr6, _row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├─StreamFilter { predicate: (event_type = 2:Int32) }
        │ └─StreamRowIdGen { row_id_index: 5 }
        │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
            └─StreamNow { output: [now] }
- id: nexmark_q1
  before:
  - create_sources
  sql: |
    SELECT
      auction,
      bidder,
      0.908 * price as price,
      date_time
    FROM bid;
  stream_plan: |-
    StreamMaterialize { columns: [auction, bidder, price, date_time, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, (0.908:Decimal * Field(bid, 2:Int32)::Decimal) as $expr5, Field(bid, 5:Int32) as $expr6, _row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├─StreamFilter { predicate: (event_type = 2:Int32) }
        │ └─StreamRowIdGen { row_id_index: 5 }
        │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
            └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, bidder, price, date_time, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └── StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, (0.908:Decimal * Field(bid, 2:Int32)::Decimal) as $expr5, Field(bid, 5:Int32) as $expr6, _row_id] }
        └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
            ├── tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ]
            ├── StreamFilter { predicate: (event_type = 2:Int32) }
            │   └── StreamRowIdGen { row_id_index: 5 }
            │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
            │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 2 ] }
            └── StreamExchange Broadcast from 1

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 3 ] }

    Table 0
    ├── columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ]
    ├── primary key: [ $4 ASC, $5 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5 ]
    ├── distribution key: [ 5 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 3 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ auction, bidder, price, date_time, _row_id, _rw_timestamp ]
    ├── primary key: [ $4 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 4 ]
    └── read pk prefix len hint: 1

- id: nexmark_q2
  before:
  - create_sources
  sql: SELECT auction, price FROM bid WHERE auction = 1007 OR auction = 1020 OR auction = 2001 OR auction = 2019 OR auction = 2087;
  stream_plan: |-
    StreamMaterialize { columns: [auction, price, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 2:Int32) as $expr4, _row_id] }
      └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├─StreamFilter { predicate: ((((Field(bid, 0:Int32) = 1007:Int32) OR (Field(bid, 0:Int32) = 1020:Int32)) OR ((Field(bid, 0:Int32) = 2001:Int32) OR (Field(bid, 0:Int32) = 2019:Int32))) OR (Field(bid, 0:Int32) = 2087:Int32)) AND (event_type = 2:Int32) }
        │ └─StreamRowIdGen { row_id_index: 5 }
        │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
            └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, price, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └── StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 2:Int32) as $expr4, _row_id] }
        └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ] }
            ├── StreamFilter { predicate: ((((Field(bid, 0:Int32) = 1007:Int32) OR (Field(bid, 0:Int32) = 1020:Int32)) OR ((Field(bid, 0:Int32) = 2001:Int32) OR (Field(bid, 0:Int32) = 2019:Int32))) OR (Field(bid, 0:Int32) = 2087:Int32)) AND (event_type = 2:Int32) }
            │   └── StreamRowIdGen { row_id_index: 5 }
            │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
            │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 2 ] }
            └── StreamExchange Broadcast from 1

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 3 ] }

    Table 0 { columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 3 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ auction, price, _row_id, _rw_timestamp ], primary key: [ $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

- id: nexmark_q4
  before:
  - create_sources
  sql: |
    SELECT
        Q.category,
        AVG(Q.final) as avg
    FROM (
        SELECT MAX(B.price) AS final, A.category
        FROM auction A, bid B
        WHERE A.id = B.auction AND B.date_time BETWEEN A.date_time AND A.expires
        GROUP BY A.id, A.category
    ) Q
    GROUP BY Q.category;
  stream_plan: |-
    StreamMaterialize { columns: [category, avg], stream_key: [category], pk_columns: [category], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr5, (sum(max($expr8)) / count(max($expr8))::Decimal) as $expr10] }
      └─StreamHashAgg { group_key: [$expr5], aggs: [sum(max($expr8)), count(max($expr8)), count] }
        └─StreamExchange { dist: HashShard($expr5) }
          └─StreamProject { exprs: [$expr2, $expr5, max($expr8)] }
            └─StreamHashAgg { group_key: [$expr2, $expr5], aggs: [max($expr8), count] }
              └─StreamProject { exprs: [$expr2, $expr5, $expr8, _row_id, _row_id] }
                └─StreamFilter { predicate: ($expr9 >= $expr3) AND ($expr9 <= $expr4) }
                  └─StreamHashJoin { type: Inner, predicate: $expr2 = $expr7, output: all }
                    ├─StreamExchange { dist: HashShard($expr2) }
                    │ └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 5:Int32) as $expr3, Field(auction, 6:Int32) as $expr4, Field(auction, 8:Int32) as $expr5, _row_id] }
                    │   └─StreamFilter { predicate: (event_type = 1:Int32) }
                    │     └─StreamShare { id: 5 }
                    │       └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                    │         └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                    │           └─StreamRowIdGen { row_id_index: 5 }
                    │             └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                    │               └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                    └─StreamExchange { dist: HashShard($expr7) }
                      └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr7, Field(bid, 2:Int32) as $expr8, Field(bid, 5:Int32) as $expr9, _row_id] }
                        └─StreamDynamicFilter { predicate: ($expr1 > $expr6), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                          ├─StreamFilter { predicate: (event_type = 2:Int32) }
                          │ └─StreamShare { id: 5 }
                          │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                          │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                          │       └─StreamRowIdGen { row_id_index: 5 }
                          │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                          │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                          └─StreamExchange { dist: Broadcast }
                            └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr6], output_watermarks: [[$expr6]] }
                              └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [category, avg], stream_key: [category], pk_columns: [category], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr5, (sum(max($expr8)) / count(max($expr8))::Decimal) as $expr10] }
        └── StreamHashAgg { group_key: [$expr5], aggs: [sum(max($expr8)), count(max($expr8)), count] }
            ├── tables: [ HashAggState: 0 ]
            └── StreamExchange Hash([1]) from 1

    Fragment 1
    StreamProject { exprs: [$expr2, $expr5, max($expr8)] }
    └── StreamHashAgg { group_key: [$expr2, $expr5], aggs: [max($expr8), count] }
        ├── tables: [ HashAggState: 2, HashAggCall0: 1 ]
        └── StreamProject { exprs: [$expr2, $expr5, $expr8, _row_id, _row_id] }
            └── StreamFilter { predicate: ($expr9 >= $expr3) AND ($expr9 <= $expr4) }
                └── StreamHashJoin { type: Inner, predicate: $expr2 = $expr7, output: all }
                    ├── tables: [ HashJoinLeft: 3, HashJoinDegreeLeft: 4, HashJoinRight: 5, HashJoinDegreeRight: 6 ]
                    ├── StreamExchange Hash([0]) from 2
                    └── StreamExchange Hash([0]) from 4

    Fragment 2
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 5:Int32) as $expr3, Field(auction, 6:Int32) as $expr4, Field(auction, 8:Int32) as $expr5, _row_id] }
    └── StreamFilter { predicate: (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 3

    Fragment 3
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 7 ] }

    Fragment 4
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr7, Field(bid, 2:Int32) as $expr8, Field(bid, 5:Int32) as $expr9, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr6), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 8, DynamicFilterRight: 9 ]
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 3
        └── StreamExchange Broadcast from 5

    Fragment 5
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr6], output_watermarks: [[$expr6]] }
    └── StreamNow { output: [now] } { tables: [ Now: 10 ] }

    Table 0
    ├── columns: [ $expr5, sum(max($expr8)), count(max($expr8)), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1
    ├── columns: [ $expr2, $expr5, $expr8, _row_id, _row_id_0, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 DESC, $3 ASC, $4 ASC ]
    ├── value indices: [ 0, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 2

    Table 2
    ├── columns: [ $expr2, $expr5, max($expr8), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 2, 3 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 2

    Table 3
    ├── columns: [ $expr2, $expr3, $expr4, $expr5, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $4 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 4 { columns: [ $expr2, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5
    ├── columns: [ $expr7, $expr8, $expr9, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $3 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 6 { columns: [ $expr7, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 8
    ├── columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 4 ]
    └── read pk prefix len hint: 1

    Table 9 { columns: [ $expr6, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 10 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ category, avg, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: nexmark_q5
  before:
  - create_sources
  sql: |
    SELECT AuctionBids.auction, AuctionBids.num FROM (
      SELECT
        bid.auction,
        count(*) AS num,
        window_start AS starttime
      FROM
        HOP(bid, date_time, INTERVAL '2' SECOND, INTERVAL '10' SECOND)
      GROUP BY
        window_start,
        bid.auction
    ) AS AuctionBids
    JOIN (
      SELECT
        max(CountBids.num) AS maxn,
        CountBids.starttime_c
      FROM (
        SELECT
          count(*) AS num,
          window_start AS starttime_c
        FROM HOP(bid, date_time, INTERVAL '2' SECOND, INTERVAL '10' SECOND)
        GROUP BY
          bid.auction,
          window_start
      ) AS CountBids
      GROUP BY
        CountBids.starttime_c
    ) AS MaxBids
    ON AuctionBids.starttime = MaxBids.starttime_c AND AuctionBids.num >= MaxBids.maxn;
  stream_plan: |-
    StreamMaterialize { columns: [auction, num, window_start(hidden), window_start#1(hidden)], stream_key: [auction, window_start], pk_columns: [auction, window_start], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr3, count, window_start, window_start] }
      └─StreamFilter { predicate: (count >= max(count)) }
        └─StreamHashJoin { type: Inner, predicate: window_start = window_start, output: all }
          ├─StreamExchange { dist: HashShard(window_start) }
          │ └─StreamShare { id: 11 }
          │   └─StreamHashAgg { group_key: [$expr3, window_start], aggs: [count] }
          │     └─StreamExchange { dist: HashShard($expr3, window_start) }
          │       └─StreamHopWindow { time_col: $expr4, slide: 00:00:02, size: 00:00:10, output: [$expr3, window_start, _row_id] }
          │         └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 5:Int32) as $expr4, _row_id] }
          │           └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
          │             ├─StreamFilter { predicate: IsNotNull(Field(bid, 5:Int32)) AND (event_type = 2:Int32) }
          │             │ └─StreamRowIdGen { row_id_index: 5 }
          │             │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
          │             │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
          │             └─StreamExchange { dist: Broadcast }
          │               └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
          │                 └─StreamNow { output: [now] }
          └─StreamProject { exprs: [window_start, max(count)] }
            └─StreamHashAgg { group_key: [window_start], aggs: [max(count), count] }
              └─StreamExchange { dist: HashShard(window_start) }
                └─StreamShare { id: 11 }
                  └─StreamHashAgg { group_key: [$expr3, window_start], aggs: [count] }
                    └─StreamExchange { dist: HashShard($expr3, window_start) }
                      └─StreamHopWindow { time_col: $expr4, slide: 00:00:02, size: 00:00:10, output: [$expr3, window_start, _row_id] }
                        └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 5:Int32) as $expr4, _row_id] }
                          └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                            ├─StreamFilter { predicate: IsNotNull(Field(bid, 5:Int32)) AND (event_type = 2:Int32) }
                            │ └─StreamRowIdGen { row_id_index: 5 }
                            │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                            │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                            └─StreamExchange { dist: Broadcast }
                              └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
                                └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, num, window_start(hidden), window_start#1(hidden)], stream_key: [auction, window_start], pk_columns: [auction, window_start], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr3, count, window_start, window_start] }
        └── StreamFilter { predicate: (count >= max(count)) }
            └── StreamHashJoin { type: Inner, predicate: window_start = window_start, output: all }
                ├── tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ]
                ├── StreamExchange Hash([1]) from 1
                └── StreamProject { exprs: [window_start, max(count)] }
                    └── StreamHashAgg { group_key: [window_start], aggs: [max(count), count] } { tables: [ HashAggState: 10, HashAggCall0: 9 ] }
                        └── StreamExchange Hash([1]) from 5

    Fragment 1
    StreamNoOp
    └── StreamExchange NoShuffle from 2

    Fragment 2
    StreamHashAgg { group_key: [$expr3, window_start], aggs: [count] } { tables: [ HashAggState: 4 ] }
    └── StreamExchange Hash([0, 1]) from 3

    Fragment 3
    StreamHopWindow { time_col: $expr4, slide: 00:00:02, size: 00:00:10, output: [$expr3, window_start, _row_id] }
    └── StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 5:Int32) as $expr4, _row_id] }
        └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
            ├── tables: [ DynamicFilterLeft: 5, DynamicFilterRight: 6 ]
            ├── StreamFilter { predicate: IsNotNull(Field(bid, 5:Int32)) AND (event_type = 2:Int32) }
            │   └── StreamRowIdGen { row_id_index: 5 }
            │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
            │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 7 ] }
            └── StreamExchange Broadcast from 4

    Fragment 4
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 8 ] }

    Fragment 5
    StreamNoOp
    └── StreamExchange NoShuffle from 2

    Table 0 { columns: [ $expr3, window_start, count, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ window_start, $expr3, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ window_start, max(count), _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ window_start, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ $expr3, window_start, count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 5
    ├── columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ]
    ├── primary key: [ $4 ASC, $5 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5 ]
    ├── distribution key: [ 5 ]
    └── read pk prefix len hint: 1

    Table 6 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 7 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 8 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 9
    ├── columns: [ window_start, count, $expr3, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 10 { columns: [ window_start, max(count), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4294967294
    ├── columns: [ auction, num, window_start, window_start#1, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $2 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 2

- id: nexmark_q6
  before:
  - create_sources
  sql: |
    SELECT
        Q.seller,
        AVG(Q.final) OVER
            (PARTITION BY Q.seller ORDER BY Q.date_time ROWS BETWEEN 10 PRECEDING AND CURRENT ROW)
        as avg
    FROM (
        SELECT MAX(B.price) AS final, A.seller, B.date_time
        FROM auction AS A, bid AS B
        WHERE A.id = B.auction and B.date_time between A.date_time and A.expires
        GROUP BY A.id, A.seller
    ) AS Q;
  planner_error: 'Invalid input syntax: column must appear in the GROUP BY clause or be used in an aggregate function'
- id: nexmark_q6_group_top1
  before:
  - create_sources
  sql: |
    SELECT
        Q.seller,
        AVG(Q.final) OVER
            (PARTITION BY Q.seller ORDER BY Q.date_time ROWS BETWEEN 10 PRECEDING AND CURRENT ROW)
        as avg
    FROM (
        SELECT ROW_NUMBER() OVER (PARTITION BY A.id, A.seller ORDER BY B.price) as rank, A.seller, B.price as final,  B.date_time
        FROM auction AS A, bid AS B
        WHERE A.id = B.auction and B.date_time between A.date_time and A.expires
    ) AS Q
    WHERE Q.rank <= 1;
  stream_plan: |-
    StreamMaterialize { columns: [seller, avg, $expr2(hidden)], stream_key: [$expr2, seller], pk_columns: [$expr2, seller], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr5, (sum / count::Decimal) as $expr10, $expr2] }
      └─StreamOverWindow { window_functions: [sum($expr8) OVER(PARTITION BY $expr5 ORDER BY $expr9 ASC ROWS BETWEEN 10 PRECEDING AND CURRENT ROW), count($expr8) OVER(PARTITION BY $expr5 ORDER BY $expr9 ASC ROWS BETWEEN 10 PRECEDING AND CURRENT ROW)] }
        └─StreamExchange { dist: HashShard($expr5) }
          └─StreamProject { exprs: [$expr5, $expr8, $expr9, $expr2] }
            └─StreamGroupTopN { order: [$expr8 ASC], limit: 1, offset: 0, group_key: [$expr2, $expr5] }
              └─StreamExchange { dist: HashShard($expr2, $expr5) }
                └─StreamProject { exprs: [$expr2, $expr5, $expr8, $expr9, _row_id, _row_id] }
                  └─StreamFilter { predicate: ($expr9 >= $expr3) AND ($expr9 <= $expr4) }
                    └─StreamHashJoin { type: Inner, predicate: $expr2 = $expr7, output: all }
                      ├─StreamExchange { dist: HashShard($expr2) }
                      │ └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 5:Int32) as $expr3, Field(auction, 6:Int32) as $expr4, Field(auction, 7:Int32) as $expr5, _row_id] }
                      │   └─StreamFilter { predicate: (event_type = 1:Int32) }
                      │     └─StreamShare { id: 5 }
                      │       └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                      │         └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                      │           └─StreamRowIdGen { row_id_index: 5 }
                      │             └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                      │               └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                      └─StreamExchange { dist: HashShard($expr7) }
                        └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr7, Field(bid, 2:Int32) as $expr8, Field(bid, 5:Int32) as $expr9, _row_id] }
                          └─StreamDynamicFilter { predicate: ($expr1 > $expr6), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                            ├─StreamFilter { predicate: (event_type = 2:Int32) }
                            │ └─StreamShare { id: 5 }
                            │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                            │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                            │       └─StreamRowIdGen { row_id_index: 5 }
                            │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                            │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                            └─StreamExchange { dist: Broadcast }
                              └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr6], output_watermarks: [[$expr6]] }
                                └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [seller, avg, $expr2(hidden)], stream_key: [$expr2, seller], pk_columns: [$expr2, seller], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr5, (sum / count::Decimal) as $expr10, $expr2] }
        └── StreamOverWindow { window_functions: [sum($expr8) OVER(PARTITION BY $expr5 ORDER BY $expr9 ASC ROWS BETWEEN 10 PRECEDING AND CURRENT ROW), count($expr8) OVER(PARTITION BY $expr5 ORDER BY $expr9 ASC ROWS BETWEEN 10 PRECEDING AND CURRENT ROW)] }
            ├── tables: [ OverWindow: 0 ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [$expr5, $expr8, $expr9, $expr2] }
    └── StreamGroupTopN { order: [$expr8 ASC], limit: 1, offset: 0, group_key: [$expr2, $expr5] } { tables: [ GroupTopN: 1 ] }
        └── StreamExchange Hash([0, 1]) from 2

    Fragment 2
    StreamProject { exprs: [$expr2, $expr5, $expr8, $expr9, _row_id, _row_id] }
    └── StreamFilter { predicate: ($expr9 >= $expr3) AND ($expr9 <= $expr4) }
        └── StreamHashJoin { type: Inner, predicate: $expr2 = $expr7, output: all } { tables: [ HashJoinLeft: 2, HashJoinDegreeLeft: 3, HashJoinRight: 4, HashJoinDegreeRight: 5 ] }
            ├── StreamExchange Hash([0]) from 3
            └── StreamExchange Hash([0]) from 5

    Fragment 3
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 5:Int32) as $expr3, Field(auction, 6:Int32) as $expr4, Field(auction, 7:Int32) as $expr5, _row_id] }
    └── StreamFilter { predicate: (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 4

    Fragment 4
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 6 ] }

    Fragment 5
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr7, Field(bid, 2:Int32) as $expr8, Field(bid, 5:Int32) as $expr9, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr6), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 7, DynamicFilterRight: 8 ] }
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 4
        └── StreamExchange Broadcast from 6

    Fragment 6
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr6], output_watermarks: [[$expr6]] }
    └── StreamNow { output: [now] } { tables: [ Now: 9 ] }

    Table 0 { columns: [ $expr5, $expr8, $expr9, $expr2, sum, count, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr2, $expr5, $expr8, $expr9, _row_id, _row_id_0, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 2 { columns: [ $expr2, $expr3, $expr4, $expr5, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr2, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ $expr7, $expr8, $expr9, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ $expr7, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 7 { columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 4 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ $expr6, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 9 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ seller, avg, $expr2, _rw_timestamp ], primary key: [ $2 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

- id: nexmark_q7
  before:
  - create_sources
  sql: |
    SELECT
      B.auction,
      B.price,
      B.bidder,
      B.date_time
    FROM
      bid B
    JOIN (
      SELECT
        MAX(price) AS maxprice,
        window_end as date_time
      FROM
        TUMBLE(bid, date_time, INTERVAL '10' SECOND)
      GROUP BY
        window_end
    ) B1 ON B.price = B1.maxprice
    WHERE
      B.date_time BETWEEN B1.date_time - INTERVAL '10' SECOND
      AND B1.date_time;
  stream_plan: |-
    StreamMaterialize { columns: [auction, price, bidder, date_time, _row_id(hidden), $expr7(hidden)], stream_key: [_row_id, $expr7, price], pk_columns: [_row_id, $expr7, price], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr3, $expr5, $expr4, $expr6, _row_id, $expr7] }
      └─StreamFilter { predicate: ($expr6 >= $expr8) AND ($expr6 <= $expr7) }
        └─StreamHashJoin { type: Inner, predicate: $expr5 = max($expr5), output: all }
          ├─StreamExchange { dist: HashShard($expr5) }
          │ └─StreamShare { id: 8 }
          │   └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 5:Int32) as $expr6, _row_id] }
          │     └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
          │       ├─StreamFilter { predicate: (event_type = 2:Int32) }
          │       │ └─StreamRowIdGen { row_id_index: 5 }
          │       │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
          │       │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
          │       └─StreamExchange { dist: Broadcast }
          │         └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
          │           └─StreamNow { output: [now] }
          └─StreamExchange { dist: HashShard(max($expr5)) }
            └─StreamProject { exprs: [$expr7, max($expr5), ($expr7 - '00:00:10':Interval) as $expr8] }
              └─StreamHashAgg { group_key: [$expr7], aggs: [max($expr5), count] }
                └─StreamExchange { dist: HashShard($expr7) }
                  └─StreamProject { exprs: [(TumbleStart($expr6, '00:00:10':Interval) + '00:00:10':Interval) as $expr7, $expr5, _row_id] }
                    └─StreamShare { id: 8 }
                      └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 5:Int32) as $expr6, _row_id] }
                        └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                          ├─StreamFilter { predicate: (event_type = 2:Int32) }
                          │ └─StreamRowIdGen { row_id_index: 5 }
                          │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                          │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                          └─StreamExchange { dist: Broadcast }
                            └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
                              └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, price, bidder, date_time, _row_id(hidden), $expr7(hidden)], stream_key: [_row_id, $expr7, price], pk_columns: [_row_id, $expr7, price], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr3, $expr5, $expr4, $expr6, _row_id, $expr7] }
        └── StreamFilter { predicate: ($expr6 >= $expr8) AND ($expr6 <= $expr7) }
            └── StreamHashJoin { type: Inner, predicate: $expr5 = max($expr5), output: all } { tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ] }
                ├── StreamExchange Hash([2]) from 1
                └── StreamExchange Hash([1]) from 4

    Fragment 1
    StreamNoOp
    └── StreamExchange NoShuffle from 2

    Fragment 2
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 5:Int32) as $expr6, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 4, DynamicFilterRight: 5 ]
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamRowIdGen { row_id_index: 5 }
        │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 6 ] }
        └── StreamExchange Broadcast from 3

    Fragment 3
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 7 ] }

    Fragment 4
    StreamProject { exprs: [$expr7, max($expr5), ($expr7 - '00:00:10':Interval) as $expr8] }
    └── StreamHashAgg { group_key: [$expr7], aggs: [max($expr5), count] } { tables: [ HashAggState: 9, HashAggCall0: 8 ] }
        └── StreamExchange Hash([0]) from 5

    Fragment 5
    StreamProject { exprs: [(TumbleStart($expr6, '00:00:10':Interval) + '00:00:10':Interval) as $expr7, $expr5, _row_id] }
    └── StreamExchange NoShuffle from 2

    Table 0
    ├── columns: [ $expr3, $expr4, $expr5, $expr6, _row_id, _rw_timestamp ]
    ├── primary key: [ $2 ASC, $4 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ $expr5, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr7, max($expr5), $expr8, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ max($expr5), $expr7, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4
    ├── columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ]
    ├── primary key: [ $4 ASC, $5 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5 ]
    ├── distribution key: [ 5 ]
    └── read pk prefix len hint: 1

    Table 5 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 6 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 7 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 8 { columns: [ $expr7, $expr5, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 DESC, $2 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ $expr7, max($expr5), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4294967294
    ├── columns: [ auction, price, bidder, date_time, _row_id, $expr7, _rw_timestamp ]
    ├── primary key: [ $4 ASC, $5 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 3

- id: nexmark_q8
  before:
  - create_sources
  sql: |
    SELECT
      P.id,
      P.name,
      P.starttime
    FROM (
      SELECT
        id,
        name,
        window_start AS starttime,
        window_end AS endtime
      FROM
        TUMBLE(person, date_time, INTERVAL '10' SECOND)
      GROUP BY
        id,
        name,
        window_start,
        window_end
    ) P
    JOIN (
      SELECT
        seller,
        window_start AS starttime,
        window_end AS endtime
      FROM
        TUMBLE(auction, date_time, INTERVAL '10' SECOND)
      GROUP BY
        seller,
        window_start,
        window_end
    ) A ON P.id = A.seller
      AND P.starttime = A.starttime
      AND P.endtime = A.endtime;
  stream_plan: |-
    StreamMaterialize { columns: [id, name, starttime, $expr6(hidden), $expr8(hidden), $expr9(hidden), $expr10(hidden)], stream_key: [id, name, starttime, $expr6], pk_columns: [id, name, starttime, $expr6], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard($expr2, $expr3, $expr5, $expr6) }
      └─StreamHashJoin [append_only] { type: Inner, predicate: $expr2 = $expr8 AND $expr5 = $expr9 AND $expr6 = $expr10, output: all }
        ├─StreamExchange { dist: HashShard($expr2, $expr5, $expr6) }
        │ └─StreamAppendOnlyDedup { dedup_cols: [$expr2, $expr3, $expr5, $expr6] }
        │   └─StreamExchange { dist: HashShard($expr2, $expr3, $expr5, $expr6) }
        │     └─StreamProject { exprs: [$expr2, $expr3, $expr5, ($expr5 + '00:00:10':Interval) as $expr6] }
        │       └─StreamProject { exprs: [$expr2, $expr3, $expr4, TumbleStart($expr4, '00:00:10':Interval) as $expr5, _row_id] }
        │         └─StreamProject { exprs: [Field(person, 0:Int32) as $expr2, Field(person, 1:Int32) as $expr3, Field(person, 6:Int32) as $expr4, _row_id] }
        │           └─StreamFilter { predicate: (event_type = 0:Int32) }
        │             └─StreamShare { id: 5 }
        │               └─StreamProject { exprs: [event_type, person, auction, _row_id] }
        │                 └─StreamFilter { predicate: ((event_type = 0:Int32) OR (event_type = 1:Int32)) }
        │                   └─StreamRowIdGen { row_id_index: 5 }
        │                     └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │                       └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
        └─StreamAppendOnlyDedup { dedup_cols: [$expr8, $expr9, $expr10] }
          └─StreamExchange { dist: HashShard($expr8, $expr9, $expr10) }
            └─StreamProject { exprs: [$expr8, $expr9, ($expr9 + '00:00:10':Interval) as $expr10] }
              └─StreamProject { exprs: [$expr7, $expr8, TumbleStart($expr7, '00:00:10':Interval) as $expr9, _row_id] }
                └─StreamProject { exprs: [Field(auction, 5:Int32) as $expr7, Field(auction, 7:Int32) as $expr8, _row_id] }
                  └─StreamFilter { predicate: (event_type = 1:Int32) }
                    └─StreamShare { id: 5 }
                      └─StreamProject { exprs: [event_type, person, auction, _row_id] }
                        └─StreamFilter { predicate: ((event_type = 0:Int32) OR (event_type = 1:Int32)) }
                          └─StreamRowIdGen { row_id_index: 5 }
                            └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                              └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [id, name, starttime, $expr6(hidden), $expr8(hidden), $expr9(hidden), $expr10(hidden)], stream_key: [id, name, starttime, $expr6], pk_columns: [id, name, starttime, $expr6], pk_conflict: NoCheck }
    └── StreamExchange Hash([0, 1, 2, 3]) from 1

    Fragment 1
    StreamHashJoin [append_only] { type: Inner, predicate: $expr2 = $expr8 AND $expr5 = $expr9 AND $expr6 = $expr10, output: all } { tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ] }
    ├── StreamExchange Hash([0, 2, 3]) from 2
    └── StreamAppendOnlyDedup { dedup_cols: [$expr8, $expr9, $expr10] } { tables: [ AppendOnlyDedup: 6 ] }
        └── StreamExchange Hash([0, 1, 2]) from 5

    Fragment 2
    StreamAppendOnlyDedup { dedup_cols: [$expr2, $expr3, $expr5, $expr6] } { tables: [ AppendOnlyDedup: 4 ] }
    └── StreamExchange Hash([0, 1, 2, 3]) from 3

    Fragment 3
    StreamProject { exprs: [$expr2, $expr3, $expr5, ($expr5 + '00:00:10':Interval) as $expr6] }
    └── StreamProject { exprs: [$expr2, $expr3, $expr4, TumbleStart($expr4, '00:00:10':Interval) as $expr5, _row_id] }
        └── StreamProject { exprs: [Field(person, 0:Int32) as $expr2, Field(person, 1:Int32) as $expr3, Field(person, 6:Int32) as $expr4, _row_id] }
            └── StreamFilter { predicate: (event_type = 0:Int32) }
                └── StreamExchange NoShuffle from 4

    Fragment 4
    StreamProject { exprs: [event_type, person, auction, _row_id] }
    └── StreamFilter { predicate: ((event_type = 0:Int32) OR (event_type = 1:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 5 ] }

    Fragment 5
    StreamProject { exprs: [$expr8, $expr9, ($expr9 + '00:00:10':Interval) as $expr10] }
    └── StreamProject { exprs: [$expr7, $expr8, TumbleStart($expr7, '00:00:10':Interval) as $expr9, _row_id] }
        └── StreamProject { exprs: [Field(auction, 5:Int32) as $expr7, Field(auction, 7:Int32) as $expr8, _row_id] }
            └── StreamFilter { predicate: (event_type = 1:Int32) }
                └── StreamExchange NoShuffle from 4

    Table 0 { columns: [ $expr2, $expr3, $expr5, $expr6, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC, $3 ASC, $1 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 2, 3 ], read pk prefix len hint: 3 }

    Table 1 { columns: [ $expr2, $expr5, $expr6, $expr3, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 2 { columns: [ $expr8, $expr9, $expr10, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 3 { columns: [ $expr8, $expr9, $expr10, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 4 { columns: [ $expr2, $expr3, $expr5, $expr6, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1, 2, 3 ], read pk prefix len hint: 4 }

    Table 5 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 6 { columns: [ $expr8, $expr9, $expr10, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 4294967294
    ├── columns: [ id, name, starttime, $expr6, $expr8, $expr9, $expr10, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6 ]
    ├── distribution key: [ 0, 1, 2, 3 ]
    └── read pk prefix len hint: 4

- id: nexmark_q9
  before:
  - create_sources
  sql: |
    SELECT
      id, item_name, description, initial_bid, reserve, date_time, expires, seller, category,
      auction, bidder, price, bid_date_time
    FROM (
      SELECT A.*, B.auction, B.bidder, B.price, B.date_time AS bid_date_time,
        ROW_NUMBER() OVER (PARTITION BY A.id ORDER BY B.price DESC, B.date_time ASC) AS rownum
      FROM auction A, bid B
      WHERE A.id = B.auction AND B.date_time BETWEEN A.date_time AND A.expires
    )
    WHERE rownum <= 1;
  stream_plan: |-
    StreamMaterialize { columns: [id, item_name, description, initial_bid, reserve, date_time, expires, seller, category, auction, bidder, price, bid_date_time, _row_id(hidden), _row_id#1(hidden)], stream_key: [id], pk_columns: [id], pk_conflict: NoCheck }
    └─StreamGroupTopN { order: [$expr14 DESC, $expr15 ASC], limit: 1, offset: 0, group_key: [$expr2] }
      └─StreamProject { exprs: [$expr2, $expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr9, $expr10, $expr12, $expr13, $expr14, $expr15, _row_id, _row_id] }
        └─StreamFilter { predicate: ($expr15 >= $expr7) AND ($expr15 <= $expr8) }
          └─StreamHashJoin { type: Inner, predicate: $expr2 = $expr12, output: all }
            ├─StreamExchange { dist: HashShard($expr2) }
            │ └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, Field(auction, 2:Int32) as $expr4, Field(auction, 3:Int32) as $expr5, Field(auction, 4:Int32) as $expr6, Field(auction, 5:Int32) as $expr7, Field(auction, 6:Int32) as $expr8, Field(auction, 7:Int32) as $expr9, Field(auction, 8:Int32) as $expr10, _row_id] }
            │   └─StreamFilter { predicate: (event_type = 1:Int32) }
            │     └─StreamShare { id: 5 }
            │       └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
            │         └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
            │           └─StreamRowIdGen { row_id_index: 5 }
            │             └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
            │               └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
            └─StreamExchange { dist: HashShard($expr12) }
              └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr12, Field(bid, 1:Int32) as $expr13, Field(bid, 2:Int32) as $expr14, Field(bid, 5:Int32) as $expr15, _row_id] }
                └─StreamDynamicFilter { predicate: ($expr1 > $expr11), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                  ├─StreamFilter { predicate: (event_type = 2:Int32) }
                  │ └─StreamShare { id: 5 }
                  │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                  │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                  │       └─StreamRowIdGen { row_id_index: 5 }
                  │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                  │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                  └─StreamExchange { dist: Broadcast }
                    └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr11], output_watermarks: [[$expr11]] }
                      └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [id, item_name, description, initial_bid, reserve, date_time, expires, seller, category, auction, bidder, price, bid_date_time, _row_id(hidden), _row_id#1(hidden)], stream_key: [id], pk_columns: [id], pk_conflict: NoCheck }
    └── StreamGroupTopN { order: [$expr14 DESC, $expr15 ASC], limit: 1, offset: 0, group_key: [$expr2] } { tables: [ GroupTopN: 0 ] }
        └── StreamProject { exprs: [$expr2, $expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr9, $expr10, $expr12, $expr13, $expr14, $expr15, _row_id, _row_id] }
            └── StreamFilter { predicate: ($expr15 >= $expr7) AND ($expr15 <= $expr8) }
                └── StreamHashJoin { type: Inner, predicate: $expr2 = $expr12, output: all } { tables: [ HashJoinLeft: 1, HashJoinDegreeLeft: 2, HashJoinRight: 3, HashJoinDegreeRight: 4 ] }
                    ├── StreamExchange Hash([0]) from 1
                    └── StreamExchange Hash([0]) from 3

    Fragment 1
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, Field(auction, 2:Int32) as $expr4, Field(auction, 3:Int32) as $expr5, Field(auction, 4:Int32) as $expr6, Field(auction, 5:Int32) as $expr7, Field(auction, 6:Int32) as $expr8, Field(auction, 7:Int32) as $expr9, Field(auction, 8:Int32) as $expr10, _row_id] }
    └── StreamFilter { predicate: (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 2

    Fragment 2
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 5 ] }

    Fragment 3
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr12, Field(bid, 1:Int32) as $expr13, Field(bid, 2:Int32) as $expr14, Field(bid, 5:Int32) as $expr15, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr11), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 6, DynamicFilterRight: 7 ] }
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 2
        └── StreamExchange Broadcast from 4

    Fragment 4
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr11], output_watermarks: [[$expr11]] }
    └── StreamNow { output: [now] } { tables: [ Now: 8 ] }

    Table 0
    ├── columns: [ $expr2, $expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr9, $expr10, $expr12, $expr13, $expr14, $expr15, _row_id, _row_id_0, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $11 DESC, $12 ASC, $13 ASC, $14 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ $expr2, $expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr9, $expr10, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr2, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr12, $expr13, $expr14, $expr15, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ $expr12, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 6 { columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 4 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ $expr11, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 8 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ id, item_name, description, initial_bid, reserve, date_time, expires, seller, category, auction, bidder, price, bid_date_time, _row_id, _row_id#1, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: nexmark_q11
  before:
  - create_sources
  sql: |
    SELECT
      B.bidder,
      count(*) as bid_count,
      SESSION_START(B.date_time, INTERVAL '10' SECOND) as starttime,
      SESSION_END(B.date_time, INTERVAL '10' SECOND) as endtime
    FROM bid B
    GROUP BY B.bidder, SESSION(B.date_time, INTERVAL '10' SECOND);
  binder_error: |
    Failed to bind expression: SESSION_START(B.date_time, INTERVAL '10' SECOND)

    Caused by:
      function session_start(timestamp without time zone, interval) does not exist
- id: nexmark_q12
  before:
  - create_sources
  sql: |
    SELECT
        B.bidder,
        count(*) as bid_count,
        TUMBLE_START(B.p_time, INTERVAL '10' SECOND) as starttime,
        TUMBLE_END(B.p_time, INTERVAL '10' SECOND) as endtime
    FROM (SELECT *, PROCTIME() as p_time FROM bid) B
    GROUP BY B.bidder, TUMBLE(B.p_time, INTERVAL '10' SECOND);
  binder_error: |
    Failed to bind expression: PROCTIME()

    Caused by:
      Invalid input syntax: Function `PROCTIME()` is only allowed in CREATE TABLE/SOURCE. Is `NOW()` what you want?
- id: nexmark_q13
  before:
  - create_sources
  sql: |
    /* SELECT
        B.auction,
        B.bidder,
        B.price,
        B.date_time,
        S.value
    FROM (SELECT *, PROCTIME() as p_time FROM bid) B
    JOIN side_input FOR SYSTEM_TIME AS OF B.p_time AS S
    ON mod(B.auction, 10000) = S.key; */
    select 1;
  stream_error: 'Bind error: An alias must be specified for the 1st expression (counting from 1) in result relation'
- id: nexmark_q14
  before:
  - create_sources
  sql: |
    SELECT
      auction,
      bidder,
      0.908 * price as price,
      CASE
        WHEN
          extract(hour from date_time) >= 8 AND
          extract(hour from date_time) <= 18
        THEN 'dayTime'
        WHEN
          extract(hour from date_time) <= 6 OR
          extract(hour from date_time) >= 20
        THEN 'nightTime'
        ELSE 'otherTime'
      END AS bidTimeType,
      date_time,
      extra
      -- ignore UDF in planner test
      -- count_char(extra, 'c') AS c_counts
    FROM bid
    WHERE 0.908 * price > 1000000 AND 0.908 * price < 50000000;
  stream_plan: |-
    StreamMaterialize { columns: [auction, bidder, price, bidtimetype, date_time, extra, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr3, $expr4, (0.908:Decimal * $expr5::Decimal) as $expr8, Case(((Extract('HOUR':Varchar, $expr6) >= 8:Decimal) AND (Extract('HOUR':Varchar, $expr6) <= 18:Decimal)), 'dayTime':Varchar, ((Extract('HOUR':Varchar, $expr6) <= 6:Decimal) OR (Extract('HOUR':Varchar, $expr6) >= 20:Decimal)), 'nightTime':Varchar, 'otherTime':Varchar) as $expr9, $expr6, $expr7, _row_id] }
      └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 5:Int32) as $expr6, Field(bid, 6:Int32) as $expr7, _row_id] }
        └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
          ├─StreamFilter { predicate: ((0.908:Decimal * Field(bid, 2:Int32)::Decimal) > 1000000:Decimal) AND ((0.908:Decimal * Field(bid, 2:Int32)::Decimal) < 50000000:Decimal) AND (event_type = 2:Int32) }
          │ └─StreamRowIdGen { row_id_index: 5 }
          │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
          │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
          └─StreamExchange { dist: Broadcast }
            └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
              └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, bidder, price, bidtimetype, date_time, extra, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr3, $expr4, (0.908:Decimal * $expr5::Decimal) as $expr8, Case(((Extract('HOUR':Varchar, $expr6) >= 8:Decimal) AND (Extract('HOUR':Varchar, $expr6) <= 18:Decimal)), 'dayTime':Varchar, ((Extract('HOUR':Varchar, $expr6) <= 6:Decimal) OR (Extract('HOUR':Varchar, $expr6) >= 20:Decimal)), 'nightTime':Varchar, 'otherTime':Varchar) as $expr9, $expr6, $expr7, _row_id] }
        └── StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 5:Int32) as $expr6, Field(bid, 6:Int32) as $expr7, _row_id] }
            └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ] }
                ├── StreamFilter { predicate: ((0.908:Decimal * Field(bid, 2:Int32)::Decimal) > 1000000:Decimal) AND ((0.908:Decimal * Field(bid, 2:Int32)::Decimal) < 50000000:Decimal) AND (event_type = 2:Int32) }
                │   └── StreamRowIdGen { row_id_index: 5 }
                │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 2 ] }
                └── StreamExchange Broadcast from 1

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 3 ] }

    Table 0 { columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 3 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ auction, bidder, price, bidtimetype, date_time, extra, _row_id, _rw_timestamp ], primary key: [ $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 6 ], read pk prefix len hint: 1 }

- id: nexmark_q18
  before:
  - create_sources
  sql: |
    SELECT auction, bidder, price, channel, url, date_time, extra
    FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY bidder, auction ORDER BY date_time DESC) AS rank_number
          FROM bid)
    WHERE rank_number <= 1;
  stream_plan: |-
    StreamMaterialize { columns: [auction, bidder, price, channel, url, date_time, extra, _row_id(hidden)], stream_key: [bidder, auction], pk_columns: [bidder, auction], pk_conflict: NoCheck }
    └─StreamGroupTopN { order: [$expr8 DESC], limit: 1, offset: 0, group_key: [$expr4, $expr3] }
      └─StreamExchange { dist: HashShard($expr4, $expr3) }
        └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, Field(bid, 6:Int32) as $expr9, _row_id] }
          └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
            ├─StreamFilter { predicate: (event_type = 2:Int32) }
            │ └─StreamRowIdGen { row_id_index: 5 }
            │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
            │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
            └─StreamExchange { dist: Broadcast }
              └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
                └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, bidder, price, channel, url, date_time, extra, _row_id(hidden)], stream_key: [bidder, auction], pk_columns: [bidder, auction], pk_conflict: NoCheck }
    └── StreamGroupTopN { order: [$expr8 DESC], limit: 1, offset: 0, group_key: [$expr4, $expr3] } { tables: [ GroupTopN: 0 ] }
        └── StreamExchange Hash([1, 0]) from 1

    Fragment 1
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, Field(bid, 6:Int32) as $expr9, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 1, DynamicFilterRight: 2 ] }
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamRowIdGen { row_id_index: 5 }
        │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 3 ] }
        └── StreamExchange Broadcast from 2

    Fragment 2
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 4 ] }

    Table 0
    ├── columns: [ $expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr9, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $0 ASC, $5 DESC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ]
    ├── distribution key: [ 1, 0 ]
    └── read pk prefix len hint: 2

    Table 1 { columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 3 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ auction, bidder, price, channel, url, date_time, extra, _row_id, _rw_timestamp ], primary key: [ $1 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 1, 0 ], read pk prefix len hint: 2 }

- id: nexmark_q18_rank
  before:
  - create_sources
  sql: |
    SELECT auction, bidder, price, channel, url, date_time, extra
    FROM (SELECT *, RANK() OVER (PARTITION BY bidder, auction ORDER BY date_time DESC) AS rank_number
          FROM bid)
    WHERE rank_number <= 1;
  stream_plan: |-
    StreamMaterialize { columns: [auction, bidder, price, channel, url, date_time, extra, _row_id(hidden)], stream_key: [bidder, auction, _row_id], pk_columns: [bidder, auction, _row_id], pk_conflict: NoCheck }
    └─StreamGroupTopN { order: [$expr8 DESC], limit: 1, offset: 0, with_ties: true, group_key: [$expr4, $expr3] }
      └─StreamExchange { dist: HashShard($expr4, $expr3) }
        └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, Field(bid, 6:Int32) as $expr9, _row_id] }
          └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
            ├─StreamFilter { predicate: (event_type = 2:Int32) }
            │ └─StreamRowIdGen { row_id_index: 5 }
            │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
            │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
            └─StreamExchange { dist: Broadcast }
              └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
                └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, bidder, price, channel, url, date_time, extra, _row_id(hidden)], stream_key: [bidder, auction, _row_id], pk_columns: [bidder, auction, _row_id], pk_conflict: NoCheck }
    └── StreamGroupTopN { order: [$expr8 DESC], limit: 1, offset: 0, with_ties: true, group_key: [$expr4, $expr3] } { tables: [ GroupTopN: 0 ] }
        └── StreamExchange Hash([1, 0]) from 1

    Fragment 1
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, Field(bid, 6:Int32) as $expr9, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 1, DynamicFilterRight: 2 ] }
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamRowIdGen { row_id_index: 5 }
        │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 3 ] }
        └── StreamExchange Broadcast from 2

    Fragment 2
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 4 ] }

    Table 0
    ├── columns: [ $expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr9, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $0 ASC, $5 DESC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ]
    ├── distribution key: [ 1, 0 ]
    └── read pk prefix len hint: 2

    Table 1 { columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 3 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ auction, bidder, price, channel, url, date_time, extra, _row_id, _rw_timestamp ]
    ├── primary key: [ $1 ASC, $0 ASC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ]
    ├── distribution key: [ 1, 0 ]
    └── read pk prefix len hint: 3

- id: nexmark_q19
  before:
  - create_sources
  sql: |
    SELECT * FROM
    (SELECT *, ROW_NUMBER() OVER (PARTITION BY auction ORDER BY price DESC) AS rank_number FROM bid)
    WHERE rank_number <= 10;
  stream_plan: |-
    StreamMaterialize { columns: [auction, bidder, price, channel, url, date_time, extra, p_time, _row_id(hidden), rank_number], stream_key: [auction, _row_id], pk_columns: [auction, _row_id], pk_conflict: NoCheck }
    └─StreamOverWindow { window_functions: [row_number() OVER(PARTITION BY $expr3 ORDER BY $expr5 DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)] }
      └─StreamGroupTopN { order: [$expr5 DESC], limit: 10, offset: 0, group_key: [$expr3] }
        └─StreamExchange { dist: HashShard($expr3) }
          └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, Field(bid, 6:Int32) as $expr9, $expr1, _row_id], output_watermarks: [[$expr1]] }
            └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
              ├─StreamFilter { predicate: (event_type = 2:Int32) }
              │ └─StreamRowIdGen { row_id_index: 5 }
              │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
              │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
              └─StreamExchange { dist: Broadcast }
                └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
                  └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, bidder, price, channel, url, date_time, extra, p_time, _row_id(hidden), rank_number], stream_key: [auction, _row_id], pk_columns: [auction, _row_id], pk_conflict: NoCheck }
    └── StreamOverWindow { window_functions: [row_number() OVER(PARTITION BY $expr3 ORDER BY $expr5 DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)] } { tables: [ OverWindow: 0 ] }
        └── StreamGroupTopN { order: [$expr5 DESC], limit: 10, offset: 0, group_key: [$expr3] } { tables: [ GroupTopN: 1 ] }
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, Field(bid, 6:Int32) as $expr9, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 2, DynamicFilterRight: 3 ] }
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamRowIdGen { row_id_index: 5 }
        │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 4 ] }
        └── StreamExchange Broadcast from 2

    Fragment 2
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 5 ] }

    Table 0 { columns: [ $expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr9, $expr1, _row_id, row_number, _rw_timestamp ], primary key: [ $0 ASC, $2 DESC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr9, $expr1, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 DESC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 5 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ auction, bidder, price, channel, url, date_time, extra, p_time, _row_id, rank_number, _rw_timestamp ], primary key: [ $0 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

- id: nexmark_q20
  before:
  - create_sources
  sql: |
    SELECT
        auction, bidder, price, channel, url, B.date_time as date_timeB,
        item_name, description, initial_bid, reserve, A.date_time as date_timeA, expires, seller, category
    FROM
        bid B INNER JOIN auction A on B.auction = A.id
    WHERE A.category = 10;
  stream_plan: |-
    StreamMaterialize { columns: [auction, bidder, price, channel, url, date_timeb, item_name, description, initial_bid, reserve, date_timea, expires, seller, category, _row_id(hidden), _row_id#1(hidden)], stream_key: [_row_id, _row_id#1, auction], pk_columns: [_row_id, _row_id#1, auction], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard($expr3, _row_id, _row_id) }
      └─StreamHashJoin { type: Inner, predicate: $expr3 = $expr9, output: [$expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr10, $expr11, $expr12, $expr13, $expr14, $expr15, $expr16, $expr17, _row_id, _row_id] }
        ├─StreamExchange { dist: HashShard($expr3) }
        │ └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, _row_id] }
        │   └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        │     ├─StreamFilter { predicate: (event_type = 2:Int32) }
        │     │ └─StreamShare { id: 5 }
        │     │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
        │     │     └─StreamFilter { predicate: ((event_type = 2:Int32) OR ((Field(auction, 8:Int32) = 10:Int32) AND (event_type = 1:Int32))) }
        │     │       └─StreamRowIdGen { row_id_index: 5 }
        │     │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │     │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
        │     └─StreamExchange { dist: Broadcast }
        │       └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
        │         └─StreamNow { output: [now] }
        └─StreamExchange { dist: HashShard($expr9) }
          └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr9, Field(auction, 1:Int32) as $expr10, Field(auction, 2:Int32) as $expr11, Field(auction, 3:Int32) as $expr12, Field(auction, 4:Int32) as $expr13, Field(auction, 5:Int32) as $expr14, Field(auction, 6:Int32) as $expr15, Field(auction, 7:Int32) as $expr16, Field(auction, 8:Int32) as $expr17, _row_id] }
            └─StreamFilter { predicate: (Field(auction, 8:Int32) = 10:Int32) AND (event_type = 1:Int32) }
              └─StreamShare { id: 5 }
                └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                  └─StreamFilter { predicate: ((event_type = 2:Int32) OR ((Field(auction, 8:Int32) = 10:Int32) AND (event_type = 1:Int32))) }
                    └─StreamRowIdGen { row_id_index: 5 }
                      └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                        └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, bidder, price, channel, url, date_timeb, item_name, description, initial_bid, reserve, date_timea, expires, seller, category, _row_id(hidden), _row_id#1(hidden)], stream_key: [_row_id, _row_id#1, auction], pk_columns: [_row_id, _row_id#1, auction], pk_conflict: NoCheck }
    └── StreamExchange Hash([0, 14, 15]) from 1

    Fragment 1
    StreamHashJoin { type: Inner, predicate: $expr3 = $expr9, output: [$expr3, $expr4, $expr5, $expr6, $expr7, $expr8, $expr10, $expr11, $expr12, $expr13, $expr14, $expr15, $expr16, $expr17, _row_id, _row_id] } { tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ] }
    ├── StreamExchange Hash([0]) from 2
    └── StreamExchange Hash([0]) from 5

    Fragment 2
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 4, DynamicFilterRight: 5 ] }
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 3
        └── StreamExchange Broadcast from 4

    Fragment 3
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 2:Int32) OR ((Field(auction, 8:Int32) = 10:Int32) AND (event_type = 1:Int32))) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 6 ] }

    Fragment 4
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 7 ] }

    Fragment 5
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr9, Field(auction, 1:Int32) as $expr10, Field(auction, 2:Int32) as $expr11, Field(auction, 3:Int32) as $expr12, Field(auction, 4:Int32) as $expr13, Field(auction, 5:Int32) as $expr14, Field(auction, 6:Int32) as $expr15, Field(auction, 7:Int32) as $expr16, Field(auction, 8:Int32) as $expr17, _row_id] }
    └── StreamFilter { predicate: (Field(auction, 8:Int32) = 10:Int32) AND (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 3

    Table 0 { columns: [ $expr3, $expr4, $expr5, $expr6, $expr7, $expr8, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $6 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr3, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr9, $expr10, $expr11, $expr12, $expr13, $expr14, $expr15, $expr16, $expr17, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr9, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 4 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 6 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 7 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ auction, bidder, price, channel, url, date_timeb, item_name, description, initial_bid, reserve, date_timea, expires, seller, category, _row_id, _row_id#1, _rw_timestamp ]
    ├── primary key: [ $14 ASC, $15 ASC, $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]
    ├── distribution key: [ 0, 14, 15 ]
    └── read pk prefix len hint: 3

- id: nexmark_q21
  before:
  - create_sources
  sql: |
    SELECT
        auction, bidder, price, channel,
        CASE
            WHEN lower(channel) = 'apple' THEN '0'
            WHEN lower(channel) = 'google' THEN '1'
            WHEN lower(channel) = 'facebook' THEN '2'
            WHEN lower(channel) = 'baidu' THEN '3'
            ELSE REGEXP_MATCH(url, '(&|^)channel_id=([^&]*)')[2]
            END
        AS channel_id FROM bid
        where REGEXP_MATCH(url, '(&|^)channel_id=([^&]*)')[2] is not null or
              lower(channel) in ('apple', 'google', 'facebook', 'baidu');
  stream_plan: |-
    StreamMaterialize { columns: [auction, bidder, price, channel, channel_id, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr3, $expr4, $expr5, $expr6, Case((Lower($expr6) = 'apple':Varchar), '0':Varchar, (Lower($expr6) = 'google':Varchar), '1':Varchar, (Lower($expr6) = 'facebook':Varchar), '2':Varchar, (Lower($expr6) = 'baidu':Varchar), '3':Varchar, ArrayAccess(RegexpMatch($expr7, '(&|^)channel_id=([^&]*)':Varchar), 2:Int32)) as $expr8, _row_id] }
      └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, _row_id] }
        └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
          ├─StreamFilter { predicate: (IsNotNull(ArrayAccess(RegexpMatch(Field(bid, 4:Int32), '(&|^)channel_id=([^&]*)':Varchar), 2:Int32)) OR In(Lower(Field(bid, 3:Int32)), 'apple':Varchar, 'google':Varchar, 'facebook':Varchar, 'baidu':Varchar)) AND (event_type = 2:Int32) }
          │ └─StreamRowIdGen { row_id_index: 5 }
          │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
          │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
          └─StreamExchange { dist: Broadcast }
            └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
              └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, bidder, price, channel, channel_id, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr3, $expr4, $expr5, $expr6, Case((Lower($expr6) = 'apple':Varchar), '0':Varchar, (Lower($expr6) = 'google':Varchar), '1':Varchar, (Lower($expr6) = 'facebook':Varchar), '2':Varchar, (Lower($expr6) = 'baidu':Varchar), '3':Varchar, ArrayAccess(RegexpMatch($expr7, '(&|^)channel_id=([^&]*)':Varchar), 2:Int32)) as $expr8, _row_id] }
        └── StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, _row_id] }
            └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true } { tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ] }
                ├── StreamFilter { predicate: (IsNotNull(ArrayAccess(RegexpMatch(Field(bid, 4:Int32), '(&|^)channel_id=([^&]*)':Varchar), 2:Int32)) OR In(Lower(Field(bid, 3:Int32)), 'apple':Varchar, 'google':Varchar, 'facebook':Varchar, 'baidu':Varchar)) AND (event_type = 2:Int32) }
                │   └── StreamRowIdGen { row_id_index: 5 }
                │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 2 ] }
                └── StreamExchange Broadcast from 1

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 3 ] }

    Table 0 { columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 3 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ auction, bidder, price, channel, channel_id, _row_id, _rw_timestamp ], primary key: [ $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

- id: nexmark_q22
  before:
  - create_sources
  sql: |
    SELECT
        auction, bidder, price, channel,
        SPLIT_PART(url, '/', 4) as dir1,
        SPLIT_PART(url, '/', 5) as dir2,
        SPLIT_PART(url, '/', 6) as dir3 FROM bid;
  stream_plan: |-
    StreamMaterialize { columns: [auction, bidder, price, channel, dir1, dir2, dir3, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr3, $expr4, $expr5, $expr6, SplitPart($expr7, '/':Varchar, 4:Int32) as $expr8, SplitPart($expr7, '/':Varchar, 5:Int32) as $expr9, SplitPart($expr7, '/':Varchar, 6:Int32) as $expr10, _row_id] }
      └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, _row_id] }
        └─StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
          ├─StreamFilter { predicate: (event_type = 2:Int32) }
          │ └─StreamRowIdGen { row_id_index: 5 }
          │   └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
          │     └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
          └─StreamExchange { dist: Broadcast }
            └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
              └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction, bidder, price, channel, dir1, dir2, dir3, _row_id(hidden)], stream_key: [_row_id], pk_columns: [_row_id], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr3, $expr4, $expr5, $expr6, SplitPart($expr7, '/':Varchar, 4:Int32) as $expr8, SplitPart($expr7, '/':Varchar, 5:Int32) as $expr9, SplitPart($expr7, '/':Varchar, 6:Int32) as $expr10, _row_id] }
        └── StreamProject { exprs: [Field(bid, 0:Int32) as $expr3, Field(bid, 1:Int32) as $expr4, Field(bid, 2:Int32) as $expr5, Field(bid, 3:Int32) as $expr6, Field(bid, 4:Int32) as $expr7, _row_id] }
            └── StreamDynamicFilter { predicate: ($expr1 > $expr2), output_watermarks: [[$expr1]], output: [event_type, person, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                ├── tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ]
                ├── StreamFilter { predicate: (event_type = 2:Int32) }
                │   └── StreamRowIdGen { row_id_index: 5 }
                │       └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                │           └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 2 ] }
                └── StreamExchange Broadcast from 1

    Fragment 1
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr2], output_watermarks: [[$expr2]] }
    └── StreamNow { output: [now] } { tables: [ Now: 3 ] }

    Table 0 { columns: [ event_type, person, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr2, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 3 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ auction, bidder, price, channel, dir1, dir2, dir3, _row_id, _rw_timestamp ]
    ├── primary key: [ $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ]
    ├── distribution key: [ 7 ]
    └── read pk prefix len hint: 1

- id: nexmark_q101
  before:
  - create_sources
  sql: |
    -- A self-made query that covers outer join.
    --
    -- Monitor ongoing auctions and track the current highest bid for each one in real-time. If
    -- the auction has no bids, the highest bid will be NULL.
    SELECT
        a.id AS auction_id,
        a.item_name AS auction_item_name,
        b.max_price AS current_highest_bid
    FROM auction a
    LEFT OUTER JOIN (
        SELECT
            b1.auction,
            MAX(b1.price) max_price
        FROM bid b1
        GROUP BY b1.auction
    ) b ON a.id = b.auction;
  stream_plan: |-
    StreamMaterialize { columns: [auction_id, auction_item_name, current_highest_bid, _row_id(hidden), $expr5(hidden)], stream_key: [_row_id, auction_id], pk_columns: [_row_id, auction_id], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard($expr2, _row_id) }
      └─StreamHashJoin { type: LeftOuter, predicate: $expr2 = $expr5, output: [$expr2, $expr3, max($expr6), _row_id, $expr5] }
        ├─StreamExchange { dist: HashShard($expr2) }
        │ └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
        │   └─StreamFilter { predicate: (event_type = 1:Int32) }
        │     └─StreamShare { id: 5 }
        │       └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
        │         └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        │           └─StreamRowIdGen { row_id_index: 5 }
        │             └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │               └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
        └─StreamProject { exprs: [$expr5, max($expr6)] }
          └─StreamHashAgg { group_key: [$expr5], aggs: [max($expr6), count] }
            └─StreamExchange { dist: HashShard($expr5) }
              └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, Field(bid, 2:Int32) as $expr6, _row_id] }
                └─StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                  ├─StreamFilter { predicate: (event_type = 2:Int32) }
                  │ └─StreamShare { id: 5 }
                  │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                  │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                  │       └─StreamRowIdGen { row_id_index: 5 }
                  │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                  │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                  └─StreamExchange { dist: Broadcast }
                    └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
                      └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction_id, auction_item_name, current_highest_bid, _row_id(hidden), $expr5(hidden)], stream_key: [_row_id, auction_id], pk_columns: [_row_id, auction_id], pk_conflict: NoCheck }
    └── StreamExchange Hash([0, 3]) from 1

    Fragment 1
    StreamHashJoin { type: LeftOuter, predicate: $expr2 = $expr5, output: [$expr2, $expr3, max($expr6), _row_id, $expr5] }
    ├── tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ]
    ├── StreamExchange Hash([0]) from 2
    └── StreamProject { exprs: [$expr5, max($expr6)] }
        └── StreamHashAgg { group_key: [$expr5], aggs: [max($expr6), count] } { tables: [ HashAggState: 6, HashAggCall0: 5 ] }
            └── StreamExchange Hash([0]) from 4

    Fragment 2
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
    └── StreamFilter { predicate: (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 3

    Fragment 3
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 4 ] }

    Fragment 4
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, Field(bid, 2:Int32) as $expr6, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 7, DynamicFilterRight: 8 ]
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 3
        └── StreamExchange Broadcast from 5

    Fragment 5
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
    └── StreamNow { output: [now] } { tables: [ Now: 9 ] }

    Table 0 { columns: [ $expr2, $expr3, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ $expr2, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ $expr5, max($expr6), _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr5, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 5 { columns: [ $expr5, $expr6, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 DESC, $2 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ $expr5, max($expr6), count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ], primary key: [ $3 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 4 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ $expr4, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 9 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ auction_id, auction_item_name, current_highest_bid, _row_id, $expr5, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $0 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 0, 3 ]
    └── read pk prefix len hint: 2

- id: nexmark_q102
  before:
  - create_sources
  sql: |
    -- A self-made query that covers dynamic filter.
    --
    -- Show the auctions whose count of bids is greater than the overall average count of bids
    -- per auction.
    SELECT
        a.id AS auction_id,
        a.item_name AS auction_item_name,
        COUNT(b.auction) AS bid_count
    FROM auction a
    JOIN bid b ON a.id = b.auction
    GROUP BY a.id, a.item_name
    HAVING COUNT(b.auction) >= (
        SELECT COUNT(*) / COUNT(DISTINCT auction) FROM bid
    )
  stream_plan: |-
    StreamMaterialize { columns: [auction_id, auction_item_name, bid_count], stream_key: [auction_id, auction_item_name], pk_columns: [auction_id, auction_item_name], pk_conflict: NoCheck }
    └─StreamDynamicFilter { predicate: (count($expr5) >= $expr6), output: [$expr2, $expr3, count($expr5)] }
      ├─StreamProject { exprs: [$expr2, $expr3, count($expr5)] }
      │ └─StreamHashAgg { group_key: [$expr2, $expr3], aggs: [count($expr5), count] }
      │   └─StreamHashJoin { type: Inner, predicate: $expr2 = $expr5, output: [$expr2, $expr3, $expr5, _row_id, _row_id] }
      │     ├─StreamExchange { dist: HashShard($expr2) }
      │     │ └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
      │     │   └─StreamFilter { predicate: (event_type = 1:Int32) }
      │     │     └─StreamShare { id: 5 }
      │     │       └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
      │     │         └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
      │     │           └─StreamRowIdGen { row_id_index: 5 }
      │     │             └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
      │     │               └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
      │     └─StreamExchange { dist: HashShard($expr5) }
      │       └─StreamShare { id: 14 }
      │         └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, _row_id] }
      │           └─StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
      │             ├─StreamFilter { predicate: (event_type = 2:Int32) }
      │             │ └─StreamShare { id: 5 }
      │             │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
      │             │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
      │             │       └─StreamRowIdGen { row_id_index: 5 }
      │             │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
      │             │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
      │             └─StreamExchange { dist: Broadcast }
      │               └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
      │                 └─StreamNow { output: [now] }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [(sum0(sum0(count)) / sum0(count($expr5))) as $expr6] }
          └─StreamSimpleAgg { aggs: [sum0(sum0(count)), sum0(count($expr5)), count] }
            └─StreamExchange { dist: Single }
              └─StreamStatelessSimpleAgg { aggs: [sum0(count), count($expr5)] }
                └─StreamHashAgg { group_key: [$expr5], aggs: [count] }
                  └─StreamExchange { dist: HashShard($expr5) }
                    └─StreamShare { id: 14 }
                      └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, _row_id] }
                        └─StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                          ├─StreamFilter { predicate: (event_type = 2:Int32) }
                          │ └─StreamShare { id: 5 }
                          │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                          │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                          │       └─StreamRowIdGen { row_id_index: 5 }
                          │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                          │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                          └─StreamExchange { dist: Broadcast }
                            └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
                              └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction_id, auction_item_name, bid_count], stream_key: [auction_id, auction_item_name], pk_columns: [auction_id, auction_item_name], pk_conflict: NoCheck }
    └── StreamDynamicFilter { predicate: (count($expr5) >= $expr6), output: [$expr2, $expr3, count($expr5)] } { tables: [ DynamicFilterLeft: 0, DynamicFilterRight: 1 ] }
        ├── StreamProject { exprs: [$expr2, $expr3, count($expr5)] }
        │   └── StreamHashAgg { group_key: [$expr2, $expr3], aggs: [count($expr5), count] } { tables: [ HashAggState: 2 ] }
        │       └── StreamHashJoin { type: Inner, predicate: $expr2 = $expr5, output: [$expr2, $expr3, $expr5, _row_id, _row_id] }
        │           ├── tables: [ HashJoinLeft: 3, HashJoinDegreeLeft: 4, HashJoinRight: 5, HashJoinDegreeRight: 6 ]
        │           ├── StreamExchange Hash([0]) from 1
        │           └── StreamExchange Hash([0]) from 3
        └── StreamExchange Broadcast from 6

    Fragment 1
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
    └── StreamFilter { predicate: (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 2

    Fragment 2
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 7 ] }

    Fragment 3
    StreamNoOp
    └── StreamExchange NoShuffle from 4

    Fragment 4
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 8, DynamicFilterRight: 9 ]
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 2
        └── StreamExchange Broadcast from 5

    Fragment 5
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
    └── StreamNow { output: [now] } { tables: [ Now: 10 ] }

    Fragment 6
    StreamProject { exprs: [(sum0(sum0(count)) / sum0(count($expr5))) as $expr6] }
    └── StreamSimpleAgg { aggs: [sum0(sum0(count)), sum0(count($expr5)), count] } { tables: [ SimpleAggState: 11 ] }
        └── StreamExchange Single from 7

    Fragment 7
    StreamStatelessSimpleAgg { aggs: [sum0(count), count($expr5)] }
    └── StreamHashAgg { group_key: [$expr5], aggs: [count] } { tables: [ HashAggState: 12 ] }
        └── StreamExchange Hash([0]) from 8

    Fragment 8
    StreamNoOp
    └── StreamExchange NoShuffle from 4

    Table 0
    ├── columns: [ $expr2, $expr3, count($expr5), _rw_timestamp ]
    ├── primary key: [ $2 ASC, $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1 { columns: [ $expr6, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ $expr2, $expr3, count($expr5), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 2, 3 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 2

    Table 3 { columns: [ $expr2, $expr3, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ $expr2, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ $expr5, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ $expr5, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 8
    ├── columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 4 ]
    └── read pk prefix len hint: 1

    Table 9 { columns: [ $expr4, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 10 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 11 { columns: [ sum0(sum0(count)), sum0(count($expr5)), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1, 2 ], distribution key: [], read pk prefix len hint: 0 }

    Table 12 { columns: [ $expr5, count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4294967294
    ├── columns: [ auction_id, auction_item_name, bid_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 2

- id: nexmark_q103
  before:
  - create_sources
  sql: |
    -- A self-made query that covers semi join.
    --
    -- Show the auctions that have at least 20 bids.
    SELECT
        a.id AS auction_id,
        a.item_name AS auction_item_name
    FROM auction a
    WHERE a.id IN (
        SELECT b.auction FROM bid b
        GROUP BY b.auction
        HAVING COUNT(*) >= 20
    );
  stream_plan: |-
    StreamMaterialize { columns: [auction_id, auction_item_name, _row_id(hidden)], stream_key: [_row_id, auction_id], pk_columns: [_row_id, auction_id], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard($expr2, _row_id) }
      └─StreamHashJoin { type: LeftSemi, predicate: $expr2 = $expr5, output: all }
        ├─StreamExchange { dist: HashShard($expr2) }
        │ └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
        │   └─StreamFilter { predicate: (event_type = 1:Int32) }
        │     └─StreamShare { id: 5 }
        │       └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
        │         └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        │           └─StreamRowIdGen { row_id_index: 5 }
        │             └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │               └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
        └─StreamProject { exprs: [$expr5] }
          └─StreamFilter { predicate: (count >= 20:Int32) }
            └─StreamHashAgg { group_key: [$expr5], aggs: [count] }
              └─StreamExchange { dist: HashShard($expr5) }
                └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, _row_id] }
                  └─StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                    ├─StreamFilter { predicate: (event_type = 2:Int32) }
                    │ └─StreamShare { id: 5 }
                    │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                    │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                    │       └─StreamRowIdGen { row_id_index: 5 }
                    │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                    │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                    └─StreamExchange { dist: Broadcast }
                      └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
                        └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction_id, auction_item_name, _row_id(hidden)], stream_key: [_row_id, auction_id], pk_columns: [_row_id, auction_id], pk_conflict: NoCheck }
    └── StreamExchange Hash([0, 2]) from 1

    Fragment 1
    StreamHashJoin { type: LeftSemi, predicate: $expr2 = $expr5, output: all }
    ├── tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ]
    ├── StreamExchange Hash([0]) from 2
    └── StreamProject { exprs: [$expr5] }
        └── StreamFilter { predicate: (count >= 20:Int32) }
            └── StreamHashAgg { group_key: [$expr5], aggs: [count] } { tables: [ HashAggState: 5 ] }
                └── StreamExchange Hash([0]) from 4

    Fragment 2
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
    └── StreamFilter { predicate: (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 3

    Fragment 3
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 4 ] }

    Fragment 4
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 6, DynamicFilterRight: 7 ]
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 3
        └── StreamExchange Broadcast from 5

    Fragment 5
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
    └── StreamNow { output: [now] } { tables: [ Now: 8 ] }

    Table 0
    ├── columns: [ $expr2, $expr3, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $2 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1
    ├── columns: [ $expr2, _row_id, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 2 { columns: [ $expr5, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr5, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 5 { columns: [ $expr5, count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6
    ├── columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 4 ]
    └── read pk prefix len hint: 1

    Table 7 { columns: [ $expr4, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 8 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ auction_id, auction_item_name, _row_id, _rw_timestamp ]
    ├── primary key: [ $2 ASC, $0 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0, 2 ]
    └── read pk prefix len hint: 2

- id: nexmark_q104
  before:
  - create_sources
  sql: |
    -- A self-made query that covers anti join.
    --
    -- This is the same as q103, which shows the auctions that have at least 20 bids.
    SELECT
        a.id AS auction_id,
        a.item_name AS auction_item_name
    FROM auction a
    WHERE a.id NOT IN (
        SELECT b.auction FROM bid b
        GROUP BY b.auction
        HAVING COUNT(*) < 20
    );
  stream_plan: |-
    StreamMaterialize { columns: [auction_id, auction_item_name, _row_id(hidden)], stream_key: [_row_id, auction_id], pk_columns: [_row_id, auction_id], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard($expr2, _row_id) }
      └─StreamHashJoin { type: LeftAnti, predicate: $expr2 = $expr5, output: all }
        ├─StreamExchange { dist: HashShard($expr2) }
        │ └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
        │   └─StreamFilter { predicate: (event_type = 1:Int32) }
        │     └─StreamShare { id: 5 }
        │       └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
        │         └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        │           └─StreamRowIdGen { row_id_index: 5 }
        │             └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
        │               └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
        └─StreamProject { exprs: [$expr5] }
          └─StreamFilter { predicate: (count < 20:Int32) }
            └─StreamHashAgg { group_key: [$expr5], aggs: [count] }
              └─StreamExchange { dist: HashShard($expr5) }
                └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, _row_id] }
                  └─StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                    ├─StreamFilter { predicate: (event_type = 2:Int32) }
                    │ └─StreamShare { id: 5 }
                    │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                    │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                    │       └─StreamRowIdGen { row_id_index: 5 }
                    │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                    │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                    └─StreamExchange { dist: Broadcast }
                      └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
                        └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction_id, auction_item_name, _row_id(hidden)], stream_key: [_row_id, auction_id], pk_columns: [_row_id, auction_id], pk_conflict: NoCheck }
    └── StreamExchange Hash([0, 2]) from 1

    Fragment 1
    StreamHashJoin { type: LeftAnti, predicate: $expr2 = $expr5, output: all }
    ├── tables: [ HashJoinLeft: 0, HashJoinDegreeLeft: 1, HashJoinRight: 2, HashJoinDegreeRight: 3 ]
    ├── StreamExchange Hash([0]) from 2
    └── StreamProject { exprs: [$expr5] }
        └── StreamFilter { predicate: (count < 20:Int32) }
            └── StreamHashAgg { group_key: [$expr5], aggs: [count] } { tables: [ HashAggState: 5 ] }
                └── StreamExchange Hash([0]) from 4

    Fragment 2
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
    └── StreamFilter { predicate: (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 3

    Fragment 3
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 4 ] }

    Fragment 4
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 6, DynamicFilterRight: 7 ]
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 3
        └── StreamExchange Broadcast from 5

    Fragment 5
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
    └── StreamNow { output: [now] } { tables: [ Now: 8 ] }

    Table 0
    ├── columns: [ $expr2, $expr3, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $2 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1
    ├── columns: [ $expr2, _row_id, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 2 { columns: [ $expr5, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ $expr5, _degree, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 5 { columns: [ $expr5, count, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6
    ├── columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 4 ]
    └── read pk prefix len hint: 1

    Table 7 { columns: [ $expr4, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 8 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ auction_id, auction_item_name, _row_id, _rw_timestamp ]
    ├── primary key: [ $2 ASC, $0 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0, 2 ]
    └── read pk prefix len hint: 2

- id: nexmark_q105
  before:
  - create_sources
  sql: |
    -- A self-made query that covers singleton top-n (and local-phase group top-n).
    --
    -- Show the top 1000 auctions by the number of bids.
    SELECT
        a.id AS auction_id,
        a.item_name AS auction_item_name,
        COUNT(b.auction) AS bid_count
    FROM auction a
    JOIN bid b ON a.id = b.auction
    GROUP BY a.id, a.item_name
    ORDER BY bid_count DESC
    LIMIT 1000;
  stream_plan: |-
    StreamMaterialize { columns: [auction_id, auction_item_name, bid_count], stream_key: [auction_id, auction_item_name], pk_columns: [bid_count, auction_id, auction_item_name], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr2, $expr3, count($expr5)] }
      └─StreamTopN { order: [count($expr5) DESC], limit: 1000, offset: 0 }
        └─StreamExchange { dist: Single }
          └─StreamGroupTopN { order: [count($expr5) DESC], limit: 1000, offset: 0, group_key: [$expr6] }
            └─StreamProject { exprs: [$expr2, $expr3, count($expr5), Vnode($expr2) as $expr6] }
              └─StreamHashAgg { group_key: [$expr2, $expr3], aggs: [count($expr5), count] }
                └─StreamHashJoin { type: Inner, predicate: $expr2 = $expr5, output: [$expr2, $expr3, $expr5, _row_id, _row_id] }
                  ├─StreamExchange { dist: HashShard($expr2) }
                  │ └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
                  │   └─StreamFilter { predicate: (event_type = 1:Int32) }
                  │     └─StreamShare { id: 5 }
                  │       └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                  │         └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                  │           └─StreamRowIdGen { row_id_index: 5 }
                  │             └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                  │               └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                  └─StreamExchange { dist: HashShard($expr5) }
                    └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, _row_id] }
                      └─StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                        ├─StreamFilter { predicate: (event_type = 2:Int32) }
                        │ └─StreamShare { id: 5 }
                        │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                        │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                        │       └─StreamRowIdGen { row_id_index: 5 }
                        │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                        │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                        └─StreamExchange { dist: Broadcast }
                          └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
                            └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [auction_id, auction_item_name, bid_count], stream_key: [auction_id, auction_item_name], pk_columns: [bid_count, auction_id, auction_item_name], pk_conflict: NoCheck }
    └── StreamProject { exprs: [$expr2, $expr3, count($expr5)] }
        └── StreamTopN { order: [count($expr5) DESC], limit: 1000, offset: 0 } { tables: [ TopN: 0 ] }
            └── StreamExchange Single from 1

    Fragment 1
    StreamGroupTopN { order: [count($expr5) DESC], limit: 1000, offset: 0, group_key: [$expr6] } { tables: [ GroupTopN: 1 ] }
    └── StreamProject { exprs: [$expr2, $expr3, count($expr5), Vnode($expr2) as $expr6] }
        └── StreamHashAgg { group_key: [$expr2, $expr3], aggs: [count($expr5), count] } { tables: [ HashAggState: 2 ] }
            └── StreamHashJoin { type: Inner, predicate: $expr2 = $expr5, output: [$expr2, $expr3, $expr5, _row_id, _row_id] }
                ├── tables: [ HashJoinLeft: 3, HashJoinDegreeLeft: 4, HashJoinRight: 5, HashJoinDegreeRight: 6 ]
                ├── StreamExchange Hash([0]) from 2
                └── StreamExchange Hash([0]) from 4

    Fragment 2
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 1:Int32) as $expr3, _row_id] }
    └── StreamFilter { predicate: (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 3

    Fragment 3
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 7 ] }

    Fragment 4
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr5, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr4), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 8, DynamicFilterRight: 9 ]
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 3
        └── StreamExchange Broadcast from 5

    Fragment 5
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr4], output_watermarks: [[$expr4]] }
    └── StreamNow { output: [now] } { tables: [ Now: 10 ] }

    Table 0
    ├── columns: [ $expr2, $expr3, count($expr5), $expr6, _rw_timestamp ]
    ├── primary key: [ $2 DESC, $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 1
    ├── columns: [ $expr2, $expr3, count($expr5), $expr6, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $2 DESC, $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 3

    Table 2 { columns: [ $expr2, $expr3, count($expr5), count, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 3 { columns: [ $expr2, $expr3, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ $expr2, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ $expr5, _row_id, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ $expr5, _row_id, _degree, _rw_timestamp ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 8
    ├── columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 4 ]
    └── read pk prefix len hint: 1

    Table 9 { columns: [ $expr4, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 10 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294
    ├── columns: [ auction_id, auction_item_name, bid_count, _rw_timestamp ]
    ├── primary key: [ $2 DESC, $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 3

- id: nexmark_q106
  before:
  - create_sources
  sql: |
    -- A self-made query that covers two-phase stateful simple aggregation.
    --
    -- Show the minimum final price of all auctions.
    SELECT
        MIN(final) AS min_final
    FROM
        (
            SELECT
                auction.id,
                MAX(price) AS final
            FROM
                auction,
                bid
            WHERE
                bid.auction = auction.id
                AND bid.date_time BETWEEN auction.date_time AND auction.expires
            GROUP BY
                auction.id
        )
  stream_plan: |-
    StreamMaterialize { columns: [min_final], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └─StreamProject { exprs: [min(min(max($expr7)))] }
      └─StreamSimpleAgg { aggs: [min(min(max($expr7))), count] }
        └─StreamExchange { dist: Single }
          └─StreamHashAgg { group_key: [$expr9], aggs: [min(max($expr7)), count] }
            └─StreamProject { exprs: [$expr2, max($expr7), Vnode($expr2) as $expr9] }
              └─StreamHashAgg { group_key: [$expr2], aggs: [max($expr7), count] }
                └─StreamProject { exprs: [$expr2, $expr7, _row_id, _row_id] }
                  └─StreamFilter { predicate: ($expr8 >= $expr3) AND ($expr8 <= $expr4) }
                    └─StreamHashJoin { type: Inner, predicate: $expr2 = $expr6, output: all }
                      ├─StreamExchange { dist: HashShard($expr2) }
                      │ └─StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 5:Int32) as $expr3, Field(auction, 6:Int32) as $expr4, _row_id] }
                      │   └─StreamFilter { predicate: (event_type = 1:Int32) }
                      │     └─StreamShare { id: 5 }
                      │       └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                      │         └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                      │           └─StreamRowIdGen { row_id_index: 5 }
                      │             └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                      │               └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                      └─StreamExchange { dist: HashShard($expr6) }
                        └─StreamProject { exprs: [Field(bid, 0:Int32) as $expr6, Field(bid, 2:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, _row_id] }
                          └─StreamDynamicFilter { predicate: ($expr1 > $expr5), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
                            ├─StreamFilter { predicate: (event_type = 2:Int32) }
                            │ └─StreamShare { id: 5 }
                            │   └─StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
                            │     └─StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
                            │       └─StreamRowIdGen { row_id_index: 5 }
                            │         └─StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                            │           └─StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] }
                            └─StreamExchange { dist: Broadcast }
                              └─StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr5], output_watermarks: [[$expr5]] }
                                └─StreamNow { output: [now] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [min_final], stream_key: [], pk_columns: [], pk_conflict: NoCheck }
    └── StreamProject { exprs: [min(min(max($expr7)))] }
        └── StreamSimpleAgg { aggs: [min(min(max($expr7))), count] }
            ├── tables: [ SimpleAggState: 1, SimpleAggCall0: 0 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamHashAgg { group_key: [$expr9], aggs: [min(max($expr7)), count] }
    ├── tables: [ HashAggState: 3, HashAggCall0: 2 ]
    └── StreamProject { exprs: [$expr2, max($expr7), Vnode($expr2) as $expr9] }
        └── StreamHashAgg { group_key: [$expr2], aggs: [max($expr7), count] }
            ├── tables: [ HashAggState: 5, HashAggCall0: 4 ]
            └── StreamProject { exprs: [$expr2, $expr7, _row_id, _row_id] }
                └── StreamFilter { predicate: ($expr8 >= $expr3) AND ($expr8 <= $expr4) }
                    └── StreamHashJoin { type: Inner, predicate: $expr2 = $expr6, output: all }
                        ├── tables:
                        │   ┌── HashJoinLeft: 6
                        │   ├── HashJoinDegreeLeft: 7
                        │   ├── HashJoinRight: 8
                        │   └── HashJoinDegreeRight: 9
                        ├── StreamExchange Hash([0]) from 2
                        └── StreamExchange Hash([0]) from 4

    Fragment 2
    StreamProject { exprs: [Field(auction, 0:Int32) as $expr2, Field(auction, 5:Int32) as $expr3, Field(auction, 6:Int32) as $expr4, _row_id] }
    └── StreamFilter { predicate: (event_type = 1:Int32) }
        └── StreamExchange NoShuffle from 3

    Fragment 3
    StreamProject { exprs: [event_type, auction, bid, $expr1, _row_id], output_watermarks: [[$expr1]] }
    └── StreamFilter { predicate: ((event_type = 1:Int32) OR (event_type = 2:Int32)) }
        └── StreamRowIdGen { row_id_index: 5 }
            └── StreamProject { exprs: [event_type, person, auction, bid, Proctime as $expr1, _row_id], output_watermarks: [[$expr1]] }
                └── StreamSource { source: nexmark, columns: [event_type, person, auction, bid, _row_id] } { tables: [ Source: 10 ] }

    Fragment 4
    StreamProject { exprs: [Field(bid, 0:Int32) as $expr6, Field(bid, 2:Int32) as $expr7, Field(bid, 5:Int32) as $expr8, _row_id] }
    └── StreamDynamicFilter { predicate: ($expr1 > $expr5), output_watermarks: [[$expr1]], output: [event_type, auction, bid, $expr1, _row_id], cleaned_by_watermark: true }
        ├── tables: [ DynamicFilterLeft: 11, DynamicFilterRight: 12 ]
        ├── StreamFilter { predicate: (event_type = 2:Int32) }
        │   └── StreamExchange NoShuffle from 3
        └── StreamExchange Broadcast from 5

    Fragment 5
    StreamProject { exprs: [SubtractWithTimeZone(now, '00:05:00':Interval, 'UTC':Varchar) as $expr5], output_watermarks: [[$expr5]] }
    └── StreamNow { output: [now] } { tables: [ Now: 13 ] }

    Table 0
    ├── columns: [ min(max($expr7)), $expr9, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 1 { columns: [ min(min(max($expr7))), count, _rw_timestamp ], primary key: [], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ $expr9, max($expr7), $expr2, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 2 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3
    ├── columns: [ $expr9, min(max($expr7)), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: []
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4
    ├── columns: [ $expr2, $expr7, _row_id, _row_id_0, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 DESC, $2 ASC, $3 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 5
    ├── columns: [ $expr2, max($expr7), count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 6
    ├── columns: [ $expr2, $expr3, $expr4, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $3 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 7
    ├── columns: [ $expr2, _row_id, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 8
    ├── columns: [ $expr6, $expr7, $expr8, _row_id, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $3 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 9
    ├── columns: [ $expr6, _row_id, _degree, _rw_timestamp ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 10 { columns: [ partition_id, offset_info, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 11
    ├── columns: [ event_type, auction, bid, $expr1, _row_id, _rw_timestamp ]
    ├── primary key: [ $3 ASC, $4 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4 ]
    ├── distribution key: [ 4 ]
    └── read pk prefix len hint: 1

    Table 12 { columns: [ $expr5, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 13 { columns: [ now, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

    Table 4294967294 { columns: [ min_final, _rw_timestamp ], primary key: [], value indices: [ 0 ], distribution key: [], read pk prefix len hint: 0 }

