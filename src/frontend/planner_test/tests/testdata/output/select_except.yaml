# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: test basic except
  sql: |
    create table t (v1 int, v2 int, v3 int);
    select * except (v1, v2) from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: t, columns: [t.v3], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [v3, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamTableScan { table: t, columns: [t.v3, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: test multiple except
  sql: |
    create table t (v1 int, v2 int, v3 int);
    select * except (t.v1, t.v2), * except (v2, v3), * except (v1, v3) from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [t.v3, t.v1, t.v2] }
      └─BatchScan { table: t, columns: [t.v1, t.v2, t.v3], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [v3, v1, v2, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t.v3, t.v1, t.v2, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: except on join
  sql: |
    create table t (v1 int, v2 int, v3 int);
    select * except (a.v2, b.v1, b.v3) from t a join t b on a.v1 = b.v1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t.v1 = t.v1, output: [t.v1, t.v3, t.v2] }
      ├─BatchExchange { order: [], dist: HashShard(t.v1) }
      │ └─BatchScan { table: t, columns: [t.v1, t.v3], distribution: SomeShard }
      └─BatchExchange { order: [], dist: HashShard(t.v1) }
        └─BatchScan { table: t, columns: [t.v1, t.v2], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [v1, v3, v2, t._row_id(hidden), t._row_id#1(hidden)], stream_key: [t._row_id, t._row_id#1, v1], pk_columns: [t._row_id, t._row_id#1, v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t.v1, t._row_id, t._row_id) }
      └─StreamHashJoin { type: Inner, predicate: t.v1 = t.v1, output: [t.v1, t.v3, t.v2, t._row_id, t._row_id] }
        ├─StreamExchange { dist: HashShard(t.v1) }
        │ └─StreamTableScan { table: t, columns: [t.v1, t.v3, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        └─StreamExchange { dist: HashShard(t.v1) }
          └─StreamTableScan { table: t, columns: [t.v1, t.v2, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: qualified wildcard
  sql: |
    create table t (v1 int, v2 int, v3 int);
    select a.* except (a.v2, a.v3), b.* except (b.v1) from t a join t b on a.v1 = b.v1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t.v1 = t.v1, output: [t.v1, t.v2, t.v3] }
      ├─BatchExchange { order: [], dist: HashShard(t.v1) }
      │ └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
      └─BatchExchange { order: [], dist: HashShard(t.v1) }
        └─BatchScan { table: t, columns: [t.v1, t.v2, t.v3], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [v1, v2, v3, t._row_id(hidden), t._row_id#1(hidden)], stream_key: [t._row_id, t._row_id#1, v1], pk_columns: [t._row_id, t._row_id#1, v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(t.v1, t._row_id, t._row_id) }
      └─StreamHashJoin { type: Inner, predicate: t.v1 = t.v1, output: [t.v1, t.v2, t.v3, t._row_id, t._row_id] }
        ├─StreamExchange { dist: HashShard(t.v1) }
        │ └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        └─StreamExchange { dist: HashShard(t.v1) }
          └─StreamTableScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: except with unknown column
  sql: |
    create table t (v1 int, v2 int, v3 int);
    select * except (v1, v4) from t;
  binder_error: |
    Failed to bind expression: v4

    Caused by:
      Item not found: Invalid column: v4
- name: only allow using except with column name
  sql: |
    create table t (v1 int, v2 int, v3 int);
    select * except (1) from t;
  binder_error: 'Bind error: Only support column name in except list'
- name: ambiguous column
  sql: |
    create table t (v1 int, v2 int);
    select * except (v1) from t t1 cross join t t2
  binder_error: |
    Failed to bind expression: v1

    Caused by:
      internal error: Ambiguous column name: v1
