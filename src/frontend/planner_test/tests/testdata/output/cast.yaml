# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: implicit cast boolean (HAVING NULL)
  sql: |
    select 1 having NULL;
  batch_plan: |
    BatchProject { exprs: [1:Int32] }
    └─BatchFilter { predicate: null:Boolean }
      └─BatchSimpleAgg { aggs: [] }
        └─BatchValues { rows: [[]] }
- name: implicit cast boolean (WHERE NULL)
  sql: |
    select 1 where NULL;
  batch_plan: |
    BatchProject { exprs: [1:Int32] }
    └─BatchFilter { predicate: null:Boolean }
      └─BatchValues { rows: [[]] }
- name: implicit cast boolean (CASE NULL)
  sql: |
    select case when NULL then 1 end;
  batch_plan: |
    BatchValues { rows: [[null:Int32]] }
- name: implicit cast boolean (JOIN ON NULL)
  sql: |
    create table t1(v1 int);
    create table t2(v1 int);
    select t1.v1 from t1 join t2 on NULL;
  batch_plan: |
    BatchNestedLoopJoin { type: Inner, predicate: true, output: all }
    ├─BatchExchange { order: [], dist: Single }
    | └─BatchFilter { predicate: null:Boolean }
    |   └─BatchScan { table: t1, columns: [t1.v1], distribution: SomeShard }
    └─BatchExchange { order: [], dist: Single }
      └─BatchFilter { predicate: null:Boolean }
        └─BatchScan { table: t2, columns: [], distribution: SomeShard }
- name: current_schemas (current_schemas(NULL))
  sql: |
    select current_schemas(NULL);
  batch_plan: |
    BatchValues { rows: [[null:List(Varchar)]] }
- name: FILTER (FILTER NULL)
  sql: |
    create table t(v1 int);
    select count(*) FILTER(WHERE null) from t;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum0(count filter(null:Boolean))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count filter(null:Boolean)] }
        └─BatchScan { table: t, columns: [], distribution: SomeShard }
- name: implicit cast boolean (HAVING with literal 'y' of unknown type)
  sql: |
    select 1 having 'y';
  batch_plan: |
    BatchValues { rows: [[1:Int32]] }
- name: implicit cast boolean (WHERE with literal 'y' of unknown type)
  sql: |
    select 1 where 'y';
  batch_plan: |
    BatchValues { rows: [[1:Int32]] }
- name: implicit cast boolean (CASE with literal 'y' of unknown type)
  sql: |
    select case when 'y' then 1 end;
  batch_plan: |
    BatchValues { rows: [[1:Int32]] }
- name: implicit cast boolean (JOIN ON with literal 'y' of unknown type)
  sql: |
    create table t1(v1 int);
    create table t2(v1 int);
    select t1.v1 from t1 join t2 on 'y';
  batch_plan: |
    BatchNestedLoopJoin { type: Inner, predicate: true, output: all }
    ├─BatchExchange { order: [], dist: Single }
    | └─BatchScan { table: t1, columns: [t1.v1], distribution: SomeShard }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: t2, columns: [], distribution: SomeShard }
- name: current_schemas (CURRENT_SCHEMAS with literal 'y' of unknown type)
  sql: |
    select current_schemas('y');
  batch_plan: |
    BatchValues { rows: [[ARRAY[pg_catalog, public]:List(Varchar)]] }
- name: FILTER (FILTER with literal 'y' of unknown type)
  sql: |
    create table t(v1 int);
    select count(*) FILTER(WHERE 'y') from t;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum0(count)] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count] }
        └─BatchScan { table: t, columns: [], distribution: SomeShard }
