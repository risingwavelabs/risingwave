# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: explicit watermark definition + implicit proctime watermark
  sql: |
    create table t (
      foo int,
      event_time timestamp,
      proc_time timestamp as proctime(),
      watermark for event_time as event_time - interval '5 minutes'
    ) append only;
    select * from t;
  stream_plan: |-
    StreamMaterialize { columns: [foo, event_time, proc_time, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck, watermark_columns: [event_time, proc_time] }
    └─StreamTableScan { table: t, columns: [t.foo, t.event_time, t.proc_time, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [foo, event_time, proc_time, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck, watermark_columns: [event_time] }
    └─StreamEowcSort { sort_column: t.event_time }
      └─StreamTableScan { table: t, columns: [t.foo, t.event_time, t.proc_time, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: tumble window_start + window_end
  sql: |
    create table t (
      foo int,
      ts timestamp,
      watermark for ts as ts - interval '5 minutes'
    ) append only;
    select
      foo, window_start, window_end
    from tumble(t, ts, interval '1 hour');
  stream_plan: |-
    StreamMaterialize { columns: [foo, window_start, window_end, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck, watermark_columns: [window_start, window_end] }
    └─StreamProject { exprs: [t.foo, $expr1, ($expr1 + '01:00:00':Interval) as $expr2, t._row_id], output_watermarks: [[$expr1, $expr2]] }
      └─StreamProject { exprs: [t.foo, t.ts, TumbleStart(t.ts, '01:00:00':Interval) as $expr1, t._row_id], output_watermarks: [[t.ts, $expr1]] }
        └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [foo, window_start, window_end, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck, watermark_columns: [window_start] }
    └─StreamEowcSort { sort_column: $expr1 }
      └─StreamProject { exprs: [t.foo, $expr1, ($expr1 + '01:00:00':Interval) as $expr2, t._row_id], output_watermarks: [[$expr1, $expr2]] }
        └─StreamProject { exprs: [t.foo, t.ts, TumbleStart(t.ts, '01:00:00':Interval) as $expr1, t._row_id], output_watermarks: [[t.ts, $expr1]] }
          └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: hop window_start + window_end
  sql: |
    create table t (
      foo int,
      ts timestamp,
      watermark for ts as ts - interval '5 minutes'
    ) append only;
    select
      foo, window_start, window_end
    from hop(t, ts, interval '20 mins', interval '1 hour');
  stream_plan: |-
    StreamMaterialize { columns: [foo, window_start, window_end, t._row_id(hidden)], stream_key: [t._row_id, window_start, window_end], pk_columns: [t._row_id, window_start, window_end], pk_conflict: NoCheck, watermark_columns: [window_start, window_end] }
    └─StreamHopWindow { time_col: t.ts, slide: 00:20:00, size: 01:00:00, output: [t.foo, window_start, window_end, t._row_id], output_watermarks: [[window_start, window_end]] }
      └─StreamFilter { predicate: IsNotNull(t.ts) }
        └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [foo, window_start, window_end, t._row_id(hidden)], stream_key: [t._row_id, window_start, window_end], pk_columns: [t._row_id, window_start, window_end], pk_conflict: NoCheck, watermark_columns: [window_start] }
    └─StreamEowcSort { sort_column: window_start }
      └─StreamHopWindow { time_col: t.ts, slide: 00:20:00, size: 01:00:00, output: [t.foo, window_start, window_end, t._row_id], output_watermarks: [[window_start, window_end]] }
        └─StreamFilter { predicate: IsNotNull(t.ts) }
          └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: join window_start = window_start
  sql: |
    create table t (
      foo int,
      ts timestamp,
      watermark for ts as ts - interval '5 minutes'
    ) append only;
    select
      foo1 + foo2 as foo,
      win1, win2
    from (
      select foo as foo1, window_start as win1 from tumble(t, ts, interval '5 mins')
    )
    join (
      select foo + 1 as foo2, window_start as win2 from tumble(t, ts, interval '10 mins')
    )
    on win1 = win2;
  stream_plan: |-
    StreamMaterialize { columns: [foo, win1, win2, t._row_id(hidden), t._row_id#1(hidden)], stream_key: [t._row_id, t._row_id#1, win1], pk_columns: [t._row_id, t._row_id#1, win1], pk_conflict: NoCheck, watermark_columns: [win1, win2] }
    └─StreamProject { exprs: [(t.foo + $expr2) as $expr4, $expr1, $expr3, t._row_id, t._row_id], output_watermarks: [[$expr1], [$expr3]] }
      └─StreamHashJoin [window, append_only] { type: Inner, predicate: $expr1 = $expr3, output_watermarks: [[$expr1], [$expr3]], output: [t.foo, $expr1, $expr2, $expr3, t._row_id, t._row_id] }
        ├─StreamExchange { dist: HashShard($expr1) }
        │ └─StreamProject { exprs: [t.foo, TumbleStart(t.ts, '00:05:00':Interval) as $expr1, t._row_id], output_watermarks: [[$expr1]] }
        │   └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        └─StreamExchange { dist: HashShard($expr3) }
          └─StreamProject { exprs: [(t.foo + 1:Int32) as $expr2, TumbleStart(t.ts, '00:10:00':Interval) as $expr3, t._row_id], output_watermarks: [[$expr3]] }
            └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [foo, win1, win2, t._row_id(hidden), t._row_id#1(hidden)], stream_key: [t._row_id, t._row_id#1, win1], pk_columns: [t._row_id, t._row_id#1, win1], pk_conflict: NoCheck, watermark_columns: [win1] }
    └─StreamEowcSort { sort_column: $expr1 }
      └─StreamProject { exprs: [(t.foo + $expr2) as $expr4, $expr1, $expr3, t._row_id, t._row_id], output_watermarks: [[$expr1], [$expr3]] }
        └─StreamHashJoin [window, append_only] { type: Inner, predicate: $expr1 = $expr3, output_watermarks: [[$expr1], [$expr3]], output: [t.foo, $expr1, $expr2, $expr3, t._row_id, t._row_id] }
          ├─StreamExchange { dist: HashShard($expr1) }
          │ └─StreamProject { exprs: [t.foo, TumbleStart(t.ts, '00:05:00':Interval) as $expr1, t._row_id], output_watermarks: [[$expr1]] }
          │   └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
          └─StreamExchange { dist: HashShard($expr3) }
            └─StreamProject { exprs: [(t.foo + 1:Int32) as $expr2, TumbleStart(t.ts, '00:10:00':Interval) as $expr3, t._row_id], output_watermarks: [[$expr3]] }
              └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: join window_start = window_start, shared node
  sql: |
    create table t (
      foo int,
      ts timestamp,
      watermark for ts as ts - interval '5 minutes'
    ) append only;
    with ttt as (
      select * from t
    )
    select
      foo1 + foo2 as foo,
      win1, win2
    from (
      select foo as foo1, window_start as win1 from tumble(ttt, ts, interval '5 mins')
    )
    join (
      select foo + 1 as foo2, window_start as win2 from tumble(ttt, ts, interval '10 mins')
    )
    on win1 = win2;
  stream_plan: |-
    StreamMaterialize { columns: [foo, win1, win2, t._row_id(hidden), t._row_id#1(hidden)], stream_key: [t._row_id, t._row_id#1, win1], pk_columns: [t._row_id, t._row_id#1, win1], pk_conflict: NoCheck, watermark_columns: [win1, win2] }
    └─StreamProject { exprs: [(t.foo + $expr2) as $expr4, $expr1, $expr3, t._row_id, t._row_id], output_watermarks: [[$expr1, $expr3]] }
      └─StreamHashJoin [window, append_only] { type: Inner, predicate: $expr1 = $expr3, output_watermarks: [[$expr1, $expr3]], output: [t.foo, $expr1, $expr2, $expr3, t._row_id, t._row_id] }
        ├─StreamExchange { dist: HashShard($expr1) }
        │ └─StreamProject { exprs: [t.foo, TumbleStart(t.ts, '00:05:00':Interval) as $expr1, t._row_id], output_watermarks: [[$expr1]] }
        │   └─StreamShare { id: 1 }
        │     └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
        └─StreamExchange { dist: HashShard($expr3) }
          └─StreamProject { exprs: [(t.foo + 1:Int32) as $expr2, TumbleStart(t.ts, '00:10:00':Interval) as $expr3, t._row_id], output_watermarks: [[$expr3]] }
            └─StreamShare { id: 1 }
              └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [foo, win1, win2, t._row_id(hidden), t._row_id#1(hidden)], stream_key: [t._row_id, t._row_id#1, win1], pk_columns: [t._row_id, t._row_id#1, win1], pk_conflict: NoCheck, watermark_columns: [win1] }
    └─StreamEowcSort { sort_column: $expr1 }
      └─StreamProject { exprs: [(t.foo + $expr2) as $expr4, $expr1, $expr3, t._row_id, t._row_id], output_watermarks: [[$expr1, $expr3]] }
        └─StreamHashJoin [window, append_only] { type: Inner, predicate: $expr1 = $expr3, output_watermarks: [[$expr1, $expr3]], output: [t.foo, $expr1, $expr2, $expr3, t._row_id, t._row_id] }
          ├─StreamExchange { dist: HashShard($expr1) }
          │ └─StreamProject { exprs: [t.foo, TumbleStart(t.ts, '00:05:00':Interval) as $expr1, t._row_id], output_watermarks: [[$expr1]] }
          │   └─StreamShare { id: 1 }
          │     └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
          └─StreamExchange { dist: HashShard($expr3) }
            └─StreamProject { exprs: [(t.foo + 1:Int32) as $expr2, TumbleStart(t.ts, '00:10:00':Interval) as $expr3, t._row_id], output_watermarks: [[$expr3]] }
              └─StreamShare { id: 1 }
                └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
- name: group by tumble window_start + window_end
  sql: |
    create table t (
      foo int,
      ts timestamp,
      watermark for ts as ts - interval '5 minutes'
    ) append only;
    select
      window_start, window_end, count(foo) as count
    from tumble(t, ts, interval '1 hour')
    group by window_start, window_end;
  stream_plan: |-
    StreamMaterialize { columns: [window_start, window_end, count], stream_key: [window_start, window_end], pk_columns: [window_start, window_end], pk_conflict: NoCheck, watermark_columns: [window_start, window_end] }
    └─StreamProject { exprs: [$expr1, $expr2, count(t.foo)], output_watermarks: [[$expr1, $expr2]] }
      └─StreamHashAgg [append_only] { group_key: [$expr1, $expr2], aggs: [count(t.foo), count], output_watermarks: [[$expr1, $expr2]] }
        └─StreamExchange { dist: HashShard($expr1, $expr2) }
          └─StreamProject { exprs: [$expr1, ($expr1 + '01:00:00':Interval) as $expr2, t.foo, t._row_id], output_watermarks: [[$expr1, $expr2]] }
            └─StreamProject { exprs: [t.foo, t.ts, TumbleStart(t.ts, '01:00:00':Interval) as $expr1, t._row_id], output_watermarks: [[t.ts, $expr1]] }
              └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [window_start, window_end, count], stream_key: [window_start, window_end], pk_columns: [window_start, window_end], pk_conflict: NoCheck, watermark_columns: [window_start] }
    └─StreamProject { exprs: [$expr1, $expr2, count(t.foo)], output_watermarks: [[$expr1]] }
      └─StreamHashAgg [append_only, eowc] { group_key: [$expr1, $expr2], aggs: [count(t.foo), count], output_watermarks: [[$expr1]] }
        └─StreamExchange { dist: HashShard($expr1, $expr2) }
          └─StreamProject { exprs: [$expr1, ($expr1 + '01:00:00':Interval) as $expr2, t.foo, t._row_id], output_watermarks: [[$expr1, $expr2]] }
            └─StreamProject { exprs: [t.foo, t.ts, TumbleStart(t.ts, '01:00:00':Interval) as $expr1, t._row_id], output_watermarks: [[t.ts, $expr1]] }
              └─StreamTableScan { table: t, columns: [t.foo, t.ts, t._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t._row_id], pk: [_row_id], dist: UpstreamHashShard(t._row_id) }
