# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_sources
  sql: |
    create source auction (id BIGINT, "item_name" VARCHAR, description VARCHAR, "initial_bid" BIGINT, reserve BIGINT, "date_time" TIMESTAMP, expires TIMESTAMP, seller BIGINT, category BIGINT, "extra" VARCHAR)
    with (
    connector = 'nexmark',
    nexmark.table.type = 'Auction',
    nexmark.split.num = '4',
    nexmark.min.event.gap.in.ns = '1000'
    );
    create source bid (auction BIGINT, bidder BIGINT, price BIGINT, "channel" VARCHAR, "url" VARCHAR, "date_time" TIMESTAMP, "extra" VARCHAR)
    with (
    connector = 'nexmark',
    nexmark.table.type = 'Bid',
    nexmark.split.num = '4',
    nexmark.min.event.gap.in.ns = '1000'
    );
- id: self_join
  before:
  - create_sources
  sql: |
    select count(*) cnt from auction A join auction B on A.id = B.id where A.initial_bid = 1 and B.initial_bid = 2;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum0(count)] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count] }
        └─BatchHashJoin { type: Inner, predicate: id = id, output: [] }
          ├─BatchExchange { order: [], dist: HashShard(id) }
          | └─BatchProject { exprs: [id] }
          |   └─BatchFilter { predicate: (initial_bid = 1:Int32) }
          |     └─BatchSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "extra", "_row_id"], filter: (None, None) }
          └─BatchExchange { order: [], dist: HashShard(id) }
            └─BatchProject { exprs: [id] }
              └─BatchFilter { predicate: (initial_bid = 2:Int32) }
                └─BatchSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "extra", "_row_id"], filter: (None, None) }
  stream_plan: |
    StreamMaterialize { columns: [cnt], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum0(count)] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [sum0(count), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [count] }
            └─StreamAppendOnlyHashJoin { type: Inner, predicate: id = id, output: [_row_id, id, _row_id, id] }
              ├─StreamExchange { dist: HashShard(id) }
              | └─StreamProject { exprs: [id, _row_id] }
              |   └─StreamFilter { predicate: (initial_bid = 1:Int32) }
              |     └─StreamShare { id = 6 }
              |       └─StreamProject { exprs: [id, initial_bid, _row_id] }
              |         └─StreamFilter { predicate: ((initial_bid = 1:Int32) OR (initial_bid = 2:Int32)) }
              |           └─StreamRowIdGen { row_id_index: 10 }
              |             └─StreamSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "extra", "_row_id"] }
              └─StreamExchange { dist: HashShard(id) }
                └─StreamProject { exprs: [id, _row_id] }
                  └─StreamFilter { predicate: (initial_bid = 2:Int32) }
                    └─StreamShare { id = 6 }
                      └─StreamProject { exprs: [id, initial_bid, _row_id] }
                        └─StreamFilter { predicate: ((initial_bid = 1:Int32) OR (initial_bid = 2:Int32)) }
                          └─StreamRowIdGen { row_id_index: 10 }
                            └─StreamSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "extra", "_row_id"] }
- id: nexmark_q5
  before:
  - create_sources
  sql: |
    SELECT AuctionBids.auction, AuctionBids.num FROM (
      SELECT
        bid.auction,
        count(*) AS num,
        window_start AS starttime
      FROM
        HOP(bid, date_time, INTERVAL '2' SECOND, INTERVAL '10' SECOND)
      GROUP BY
        bid.auction,
        window_start
    ) AS AuctionBids
    JOIN (
      SELECT
        max(CountBids.num) AS maxn,
        CountBids.starttime_c
      FROM (
        SELECT
          count(*) AS num,
          window_start AS starttime_c
        FROM HOP(bid, date_time, INTERVAL '2' SECOND, INTERVAL '10' SECOND)
        GROUP BY
          bid.auction,
          window_start
      ) AS CountBids
      GROUP BY
        CountBids.starttime_c
    ) AS MaxBids
    ON AuctionBids.starttime = MaxBids.starttime_c AND AuctionBids.num >= MaxBids.maxn;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: window_start = window_start AND (count >= max(count)), output: [auction, count] }
      ├─BatchExchange { order: [], dist: HashShard(window_start) }
      | └─BatchProject { exprs: [auction, count, window_start] }
      |   └─BatchHashAgg { group_key: [auction, window_start], aggs: [count] }
      |     └─BatchHopWindow { time_col: date_time, slide: 00:00:02, size: 00:00:10, output: [auction, window_start] }
      |       └─BatchExchange { order: [], dist: HashShard(auction) }
      |         └─BatchProject { exprs: [auction, date_time] }
      |           └─BatchFilter { predicate: IsNotNull(date_time) }
      |             └─BatchSource { source: "bid", columns: ["auction", "bidder", "price", "channel", "url", "date_time", "extra", "_row_id"], filter: (None, None) }
      └─BatchProject { exprs: [max(count), window_start] }
        └─BatchHashAgg { group_key: [window_start], aggs: [max(count)] }
          └─BatchExchange { order: [], dist: HashShard(window_start) }
            └─BatchHashAgg { group_key: [auction, window_start], aggs: [count] }
              └─BatchHopWindow { time_col: date_time, slide: 00:00:02, size: 00:00:10, output: [auction, window_start] }
                └─BatchExchange { order: [], dist: HashShard(auction) }
                  └─BatchProject { exprs: [auction, date_time] }
                    └─BatchFilter { predicate: IsNotNull(date_time) }
                      └─BatchSource { source: "bid", columns: ["auction", "bidder", "price", "channel", "url", "date_time", "extra", "_row_id"], filter: (None, None) }
  stream_plan: |
    StreamMaterialize { columns: [auction, num, window_start(hidden), window_start#1(hidden)], pk_columns: [auction, window_start, window_start#1], pk_conflict: "no check" }
    └─StreamProject { exprs: [auction, count, window_start, window_start] }
      └─StreamFilter { predicate: (count >= max(count)) }
        └─StreamHashJoin { type: Inner, predicate: window_start = window_start, output: all }
          ├─StreamExchange { dist: HashShard(window_start) }
          | └─StreamProject { exprs: [auction, count, window_start] }
          |   └─StreamShare { id = 11 }
          |     └─StreamAppendOnlyHashAgg { group_key: [auction, window_start], aggs: [count] }
          |       └─StreamExchange { dist: HashShard(auction, window_start) }
          |         └─StreamHopWindow { time_col: date_time, slide: 00:00:02, size: 00:00:10, output: [auction, window_start, _row_id] }
          |           └─StreamProject { exprs: [auction, date_time, _row_id] }
          |             └─StreamFilter { predicate: IsNotNull(date_time) }
          |               └─StreamRowIdGen { row_id_index: 7 }
          |                 └─StreamSource { source: "bid", columns: ["auction", "bidder", "price", "channel", "url", "date_time", "extra", "_row_id"] }
          └─StreamProject { exprs: [max(count), window_start] }
            └─StreamHashAgg { group_key: [window_start], aggs: [max(count), count] }
              └─StreamExchange { dist: HashShard(window_start) }
                └─StreamProject { exprs: [auction, window_start, count] }
                  └─StreamShare { id = 11 }
                    └─StreamAppendOnlyHashAgg { group_key: [auction, window_start], aggs: [count] }
                      └─StreamExchange { dist: HashShard(auction, window_start) }
                        └─StreamHopWindow { time_col: date_time, slide: 00:00:02, size: 00:00:10, output: [auction, window_start, _row_id] }
                          └─StreamProject { exprs: [auction, date_time, _row_id] }
                            └─StreamFilter { predicate: IsNotNull(date_time) }
                              └─StreamRowIdGen { row_id_index: 7 }
                                └─StreamSource { source: "bid", columns: ["auction", "bidder", "price", "channel", "url", "date_time", "extra", "_row_id"] }
- sql: |
    set rw_enable_share_plan=true;
    create table t(a int, b int);
    with cte as (select count(*) from t) select * from cte union all select * from cte;
  stream_plan: |
    StreamMaterialize { columns: [count, 0:Int32(hidden)], pk_columns: [0:Int32], pk_conflict: "no check" }
    └─StreamUnion { all: true }
      ├─StreamExchange { dist: HashShard(0:Int32) }
      | └─StreamProject { exprs: [sum0(count), 0:Int32] }
      |   └─StreamShare { id = 8 }
      |     └─StreamProject { exprs: [sum0(count)] }
      |       └─StreamGlobalSimpleAgg { aggs: [sum0(count), count] }
      |         └─StreamExchange { dist: Single }
      |           └─StreamStatelessLocalSimpleAgg { aggs: [count] }
      |             └─StreamTableScan { table: t, columns: [t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
      └─StreamExchange { dist: HashShard(1:Int32) }
        └─StreamProject { exprs: [sum0(count), 1:Int32] }
          └─StreamShare { id = 8 }
            └─StreamProject { exprs: [sum0(count)] }
              └─StreamGlobalSimpleAgg { aggs: [sum0(count), count] }
                └─StreamExchange { dist: Single }
                  └─StreamStatelessLocalSimpleAgg { aggs: [count] }
                    └─StreamTableScan { table: t, columns: [t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    set rw_enable_share_plan=false;
    create table t(a int, b int);
    with cte as (select count(*) from t) select * from cte union all select * from cte;
  stream_plan: |
    StreamMaterialize { columns: [count, 0:Int32(hidden)], pk_columns: [0:Int32], pk_conflict: "no check" }
    └─StreamUnion { all: true }
      ├─StreamExchange { dist: HashShard(0:Int32) }
      | └─StreamProject { exprs: [sum0(count), 0:Int32] }
      |   └─StreamGlobalSimpleAgg { aggs: [sum0(count), count] }
      |     └─StreamExchange { dist: Single }
      |       └─StreamStatelessLocalSimpleAgg { aggs: [count] }
      |         └─StreamTableScan { table: t, columns: [t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
      └─StreamExchange { dist: HashShard(1:Int32) }
        └─StreamProject { exprs: [sum0(count), 1:Int32] }
          └─StreamGlobalSimpleAgg { aggs: [sum0(count), count] }
            └─StreamExchange { dist: Single }
              └─StreamStatelessLocalSimpleAgg { aggs: [count] }
                └─StreamTableScan { table: t, columns: [t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- id: force_share_source_for_self_join
  before:
  - create_sources
  sql: |
    set rw_enable_share_plan=false;
    select count(*) cnt from auction A join auction B on A.id = B.id;
  stream_plan: |
    StreamMaterialize { columns: [cnt], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum0(count)] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [sum0(count), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [count] }
            └─StreamAppendOnlyHashJoin { type: Inner, predicate: id = id, output: [_row_id, id, _row_id, id] }
              ├─StreamExchange { dist: HashShard(id) }
              | └─StreamProject { exprs: [id, _row_id] }
              |   └─StreamShare { id = 4 }
              |     └─StreamProject { exprs: [id, _row_id] }
              |       └─StreamRowIdGen { row_id_index: 10 }
              |         └─StreamSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "extra", "_row_id"] }
              └─StreamExchange { dist: HashShard(id) }
                └─StreamProject { exprs: [id, _row_id] }
                  └─StreamShare { id = 4 }
                    └─StreamProject { exprs: [id, _row_id] }
                      └─StreamRowIdGen { row_id_index: 10 }
                        └─StreamSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "extra", "_row_id"] }
