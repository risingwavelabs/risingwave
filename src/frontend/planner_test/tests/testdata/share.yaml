# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_sources
  sql: |
    create source auction (id INTEGER, "item_name" VARCHAR, description VARCHAR, "initial_bid" INTEGER, reserve INTEGER, "date_time" TIMESTAMP, expires TIMESTAMP, seller INTEGER, category INTEGER)
    with (
    connector = 'nexmark',
    nexmark.table.type = 'Auction',
    nexmark.split.num = '4',
    nexmark.min.event.gap.in.ns = '1000'
    ) row format json;
    create source bid (auction INTEGER, bidder INTEGER, price INTEGER, "date_time" TIMESTAMP)
    with (
    connector = 'nexmark',
    nexmark.table.type = 'Bid',
    nexmark.split.num = '4',
    nexmark.min.event.gap.in.ns = '1000'
    ) row format json;
- id: self_join
  before:
  - create_sources
  sql: |
    select count(*) cnt from auction A join auction B on A.id = B.id where A.initial_bid = 1 and B.initial_bid = 2;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum0(count)] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count] }
        └─BatchHashJoin { type: Inner, predicate: id = id, output: [] }
          ├─BatchExchange { order: [], dist: HashShard(id) }
          | └─BatchProject { exprs: [id] }
          |   └─BatchFilter { predicate: (initial_bid = 1:Int32) }
          |     └─BatchProject { exprs: [id, initial_bid] }
          |       └─BatchFilter { predicate: ((initial_bid = 1:Int32) OR (initial_bid = 2:Int32)) }
          |         └─BatchSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "_row_id"], filter: (None, None) }
          └─BatchExchange { order: [], dist: HashShard(id) }
            └─BatchProject { exprs: [id] }
              └─BatchFilter { predicate: (initial_bid = 2:Int32) }
                └─BatchProject { exprs: [id, initial_bid] }
                  └─BatchFilter { predicate: ((initial_bid = 1:Int32) OR (initial_bid = 2:Int32)) }
                    └─BatchSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "_row_id"], filter: (None, None) }
  stream_plan: |
    StreamMaterialize { columns: [cnt], pk_columns: [] }
    └─StreamProject { exprs: [sum0(count)] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [count, sum0(count)] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [count, count] }
            └─StreamAppendOnlyHashJoin { type: Inner, predicate: id = id, output: [_row_id, id, _row_id, id] }
              ├─StreamExchange { dist: HashShard(id) }
              | └─StreamProject { exprs: [id, _row_id] }
              |   └─StreamFilter { predicate: (initial_bid = 1:Int32) }
              |     └─StreamProject { exprs: [id, initial_bid, _row_id] }
              |       └─StreamShare { id = 541 }
              |         └─StreamProject { exprs: [id, initial_bid, _row_id] }
              |           └─StreamFilter { predicate: ((initial_bid = 1:Int32) OR (initial_bid = 2:Int32)) }
              |             └─StreamRowIdGen { row_id_index: 9 }
              |               └─StreamSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "_row_id"] }
              └─StreamExchange { dist: HashShard(id) }
                └─StreamProject { exprs: [id, _row_id] }
                  └─StreamFilter { predicate: (initial_bid = 2:Int32) }
                    └─StreamProject { exprs: [id, initial_bid, _row_id] }
                      └─StreamShare { id = 555 }
                        └─StreamProject { exprs: [id, initial_bid, _row_id] }
                          └─StreamFilter { predicate: ((initial_bid = 1:Int32) OR (initial_bid = 2:Int32)) }
                            └─StreamRowIdGen { row_id_index: 9 }
                              └─StreamSource { source: "auction", columns: ["id", "item_name", "description", "initial_bid", "reserve", "date_time", "expires", "seller", "category", "_row_id"] }
- id: nexmark_q5
  before:
  - create_sources
  sql: |
    SELECT AuctionBids.auction, AuctionBids.num FROM (
      SELECT
        bid.auction,
        count(*) AS num,
        window_start AS starttime
      FROM
        HOP(bid, date_time, INTERVAL '2' SECOND, INTERVAL '10' SECOND)
      GROUP BY
        window_start,
        bid.auction
    ) AS AuctionBids
    JOIN (
      SELECT
        max(CountBids.num) AS maxn,
        CountBids.starttime_c
      FROM (
        SELECT
          count(*) AS num,
          window_start AS starttime_c
        FROM HOP(bid, date_time, INTERVAL '2' SECOND, INTERVAL '10' SECOND)
        GROUP BY
          bid.auction,
          window_start
      ) AS CountBids
      GROUP BY
        CountBids.starttime_c
    ) AS MaxBids
    ON AuctionBids.starttime = MaxBids.starttime_c AND AuctionBids.num >= MaxBids.maxn;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [auction, count] }
      └─BatchFilter { predicate: (count >= max(count)) }
        └─BatchHashJoin { type: Inner, predicate: window_start = window_start, output: all }
          ├─BatchExchange { order: [], dist: HashShard(window_start) }
          | └─BatchProject { exprs: [auction, count, window_start] }
          |   └─BatchHashAgg { group_key: [window_start, auction], aggs: [count] }
          |     └─BatchHopWindow { time_col: date_time, slide: 00:00:02, size: 00:00:10, output: [auction, window_start] }
          |       └─BatchExchange { order: [], dist: HashShard(auction) }
          |         └─BatchProject { exprs: [auction, date_time] }
          |           └─BatchSource { source: "bid", columns: ["auction", "bidder", "price", "date_time", "_row_id"], filter: (None, None) }
          └─BatchProject { exprs: [max(count), window_start] }
            └─BatchHashAgg { group_key: [window_start], aggs: [max(count)] }
              └─BatchExchange { order: [], dist: HashShard(window_start) }
                └─BatchHashAgg { group_key: [auction, window_start], aggs: [count] }
                  └─BatchHopWindow { time_col: date_time, slide: 00:00:02, size: 00:00:10, output: [auction, window_start] }
                    └─BatchExchange { order: [], dist: HashShard(auction) }
                      └─BatchProject { exprs: [auction, date_time] }
                        └─BatchSource { source: "bid", columns: ["auction", "bidder", "price", "date_time", "_row_id"], filter: (None, None) }
  stream_plan: |
    StreamMaterialize { columns: [auction, num, window_start(hidden), window_start#1(hidden)], pk_columns: [window_start, auction, window_start#1] }
    └─StreamProject { exprs: [auction, count, window_start, window_start] }
      └─StreamFilter { predicate: (count >= max(count)) }
        └─StreamHashJoin { type: Inner, predicate: window_start = window_start, output: all }
          ├─StreamExchange { dist: HashShard(window_start) }
          | └─StreamProject { exprs: [auction, count, window_start] }
          |   └─StreamAppendOnlyHashAgg { group_key: [window_start, auction], aggs: [count, count] }
          |     └─StreamExchange { dist: HashShard(auction, window_start) }
          |       └─StreamHopWindow { time_col: date_time, slide: 00:00:02, size: 00:00:10, output: [auction, window_start, _row_id] }
          |         └─StreamProject { exprs: [auction, date_time, _row_id] }
          |           └─StreamShare { id = 775 }
          |             └─StreamProject { exprs: [auction, date_time, _row_id] }
          |               └─StreamRowIdGen { row_id_index: 4 }
          |                 └─StreamSource { source: "bid", columns: ["auction", "bidder", "price", "date_time", "_row_id"] }
          └─StreamProject { exprs: [max(count), window_start] }
            └─StreamHashAgg { group_key: [window_start], aggs: [count, max(count)] }
              └─StreamExchange { dist: HashShard(window_start) }
                └─StreamProject { exprs: [auction, window_start, count] }
                  └─StreamAppendOnlyHashAgg { group_key: [auction, window_start], aggs: [count, count] }
                    └─StreamExchange { dist: HashShard(auction, window_start) }
                      └─StreamHopWindow { time_col: date_time, slide: 00:00:02, size: 00:00:10, output: [auction, window_start, _row_id] }
                        └─StreamProject { exprs: [auction, date_time, _row_id] }
                          └─StreamShare { id = 790 }
                            └─StreamProject { exprs: [auction, date_time, _row_id] }
                              └─StreamRowIdGen { row_id_index: 4 }
                                └─StreamSource { source: "bid", columns: ["auction", "bidder", "price", "date_time", "_row_id"] }
