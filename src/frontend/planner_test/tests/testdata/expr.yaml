# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: bind typed literal - int
  sql: |
    select int '1';
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bind typed literal - bool
  sql: |
    SELECT bool 't'
  logical_plan: |
    LogicalProject { exprs: [true:Boolean] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    values(must_be_unimplemented_func(1));
  binder_error: |-
    Bind error: failed to bind expression: must_be_unimplemented_func(1)

    Caused by:
      Feature is not yet implemented: unsupported function: "must_be_unimplemented_func"
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/112
- sql: |
    values(cast(1 as bigint));
  batch_plan: |
    BatchValues { rows: [[1:Int64]] }
- sql: |
    values(not true);
  batch_plan: |
    BatchValues { rows: [[false:Boolean]] }
- sql: |
    create table t ();
    select (((((false is not true) is true) is not false) is false) is not null) is null from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [false:Boolean] }
      └─BatchScan { table: t, columns: [], distribution: SomeShard }
- name: bind between
  sql: |
    SELECT 1 between 2 and 3
  logical_plan: |
    LogicalProject { exprs: [((1:Int32 >= 2:Int32) AND (1:Int32 <= 3:Int32)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: null eq null
  sql: |
    SELECT null = null;
  logical_plan: |
    LogicalProject { exprs: [(null:Varchar = null:Varchar) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: null lt null
  sql: |
    SELECT null < null;
  logical_plan: |
    LogicalProject { exprs: [(null:Varchar < null:Varchar) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bind is distinct from
  sql: |
    SELECT 1 IS DISTINCT FROM 2
  logical_plan: |
    LogicalProject { exprs: [IsDistinctFrom(1:Int32, 2:Int32) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bind is not distinct from
  sql: |
    SELECT 1 IS NOT DISTINCT FROM 2
  logical_plan: |
    LogicalProject { exprs: [IsNotDistinctFrom(1:Int32, 2:Int32) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: in-list with aligned types
  sql: |
    SELECT 1::real in (3, 1.0, 2);
  batch_plan: |
    BatchValues { rows: [[true:Boolean]] }
- name: not in-list with aligned types
  sql: |
    SELECT 1::real not in (3, 1.0, 2);
  batch_plan: |
    BatchValues { rows: [[false:Boolean]] }
- name: in-list with misaligned types
  sql: |
    SELECT true in (3, 1.0, 2);
  binder_error: |-
    Bind error: failed to bind expression: true IN (3, 1.0, 2)

    Caused by:
      Bind error: types Boolean and Int32 cannot be matched
- name: in-list with non-const - agg
  sql: |
    create table t (v1 int);
    SELECT 1 in (3, 0.5*2, min(v1)) from t;
  batch_plan: |
    BatchProject { exprs: [(true:Boolean OR (1:Int32 = min(min(t.v1)))) as $expr1] }
    └─BatchSimpleAgg { aggs: [min(min(t.v1))] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchSimpleAgg { aggs: [min(t.v1)] }
          └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: in-list with non-const - scalar subquery
  sql: |
    create table t (v1 int);
    create table b (b1 int, b2 int);
    SELECT b2 from b where 1 in (3, 1.0, (select min(v1) from t));
  batch_plan: |
    BatchProject { exprs: [b.b2] }
    └─BatchFilter { predicate: true }
      └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
        ├─BatchExchange { order: [], dist: Single }
        | └─BatchScan { table: b, columns: [b.b2], distribution: SomeShard }
        └─BatchSimpleAgg { aggs: [min(min(t.v1))] }
          └─BatchExchange { order: [], dist: Single }
            └─BatchSimpleAgg { aggs: [min(t.v1)] }
              └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: in-list with non-const - correlated ref
  sql: |
    create table t (v1 int);
    create table b (b1 int, b2 int);
    SELECT b2 from b where exists (select 2 from t where v1 in (3, 1.0, b1));
  logical_plan: |
    LogicalProject { exprs: [b.b2] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalScan { table: b, columns: [b.b1, b.b2, b._row_id] }
      └─LogicalProject { exprs: [2:Int32] }
        └─LogicalFilter { predicate: (In(t.v1::Decimal, 3:Int32::Decimal, 1.0:Decimal) OR (t.v1 = CorrelatedInputRef { index: 0, correlated_id: 1 })) }
          └─LogicalScan { table: t, columns: [t.v1, t._row_id] }
  batch_plan: |
    BatchNestedLoopJoin { type: LeftSemi, predicate: (In(t.v1::Decimal, 3:Decimal, 1.0:Decimal) OR (t.v1 = b.b1)), output: [b.b2] }
    ├─BatchExchange { order: [], dist: Single }
    | └─BatchScan { table: b, columns: [b.b1, b.b2], distribution: SomeShard }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.v1, t.v1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    select +1.0, -2.0;
  batch_plan: |
    BatchValues { rows: [[1.0:Decimal, -2.0:Decimal]] }
- sql: |
    values(round(42.4382, 2));
  batch_plan: |
    BatchValues { rows: [[42.44:Decimal]] }
- sql: |
    values(round(42.4382));
  batch_plan: |
    BatchValues { rows: [[42:Decimal]] }
- sql: |
    values(round(42));
  batch_plan: |
    BatchValues { rows: [[42:Float64]] }
- sql: |
    values(round(42, 2));
  batch_plan: |
    BatchValues { rows: [[42:Decimal]] }
- sql: |
    values(round(true));
  binder_error: |-
    Bind error: failed to bind expression: round(true)

    Caused by:
      Feature is not yet implemented: Round[Boolean]
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/112
- sql: |
    -- Single quoted literal can be treated as number without error.
    values(round('123'));
  batch_plan: |
    BatchValues { rows: [[123:Float64]] }
- sql: |
    -- When it is invalid, PostgreSQL reports error during explain, but we have to wait until execution as of now. #4235
    values(round('abc'));
- sql: |
    values(extract(hour from timestamp '2001-02-16 20:38:40'));
  batch_plan: |
    BatchValues { rows: [[20:Decimal]] }
- sql: |
    values('Postgres' not like 'Post%');
  batch_plan: |
    BatchValues { rows: [[false:Boolean]] }
- sql: |
    values(1 not like 1.23);
  binder_error: |-
    Bind error: failed to bind expression: 1 NOT LIKE 1.23

    Caused by:
      Feature is not yet implemented: Like[Int32, Decimal]
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/112
- sql: |
    select length(trim(trailing '1' from '12'))+length(trim(leading '2' from '23'))+length(trim(both '3' from '34'));
  batch_plan: |
    BatchValues { rows: [[4:Int32]] }
- sql: |
    select position('123' in replace('1','1','2')) where '12' like '%1';
  batch_plan: |
    BatchValues { rows: [] }
- name: case searched form with else
  sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2 else 0.0 end) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), 1:Decimal, (t.v1 = 2:Int32), 2:Decimal, 0.0:Decimal) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [Case((t.v1 = 1:Int32), 1:Decimal, (t.v1 = 2:Int32), 2:Decimal, 0.0:Decimal) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: case searched form without else
  sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2.1 end) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), 1:Decimal, (t.v1 = 2:Int32), 2.1:Decimal) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: case simple form
  sql: |
    create table t (v1 int);
    select (case v1 when 1 then 1 when 2.0 then 2 else 0.0 end) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), 1:Decimal, (t.v1::Decimal = 2.0:Decimal), 2:Decimal, 0.0:Decimal) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: case misaligned result types
  sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2 else true end) from t;
  binder_error: |-
    Bind error: failed to bind expression: (CASE WHEN v1 = 1 THEN 1 WHEN v1 = 2 THEN 2 ELSE true END)

    Caused by:
      Bind error: types Int32 and Boolean cannot be matched
- name: case misaligned value types
  sql: |
    create table t (v1 int);
    select (case v1 when 1 then 1 when true then 2 else 0.0 end) from t;
  binder_error: |-
    Bind error: failed to bind expression: (CASE v1 WHEN 1 THEN 1 WHEN true THEN 2 ELSE 0.0 END)

    Caused by:
      Feature is not yet implemented: Equal[Int32, Boolean]
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/112
- sql: |
    create table t (v1 int);
    select nullif(v1, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), null:Int32, t.v1) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [Case((t.v1 = 1:Int32), null:Int32, t.v1) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int);
    select nullif(v1, 1, 2) from t;
  binder_error: |-
    Bind error: failed to bind expression: nullif(v1, 1, 2)

    Caused by:
      Bind error: Nullif function must contain 2 arguments
- sql: |
    create table t (v1 int);
    select nullif(v1, true) from t;
  binder_error: |-
    Bind error: failed to bind expression: nullif(v1, true)

    Caused by:
      Feature is not yet implemented: Equal[Int32, Boolean]
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/112
- sql: |
    create table t (v1 int);
    select coalesce(v1, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Coalesce(t.v1, 1:Int32) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [Coalesce(t.v1, 1:Int32) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int);
    select coalesce(v1, 1.2) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Coalesce(t.v1::Decimal, 1.2:Decimal) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    create table t (v1 int);
    select coalesce() from t;
  binder_error: |-
    Bind error: failed to bind expression: coalesce()

    Caused by:
      Bind error: Function `coalesce` takes at least 1 arguments (0 given)
- sql: |
    create table t (v1 int);
    select coalesce(1,true) from t;
  binder_error: |-
    Bind error: failed to bind expression: coalesce(1, true)

    Caused by:
      Bind error: types Int32 and Boolean cannot be matched
- sql: |
    create table t (v1 varchar);
    select concat_ws(v1, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs(t.v1, '1':Varchar) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [ConcatWs(t.v1, '1':Varchar) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 varchar);
    select concat_ws(v1, 1.2) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs(t.v1, '1.2':Varchar) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    create table t (v1 int);
    select concat_ws(v1, 1.2) from t;
  binder_error: |-
    Bind error: failed to bind expression: concat_ws(v1, 1.2)

    Caused by:
      Bind error: cannot cast type "integer" to "varchar" in Implicit context
- sql: |
    create table t (v1 int);
    select concat_ws() from t;
  binder_error: |-
    Bind error: failed to bind expression: concat_ws()

    Caused by:
      Bind error: Function `concat_ws` takes at least 2 arguments (0 given)
- sql: |
    create table t (v1 varchar, v2 int, v3 float);
    select concat(v1, v2, v3, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs('':Varchar, t.v1, t.v2::Varchar, t.v3::Varchar, '1':Varchar) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1, t.v2, t.v3], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: "NoCheck" }
    └─StreamProject { exprs: [ConcatWs('':Varchar, t.v1, t.v2::Varchar, t.v3::Varchar, '1':Varchar) as $expr1, t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 float);
    select concat(v1) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs('':Varchar, t.v1::Varchar) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    create table t (v1 int);
    select concat() from t;
  binder_error: |-
    Bind error: failed to bind expression: concat()

    Caused by:
      Bind error: Function `Concat` takes at least 1 arguments (0 given)
- sql: |
    select concat(':', true);
  batch_plan: |
    BatchValues { rows: [[':t':Varchar]] }
- sql: |
    select ':' || true;
  batch_plan: |
    BatchValues { rows: [[':true':Varchar]] }
- sql: |
    select substr('hello', NULL);
  batch_plan: |
    BatchValues { rows: [[null:Varchar]] }
- sql: |
    select substr(NULL, 1);
  batch_plan: |
    BatchValues { rows: [[null:Varchar]] }
- sql: |
    select pg_typeof('123');
  batch_plan: |
    BatchValues { rows: [['unknown':Varchar]] }
- sql: |
    select pg_typeof(round(null));
  batch_plan: |
    BatchValues { rows: [['double precision':Varchar]] }
- sql: |
    select pg_typeof(row(true, 1, 'hello'));
  batch_plan: |
    BatchValues { rows: [['record':Varchar]] }
- sql: |
    select pg_typeof(array[1, 2]);
  batch_plan: |
    BatchValues { rows: [['integer[]':Varchar]] }
- sql: |
    select pg_typeof(array[array[1, 2], array[3, 4]]);
  batch_plan: |
    BatchValues { rows: [['integer[][]':Varchar]] }
- sql: |
    select 1 = SOME(1);
  binder_error: |-
    Bind error: failed to bind expression: 1 = SOME(1)

    Caused by:
      Bind error: op SOME/ANY/ALL (array) requires array on right side
- sql: |
    select 1 < SOME(null);
  logical_plan: |
    LogicalProject { exprs: [Some((1:Int32 < null:List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ANY(null);
  logical_plan: |
    LogicalProject { exprs: [Some((1:Int32 < null:List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ALL(null);
  logical_plan: |
    LogicalProject { exprs: [All((1:Int32 < null:List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ALL('{2,3}');
  logical_plan: |
    LogicalProject { exprs: [All((1:Int32 < '{2,3}':Varchar::List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < SOME(null::integer[]);
  logical_plan: |
    LogicalProject { exprs: [Some((1:Int32 < null:List(Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < SOME(null::varchar[]);
  binder_error: |-
    Bind error: failed to bind expression: 1 < SOME(CAST(NULL AS CHARACTER VARYING[]))

    Caused by:
      Feature is not yet implemented: LessThan[Int32, Varchar]
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/112
- sql: |
    select 1 < SOME(null::date);
  binder_error: |-
    Bind error: failed to bind expression: 1 < SOME(CAST(NULL AS DATE))

    Caused by:
      Bind error: op SOME/ANY/ALL (array) requires array on right side
- name: array/struct on left not supported yet 5808
  sql: |
    select array[1] < SOME(null);
  binder_error: |-
    Bind error: failed to bind expression: ARRAY[1] < SOME(NULL)

    Caused by:
      Bind error: array/struct on left are not supported yet
- name: array of array/struct on right not supported yet 5808
  sql: |
    select null < SOME(array[array[1]]);
  binder_error: |-
    Bind error: failed to bind expression: NULL < SOME(ARRAY[ARRAY[1]])

    Caused by:
      Bind error: array of array/struct on right are not supported yet
- sql: |
    select 1 < SOME(array[null]::integer[]);
  logical_plan: |
    LogicalProject { exprs: [Some((1:Int32 < Array(null:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < SOME(array[1, 2]);
  logical_plan: |
    LogicalProject { exprs: [Some((1:Int32 < Array(1:Int32, 2:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < SOME((select array[1]) || array[2]);
  logical_plan: |
    LogicalProject { exprs: [Some((1:Int32 < ArrayCat($expr1, Array(2:Int32)))) as $expr2] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalProject { exprs: [Array(1:Int32) as $expr1] }
        └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |
    BatchProject { exprs: [Some((1:Int32 < ArrayCat($expr10033, ARRAY[2]:List(Int32)))) as $expr1] }
    └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
      ├─BatchValues { rows: [[]] }
      └─BatchValues { rows: [[ARRAY[1]:List(Int32)]] }
- sql: |
    select 1 < ALL(array[null]::integer[]);
  logical_plan: |
    LogicalProject { exprs: [All((1:Int32 < Array(null:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ALL(array[1, 2]);
  logical_plan: |
    LogicalProject { exprs: [All((1:Int32 < Array(1:Int32, 2:Int32))) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    select 1 < ALL((select array[1]) || array[2]);
  logical_plan: |
    LogicalProject { exprs: [All((1:Int32 < ArrayCat($expr1, Array(2:Int32)))) as $expr2] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalProject { exprs: [Array(1:Int32) as $expr1] }
        └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |
    BatchProject { exprs: [All((1:Int32 < ArrayCat($expr10033, ARRAY[2]:List(Int32)))) as $expr1] }
    └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
      ├─BatchValues { rows: [[]] }
      └─BatchValues { rows: [[ARRAY[1]:List(Int32)]] }
- name: now expression
  sql: |
    create table t (v1 timestamp with time zone);
    select * from t where v1 >= now();
  logical_plan: |
    LogicalProject { exprs: [t.v1] }
    └─LogicalFilter { predicate: (t.v1 >= '2021-04-01 00:00:00+00:00':Timestamptz) }
      └─LogicalScan { table: t, columns: [t.v1, t._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: "NoCheck", watermark_columns: [v1] }
    └─StreamDynamicFilter { predicate: (t.v1 >= now), output_watermarks: [t.v1], output: [t.v1, t._row_id] }
      ├─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamNow { output: [now] }
- name: now expression with proj
  sql: |
    create table t (v1 timestamp with time zone);
    select * from t where v1 >= now() - INTERVAL '2' SECOND;
  logical_plan: |
    LogicalProject { exprs: [t.v1] }
    └─LogicalFilter { predicate: (t.v1 >= ('2021-04-01 00:00:00+00:00':Timestamptz - '00:00:02':Interval)) }
      └─LogicalScan { table: t, columns: [t.v1, t._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: "NoCheck", watermark_columns: [v1] }
    └─StreamDynamicFilter { predicate: (t.v1 >= $expr1), output_watermarks: [t.v1], output: [t.v1, t._row_id] }
      ├─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [(AtTimeZone((AtTimeZone(now, 'UTC':Varchar) - '00:00:00':Interval), 'UTC':Varchar) - '00:00:02':Interval) as $expr1], output_watermarks: [$expr1] }
          └─StreamNow { output: [now] }
- name: and of two now expression condition
  sql: |
    create table t (v1 timestamp with time zone, v2 timestamp with time zone);
    select * from t where v1 >= now() and v2 >= now();
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: "NoCheck", watermark_columns: [v2] }
    └─StreamDynamicFilter { predicate: (t.v2 >= now), output_watermarks: [t.v2], output: [t.v1, t.v2, t._row_id] }
      ├─StreamDynamicFilter { predicate: (t.v1 >= now), output_watermarks: [t.v1], output: [t.v1, t.v2, t._row_id] }
      | ├─StreamTableScan { table: t, columns: [t.v1, t.v2, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
      | └─StreamExchange { dist: Broadcast }
      |   └─StreamNow { output: [now] }
      └─StreamExchange { dist: Broadcast }
        └─StreamNow { output: [now] }
- name: or of two now expression condition
  sql: |
    create table t (v1 timestamp with time zone, v2 timestamp with time zone);
    select * from t where v1 >= now() or v2 >= now();
  stream_error: 'internal error: Conditions containing now must be of the form `input_expr cmp now() [+- const_expr]` or `now() [+- const_expr] cmp input_expr`, where `input_expr` references a column and contains no `now()`.'
- name: now inside HAVING clause
  sql: |
    create table t (v1 timestamp with time zone, v2 int);
    select max(v1) as max_time from t group by v2 having max(v1) >= now();
  stream_plan: |
    StreamMaterialize { columns: [max_time, t.v2(hidden)], stream_key: [t.v2], pk_columns: [t.v2], pk_conflict: "NoCheck", watermark_columns: [max_time] }
    └─StreamProject { exprs: [max(t.v1), t.v2], output_watermarks: [max(t.v1)] }
      └─StreamDynamicFilter { predicate: (max(t.v1) >= now), output_watermarks: [max(t.v1)], output: [t.v2, max(t.v1)] }
        ├─StreamProject { exprs: [t.v2, max(t.v1)] }
        | └─StreamHashAgg { group_key: [t.v2], aggs: [max(t.v1), count] }
        |   └─StreamExchange { dist: HashShard(t.v2) }
        |     └─StreamTableScan { table: t, columns: [t.v1, t.v2, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: forbid now in group by for stream
  sql: |
    create table t (v1 timestamp with time zone, v2 int);
    select sum(v2) as sum_v2 from t group by v1 >= now();
  stream_error: |-
    Bind error: failed to bind expression: v1 >= now()

    Caused by:
      Invalid input syntax: For creation of materialized views, `NOW()` function is only allowed in `WHERE` and `HAVING`. Found in clause: Some(GroupBy)
- name: forbid now in select for stream
  sql: |
    create table t (v1 timestamp with time zone, v2 timestamp with time zone);
    select now() as n, * from t where v1 >= now();
  stream_error: |-
    Bind error: failed to bind expression: now()

    Caused by:
      Invalid input syntax: For creation of materialized views, `NOW()` function is only allowed in `WHERE` and `HAVING`. Found in clause: None
- name: forbid now in agg filter for stream
  sql: |
    create table t (v1 timestamp with time zone, v2 int);
    select sum(v2) filter (where v1 >= now()) as sum_v2 from t;
  stream_error: |-
    Bind error: failed to bind expression: sum(v2) FILTER(WHERE v1 >= now())

    Caused by:
      Invalid input syntax: For creation of materialized views, `NOW()` function is only allowed in `WHERE` and `HAVING`. Found in clause: Some(Filter)
- name: typo pg_teminate_backend
  sql: |
    select pg_teminate_backend(1);
  binder_error: |-
    Bind error: failed to bind expression: pg_teminate_backend(1)

    Caused by:
      Feature is not yet implemented: unsupported function "pg_teminate_backend", do you mean "pg_terminate_backend"?
    Tracking issue: https://github.com/risingwavelabs/risingwave/issues/112
- name: regression (#7571) - literal debug display for array with NULL values
  sql: |
    select ARRAY[1, null] t;
  logical_plan: |
    LogicalProject { exprs: [Array(1:Int32, null:Int32) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: regression (#7641) -fuzzing test failed at Bind error,types Boolean and Varchar cannot be matched
  sql: |
    select false >= 'LN1O0QP1yi' NOT IN (md5('4SeUPZhUbH'))
  batch_plan: |
    BatchValues { rows: [[false:Boolean]] }
- name: const_eval of const expr
  sql: |
    create table t(v1 int);
    select 1 + 2 + v1 from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [(3:Int32 + t.v1) as $expr1] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: const_eval of division by 0 error
  sql: select 1 / 0 t1;
  batch_error: 'Expr error: Division by zero'
