# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- sql: |
    values(sum(1));
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in VALUES'
- sql: |
    values(count(1));
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in VALUES'
- sql: |
    values(min(1));
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in VALUES'
- sql: |
    values(1 + max(1));
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in VALUES'
- sql: |
    create table t (v1 int);
    select v1 from t where min(v1);
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in WHERE'
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select v1, min(v2) + max(v3) * count(v1) as agg from t group by v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, ($1 + ($2 * $3))] }
        BatchHashAgg { group_key: [$0], aggs: [min($1), max($2), count($0)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchScan { table: t, columns: [v1, v2, v3] }
  batch_local_plan: |
    BatchProject { exprs: [$0, ($1 + ($2 * $3))] }
      BatchHashAgg { group_key: [$0], aggs: [min($1), max($2), count($0)] }
        BatchExchange { order: [], dist: Single }
          BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [v1, agg], pk_columns: [v1] }
      StreamProject { exprs: [$0, ($2 + ($3 * $4))] }
        StreamHashAgg { group_key: [$0], aggs: [count, min($1), max($2), count($0)] }
          StreamExchange { dist: HashShard([0]) }
            StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select min(v1) + max(v2) * count(v3) as agg from t;
  batch_plan: |
    BatchProject { exprs: [($0 + ($1 * $2))] }
      BatchSimpleAgg { aggs: [min($0), max($1), sum($2)] }
        BatchExchange { order: [], dist: Single }
          BatchSimpleAgg { aggs: [min($0), max($1), count($2)] }
            BatchScan { table: t, columns: [v1, v2, v3] }
  batch_local_plan: |
    BatchProject { exprs: [($0 + ($1 * $2))] }
      BatchSimpleAgg { aggs: [min($0), max($1), count($2)] }
        BatchExchange { order: [], dist: Single }
          BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [agg], pk_columns: [] }
      StreamProject { exprs: [($1 + ($2 * $3))] }
        StreamGlobalSimpleAgg { aggs: [count, min($0), max($1), count($2)] }
          StreamExchange { dist: Single }
            StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    create table t(v1 int, v2 int);
    select v1 from t group by v2;
  planner_error: 'Invalid input syntax: column must appear in the GROUP BY clause or be used in an aggregate function'
- sql: |
    create table t(v1 int, v2 int);
    select sum(v1), v1 from t group by v2, v2;
  planner_error: 'Invalid input syntax: column must appear in the GROUP BY clause or be used in an aggregate function'
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select v3, min(v1) * avg(v1+v2) as agg from t group by v3;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, ($1 * ($2::Decimal / $3))] }
        BatchHashAgg { group_key: [$0], aggs: [min($1), sum($2), count($2)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$2, $0, ($0 + $1)] }
              BatchScan { table: t, columns: [v1, v2, v3] }
  batch_local_plan: |
    BatchProject { exprs: [$0, ($1 * ($2::Decimal / $3))] }
      BatchHashAgg { group_key: [$0], aggs: [min($1), sum($2), count($2)] }
        BatchExchange { order: [], dist: Single }
          BatchProject { exprs: [$2, $0, ($0 + $1)] }
            BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [v3, agg], pk_columns: [v3] }
      StreamProject { exprs: [$0, ($2 * ($3::Decimal / $4))] }
        StreamHashAgg { group_key: [$0], aggs: [count, min($1), sum($2), count($2)] }
          StreamExchange { dist: HashShard([0]) }
            StreamProject { exprs: [$2, $0, ($0 + $1), $3] }
              StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    /* test logical_agg with complex group expression */
    create table t(v1 int, v2 int);
    select min(v1), sum(v1 + v2) from t group by v1 + v2;
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalAgg { group_key: [0], agg_calls: [min($1), sum($0)] }
        LogicalProject { exprs: [($1 + $2), $1] }
          LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* test logical_agg with complex group expression */
    create table t(v1 int, v2 int, v3 int);
    select v1, sum(v1 * v2) as sum from t group by (v1 + v2) / v3, v1;
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalAgg { group_key: [0, 1], agg_calls: [sum($2)] }
        LogicalProject { exprs: [(($1 + $2) / $3), $1, ($1 * $2)] }
          LogicalScan { table: t, columns: [_row_id, v1, v2, v3] }
- sql: |
    /* test logical_agg with complex group expression */
    create table t(v1 int, v2 int);
    select v1 + v2 from t group by v1 + v2;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [0], agg_calls: [] }
        LogicalProject { exprs: [($1 + $2)] }
          LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* test logical_agg with complex group expression */
    /* should complain about nested agg call */
    create table t(v1 int, v2 int);
    select avg(sum(v1 + v2)) from t group by v1 + v2;
  planner_error: 'Invalid input syntax: Aggregation calls should not be nested'
- sql: |
    /* test logical_agg with complex select expression */
    create table t(v1 int, v2 int);
    select v1 + v2 from t group by v1, v2;
  logical_plan: |
    LogicalProject { exprs: [($0 + $1)] }
      LogicalAgg { group_key: [0, 1], agg_calls: [] }
        LogicalProject { exprs: [$1, $2] }
          LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    create table t(v1 int, v2 int);
    select v1 from t group by v1 + v2;
  planner_error: 'Invalid input syntax: column must appear in the GROUP BY clause or be used in an aggregate function'
- sql: |
    create table t(v1 int, v2 int);
    select count(v1 + v2) as cnt, sum(v1 + v2) as sum from t;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0), sum($1)] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [count($0), sum($0)] }
          BatchProject { exprs: [($0 + $1)] }
            BatchScan { table: t, columns: [v1, v2] }
  batch_local_plan: |
    BatchSimpleAgg { aggs: [count($0), sum($0)] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [($0 + $1)] }
          BatchScan { table: t, columns: [v1, v2] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), cnt, sum], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1), sum($2)] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, count($0), sum($0)] }
            StreamProject { exprs: [($0 + $1), $2] }
              StreamTableScan { table: t, columns: [v1, v2, _row_id], pk_indices: [2] }
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select v1, sum(v2 + v3) / count(v2 + v3) + max(v1) as agg from t group by v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, (($1 / $2) + $3)] }
        BatchHashAgg { group_key: [$0], aggs: [sum($1), count($1), max($0)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$0, ($1 + $2)] }
              BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [v1, agg], pk_columns: [v1] }
      StreamProject { exprs: [$0, (($2 / $3) + $4)] }
        StreamHashAgg { group_key: [$0], aggs: [count, sum($1), count($1), max($0)] }
          StreamExchange { dist: HashShard([0]) }
            StreamProject { exprs: [$0, ($1 + $2), $3] }
              StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    create table t (v1 real not null);
    select v1, count(*) from t group by v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashAgg { group_key: [$0], aggs: [count] }
        BatchExchange { order: [], dist: HashShard([0]) }
          BatchScan { table: t, columns: [v1] }
- sql: |
    create table t (v1 real not null);
    select count(*) from t;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0)] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [count] }
          BatchScan { table: t, columns: [] }
- sql: |
    /* having with agg call */
    create table t (v1 real not null);
    select 1 from t having sum(v1) > 5;
  batch_plan: |
    BatchProject { exprs: [1:Int32] }
      BatchFilter { predicate: ($0 > 5:Int32) }
        BatchSimpleAgg { aggs: [sum($0)] }
          BatchExchange { order: [], dist: Single }
            BatchSimpleAgg { aggs: [sum($0)] }
              BatchScan { table: t, columns: [v1] }
- sql: |
    /* having with group column */
    create table t (v1 real not null);
    select 1 from t group by v1 having v1 > 5;
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
      LogicalFilter { predicate: ($0 > 5:Int32) }
        LogicalAgg { group_key: [0], agg_calls: [] }
          LogicalProject { exprs: [$1] }
            LogicalScan { table: t, columns: [_row_id, v1] }
- sql: |
    /* having with non-group column */
    create table t (v1 real not null, v2 int);
    select 1 from t group by v1 having v2 > 5;
  planner_error: 'Invalid input syntax: column must appear in the GROUP BY clause or be used in an aggregate function'
- sql: |
    /* distinct without agg */
    create table t (v1 int, v2 int);
    select distinct v1 from t;
  logical_plan: |
    LogicalAgg { group_key: [0], agg_calls: [] }
      LogicalProject { exprs: [$1] }
        LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* distinct with agg */
    create table t (v1 int, v2 int);
    select distinct sum(v1) from t group by v2;
  logical_plan: |
    LogicalAgg { group_key: [0], agg_calls: [] }
      LogicalProject { exprs: [$1] }
        LogicalAgg { group_key: [0], agg_calls: [sum($1)] }
          LogicalProject { exprs: [$2, $1] }
            LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* arguments out-of-order */
    create table t(v1 int, v2 int, v3 int);
    select count(v3), min(v2), max(v1) from t;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0), min($1), max($2)] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [count($0), min($1), max($2)] }
          BatchProject { exprs: [$2, $1, $0] }
            BatchScan { table: t, columns: [v1, v2, v3] }
- sql: |
    /* simple-agg arguments out-of-order */
    create table t(v1 int, v2 int, v3 int);
    select min(v1) + max(v3) * count(v2) as agg from t;
  batch_plan: |
    BatchProject { exprs: [($0 + ($1 * $2))] }
      BatchSimpleAgg { aggs: [min($0), max($1), sum($2)] }
        BatchExchange { order: [], dist: Single }
          BatchSimpleAgg { aggs: [min($0), max($1), count($2)] }
            BatchProject { exprs: [$0, $2, $1] }
              BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [agg], pk_columns: [] }
      StreamProject { exprs: [($1 + ($2 * $3))] }
        StreamGlobalSimpleAgg { aggs: [count, min($0), max($1), count($2)] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [$0, $2, $1, $3] }
              StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    /* simple-agg with single distribution */
    create table t(v1 int);
    select sum(c1) as s1 from (select sum(v1) as c1 from t);
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0)] }
      BatchSimpleAgg { aggs: [sum($0)] }
        BatchExchange { order: [], dist: Single }
          BatchSimpleAgg { aggs: [sum($0)] }
            BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [count, sum($1)] }
        StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
          StreamExchange { dist: Single }
            StreamLocalSimpleAgg { aggs: [count, sum($0)] }
              StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    /* simple-agg with some shard distribution */
    create table t(v1 int);
    select sum(v1) as s1 from t;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0)] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [sum($0)] }
          BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0)] }
            StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    /* simple-agg with hash shard distribution */
    create table t(v1 int, v2 int);
    select sum(c1) as s1 from (select v1, sum(v2) as c1 from t group by v1);
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0)] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [sum($0)] }
          BatchProject { exprs: [$1] }
            BatchHashAgg { group_key: [$0], aggs: [sum($1)] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchScan { table: t, columns: [v1, v2] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0)] }
            StreamProject { exprs: [$2, $0] }
              StreamHashAgg { group_key: [$0], aggs: [count, sum($1)] }
                StreamExchange { dist: HashShard([0]) }
                  StreamTableScan { table: t, columns: [v1, v2, _row_id], pk_indices: [2] }
- sql: |
    /* simple-stream-agg with append-only min-max should use 2-phase-agg */
    create table t(v1 int, v2 int) with ('appendonly' = true);
    select min(v1) as a1, max(v2) as a2 from t;
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), a1, a2], pk_columns: [] }
      StreamAppendOnlyGlobalSimpleAgg { aggs: [count, min($0), max($1)] }
        StreamExchange { dist: Single }
          StreamTableScan { table: t, columns: [v1, v2, _row_id], pk_indices: [2] }
- sql: |
    /* simple-stream-agg with non-append-only min-max should use 1-phase agg */
    create table t(v1 int, v2 int) with ('appendonly' = false);
    select sum(v1) as s1, min(v1) as a1, max(v2) as a2 from t;
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1, a1, a2], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [count, sum($0), min($0), max($1)] }
        StreamExchange { dist: Single }
          StreamTableScan { table: t, columns: [v1, v2, _row_id], pk_indices: [2] }
- sql: |
    /* dup group key */
    create table t(v1 int) with ('appendonly' = false);
    select v1 from t group by v1, v1;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [0, 0], agg_calls: [] }
        LogicalProject { exprs: [$1] }
          LogicalScan { table: t, columns: [_row_id, v1] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [0, 0], agg_calls: [] }
        LogicalScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [v1], pk_columns: [v1, v1], order_descs: [v1] }
      StreamExchange { dist: HashShard([0]) }
        StreamProject { exprs: [$0] }
          StreamHashAgg { group_key: [$0, $0], aggs: [count] }
            StreamExchange { dist: HashShard([0]) }
              StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    /* dup group key */
    create table t(v1 int, v2 int, v3 int) with ('appendonly' = false);
    select v2, min(v1) as min_v1, v3, max(v1) as max_v1 from t group by v3, v2, v2;
  logical_plan: |
    LogicalProject { exprs: [$1, $3, $0, $4] }
      LogicalAgg { group_key: [0, 1, 1], agg_calls: [min($2), max($2)] }
        LogicalProject { exprs: [$3, $2, $1] }
          LogicalScan { table: t, columns: [_row_id, v1, v2, v3] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$1, $3, $0, $4] }
      LogicalAgg { group_key: [0, 1, 1], agg_calls: [min($2), max($2)] }
        LogicalProject { exprs: [$2, $1, $0] }
          LogicalScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [v2, min_v1, v3, max_v1], pk_columns: [v3, v2, v2], order_descs: [v3, v2] }
      StreamExchange { dist: HashShard([0, 2]) }
        StreamProject { exprs: [$1, $4, $0, $5] }
          StreamHashAgg { group_key: [$0, $1, $1], aggs: [count, min($2), max($2)] }
            StreamExchange { dist: HashShard([0, 1]) }
              StreamProject { exprs: [$2, $1, $0, $3] }
                StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    /* order by agg input */
    create table t(v1 int);
    select sum(v1 order by v1) as s1 from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($0))] }
        LogicalProject { exprs: [$1] }
          LogicalScan { table: t, columns: [_row_id, v1] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($0))] }
      LogicalScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1 order_by($0))] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0 order_by($0))] }
            StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    /* order by other columns */
    create table t(v1 int, v2 varchar);
    select sum(v1 order by v2) as s1 from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($1))] }
        LogicalProject { exprs: [$1, $2] }
          LogicalScan { table: t, columns: [_row_id, v1, v2] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($1))] }
      LogicalScan { table: t, columns: [v1, v2] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1 order_by($1))] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0 order_by($1))] }
            StreamTableScan { table: t, columns: [v1, v2, _row_id], pk_indices: [2] }
- sql: |
    /* order by ASC/DESC and default */
    create table t(v1 int, v2 varchar, v3 int);
    select sum(v1 order by v1, v2 ASC, v3 DESC) as s1 from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($0, $1 ASC, $2 DESC))] }
        LogicalProject { exprs: [$1, $2, $3] }
          LogicalScan { table: t, columns: [_row_id, v1, v2, v3] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($0, $1 ASC, $2 DESC))] }
      LogicalScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1 order_by($0, $1 ASC, $2 DESC))] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0 order_by($0, $1 ASC, $2 DESC))] }
            StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    /* order by NULLS FIRST/LAST and default */
    create table t(v1 int, v2 varchar, v3 int);
    select sum(v1 order by v1, v2 NULLS FIRST, v3 NULLS LAST) as s1 from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($0, $1 NULLS FIRST, $2 NULLS LAST))] }
        LogicalProject { exprs: [$1, $2, $3] }
          LogicalScan { table: t, columns: [_row_id, v1, v2, v3] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($0, $1 NULLS FIRST, $2 NULLS LAST))] }
      LogicalScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1 order_by($0, $1 NULLS FIRST, $2 NULLS LAST))] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0 order_by($0, $1 NULLS FIRST, $2 NULLS LAST))] }
            StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    /* order by complex expressions */
    create table t(v1 int, v2 varchar, v3 int);
    select sum(v1 order by v1 + v3 ASC, length(v2) * v3 DESC NULLS FIRST) as s1 from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($1 ASC, $2 DESC NULLS FIRST))] }
        LogicalProject { exprs: [$1, ($1 + $3), (Length($2) * $3)] }
          LogicalScan { table: t, columns: [_row_id, v1, v2, v3] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($0 order_by($1 ASC, $2 DESC NULLS FIRST))] }
      LogicalProject { exprs: [$0, ($0 + $2), (Length($1) * $2)] }
        LogicalScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1 order_by($1 ASC, $2 DESC NULLS FIRST))] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0 order_by($1 ASC, $2 DESC NULLS FIRST))] }
            StreamProject { exprs: [$0, ($0 + $2), (Length($1) * $2), $3] }
              StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    /* filter clause */
    create table t(v1 int);
    select sum(v1) FILTER (WHERE v1 > 0) AS sa from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($0) filter(($0 > 0:Int32))] }
        LogicalProject { exprs: [$1] }
          LogicalScan { table: t, columns: [_row_id, v1] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($0) filter(($0 > 0:Int32))] }
      LogicalScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), sa], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0) filter(($0 > 0:Int32))] }
            StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    /* filter clause */
    /* extra calculation, should reuse result from project */
    create table t(a int, b int);
    select sum(a * b) filter (where a * b > 0) as sab from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($2) filter((($0 * $1) > 0:Int32))] }
        LogicalProject { exprs: [$1, $2, ($1 * $2)] }
          LogicalScan { table: t, columns: [_row_id, a, b] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($2) filter((($0 * $1) > 0:Int32))] }
      LogicalProject { exprs: [$0, $1, ($0 * $1)] }
        LogicalScan { table: t, columns: [a, b] }
- sql: |
    /* complex filter clause */
    create table t(a int, b int);
    select max(a * b) FILTER (WHERE a < b AND a + b < 100 AND a * b != a + b - 1) AS sab from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [max($2) filter(((($0 < $1) AND (($0 + $1) < 100:Int32)) AND (($0 * $1) <> (($0 + $1) - 1:Int32))))] }
        LogicalProject { exprs: [$1, $2, ($1 * $2)] }
          LogicalScan { table: t, columns: [_row_id, a, b] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [max($2) filter(((($0 < $1) AND (($0 + $1) < 100:Int32)) AND (($0 * $1) <> (($0 + $1) - 1:Int32))))] }
      LogicalProject { exprs: [$0, $1, ($0 * $1)] }
        LogicalScan { table: t, columns: [a, b] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), sab], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [count, max($2) filter(((($0 < $1) AND (($0 + $1) < 100:Int32)) AND (($0 * $1) <> (($0 + $1) - 1:Int32))))] }
        StreamExchange { dist: Single }
          StreamProject { exprs: [$0, $1, ($0 * $1), $2] }
            StreamTableScan { table: t, columns: [a, b, _row_id], pk_indices: [2] }
- sql: |
    /* avg filter clause + group by */
    create table t(a int, b int);
    select avg(a) FILTER (WHERE a > b) AS avga from t group by b ;
  logical_plan: |
    LogicalProject { exprs: [($1::Decimal / $2)] }
      LogicalAgg { group_key: [0], agg_calls: [sum($1) filter(($1 > $0)), count($1) filter(($1 > $0))] }
        LogicalProject { exprs: [$2, $1] }
          LogicalScan { table: t, columns: [_row_id, a, b] }
  optimized_logical_plan: |
    LogicalProject { exprs: [($1::Decimal / $2)] }
      LogicalAgg { group_key: [0], agg_calls: [sum($1) filter(($1 > $0)), count($1) filter(($1 > $0))] }
        LogicalProject { exprs: [$1, $0] }
          LogicalScan { table: t, columns: [a, b] }
  stream_plan: |
    StreamMaterialize { columns: [avga, b(hidden)], pk_columns: [b] }
      StreamProject { exprs: [($2::Decimal / $3), $0] }
        StreamHashAgg { group_key: [$0], aggs: [count, sum($1) filter(($1 > $0)), count($1) filter(($1 > $0))] }
          StreamExchange { dist: HashShard([0]) }
            StreamProject { exprs: [$1, $0, $2] }
              StreamTableScan { table: t, columns: [a, b, _row_id], pk_indices: [2] }
- sql: |
    /* count filter clause */
    create table t(a int, b int);
    select count(*) FILTER (WHERE a > b) AS cnt_agb from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [count filter(($0 > $1))] }
        LogicalProject { exprs: [$1, $2] }
          LogicalScan { table: t, columns: [_row_id, a, b] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [count filter(($0 > $1))] }
      LogicalScan { table: t, columns: [a, b] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), cnt_agb], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, count filter(($0 > $1))] }
            StreamTableScan { table: t, columns: [a, b, _row_id], pk_indices: [2] }
- sql: |
    /* filter clause + non-boolean function */
    create table t(a int, b int);
    select avg(a) FILTER (WHERE abs(a)) AS avga from t;
  binder_error: 'Invalid input syntax: the type of filter clause should be boolean, but found Int32'
- sql: |
    /* filter clause + subquery */
    create table t(a int, b int);
    select avg(a) FILTER (WHERE 0 < (select max(a) from t)) AS avga from t;
  binder_error: 'Invalid input syntax: subquery in filter clause is not supported'
- sql: |
    /* aggregation in filter clause */
    create table t(a int, b int);
    select avg(a) FILTER (WHERE a < avg(b)) AS avga from t;
  binder_error: 'Invalid input syntax: aggregation function in filter clause is not supported'
- sql: |
    /* filter clause + non-boolean function */
    create table t(a int, b int);
    select abs(a) FILTER (WHERE a > 0) AS avga from t;
  binder_error: 'Invalid input syntax: DISTINCT, ORDER BY or FILTER is only allowed in aggregation functions, but `abs` is not an aggregation function'
- sql: |
    /* prune column before filter */
    create table t(v1 int, v2 int);
    with sub(a, b) as (select min(v1), sum(v2) filter (where v2 < 5) from t) select b from sub;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0)] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [sum($0) filter(($0 < 5:Int32))] }
          BatchScan { table: t, columns: [v2] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), b], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0) filter(($0 < 5:Int32))] }
            StreamTableScan { table: t, columns: [v2, _row_id], pk_indices: [1] }
- sql: |
    /* combined order by & filter clauses */
    create table t(a varchar, b int);
    select sum(length(a) * b order by length(a) + b) filter (where b < 100 AND b * 2 > 10) as s1 from t;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($1 order_by($2)) filter((($0 < 100:Int32) AND (($0 * 2:Int32) > 10:Int32)))] }
        LogicalProject { exprs: [$2, (Length($1) * $2), (Length($1) + $2)] }
          LogicalScan { table: t, columns: [_row_id, a, b] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($1 order_by($2)) filter((($0 < 100:Int32) AND (($0 * 2:Int32) > 10:Int32)))] }
      LogicalProject { exprs: [$1, (Length($0) * $1), (Length($0) + $1)] }
        LogicalScan { table: t, columns: [a, b] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), s1], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1 order_by($2))] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($1 order_by($2)) filter((($0 < 100:Int32) AND (($0 * 2:Int32) > 10:Int32)))] }
            StreamProject { exprs: [$1, (Length($0) * $1), (Length($0) + $1), $2] }
              StreamTableScan { table: t, columns: [a, b, _row_id], pk_indices: [2] }
