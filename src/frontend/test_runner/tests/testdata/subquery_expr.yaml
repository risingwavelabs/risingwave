# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- sql: |
    select (select 1);
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
      LogicalJoin { type: LeftOuter, on: true, output: all }
        LogicalValues { rows: [[]], schema: Schema { fields: [] } }
        LogicalProject { exprs: [1:Int32] }
          LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    create table t(x int);
    select (select x from t), 1 from t;
  logical_plan: |
    LogicalProject { exprs: [t.x, 1:Int32] }
      LogicalJoin { type: LeftOuter, on: true, output: all }
        LogicalScan { table: t, columns: [t._row_id, t.x] }
        LogicalProject { exprs: [t.x] }
          LogicalScan { table: t, columns: [t._row_id, t.x] }
- sql: |
    create table t(x int);
    select (select x from t) + 1 from t;
  logical_plan: |
    LogicalProject { exprs: [(t.x + 1:Int32)] }
      LogicalJoin { type: LeftOuter, on: true, output: all }
        LogicalScan { table: t, columns: [t._row_id, t.x] }
        LogicalProject { exprs: [t.x] }
          LogicalScan { table: t, columns: [t._row_id, t.x] }
- sql: |
    create table t(x int);
    select (select x from t), (select 1);
  logical_plan: |
    LogicalProject { exprs: [t.x, 1:Int32] }
      LogicalJoin { type: LeftOuter, on: true, output: all }
        LogicalJoin { type: LeftOuter, on: true, output: all }
          LogicalValues { rows: [[]], schema: Schema { fields: [] } }
          LogicalProject { exprs: [t.x] }
            LogicalScan { table: t, columns: [t._row_id, t.x] }
        LogicalProject { exprs: [1:Int32] }
          LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    create table t(x int);
    select x + (select x + (select x as v1 from t) as v2 from t) as v3 from t;
  logical_plan: |
    LogicalProject { exprs: [(t.x + (t.x + t.x))] }
      LogicalJoin { type: LeftOuter, on: true, output: all }
        LogicalScan { table: t, columns: [t._row_id, t.x] }
        LogicalProject { exprs: [(t.x + t.x)] }
          LogicalJoin { type: LeftOuter, on: true, output: all }
            LogicalScan { table: t, columns: [t._row_id, t.x] }
            LogicalProject { exprs: [t.x] }
              LogicalScan { table: t, columns: [t._row_id, t.x] }
- sql: |
    select (select 1, 2);
  binder_error: 'Bind error: Subquery must return only one column'
- sql: |
    create table t(x int);
    select 1 where exists (select * from t);
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
      LogicalJoin { type: LeftSemi, on: true, output: all }
        LogicalValues { rows: [[]], schema: Schema { fields: [] } }
        LogicalProject { exprs: [t.x] }
          LogicalScan { table: t, columns: [t._row_id, t.x] }
  optimized_logical_plan: |
    LogicalProject { exprs: [1:Int32] }
      LogicalJoin { type: LeftSemi, on: true, output: all }
        LogicalValues { rows: [[]], schema: Schema { fields: [] } }
        LogicalScan { table: t, columns: [] }
- sql: |
    create table t(x int);
    select 1 where not exists (select * from t);
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
      LogicalJoin { type: LeftAnti, on: true, output: all }
        LogicalValues { rows: [[]], schema: Schema { fields: [] } }
        LogicalProject { exprs: [t.x] }
          LogicalScan { table: t, columns: [t._row_id, t.x] }
  optimized_logical_plan: |
    LogicalProject { exprs: [1:Int32] }
      LogicalJoin { type: LeftAnti, on: true, output: all }
        LogicalValues { rows: [[]], schema: Schema { fields: [] } }
        LogicalScan { table: t, columns: [] }
- sql: |
    create table t1(x int);
    create table t2(x int);
    select x from t1 where exists (select x from t2);
  logical_plan: |
    LogicalProject { exprs: [t1.x] }
      LogicalJoin { type: LeftSemi, on: true, output: all }
        LogicalScan { table: t1, columns: [t1._row_id, t1.x] }
        LogicalProject { exprs: [t2.x] }
          LogicalScan { table: t2, columns: [t2._row_id, t2.x] }
- sql: |
    create table t(x int);
    select x from t where exists (select * from t);
  logical_plan: |
    LogicalProject { exprs: [t.x] }
      LogicalJoin { type: LeftSemi, on: true, output: all }
        LogicalScan { table: t, columns: [t._row_id, t.x] }
        LogicalProject { exprs: [t.x] }
          LogicalScan { table: t, columns: [t._row_id, t.x] }
- sql: |
    create table t1(x int);
    create table t2(x int);
    select x from t1 where x > (select x from t2)
  logical_plan: |
    LogicalProject { exprs: [t1.x] }
      LogicalFilter { predicate: (t1.x > t2.x) }
        LogicalJoin { type: LeftOuter, on: true, output: all }
          LogicalScan { table: t1, columns: [t1._row_id, t1.x] }
          LogicalProject { exprs: [t2.x] }
            LogicalScan { table: t2, columns: [t2._row_id, t2.x] }
- sql: |
    select 1 where 1>0 and exists (values (1))
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
      LogicalFilter { predicate: (1:Int32 > 0:Int32) }
        LogicalJoin { type: LeftSemi, on: true, output: all }
          LogicalValues { rows: [[]], schema: Schema { fields: [] } }
          LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [:Int32] } }
- sql: |
    select 1 where (not exists (values (1))) and (1>0 or exists (values (1)))
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
      LogicalFilter { predicate: ((1:Int32 > 0:Int32) OR (count >= 1:Int32)) }
        LogicalJoin { type: LeftOuter, on: true, output: all }
          LogicalJoin { type: LeftAnti, on: true, output: all }
            LogicalValues { rows: [[]], schema: Schema { fields: [] } }
            LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [:Int32] } }
          LogicalProject { exprs: [(count >= 1:Int32)] }
            LogicalAgg { aggs: [count] }
              LogicalValues { rows: [[1:Int32]], schema: Schema { fields: [:Int32] } }
- sql: |
    select 1 + (select 2 from t);
  binder_error: 'Catalog error: table or source not found: t'
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y from t2);
  logical_plan: |
    LogicalProject { exprs: [t1.x] }
      LogicalJoin { type: LeftSemi, on: (t1.y = t2.y), output: all }
        LogicalScan { table: t1, columns: [t1._row_id, t1.x, t1.y] }
        LogicalProject { exprs: [t2.y] }
          LogicalScan { table: t2, columns: [t2._row_id, t2.x, t2.y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y not in (select y from t2);
  logical_plan: |
    LogicalProject { exprs: [t1.x] }
      LogicalJoin { type: LeftAnti, on: (t1.y = t2.y), output: all }
        LogicalScan { table: t1, columns: [t1._row_id, t1.x, t1.y] }
        LogicalProject { exprs: [t2.y] }
          LogicalScan { table: t2, columns: [t2._row_id, t2.x, t2.y] }
