# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x > (select 1.5 * min(x) from t2 where t1.y=t2.y and t2.y = 1000)
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalFilter { predicate: ($1 > $4) }
        LogicalJoin { type: LeftOuter, on: ($2 = $3) }
          LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalApply { type: Inner, on: true }
            LogicalAgg { group_keys: [0], agg_calls: [] }
              LogicalProject { exprs: [$2] }
                LogicalScan { table: t1, columns: [_row_id, x, y] }
            LogicalProject { exprs: [(1.5:Decimal * $0)] }
              LogicalAgg { group_keys: [], agg_calls: [min($0)] }
                LogicalProject { exprs: [$1] }
                  LogicalFilter { predicate: (CorrelatedInputRef { index: 0, depth: 1 } = $2) AND ($2 = 1000:Int32) }
                    LogicalScan { table: t2, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalJoin { type: Inner, on: ($1 = $2) AND ($0 > $3) }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalProject { exprs: [$0, (1.5:Decimal * $1)] }
          LogicalAgg { group_keys: [0], agg_calls: [min($1)] }
            LogicalProject { exprs: [$1, $0] }
              LogicalFilter { predicate: ($1 = 1000:Int32) }
                LogicalScan { table: t2, columns: [x, y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x>(select min(x) from t2 where t2.y = (select t1.y))
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalFilter { predicate: ($1 > $4) }
        LogicalJoin { type: LeftOuter, on: ($2 = $3) }
          LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalApply { type: Inner, on: true }
            LogicalAgg { group_keys: [0], agg_calls: [] }
              LogicalProject { exprs: [$2] }
                LogicalScan { table: t1, columns: [_row_id, x, y] }
            LogicalProject { exprs: [$0] }
              LogicalAgg { group_keys: [], agg_calls: [min($0)] }
                LogicalProject { exprs: [$1] }
                  LogicalFilter { predicate: ($2 = $3) }
                    LogicalJoin { type: LeftOuter, on: true }
                      LogicalScan { table: t2, columns: [_row_id, x, y] }
                      LogicalProject { exprs: [CorrelatedInputRef { index: 0, depth: 2 }] }
                        LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1 where x>(select min(x) from t2 where t1.y=t2.y and t1.x=(select max(x) from t3, (select 1) as dummy where t3.y=t1.y))
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalFilter { predicate: ($1 > $6) }
        LogicalJoin { type: LeftOuter, on: ($2 = $3) AND ($1 = $4) AND ($2 = $5) }
          LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalApply { type: Inner, on: true }
            LogicalAgg { group_keys: [0, 1, 2], agg_calls: [] }
              LogicalProject { exprs: [$2, $1, $2] }
                LogicalScan { table: t1, columns: [_row_id, x, y] }
            LogicalProject { exprs: [$0] }
              LogicalAgg { group_keys: [], agg_calls: [min($0)] }
                LogicalProject { exprs: [$1] }
                  LogicalFilter { predicate: (CorrelatedInputRef { index: 0, depth: 1 } = $2) AND (CorrelatedInputRef { index: 1, depth: 1 } = $3) }
                    LogicalJoin { type: LeftOuter, on: true }
                      LogicalScan { table: t2, columns: [_row_id, x, y] }
                      LogicalProject { exprs: [$0] }
                        LogicalAgg { group_keys: [], agg_calls: [max($0)] }
                          LogicalProject { exprs: [$1] }
                            LogicalFilter { predicate: ($2 = CorrelatedInputRef { index: 2, depth: 2 }) }
                              LogicalJoin { type: Inner, on: true }
                                LogicalScan { table: t3, columns: [_row_id, x, y] }
                                LogicalProject { exprs: [1:Int32] }
                                  LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where exists(select * from t2 where y = 100 and t1.x = t2.x and x = 1000 and t1.y = t2.y);
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalJoin { type: LeftSemi, on: ($1 = $3) AND ($2 = $4) }
        LogicalScan { table: t1, columns: [_row_id, x, y] }
        LogicalApply { type: Inner, on: true }
          LogicalAgg { group_keys: [0, 1], agg_calls: [] }
            LogicalProject { exprs: [$1, $2] }
              LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalProject { exprs: [$1, $2] }
            LogicalFilter { predicate: ($2 = 100:Int32) AND (CorrelatedInputRef { index: 0, depth: 1 } = $1) AND ($1 = 1000:Int32) AND (CorrelatedInputRef { index: 1, depth: 1 } = $2) }
              LogicalScan { table: t2, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: ($0 = $2) AND ($1 = $3), output_indices: all }
      LogicalScan { table: t1, columns: [x, y] }
      LogicalScan { table: t2, output_columns: [x, y], required_columns: [$1:x, $2:y], predicate: ($2 = 100:Int32) AND ($1 = 1000:Int32) }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x > (select 1.5 * min(x) from t2 where t1.y = t2.y);
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalFilter { predicate: ($1 > $4) }
        LogicalJoin { type: LeftOuter, on: ($2 = $3) }
          LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalApply { type: Inner, on: true }
            LogicalAgg { group_keys: [0], agg_calls: [] }
              LogicalProject { exprs: [$2] }
                LogicalScan { table: t1, columns: [_row_id, x, y] }
            LogicalProject { exprs: [(1.5:Decimal * $0)] }
              LogicalAgg { group_keys: [], agg_calls: [min($0)] }
                LogicalProject { exprs: [$1] }
                  LogicalFilter { predicate: (CorrelatedInputRef { index: 0, depth: 1 } = $2) }
                    LogicalScan { table: t2, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalJoin { type: Inner, on: ($1 = $2) AND ($0 > $3) }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalProject { exprs: [$0, (1.5:Decimal * $1)] }
          LogicalAgg { group_keys: [0], agg_calls: [min($1)] }
            LogicalProject { exprs: [$1, $0] }
              LogicalScan { table: t2, columns: [x, y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x > (select count(*) from t2 where t1.y = t2.y);
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalFilter { predicate: ($1 > $4) }
        LogicalJoin { type: LeftOuter, on: ($2 = $3) }
          LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalApply { type: Inner, on: true }
            LogicalAgg { group_keys: [0], agg_calls: [] }
              LogicalProject { exprs: [$2] }
                LogicalScan { table: t1, columns: [_row_id, x, y] }
            LogicalProject { exprs: [$0] }
              LogicalAgg { group_keys: [], agg_calls: [count] }
                LogicalProject { exprs: [] }
                  LogicalFilter { predicate: (CorrelatedInputRef { index: 0, depth: 1 } = $2) }
                    LogicalScan { table: t2, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalJoin { type: Inner, on: ($1 = $2) AND ($0 > $3) }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalAgg { group_keys: [0], agg_calls: [count] }
          LogicalScan { table: t2, columns: [y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where x > (select count(*) + count(*) from t2 where t1.y = t2.y);
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalFilter { predicate: ($1 > $4) }
        LogicalJoin { type: LeftOuter, on: ($2 = $3) }
          LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalApply { type: Inner, on: true }
            LogicalAgg { group_keys: [0], agg_calls: [] }
              LogicalProject { exprs: [$2] }
                LogicalScan { table: t1, columns: [_row_id, x, y] }
            LogicalProject { exprs: [($0 + $1)] }
              LogicalAgg { group_keys: [], agg_calls: [count, count] }
                LogicalProject { exprs: [] }
                  LogicalFilter { predicate: (CorrelatedInputRef { index: 0, depth: 1 } = $2) }
                    LogicalScan { table: t2, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalJoin { type: Inner, on: ($1 = $2) AND ($0 > $3) }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalProject { exprs: [$0, ($1 + $2)] }
          LogicalAgg { group_keys: [0], agg_calls: [count, count] }
            LogicalScan { table: t2, columns: [y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y from t2 where t1.x = t2.x);
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalJoin { type: LeftSemi, on: ($2 = $4) AND ($1 = $3) }
        LogicalScan { table: t1, columns: [_row_id, x, y] }
        LogicalApply { type: Inner, on: true }
          LogicalAgg { group_keys: [0], agg_calls: [] }
            LogicalProject { exprs: [$1] }
              LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalProject { exprs: [$2] }
            LogicalFilter { predicate: (CorrelatedInputRef { index: 0, depth: 1 } = $1) }
              LogicalScan { table: t2, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalJoin { type: LeftSemi, on: ($1 = $3) AND ($0 = $2) }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalScan { table: t2, columns: [x, y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y not in (select y from t2 where t1.x = t2.x);
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y from t2 where t1.x + t2.x = 100 and t1.y = 1000);
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalJoin { type: LeftSemi, on: ($2 = $5) AND ($1 = $3) AND ($2 = $4) }
        LogicalScan { table: t1, columns: [_row_id, x, y] }
        LogicalApply { type: Inner, on: true }
          LogicalAgg { group_keys: [0, 1], agg_calls: [] }
            LogicalProject { exprs: [$1, $2] }
              LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalProject { exprs: [$2] }
            LogicalFilter { predicate: ((CorrelatedInputRef { index: 0, depth: 1 } + $1) = 100:Int32) AND (CorrelatedInputRef { index: 1, depth: 1 } = 1000:Int32) }
              LogicalScan { table: t2, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalJoin { type: LeftSemi, on: ($1 = $4) AND ($0 = $2) AND ($1 = $3) }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalProject { exprs: [$0, $1, $3] }
          LogicalJoin { type: Inner, on: (($0 + $2) = 100:Int32) }
            LogicalAgg { group_keys: [0, 1], agg_calls: [] }
              LogicalFilter { predicate: ($1 = 1000:Int32) }
                LogicalScan { table: t1, columns: [x, y] }
            LogicalScan { table: t2, columns: [x, y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y from t2 where t1.x > t2.x + 1000);
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalJoin { type: LeftSemi, on: ($2 = $4) AND ($1 = $3) }
        LogicalScan { table: t1, columns: [_row_id, x, y] }
        LogicalApply { type: Inner, on: true }
          LogicalAgg { group_keys: [0], agg_calls: [] }
            LogicalProject { exprs: [$1] }
              LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalProject { exprs: [$2] }
            LogicalFilter { predicate: (CorrelatedInputRef { index: 0, depth: 1 } > ($1 + 1000:Int32)) }
              LogicalScan { table: t2, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalJoin { type: LeftSemi, on: ($1 = $3) AND ($0 = $2) }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalProject { exprs: [$0, $2] }
          LogicalJoin { type: Inner, on: ($0 > ($1 + 1000:Int32)) }
            LogicalAgg { group_keys: [0], agg_calls: [] }
              LogicalScan { table: t1, columns: [x] }
            LogicalScan { table: t2, columns: [x, y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select x from t1 where y in (select y, x from t2 where t1.x > t2.x + 1000);
  binder_error: 'Bind error: Subquery must return only one column'
- sql: |
    /* correlated outer subquery with an uncorrelated inner subquery */
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select x from t1 where y in (select x from t2 where t2.y = t1.y and x > (select min(x) from t3));
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalJoin { type: LeftSemi, on: ($2 = $4) AND ($2 = $3) }
        LogicalScan { table: t1, columns: [_row_id, x, y] }
        LogicalApply { type: Inner, on: true }
          LogicalAgg { group_keys: [0], agg_calls: [] }
            LogicalProject { exprs: [$2] }
              LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalProject { exprs: [$1] }
            LogicalFilter { predicate: ($2 = CorrelatedInputRef { index: 0, depth: 1 }) AND ($1 > $3) }
              LogicalJoin { type: LeftOuter, on: true }
                LogicalScan { table: t2, columns: [_row_id, x, y] }
                LogicalProject { exprs: [$0] }
                  LogicalAgg { group_keys: [], agg_calls: [min($0)] }
                    LogicalProject { exprs: [$1] }
                      LogicalScan { table: t3, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalJoin { type: LeftSemi, on: ($1 = $3) AND ($1 = $2) }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalProject { exprs: [$1, $0] }
          LogicalJoin { type: Inner, on: ($0 > $2) }
            LogicalScan { table: t2, columns: [x, y] }
            LogicalAgg { group_keys: [], agg_calls: [min($0)] }
              LogicalScan { table: t3, columns: [x] }
- sql: |
    /* correlated inner subquery with depth = 2 */
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select x from t1 where y in (select x from t2 where y in (select y from t3 where t1.y = t3.y));
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalJoin { type: LeftSemi, on: ($2 = $4) AND ($2 = $3) }
        LogicalScan { table: t1, columns: [_row_id, x, y] }
        LogicalApply { type: Inner, on: true }
          LogicalAgg { group_keys: [0], agg_calls: [] }
            LogicalProject { exprs: [$2] }
              LogicalScan { table: t1, columns: [_row_id, x, y] }
          LogicalProject { exprs: [$1] }
            LogicalJoin { type: LeftSemi, on: ($2 = $3) }
              LogicalScan { table: t2, columns: [_row_id, x, y] }
              LogicalProject { exprs: [$2] }
                LogicalFilter { predicate: (CorrelatedInputRef { index: 0, depth: 2 } = $2) }
                  LogicalScan { table: t3, columns: [_row_id, x, y] }
- sql: |
    /* uncorrelated outer subquery with a correlated inner subquery */
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select x from t1 where y in (select x from t2 where y in (select y from t3 where t2.y = t3.y));
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalJoin { type: LeftSemi, on: ($2 = $3), output_indices: all }
        LogicalScan { table: t1, columns: [_row_id, x, y] }
        LogicalProject { exprs: [$1] }
          LogicalJoin { type: LeftSemi, on: ($2 = $4) AND ($2 = $3) }
            LogicalScan { table: t2, columns: [_row_id, x, y] }
            LogicalApply { type: Inner, on: true }
              LogicalAgg { group_keys: [0], agg_calls: [] }
                LogicalProject { exprs: [$2] }
                  LogicalScan { table: t2, columns: [_row_id, x, y] }
              LogicalProject { exprs: [$2] }
                LogicalFilter { predicate: (CorrelatedInputRef { index: 0, depth: 1 } = $2) }
                  LogicalScan { table: t3, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalJoin { type: LeftSemi, on: ($1 = $2) }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalProject { exprs: [$0] }
          LogicalJoin { type: LeftSemi, on: ($1 = $3) AND ($1 = $2) }
            LogicalScan { table: t2, columns: [x, y] }
            LogicalProject { exprs: [$0, $0] }
              LogicalScan { table: t3, columns: [y] }
- sql: |
    /* correlated agg column in SELECT */
    create table t (v1 int, v2 int);
    select min(v1), (select max(v2)) from t;
  planner_error: 'Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg, Tracking issue: https://github.com/singularity-data/risingwave/issues/2275'
- sql: |
    /* correlated group column in SELECT */
    create table t (v1 int, v2 int);
    select min(v1), (select v2) from t group by v2;
  planner_error: 'Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg, Tracking issue: https://github.com/singularity-data/risingwave/issues/2275'
- sql: |
    /* correlated non-group column in SELECT */
    create table t (v1 int, v2 int);
    select min(v1), (select v2) from t;
  planner_error: 'Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg, Tracking issue: https://github.com/singularity-data/risingwave/issues/2275'
- sql: |
    /* correlated agg column in HAVING */
    create table t (v1 int, v2 int);
    select 1 from t having min(v1) > (select max(v2));
  planner_error: 'Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg, Tracking issue: https://github.com/singularity-data/risingwave/issues/2275'
- sql: |
    /* correlated group column in HAVING */
    create table t (v1 int, v2 int);
    select 1 from t group by v2 having min(v1) > (select v2);
  planner_error: 'Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg, Tracking issue: https://github.com/singularity-data/risingwave/issues/2275'
- sql: |
    /* correlated non-group column in HAVING */
    create table t (v1 int, v2 int);
    select 1 from t having min(v1) > (select v2);
  planner_error: 'Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg, Tracking issue: https://github.com/singularity-data/risingwave/issues/2275'
- sql: |
    /* correlated agg column belongs to outer query */
    create table t (v1 int, v2 int);
    create table t2 (v3 int, v4 int);
    select
      min(v1),
      (select max(v2) + v3 from t2)  -- access to v3 is ok
    from t;
  planner_error: 'Feature is not yet implemented: correlated subquery in HAVING or SELECT with agg, Tracking issue: https://github.com/singularity-data/risingwave/issues/2275'
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select t2.x, (select x from t1 where t1.y = t2.y) from t2 where x > 100 order by t2.x limit 100;
  logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalTopN { order: [$2 ASC], limit: 100, offset: 0 }
        LogicalProject { exprs: [$1, $4, $1] }
          LogicalJoin { type: LeftOuter, on: ($2 = $3) }
            LogicalFilter { predicate: ($1 > 100:Int32) }
              LogicalScan { table: t2, columns: [_row_id, x, y] }
            LogicalApply { type: Inner, on: true }
              LogicalAgg { group_keys: [0], agg_calls: [] }
                LogicalProject { exprs: [$2] }
                  LogicalFilter { predicate: ($1 > 100:Int32) }
                    LogicalScan { table: t2, columns: [_row_id, x, y] }
              LogicalProject { exprs: [$1] }
                LogicalFilter { predicate: ($2 = CorrelatedInputRef { index: 0, depth: 1 }) }
                  LogicalScan { table: t1, columns: [_row_id, x, y] }
  optimized_logical_plan: |
    LogicalTopN { order: [$2 ASC], limit: 100, offset: 0 }
      LogicalProject { exprs: [$0, $3, $0] }
        LogicalJoin { type: LeftOuter, on: ($1 = $2) }
          LogicalFilter { predicate: ($0 > 100:Int32) }
            LogicalScan { table: t2, columns: [x, y] }
          LogicalProject { exprs: [$1, $0] }
            LogicalScan { table: t1, columns: [x, y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1 where exists(select x from t2 where t1.x = t2.x and t1.y = t2.y)
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: ($0 = $2) AND ($1 = $3) }
      LogicalScan { table: t1, columns: [x, y] }
      LogicalScan { table: t2, columns: [x, y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    create table t3(x int, y int);
    select * from t1, t2 where exists(select x from t3 where t3.x = t1.x and t3.y <> t2.y);
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: ($0 = $4) AND ($3 = $5) }
      LogicalJoin { type: Inner, on: true }
        LogicalScan { table: t1, columns: [x, y] }
        LogicalScan { table: t2, columns: [x, y] }
      LogicalProject { exprs: [$0, $1] }
        LogicalJoin { type: Inner, on: ($2 = $0) AND ($3 <> $1) }
          LogicalAgg { group_keys: [0, 1], agg_calls: [] }
            LogicalJoin { type: Inner, on: true }
              LogicalScan { table: t1, columns: [x] }
              LogicalScan { table: t2, columns: [y] }
          LogicalScan { table: t3, columns: [x, y] }
