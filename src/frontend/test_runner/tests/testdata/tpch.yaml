# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- id: create_tables
  sql: |
    CREATE TABLE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR(25),
            s_address VARCHAR(40),
            s_nationkey INTEGER,
            s_phone VARCHAR(15),
            s_acctbal NUMERIC,
            s_comment VARCHAR(101));

    CREATE TABLE part (
            p_partkey INTEGER,
            p_name VARCHAR(55),
            p_mfgr VARCHAR(25),
            p_brand VARCHAR(10),
            p_type VARCHAR(100),
            p_size INTEGER,
            p_container VARCHAR(10),
            p_retailprice NUMERIC,
            p_comment VARCHAR(23));

    CREATE TABLE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR(199));

    CREATE TABLE customer (
            c_custkey INTEGER,
            c_name VARCHAR(25),
            c_address VARCHAR(40),
            c_nationkey INTEGER,
            c_phone VARCHAR(15),
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR(10),
            c_comment VARCHAR(117));

    CREATE TABLE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR(1),
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR(15),
            o_clerk VARCHAR(15),
            o_shippriority INTEGER,
            o_comment VARCHAR(79));

    CREATE TABLE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR(1),
            l_linestatus VARCHAR(1),
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR(25),
            l_shipmode VARCHAR(10),
            l_comment VARCHAR(44));

    CREATE TABLE nation (
            n_nationkey INTEGER,
            n_name VARCHAR(25),
            n_regionkey INTEGER,
            n_comment VARCHAR(152));

    CREATE TABLE region (
            r_regionkey INTEGER,
            r_name VARCHAR(25),
            r_comment VARCHAR(152));
- id: tpch_q1
  before:
    - create_tables
  sql: |
    select
      l_returnflag,
      l_linestatus,
      sum(l_quantity) as sum_qty,
      sum(l_extendedprice) as sum_base_price,
      sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
      sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
      round(avg(l_quantity), 4) as avg_qty,
      round(avg(l_extendedprice), 4) as avg_price,
      round(avg(l_discount), 4) as avg_disc,
      count(*) as count_order
    from
      lineitem
    where
      l_shipdate <= date '1998-12-01' - interval '71' day
    group by
      l_returnflag,
      l_linestatus
    order by
      l_returnflag,
      l_linestatus;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $2, $3, $4, $5, RoundDigit(($6 / $7), 4:Int32), RoundDigit(($8 / $9), 4:Int32), RoundDigit(($10 / $11), 4:Int32), $12] }
      LogicalAgg { group_key: [0, 1], agg_calls: [sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
        LogicalProject { exprs: [$9, $10, $5, $6, ($6 * (1:Int32 - $7)), (($6 * (1:Int32 - $7)) * (1:Int32 + $8)), $7] }
          LogicalFilter { predicate: ($11 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
            LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, $1, $2, $3, $4, $5, RoundDigit(($6 / $7), 4:Int32), RoundDigit(($8 / $9), 4:Int32), RoundDigit(($10 / $11), 4:Int32), $12] }
      LogicalAgg { group_key: [0, 1], agg_calls: [sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
        LogicalProject { exprs: [$4, $5, $0, $1, ($1 * (1:Int32 - $2)), (($1 * (1:Int32 - $2)) * (1:Int32 + $3)), $2] }
          LogicalScan { table: lineitem, output_columns: [l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus], required_columns: [$5:l_quantity, $6:l_extendedprice, $7:l_discount, $8:l_tax, $9:l_returnflag, $10:l_linestatus, $11:l_shipdate], predicate: ($11 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 ASC], dist: Single }
      BatchSort { order: [$0 ASC, $1 ASC] }
        BatchProject { exprs: [$0, $1, $2, $3, $4, $5, RoundDigit(($6 / $7), 4:Int32), RoundDigit(($8 / $9), 4:Int32), RoundDigit(($10 / $11), 4:Int32), $12] }
          BatchHashAgg { group_key: [$0, $1], aggs: [sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
            BatchExchange { order: [], dist: HashShard([0, 1]) }
              BatchProject { exprs: [$4, $5, $0, $1, ($1 * (1:Int32 - $2)), (($1 * (1:Int32 - $2)) * (1:Int32 + $3)), $2] }
                BatchFilter { predicate: ($6 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
                  BatchScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, avg_qty, avg_price, avg_disc, count_order], pk_columns: [l_returnflag, l_linestatus] }
      StreamProject { exprs: [$0, $1, $3, $4, $5, $6, RoundDigit(($7 / $8), 4:Int32), RoundDigit(($9 / $10), 4:Int32), RoundDigit(($11 / $12), 4:Int32), $13] }
        StreamHashAgg { group_key: [$0, $1], aggs: [count, sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
          StreamExchange { dist: HashShard([0, 1]) }
            StreamProject { exprs: [$4, $5, $0, $1, ($1 * (1:Int32 - $2)), (($1 * (1:Int32 - $2)) * (1:Int32 + $3)), $2, $6] }
              StreamFilter { predicate: ($7 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
                StreamTableScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, _row_id, l_shipdate], pk_indices: [6] }
- id: tpch_q2
  before:
    - create_tables
  sql: |
    select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
    from
        partsupp,
        part,
        supplier,
     /* TODO(#1866): join reorder to avoid cross join */
     /* partsupp, */
        nation,
        region
    where
            p_partkey = ps_partkey
            and s_suppkey = ps_suppkey
      and p_size = 4
      and p_type like '%TIN'
            and s_nationkey = n_nationkey
            and n_regionkey = r_regionkey
            and r_name = 'AFRICA'
            and ps_supplycost = (
                    select
                            min(ps_supplycost)
                    from
                            partsupp,
                            supplier,
                            nation,
                            region
                    where
                            p_partkey = ps_partkey
                            and s_suppkey = ps_suppkey
                            and s_nationkey = n_nationkey
                            and n_regionkey = r_regionkey
                            and r_name = 'AFRICA'
            )
    order by
          s_acctbal desc,
          n_name,
          s_name,
          p_partkey
    limit 100;
  logical_plan: |
    LogicalTopN { order: [$0 DESC, $2 ASC, $1 ASC, $3 ASC], limit: 100, offset: 0 }
      LogicalProject { exprs: [$22, $18, $26, $7, $9, $19, $21, $23] }
        LogicalFilter { predicate: ($7 = $1) AND ($17 = $2) AND ($12 = 4:Int32) AND Like($11, '%TIN':Varchar) AND ($20 = $25) AND ($27 = $30) AND ($31 = 'AFRICA':Varchar) AND ($4 = $33) }
          LogicalApply { type: LeftOuter, on: true }
            LogicalJoin { type: Inner, on: true, output_indices: all }
              LogicalJoin { type: Inner, on: true, output_indices: all }
                LogicalJoin { type: Inner, on: true, output_indices: all }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                    LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                  LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
              LogicalScan { table: region, columns: [_row_id, r_regionkey, r_name, r_comment] }
            LogicalProject { exprs: [$0] }
              LogicalAgg { group_key: [], agg_calls: [min($0)] }
                LogicalProject { exprs: [$4] }
                  LogicalFilter { predicate: (CorrelatedInputRef { index: 7, depth: 1 } = $1) AND ($7 = $2) AND ($10 = $15) AND ($17 = $20) AND ($21 = 'AFRICA':Varchar) }
                    LogicalJoin { type: Inner, on: true, output_indices: all }
                      LogicalJoin { type: Inner, on: true, output_indices: all }
                        LogicalJoin { type: Inner, on: true, output_indices: all }
                          LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                          LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                        LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
                      LogicalScan { table: region, columns: [_row_id, r_regionkey, r_name, r_comment] }
  optimized_logical_plan: |
    LogicalTopN { order: [$0 DESC, $2 ASC, $1 ASC, $3 ASC], limit: 100, offset: 0 }
      LogicalProject { exprs: [$5, $2, $7, $0, $1, $3, $4, $6] }
        LogicalJoin { type: Inner, on: ($1 = $9) AND ($0 = $10), output_indices: [1, 2, 3, 4, 5, 6, 7, 8] }
          LogicalJoin { type: Inner, on: ($9 = $10), output_indices: [0, 1, 2, 3, 4, 5, 6, 7, 8] }
            LogicalJoin { type: Inner, on: ($5 = $9), output_indices: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11] }
              LogicalJoin { type: Inner, on: ($4 = $0), output_indices: [1, 2, 3, 5, 6, 7, 8, 9, 10] }
                LogicalJoin { type: Inner, on: ($3 = $0), output_indices: [1, 2, 3, 4] }
                  LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
                  LogicalScan { table: part, output_columns: [p_partkey, p_mfgr], required_columns: [$1:p_partkey, $3:p_mfgr, $5:p_type, $6:p_size], predicate: ($6 = 4:Int32) AND Like($5, '%TIN':Varchar) }
                LogicalScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
              LogicalScan { table: nation, columns: [n_nationkey, n_name, n_regionkey] }
            LogicalScan { table: region, output_columns: [r_regionkey], required_columns: [$1:r_regionkey, $2:r_name], predicate: ($2 = 'AFRICA':Varchar) }
          LogicalAgg { group_key: [0], agg_calls: [min($1)] }
            LogicalJoin { type: Inner, on: ($2 = $3), output_indices: [0, 1] }
              LogicalJoin { type: Inner, on: ($2 = $3), output_indices: [0, 1, 4] }
                LogicalJoin { type: Inner, on: ($3 = $1), output_indices: [0, 2, 4] }
                  LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
                  LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                LogicalScan { table: nation, columns: [n_nationkey, n_regionkey] }
              LogicalScan { table: region, output_columns: [r_regionkey], required_columns: [$1:r_regionkey, $2:r_name], predicate: ($2 = 'AFRICA':Varchar) }
  batch_plan: |
    BatchTopN { order: [$0 DESC, $2 ASC, $1 ASC, $3 ASC], limit: 100, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchTopN { order: [$0 DESC, $2 ASC, $1 ASC, $3 ASC], limit: 100, offset: 0 }
          BatchProject { exprs: [$5, $2, $7, $0, $1, $3, $4, $6] }
            BatchHashJoin { type: Inner, predicate: $1 = $9 AND $0 = $10, output_indices: [1, 2, 3, 4, 5, 6, 7, 8] }
              BatchExchange { order: [], dist: HashShard([1]) }
                BatchHashJoin { type: Inner, predicate: $9 = $10, output_indices: [0, 1, 2, 3, 4, 5, 6, 7, 8] }
                  BatchExchange { order: [], dist: HashShard([9]) }
                    BatchHashJoin { type: Inner, predicate: $5 = $9, output_indices: [0, 1, 2, 3, 4, 6, 7, 8, 10, 11] }
                      BatchExchange { order: [], dist: HashShard([5]) }
                        BatchHashJoin { type: Inner, predicate: $0 = $4, output_indices: [1, 2, 3, 5, 6, 7, 8, 9, 10] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchHashJoin { type: Inner, predicate: $0 = $3, output_indices: [1, 2, 3, 4] }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchProject { exprs: [$0, $1] }
                                  BatchFilter { predicate: ($3 = 4:Int32) AND Like($2, '%TIN':Varchar) }
                                    BatchScan { table: part, columns: [p_partkey, p_mfgr, p_type, p_size] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: nation, columns: [n_nationkey, n_name, n_regionkey] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchProject { exprs: [$0] }
                      BatchFilter { predicate: ($1 = 'AFRICA':Varchar) }
                        BatchScan { table: region, columns: [r_regionkey, r_name] }
              BatchHashAgg { group_key: [$0], aggs: [min($1)] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchHashJoin { type: Inner, predicate: $2 = $3, output_indices: [0, 1] }
                    BatchExchange { order: [], dist: HashShard([2]) }
                      BatchHashJoin { type: Inner, predicate: $2 = $3, output_indices: [0, 1, 4] }
                        BatchExchange { order: [], dist: HashShard([2]) }
                          BatchHashJoin { type: Inner, predicate: $1 = $3, output_indices: [0, 2, 4] }
                            BatchExchange { order: [], dist: HashShard([1]) }
                              BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
                            BatchExchange { order: [], dist: HashShard([0]) }
                              BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: nation, columns: [n_nationkey, n_regionkey] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchProject { exprs: [$0] }
                        BatchFilter { predicate: ($1 = 'AFRICA':Varchar) }
                          BatchScan { table: region, columns: [r_regionkey, r_name] }
  stream_plan: |
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), _row_id#1(hidden), _row_id#2(hidden), _row_id#3(hidden), _row_id#4(hidden), ps_partkey(hidden)], pk_columns: [_row_id, _row_id#1, _row_id#2, _row_id#3, _row_id#4, ps_partkey], order_descs: [s_acctbal, n_name, s_name, p_partkey, _row_id, _row_id#1, _row_id#2, _row_id#3, _row_id#4, ps_partkey] }
      StreamTopN { order: [$0 DESC, $2 ASC, $1 ASC, $3 ASC], limit: 100, offset: 0 }
        StreamExchange { dist: Single }
          StreamProject { exprs: [$5, $2, $7, $0, $1, $3, $4, $6, $8, $9, $10, $11, $12, $13] }
            StreamHashJoin { type: Inner, predicate: $1 = $14 AND $0 = $16, output_indices: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] }
              StreamExchange { dist: HashShard([1]) }
                StreamHashJoin { type: Inner, predicate: $9 = $14, output_indices: [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 15] }
                  StreamExchange { dist: HashShard([9]) }
                    StreamHashJoin { type: Inner, predicate: $5 = $12, output_indices: [0, 1, 2, 3, 4, 6, 7, 8, 13, 14, 9, 10, 11, 15] }
                      StreamExchange { dist: HashShard([5]) }
                        StreamHashJoin { type: Inner, predicate: $0 = $6, output_indices: [1, 2, 3, 7, 8, 9, 10, 11, 12, 4, 5, 13] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamHashJoin { type: Inner, predicate: $0 = $4, output_indices: [1, 2, 4, 5, 3, 6] }
                              StreamExchange { dist: HashShard([0]) }
                                StreamTableScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost, _row_id], pk_indices: [3] }
                              StreamExchange { dist: HashShard([0]) }
                                StreamProject { exprs: [$0, $1, $2] }
                                  StreamFilter { predicate: ($4 = 4:Int32) AND Like($3, '%TIN':Varchar) }
                                    StreamTableScan { table: part, columns: [p_partkey, p_mfgr, _row_id, p_type, p_size], pk_indices: [2] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamTableScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], pk_indices: [7] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: nation, columns: [n_nationkey, n_name, n_regionkey, _row_id], pk_indices: [3] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamProject { exprs: [$0, $1] }
                      StreamFilter { predicate: ($2 = 'AFRICA':Varchar) }
                        StreamTableScan { table: region, columns: [r_regionkey, _row_id, r_name], pk_indices: [1] }
              StreamHashAgg { group_key: [$0], aggs: [count, min($1)] }
                StreamExchange { dist: HashShard([0]) }
                  StreamHashJoin { type: Inner, predicate: $2 = $6, output_indices: [0, 1, 3, 4, 5, 7] }
                    StreamExchange { dist: HashShard([2]) }
                      StreamHashJoin { type: Inner, predicate: $2 = $5, output_indices: [0, 1, 6, 3, 4, 7] }
                        StreamExchange { dist: HashShard([2]) }
                          StreamHashJoin { type: Inner, predicate: $1 = $4, output_indices: [0, 2, 5, 3, 6] }
                            StreamExchange { dist: HashShard([1]) }
                              StreamTableScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost, _row_id], pk_indices: [3] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamTableScan { table: nation, columns: [n_nationkey, n_regionkey, _row_id], pk_indices: [2] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamProject { exprs: [$0, $1] }
                        StreamFilter { predicate: ($2 = 'AFRICA':Varchar) }
                          StreamTableScan { table: region, columns: [r_regionkey, _row_id, r_name], pk_indices: [1] }
- id: tpch_q3
  before:
    - create_tables
  sql: |
    select
      l_orderkey,
      sum(l_extendedprice * (1 - l_discount)) as revenue,
      o_orderdate,
      o_shippriority
    from
      customer,
      orders,
      lineitem
    where
      c_mktsegment = 'FURNITURE'
      and c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and o_orderdate < date '1995-03-29'
      and l_shipdate > date '1995-03-29'
    group by
      l_orderkey,
      o_orderdate,
      o_shippriority
    order by
      revenue desc,
      o_orderdate
    limit 10;
  logical_plan: |
    LogicalTopN { order: [$1 DESC, $2 ASC], limit: 10, offset: 0 }
      LogicalProject { exprs: [$0, $3, $1, $2] }
        LogicalAgg { group_key: [0, 1, 2], agg_calls: [sum($3)] }
          LogicalProject { exprs: [$20, $14, $17, ($25 * (1:Int32 - $26))] }
            LogicalFilter { predicate: ($7 = 'FURNITURE':Varchar) AND ($1 = $11) AND ($20 = $10) AND ($14 < '1995-03-29':Varchar::Date) AND ($30 > '1995-03-29':Varchar::Date) }
              LogicalJoin { type: Inner, on: true, output_indices: all }
                LogicalJoin { type: Inner, on: true, output_indices: all }
                  LogicalScan { table: customer, columns: [_row_id, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                  LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalTopN { order: [$1 DESC, $2 ASC], limit: 10, offset: 0 }
      LogicalProject { exprs: [$0, $3, $1, $2] }
        LogicalAgg { group_key: [0, 1, 2], agg_calls: [sum($3)] }
          LogicalProject { exprs: [$2, $0, $1, ($3 * (1:Int32 - $4))] }
            LogicalJoin { type: Inner, on: ($3 = $0), output_indices: [1, 2, 3, 4, 5] }
              LogicalJoin { type: Inner, on: ($0 = $2), output_indices: [1, 3, 4] }
                LogicalScan { table: customer, output_columns: [c_custkey], required_columns: [$1:c_custkey, $7:c_mktsegment], predicate: ($7 = 'FURNITURE':Varchar) }
                LogicalScan { table: orders, output_columns: [o_orderkey, o_custkey, o_orderdate, o_shippriority], required_columns: [$1:o_orderkey, $2:o_custkey, $5:o_orderdate, $8:o_shippriority], predicate: ($5 < '1995-03-29':Varchar::Date) }
              LogicalScan { table: lineitem, output_columns: [l_orderkey, l_extendedprice, l_discount], required_columns: [$1:l_orderkey, $6:l_extendedprice, $7:l_discount, $11:l_shipdate], predicate: ($11 > '1995-03-29':Varchar::Date) }
  batch_plan: |
    BatchTopN { order: [$1 DESC, $2 ASC], limit: 10, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchTopN { order: [$1 DESC, $2 ASC], limit: 10, offset: 0 }
          BatchProject { exprs: [$0, $3, $1, $2] }
            BatchHashAgg { group_key: [$0, $1, $2], aggs: [sum($3)] }
              BatchExchange { order: [], dist: HashShard([0, 1, 2]) }
                BatchProject { exprs: [$2, $0, $1, ($3 * (1:Int32 - $4))] }
                  BatchHashJoin { type: Inner, predicate: $0 = $3, output_indices: [1, 2, 3, 4, 5] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchHashJoin { type: Inner, predicate: $0 = $2, output_indices: [1, 3, 4] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchProject { exprs: [$0] }
                            BatchFilter { predicate: ($1 = 'FURNITURE':Varchar) }
                              BatchScan { table: customer, columns: [c_custkey, c_mktsegment] }
                        BatchExchange { order: [], dist: HashShard([1]) }
                          BatchFilter { predicate: ($2 < '1995-03-29':Varchar::Date) }
                            BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, o_shippriority] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchProject { exprs: [$0, $1, $2] }
                        BatchFilter { predicate: ($3 > '1995-03-29':Varchar::Date) }
                          BatchScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [l_orderkey, revenue, o_orderdate, o_shippriority], pk_columns: [l_orderkey, o_orderdate, o_shippriority], order_descs: [revenue, o_orderdate, l_orderkey, o_shippriority] }
      StreamTopN { order: [$1 DESC, $2 ASC], limit: 10, offset: 0 }
        StreamExchange { dist: Single }
          StreamProject { exprs: [$0, $4, $1, $2] }
            StreamHashAgg { group_key: [$0, $1, $2], aggs: [count, sum($3)] }
              StreamExchange { dist: HashShard([0, 1, 2]) }
                StreamProject { exprs: [$2, $0, $1, ($3 * (1:Int32 - $4)), $5, $6, $7] }
                  StreamHashJoin { type: Inner, predicate: $0 = $5, output_indices: [1, 2, 5, 6, 7, 3, 4, 8] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamHashJoin { type: Inner, predicate: $0 = $3, output_indices: [2, 4, 5, 1, 6] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamProject { exprs: [$0, $1] }
                            StreamFilter { predicate: ($2 = 'FURNITURE':Varchar) }
                              StreamTableScan { table: customer, columns: [c_custkey, _row_id, c_mktsegment], pk_indices: [1] }
                        StreamExchange { dist: HashShard([1]) }
                          StreamFilter { predicate: ($2 < '1995-03-29':Varchar::Date) }
                            StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, o_shippriority, _row_id], pk_indices: [4] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamProject { exprs: [$0, $1, $2, $3] }
                        StreamFilter { predicate: ($4 > '1995-03-29':Varchar::Date) }
                          StreamTableScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, _row_id, l_shipdate], pk_indices: [3] }
- id: tpch_q4
  before:
    - create_tables
  sql: |
    select
      o_orderpriority,
      count(*) as order_count
    from
      orders
    where
      o_orderdate >= date '1997-07-01'
      and o_orderdate < date '1997-07-01' + interval '3' month
      and exists (
        select
          *
        from
          lineitem
        where
          l_orderkey = o_orderkey
          and l_commitdate < l_receiptdate
      )
    group by
      o_orderpriority
    order by
      o_orderpriority;
  logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalAgg { group_key: [0], agg_calls: [count] }
        LogicalProject { exprs: [$6] }
          LogicalFilter { predicate: ($5 >= '1997-07-01':Varchar::Date) AND ($5 < ('1997-07-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
            LogicalApply { type: LeftSemi, on: true }
              LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
              LogicalProject { exprs: [$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16] }
                LogicalFilter { predicate: ($1 = CorrelatedInputRef { index: 1, depth: 1 }) AND ($12 < $13) }
                  LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [0], agg_calls: [count] }
      LogicalJoin { type: LeftSemi, on: ($2 = $0), output_indices: [1] }
        LogicalScan { table: orders, output_columns: [o_orderkey, o_orderpriority], required_columns: [$1:o_orderkey, $6:o_orderpriority, $5:o_orderdate], predicate: ($5 >= '1997-07-01':Varchar::Date) AND ($5 < ('1997-07-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
        LogicalScan { table: lineitem, output_columns: [l_orderkey], required_columns: [$1:l_orderkey, $12:l_commitdate, $13:l_receiptdate], predicate: ($12 < $13) }
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchHashAgg { group_key: [$0], aggs: [count] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchHashJoin { type: LeftSemi, predicate: $0 = $2, output_indices: [1] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchProject { exprs: [$0, $1] }
                  BatchFilter { predicate: ($2 >= '1997-07-01':Varchar::Date) AND ($2 < ('1997-07-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                    BatchScan { table: orders, columns: [o_orderkey, o_orderpriority, o_orderdate] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchProject { exprs: [$0] }
                  BatchFilter { predicate: ($1 < $2) }
                    BatchScan { table: lineitem, columns: [l_orderkey, l_commitdate, l_receiptdate] }
  stream_plan: |
    StreamMaterialize { columns: [o_orderpriority, agg#0(hidden), order_count], pk_columns: [o_orderpriority] }
      StreamHashAgg { group_key: [$0], aggs: [count, count] }
        StreamExchange { dist: HashShard([0]) }
          StreamHashJoin { type: LeftSemi, predicate: $0 = $3, output_indices: [1, 2] }
            StreamExchange { dist: HashShard([0]) }
              StreamProject { exprs: [$0, $1, $2] }
                StreamFilter { predicate: ($3 >= '1997-07-01':Varchar::Date) AND ($3 < ('1997-07-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                  StreamTableScan { table: orders, columns: [o_orderkey, o_orderpriority, _row_id, o_orderdate], pk_indices: [2] }
            StreamExchange { dist: HashShard([0]) }
              StreamProject { exprs: [$0, $1] }
                StreamFilter { predicate: ($2 < $3) }
                  StreamTableScan { table: lineitem, columns: [l_orderkey, _row_id, l_commitdate, l_receiptdate], pk_indices: [1] }
- id: tpch_q5
  before:
    - create_tables
  sql: |
    select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
      and r_name = 'MIDDLE EAST'
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '1' year
    group by
      n_name
    order by
      revenue desc;
  logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalAgg { group_key: [0], agg_calls: [sum($1)] }
        LogicalProject { exprs: [$46, ($25 * (1:Int32 - $26))] }
          LogicalFilter { predicate: ($1 = $11) AND ($20 = $10) AND ($22 = $37) AND ($4 = $40) AND ($40 = $45) AND ($47 = $50) AND ($51 = 'MIDDLE EAST':Varchar) AND ($14 >= '1994-01-01':Varchar::Date) AND ($14 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
            LogicalJoin { type: Inner, on: true, output_indices: all }
              LogicalJoin { type: Inner, on: true, output_indices: all }
                LogicalJoin { type: Inner, on: true, output_indices: all }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalJoin { type: Inner, on: true, output_indices: all }
                      LogicalScan { table: customer, columns: [_row_id, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                      LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                    LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                  LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
              LogicalScan { table: region, columns: [_row_id, r_regionkey, r_name, r_comment] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [0], agg_calls: [sum($1)] }
      LogicalProject { exprs: [$2, ($0 * (1:Int32 - $1))] }
        LogicalJoin { type: Inner, on: ($3 = $4), output_indices: [0, 1, 2] }
          LogicalJoin { type: Inner, on: ($2 = $3), output_indices: [0, 1, 4, 5] }
            LogicalJoin { type: Inner, on: ($1 = $4) AND ($0 = $5), output_indices: [2, 3, 5] }
              LogicalJoin { type: Inner, on: ($2 = $1), output_indices: [0, 3, 4, 5] }
                LogicalJoin { type: Inner, on: ($0 = $3), output_indices: [1, 2] }
                  LogicalScan { table: customer, columns: [c_custkey, c_nationkey] }
                  LogicalScan { table: orders, output_columns: [o_orderkey, o_custkey], required_columns: [$1:o_orderkey, $2:o_custkey, $5:o_orderdate], predicate: ($5 >= '1994-01-01':Varchar::Date) AND ($5 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                LogicalScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
              LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
            LogicalScan { table: nation, columns: [n_nationkey, n_name, n_regionkey] }
          LogicalScan { table: region, output_columns: [r_regionkey], required_columns: [$1:r_regionkey, $2:r_name], predicate: ($2 = 'MIDDLE EAST':Varchar) }
  batch_plan: |
    BatchExchange { order: [$1 DESC], dist: Single }
      BatchSort { order: [$1 DESC] }
        BatchHashAgg { group_key: [$0], aggs: [sum($1)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$2, ($0 * (1:Int32 - $1))] }
              BatchHashJoin { type: Inner, predicate: $3 = $4, output_indices: [0, 1, 2] }
                BatchExchange { order: [], dist: HashShard([3]) }
                  BatchHashJoin { type: Inner, predicate: $2 = $3, output_indices: [0, 1, 4, 5] }
                    BatchExchange { order: [], dist: HashShard([2]) }
                      BatchHashJoin { type: Inner, predicate: $1 = $4 AND $0 = $5, output_indices: [2, 3, 5] }
                        BatchExchange { order: [], dist: HashShard([1, 0]) }
                          BatchHashJoin { type: Inner, predicate: $1 = $2, output_indices: [0, 3, 4, 5] }
                            BatchExchange { order: [], dist: HashShard([1]) }
                              BatchHashJoin { type: Inner, predicate: $0 = $3, output_indices: [1, 2] }
                                BatchExchange { order: [], dist: HashShard([0]) }
                                  BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                                BatchExchange { order: [], dist: HashShard([1]) }
                                  BatchProject { exprs: [$0, $1] }
                                    BatchFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                      BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                            BatchExchange { order: [], dist: HashShard([0]) }
                              BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
                        BatchExchange { order: [], dist: HashShard([0, 1]) }
                          BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchScan { table: nation, columns: [n_nationkey, n_name, n_regionkey] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchProject { exprs: [$0] }
                    BatchFilter { predicate: ($1 = 'MIDDLE EAST':Varchar) }
                      BatchScan { table: region, columns: [r_regionkey, r_name] }
  stream_plan: |
    StreamMaterialize { columns: [n_name, agg#0(hidden), revenue], pk_columns: [n_name], order_descs: [revenue, n_name] }
      StreamHashAgg { group_key: [$0], aggs: [count, sum($1)] }
        StreamExchange { dist: HashShard([0]) }
          StreamProject { exprs: [$2, ($0 * (1:Int32 - $1)), $3, $4, $5, $6, $7, $8] }
            StreamHashJoin { type: Inner, predicate: $3 = $9, output_indices: [0, 1, 2, 4, 5, 6, 7, 8, 10] }
              StreamExchange { dist: HashShard([3]) }
                StreamHashJoin { type: Inner, predicate: $2 = $7, output_indices: [0, 1, 8, 9, 3, 4, 5, 6, 10] }
                  StreamExchange { dist: HashShard([2]) }
                    StreamHashJoin { type: Inner, predicate: $1 = $7 AND $0 = $8, output_indices: [2, 3, 8, 4, 5, 6, 9] }
                      StreamExchange { dist: HashShard([1, 0]) }
                        StreamHashJoin { type: Inner, predicate: $1 = $4, output_indices: [0, 5, 6, 7, 2, 3, 8] }
                          StreamExchange { dist: HashShard([1]) }
                            StreamHashJoin { type: Inner, predicate: $0 = $4, output_indices: [1, 3, 2, 5] }
                              StreamExchange { dist: HashShard([0]) }
                                StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id], pk_indices: [2] }
                              StreamExchange { dist: HashShard([1]) }
                                StreamProject { exprs: [$0, $1, $2] }
                                  StreamFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                    StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, _row_id, o_orderdate], pk_indices: [2] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id], pk_indices: [4] }
                      StreamExchange { dist: HashShard([0, 1]) }
                        StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamTableScan { table: nation, columns: [n_nationkey, n_name, n_regionkey, _row_id], pk_indices: [3] }
              StreamExchange { dist: HashShard([0]) }
                StreamProject { exprs: [$0, $1] }
                  StreamFilter { predicate: ($2 = 'MIDDLE EAST':Varchar) }
                    StreamTableScan { table: region, columns: [r_regionkey, _row_id, r_name], pk_indices: [1] }
- id: tpch_q6
  before:
    - create_tables
  sql: |
    select
      sum(l_extendedprice * l_discount) as revenue
    from
      lineitem
    where
      l_shipdate >= date '1994-01-01'
      and l_shipdate < date '1994-01-01' + interval '1' year
      and l_discount between 0.08 - 0.01 and 0.08 + 0.01
      and l_quantity < 24;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($0)] }
        LogicalProject { exprs: [($6 * $7)] }
          LogicalFilter { predicate: ($11 >= '1994-01-01':Varchar::Date) AND ($11 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($7 >= (0.08:Decimal - 0.01:Decimal)) AND ($7 <= (0.08:Decimal + 0.01:Decimal)) AND ($5 < 24:Int32) }
            LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($0)] }
      LogicalProject { exprs: [($0 * $1)] }
        LogicalScan { table: lineitem, output_columns: [l_extendedprice, l_discount], required_columns: [$6:l_extendedprice, $7:l_discount, $5:l_quantity, $11:l_shipdate], predicate: ($11 >= '1994-01-01':Varchar::Date) AND ($11 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($7 >= (0.08:Decimal - 0.01:Decimal)) AND ($7 <= (0.08:Decimal + 0.01:Decimal)) AND ($5 < 24:Int32) }
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0)] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [sum($0)] }
          BatchProject { exprs: [($0 * $1)] }
            BatchFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($1 >= (0.08:Decimal - 0.01:Decimal)) AND ($1 <= (0.08:Decimal + 0.01:Decimal)) AND ($2 < 24:Int32) }
              BatchScan { table: lineitem, columns: [l_extendedprice, l_discount, l_quantity, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), revenue], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0)] }
            StreamProject { exprs: [($0 * $1), $2] }
              StreamFilter { predicate: ($4 >= '1994-01-01':Varchar::Date) AND ($4 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($1 >= (0.08:Decimal - 0.01:Decimal)) AND ($1 <= (0.08:Decimal + 0.01:Decimal)) AND ($3 < 24:Int32) }
                StreamTableScan { table: lineitem, columns: [l_extendedprice, l_discount, _row_id, l_quantity, l_shipdate], pk_indices: [2] }
- id: tpch_q7
  before:
    - create_tables
  sql: |
    select
      supp_nation,
      cust_nation,
      l_year,
      sum(volume) as revenue
    from
      (
        select
          n1.n_name as supp_nation,
          n2.n_name as cust_nation,
          extract(year from l_shipdate) as l_year,
          l_extendedprice * (1 - l_discount) as volume
        from
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2
        where
          s_suppkey = l_suppkey
          and o_orderkey = l_orderkey
          and c_custkey = o_custkey
          and s_nationkey = n1.n_nationkey
          and c_nationkey = n2.n_nationkey
          and (
            (n1.n_name = 'ROMANIA' and n2.n_name = 'IRAN')
            or (n1.n_name = 'IRAN' and n2.n_name = 'ROMANIA')
          )
          and l_shipdate between date '1983-01-01' and date '2000-12-31'
      ) as shipping
    group by
      supp_nation,
      cust_nation,
      l_year
    order by
      supp_nation,
      cust_nation,
      l_year;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $2, $3] }
      LogicalAgg { group_key: [0, 1, 2], agg_calls: [sum($3)] }
        LogicalProject { exprs: [$0, $1, $2, $3] }
          LogicalProject { exprs: [$46, $51, Extract('YEAR':Varchar, $19), ($14 * (1:Int32 - $15))] }
            LogicalFilter { predicate: ($1 = $11) AND ($26 = $9) AND ($36 = $27) AND ($4 = $45) AND ($39 = $50) AND ((($46 = 'ROMANIA':Varchar) AND ($51 = 'IRAN':Varchar)) OR (($46 = 'IRAN':Varchar) AND ($51 = 'ROMANIA':Varchar))) AND ($19 >= '1983-01-01':Varchar::Date) AND ($19 <= '2000-12-31':Varchar::Date) }
              LogicalJoin { type: Inner, on: true, output_indices: all }
                LogicalJoin { type: Inner, on: true, output_indices: all }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalJoin { type: Inner, on: true, output_indices: all }
                      LogicalJoin { type: Inner, on: true, output_indices: all }
                        LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                        LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                      LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                    LogicalScan { table: customer, columns: [_row_id, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                  LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
                LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [0, 1, 2], agg_calls: [sum($3)] }
      LogicalProject { exprs: [$3, $4, Extract('YEAR':Varchar, $2), ($0 * (1:Int32 - $1))] }
        LogicalJoin { type: Inner, on: ($3 = $5) AND ((($4 = 'ROMANIA':Varchar) AND ($6 = 'IRAN':Varchar)) OR (($4 = 'IRAN':Varchar) AND ($6 = 'ROMANIA':Varchar))), output_indices: [0, 1, 2, 4, 6] }
          LogicalJoin { type: Inner, on: ($0 = $5), output_indices: [1, 2, 3, 4, 6] }
            LogicalJoin { type: Inner, on: ($5 = $4), output_indices: [0, 1, 2, 3, 6] }
              LogicalJoin { type: Inner, on: ($5 = $1), output_indices: [0, 2, 3, 4, 6] }
                LogicalJoin { type: Inner, on: ($0 = $3), output_indices: [1, 2, 4, 5, 6] }
                  LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                  LogicalScan { table: lineitem, output_columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate], required_columns: [$1:l_orderkey, $3:l_suppkey, $6:l_extendedprice, $7:l_discount, $11:l_shipdate], predicate: ($11 >= '1983-01-01':Varchar::Date) AND ($11 <= '2000-12-31':Varchar::Date) }
                LogicalScan { table: orders, columns: [o_orderkey, o_custkey] }
              LogicalScan { table: customer, columns: [c_custkey, c_nationkey] }
            LogicalScan { table: nation, columns: [n_nationkey, n_name] }
          LogicalScan { table: nation, columns: [n_nationkey, n_name] }
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 ASC, $2 ASC], dist: Single }
      BatchSort { order: [$0 ASC, $1 ASC, $2 ASC] }
        BatchHashAgg { group_key: [$0, $1, $2], aggs: [sum($3)] }
          BatchExchange { order: [], dist: HashShard([0, 1, 2]) }
            BatchProject { exprs: [$4, $6, Extract('YEAR':Varchar, $2), ($0 * (1:Int32 - $1))] }
              BatchFilter { predicate: ((($4 = 'ROMANIA':Varchar) AND ($6 = 'IRAN':Varchar)) OR (($4 = 'IRAN':Varchar) AND ($6 = 'ROMANIA':Varchar))) }
                BatchHashJoin { type: Inner, predicate: $3 = $5, output_indices: all }
                  BatchExchange { order: [], dist: HashShard([3]) }
                    BatchHashJoin { type: Inner, predicate: $0 = $5, output_indices: [1, 2, 3, 4, 6] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchHashJoin { type: Inner, predicate: $4 = $5, output_indices: [0, 1, 2, 3, 6] }
                          BatchExchange { order: [], dist: HashShard([4]) }
                            BatchHashJoin { type: Inner, predicate: $1 = $5, output_indices: [0, 2, 3, 4, 6] }
                              BatchExchange { order: [], dist: HashShard([1]) }
                                BatchHashJoin { type: Inner, predicate: $0 = $3, output_indices: [1, 2, 4, 5, 6] }
                                  BatchExchange { order: [], dist: HashShard([0]) }
                                    BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                                  BatchExchange { order: [], dist: HashShard([1]) }
                                    BatchFilter { predicate: ($4 >= '1983-01-01':Varchar::Date) AND ($4 <= '2000-12-31':Varchar::Date) }
                                      BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate] }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchScan { table: orders, columns: [o_orderkey, o_custkey] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: nation, columns: [n_nationkey, n_name] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: nation, columns: [n_nationkey, n_name] }
  stream_plan: |
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, agg#0(hidden), revenue], pk_columns: [supp_nation, cust_nation, l_year] }
      StreamHashAgg { group_key: [$0, $1, $2], aggs: [count, sum($3)] }
        StreamExchange { dist: HashShard([0, 1, 2]) }
          StreamProject { exprs: [$4, $11, Extract('YEAR':Varchar, $2), ($0 * (1:Int32 - $1)), $5, $6, $7, $8, $9, $12] }
            StreamFilter { predicate: ((($4 = 'ROMANIA':Varchar) AND ($11 = 'IRAN':Varchar)) OR (($4 = 'IRAN':Varchar) AND ($11 = 'ROMANIA':Varchar))) }
              StreamHashJoin { type: Inner, predicate: $3 = $10, output_indices: all }
                StreamExchange { dist: HashShard([3]) }
                  StreamHashJoin { type: Inner, predicate: $0 = $9, output_indices: [1, 2, 3, 4, 10, 5, 6, 7, 8, 11] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamHashJoin { type: Inner, predicate: $4 = $8, output_indices: [0, 1, 2, 3, 9, 5, 6, 7, 10] }
                        StreamExchange { dist: HashShard([4]) }
                          StreamHashJoin { type: Inner, predicate: $1 = $7, output_indices: [0, 2, 3, 4, 8, 5, 6, 9] }
                            StreamExchange { dist: HashShard([1]) }
                              StreamHashJoin { type: Inner, predicate: $0 = $4, output_indices: [1, 3, 5, 6, 7, 2, 8] }
                                StreamExchange { dist: HashShard([0]) }
                                  StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                                StreamExchange { dist: HashShard([1]) }
                                  StreamFilter { predicate: ($4 >= '1983-01-01':Varchar::Date) AND ($4 <= '2000-12-31':Varchar::Date) }
                                    StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate, _row_id], pk_indices: [5] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, _row_id], pk_indices: [2] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id], pk_indices: [2] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
                StreamExchange { dist: HashShard([0]) }
                  StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
- id: tpch_q8
  before:
    - create_tables
  sql: |
    select
      o_year,
      round(sum(case
        when nation = 'IRAN' then volume
        else 0
      end) / sum(volume), 6) as mkt_share
    from
      (
        select
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) as volume,
          n2.n_name as nation
        from
          lineitem,
          part,
          supplier,
       /* TODO(#1866): join reorder to avoid cross join */
       /* lineitem, */
          orders,
          customer,
          nation n1,
          nation n2,
          region
        where
          p_partkey = l_partkey
          and s_suppkey = l_suppkey
          and l_orderkey = o_orderkey
          and o_custkey = c_custkey
          and c_nationkey = n1.n_nationkey
          and n1.n_regionkey = r_regionkey
          and r_name = 'ASIA'
          and s_nationkey = n2.n_nationkey
          and o_orderdate between date '1995-01-01' and date '1996-12-31'
          and p_type = 'PROMO ANODIZED STEEL'
      ) as all_nations
    group by
      o_year
    order by
      o_year;
  logical_plan: |
    LogicalProject { exprs: [$0, RoundDigit(($1 / $2), 6:Int32)] }
      LogicalAgg { group_key: [0], agg_calls: [sum($1), sum($2)] }
        LogicalProject { exprs: [$0, Case(($2 = 'IRAN':Varchar), $1, 0:Int32::Decimal), $1] }
          LogicalProject { exprs: [Extract('YEAR':Varchar, $40), ($6 * (1:Int32 - $7)), $61] }
            LogicalFilter { predicate: ($18 = $2) AND ($28 = $3) AND ($1 = $36) AND ($37 = $46) AND ($49 = $55) AND ($57 = $65) AND ($66 = 'ASIA':Varchar) AND ($31 = $60) AND ($40 >= '1995-01-01':Varchar::Date) AND ($40 <= '1996-12-31':Varchar::Date) AND ($22 = 'PROMO ANODIZED STEEL':Varchar) }
              LogicalJoin { type: Inner, on: true, output_indices: all }
                LogicalJoin { type: Inner, on: true, output_indices: all }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalJoin { type: Inner, on: true, output_indices: all }
                      LogicalJoin { type: Inner, on: true, output_indices: all }
                        LogicalJoin { type: Inner, on: true, output_indices: all }
                          LogicalJoin { type: Inner, on: true, output_indices: all }
                            LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                            LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                          LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                        LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                      LogicalScan { table: customer, columns: [_row_id, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                    LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
                  LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
                LogicalScan { table: region, columns: [_row_id, r_regionkey, r_name, r_comment] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, RoundDigit(($1 / $2), 6:Int32)] }
      LogicalAgg { group_key: [0], agg_calls: [sum($1), sum($2)] }
        LogicalProject { exprs: [Extract('YEAR':Varchar, $2), Case(($3 = 'IRAN':Varchar), ($0 * (1:Int32 - $1)), 0:Int32::Decimal), ($0 * (1:Int32 - $1))] }
          LogicalJoin { type: Inner, on: ($3 = $5), output_indices: [0, 1, 2, 4] }
            LogicalJoin { type: Inner, on: ($2 = $5), output_indices: [0, 1, 3, 4, 6] }
              LogicalJoin { type: Inner, on: ($4 = $5), output_indices: [0, 1, 2, 3, 6] }
                LogicalJoin { type: Inner, on: ($3 = $5), output_indices: [0, 1, 2, 4, 6] }
                  LogicalJoin { type: Inner, on: ($0 = $4), output_indices: [1, 2, 3, 5, 6] }
                    LogicalJoin { type: Inner, on: ($4 = $1), output_indices: [0, 2, 3, 5] }
                      LogicalJoin { type: Inner, on: ($5 = $1), output_indices: [0, 2, 3, 4] }
                        LogicalScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount] }
                        LogicalScan { table: part, output_columns: [p_partkey], required_columns: [$1:p_partkey, $5:p_type], predicate: ($5 = 'PROMO ANODIZED STEEL':Varchar) }
                      LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                    LogicalScan { table: orders, output_columns: [o_orderkey, o_custkey, o_orderdate], required_columns: [$1:o_orderkey, $2:o_custkey, $5:o_orderdate], predicate: ($5 >= '1995-01-01':Varchar::Date) AND ($5 <= '1996-12-31':Varchar::Date) }
                  LogicalScan { table: customer, columns: [c_custkey, c_nationkey] }
                LogicalScan { table: nation, columns: [n_nationkey, n_regionkey] }
              LogicalScan { table: nation, columns: [n_nationkey, n_name] }
            LogicalScan { table: region, output_columns: [r_regionkey], required_columns: [$1:r_regionkey, $2:r_name], predicate: ($2 = 'ASIA':Varchar) }
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchProject { exprs: [$0, RoundDigit(($1 / $2), 6:Int32)] }
          BatchHashAgg { group_key: [$0], aggs: [sum($1), sum($2)] }
            BatchExchange { order: [], dist: HashShard([0]) }
              BatchProject { exprs: [Extract('YEAR':Varchar, $2), Case(($3 = 'IRAN':Varchar), ($0 * (1:Int32 - $1)), 0:Int32::Decimal), ($0 * (1:Int32 - $1))] }
                BatchHashJoin { type: Inner, predicate: $3 = $5, output_indices: [0, 1, 2, 4] }
                  BatchExchange { order: [], dist: HashShard([3]) }
                    BatchHashJoin { type: Inner, predicate: $2 = $5, output_indices: [0, 1, 3, 4, 6] }
                      BatchExchange { order: [], dist: HashShard([2]) }
                        BatchHashJoin { type: Inner, predicate: $4 = $5, output_indices: [0, 1, 2, 3, 6] }
                          BatchExchange { order: [], dist: HashShard([4]) }
                            BatchHashJoin { type: Inner, predicate: $3 = $5, output_indices: [0, 1, 2, 4, 6] }
                              BatchExchange { order: [], dist: HashShard([3]) }
                                BatchHashJoin { type: Inner, predicate: $0 = $4, output_indices: [1, 2, 3, 5, 6] }
                                  BatchExchange { order: [], dist: HashShard([0]) }
                                    BatchHashJoin { type: Inner, predicate: $1 = $4, output_indices: [0, 2, 3, 5] }
                                      BatchExchange { order: [], dist: HashShard([1]) }
                                        BatchHashJoin { type: Inner, predicate: $1 = $5, output_indices: [0, 2, 3, 4] }
                                          BatchExchange { order: [], dist: HashShard([1]) }
                                            BatchScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount] }
                                          BatchExchange { order: [], dist: HashShard([0]) }
                                            BatchProject { exprs: [$0] }
                                              BatchFilter { predicate: ($1 = 'PROMO ANODIZED STEEL':Varchar) }
                                                BatchScan { table: part, columns: [p_partkey, p_type] }
                                      BatchExchange { order: [], dist: HashShard([0]) }
                                        BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                                  BatchExchange { order: [], dist: HashShard([0]) }
                                    BatchFilter { predicate: ($2 >= '1995-01-01':Varchar::Date) AND ($2 <= '1996-12-31':Varchar::Date) }
                                      BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: nation, columns: [n_nationkey, n_regionkey] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: nation, columns: [n_nationkey, n_name] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchProject { exprs: [$0] }
                      BatchFilter { predicate: ($1 = 'ASIA':Varchar) }
                        BatchScan { table: region, columns: [r_regionkey, r_name] }
  stream_plan: |
    StreamMaterialize { columns: [o_year, mkt_share], pk_columns: [o_year] }
      StreamProject { exprs: [$0, RoundDigit(($2 / $3), 6:Int32)] }
        StreamHashAgg { group_key: [$0], aggs: [count, sum($1), sum($2)] }
          StreamExchange { dist: HashShard([0]) }
            StreamProject { exprs: [Extract('YEAR':Varchar, $2), Case(($3 = 'IRAN':Varchar), ($0 * (1:Int32 - $1)), 0:Int32::Decimal), ($0 * (1:Int32 - $1)), $4, $5, $6, $7, $8, $9, $10, $11] }
              StreamHashJoin { type: Inner, predicate: $3 = $12, output_indices: [0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 13] }
                StreamExchange { dist: HashShard([3]) }
                  StreamHashJoin { type: Inner, predicate: $2 = $11, output_indices: [0, 1, 3, 4, 12, 5, 6, 7, 8, 9, 10, 13] }
                    StreamExchange { dist: HashShard([2]) }
                      StreamHashJoin { type: Inner, predicate: $4 = $10, output_indices: [0, 1, 2, 3, 11, 5, 6, 7, 8, 9, 12] }
                        StreamExchange { dist: HashShard([4]) }
                          StreamHashJoin { type: Inner, predicate: $3 = $9, output_indices: [0, 1, 2, 4, 10, 5, 6, 7, 8, 11] }
                            StreamExchange { dist: HashShard([3]) }
                              StreamHashJoin { type: Inner, predicate: $0 = $7, output_indices: [1, 2, 3, 8, 9, 4, 5, 6, 10] }
                                StreamExchange { dist: HashShard([0]) }
                                  StreamHashJoin { type: Inner, predicate: $1 = $6, output_indices: [0, 2, 3, 7, 4, 5, 8] }
                                    StreamExchange { dist: HashShard([1]) }
                                      StreamHashJoin { type: Inner, predicate: $1 = $6, output_indices: [0, 2, 3, 4, 5, 7] }
                                        StreamExchange { dist: HashShard([1]) }
                                          StreamTableScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount, _row_id], pk_indices: [5] }
                                        StreamExchange { dist: HashShard([0]) }
                                          StreamProject { exprs: [$0, $1] }
                                            StreamFilter { predicate: ($2 = 'PROMO ANODIZED STEEL':Varchar) }
                                              StreamTableScan { table: part, columns: [p_partkey, _row_id, p_type], pk_indices: [1] }
                                    StreamExchange { dist: HashShard([0]) }
                                      StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                                StreamExchange { dist: HashShard([0]) }
                                  StreamFilter { predicate: ($2 >= '1995-01-01':Varchar::Date) AND ($2 <= '1996-12-31':Varchar::Date) }
                                    StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, _row_id], pk_indices: [3] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id], pk_indices: [2] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamTableScan { table: nation, columns: [n_nationkey, n_regionkey, _row_id], pk_indices: [2] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
                StreamExchange { dist: HashShard([0]) }
                  StreamProject { exprs: [$0, $1] }
                    StreamFilter { predicate: ($2 = 'ASIA':Varchar) }
                      StreamTableScan { table: region, columns: [r_regionkey, _row_id, r_name], pk_indices: [1] }
- id: tpch_q9
  before:
    - create_tables
  sql: |
    select
      nation,
      o_year,
      round(sum(amount), 2) as sum_profit
    from
      (
        select
          n_name as nation,
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
          lineitem,
          part,
          supplier,
       /* TODO(#1866): join reorder to avoid cross join */
       /* lineitem, */
          partsupp,
          orders,
          nation
        where
          s_suppkey = l_suppkey
          and ps_suppkey = l_suppkey
          and ps_partkey = l_partkey
          and p_partkey = l_partkey
          and o_orderkey = l_orderkey
          and s_nationkey = n_nationkey
          and p_name like '%yellow%'
      ) as profit
    group by
      nation,
      o_year
    order by
      nation,
      o_year desc;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, RoundDigit($2, 2:Int32)] }
      LogicalAgg { group_key: [0, 1], agg_calls: [sum($2)] }
        LogicalProject { exprs: [$0, $1, $2] }
          LogicalProject { exprs: [$53, Extract('YEAR':Varchar, $46), (($6 * (1:Int32 - $7)) - ($39 * $5))] }
            LogicalFilter { predicate: ($28 = $3) AND ($37 = $3) AND ($36 = $2) AND ($18 = $2) AND ($42 = $1) AND ($31 = $52) AND Like($19, '%yellow%':Varchar) }
              LogicalJoin { type: Inner, on: true, output_indices: all }
                LogicalJoin { type: Inner, on: true, output_indices: all }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalJoin { type: Inner, on: true, output_indices: all }
                      LogicalJoin { type: Inner, on: true, output_indices: all }
                        LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                        LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                      LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                    LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                  LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, $1, RoundDigit($2, 2:Int32)] }
      LogicalAgg { group_key: [0, 1], agg_calls: [sum($2)] }
        LogicalProject { exprs: [$5, Extract('YEAR':Varchar, $4), (($1 * (1:Int32 - $2)) - ($3 * $0))] }
          LogicalJoin { type: Inner, on: ($3 = $6), output_indices: [0, 1, 2, 4, 5, 7] }
            LogicalJoin { type: Inner, on: ($6 = $0), output_indices: [1, 2, 3, 4, 5, 7] }
              LogicalJoin { type: Inner, on: ($8 = $2) AND ($7 = $1), output_indices: [0, 3, 4, 5, 6, 9] }
                LogicalJoin { type: Inner, on: ($6 = $2), output_indices: [0, 1, 2, 3, 4, 5, 7] }
                  LogicalJoin { type: Inner, on: ($6 = $1), output_indices: [0, 1, 2, 3, 4, 5] }
                    LogicalScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
                    LogicalScan { table: part, output_columns: [p_partkey], required_columns: [$1:p_partkey, $2:p_name], predicate: Like($2, '%yellow%':Varchar) }
                  LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
              LogicalScan { table: orders, columns: [o_orderkey, o_orderdate] }
            LogicalScan { table: nation, columns: [n_nationkey, n_name] }
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 DESC], dist: Single }
      BatchSort { order: [$0 ASC, $1 DESC] }
        BatchProject { exprs: [$0, $1, RoundDigit($2, 2:Int32)] }
          BatchHashAgg { group_key: [$0, $1], aggs: [sum($2)] }
            BatchExchange { order: [], dist: HashShard([0, 1]) }
              BatchProject { exprs: [$5, Extract('YEAR':Varchar, $4), (($1 * (1:Int32 - $2)) - ($3 * $0))] }
                BatchHashJoin { type: Inner, predicate: $3 = $6, output_indices: [0, 1, 2, 4, 5, 7] }
                  BatchExchange { order: [], dist: HashShard([3]) }
                    BatchHashJoin { type: Inner, predicate: $0 = $6, output_indices: [1, 2, 3, 4, 5, 7] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchHashJoin { type: Inner, predicate: $2 = $8 AND $1 = $7, output_indices: [0, 3, 4, 5, 6, 9] }
                          BatchExchange { order: [], dist: HashShard([1, 2]) }
                            BatchHashJoin { type: Inner, predicate: $2 = $6, output_indices: [0, 1, 2, 3, 4, 5, 7] }
                              BatchExchange { order: [], dist: HashShard([2]) }
                                BatchHashJoin { type: Inner, predicate: $1 = $6, output_indices: [0, 1, 2, 3, 4, 5] }
                                  BatchExchange { order: [], dist: HashShard([1]) }
                                    BatchScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
                                  BatchExchange { order: [], dist: HashShard([0]) }
                                    BatchProject { exprs: [$0] }
                                      BatchFilter { predicate: Like($1, '%yellow%':Varchar) }
                                        BatchScan { table: part, columns: [p_partkey, p_name] }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                          BatchExchange { order: [], dist: HashShard([0, 1]) }
                            BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: orders, columns: [o_orderkey, o_orderdate] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: nation, columns: [n_nationkey, n_name] }
  stream_plan: |
    StreamMaterialize { columns: [nation, o_year, sum_profit], pk_columns: [nation, o_year] }
      StreamProject { exprs: [$0, $1, RoundDigit($3, 2:Int32)] }
        StreamHashAgg { group_key: [$0, $1], aggs: [count, sum($2)] }
          StreamExchange { dist: HashShard([0, 1]) }
            StreamProject { exprs: [$5, Extract('YEAR':Varchar, $4), (($1 * (1:Int32 - $2)) - ($3 * $0)), $6, $7, $8, $9, $10, $11] }
              StreamHashJoin { type: Inner, predicate: $3 = $11, output_indices: [0, 1, 2, 4, 5, 12, 6, 7, 8, 9, 10, 13] }
                StreamExchange { dist: HashShard([3]) }
                  StreamHashJoin { type: Inner, predicate: $0 = $10, output_indices: [1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 12] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamHashJoin { type: Inner, predicate: $2 = $11 AND $1 = $10, output_indices: [0, 3, 4, 5, 6, 12, 7, 8, 9, 13] }
                        StreamExchange { dist: HashShard([1, 2]) }
                          StreamHashJoin { type: Inner, predicate: $2 = $8, output_indices: [0, 1, 2, 3, 4, 5, 9, 6, 7, 10] }
                            StreamExchange { dist: HashShard([2]) }
                              StreamHashJoin { type: Inner, predicate: $1 = $7, output_indices: [0, 1, 2, 3, 4, 5, 6, 8] }
                                StreamExchange { dist: HashShard([1]) }
                                  StreamTableScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id], pk_indices: [6] }
                                StreamExchange { dist: HashShard([0]) }
                                  StreamProject { exprs: [$0, $1] }
                                    StreamFilter { predicate: Like($2, '%yellow%':Varchar) }
                                      StreamTableScan { table: part, columns: [p_partkey, _row_id, p_name], pk_indices: [1] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                        StreamExchange { dist: HashShard([0, 1]) }
                          StreamTableScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost, _row_id], pk_indices: [3] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: orders, columns: [o_orderkey, o_orderdate, _row_id], pk_indices: [2] }
                StreamExchange { dist: HashShard([0]) }
                  StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
- id: tpch_q10
  before:
    - create_tables
  sql: |
    select
      c_custkey,
      c_name,
      sum(l_extendedprice * (1.00 - l_discount)) as revenue,
      c_acctbal,
      n_name,
      c_address,
      c_phone,
      c_comment
    from
      customer,
      orders,
      lineitem,
      nation
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '3' month
      and l_returnflag = 'R'
      and c_nationkey = n_nationkey
    group by
      c_custkey,
      c_name,
      c_acctbal,
      c_phone,
      n_name,
      c_address,
      c_comment
    order by
      revenue desc
    limit 20;
  logical_plan: |
    LogicalTopN { order: [$2 DESC], limit: 20, offset: 0 }
      LogicalProject { exprs: [$0, $1, $7, $2, $4, $5, $3, $6] }
        LogicalAgg { group_key: [0, 1, 2, 3, 4, 5, 6], agg_calls: [sum($7)] }
          LogicalProject { exprs: [$1, $2, $6, $5, $38, $3, $8, ($25 * (1.00:Decimal - $26))] }
            LogicalFilter { predicate: ($1 = $11) AND ($20 = $10) AND ($14 >= '1994-01-01':Varchar::Date) AND ($14 < ('1994-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) AND ($28 = 'R':Varchar) AND ($4 = $37) }
              LogicalJoin { type: Inner, on: true, output_indices: all }
                LogicalJoin { type: Inner, on: true, output_indices: all }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalScan { table: customer, columns: [_row_id, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                    LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                  LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
  optimized_logical_plan: |
    LogicalTopN { order: [$2 DESC], limit: 20, offset: 0 }
      LogicalProject { exprs: [$0, $1, $7, $2, $4, $5, $3, $6] }
        LogicalAgg { group_key: [0, 1, 2, 3, 4, 5, 6], agg_calls: [sum($7)] }
          LogicalProject { exprs: [$0, $1, $4, $3, $8, $2, $5, ($6 * (1.00:Decimal - $7))] }
            LogicalJoin { type: Inner, on: ($3 = $9), output_indices: [0, 1, 2, 4, 5, 6, 7, 8, 10] }
              LogicalJoin { type: Inner, on: ($8 = $7), output_indices: [0, 1, 2, 3, 4, 5, 6, 9, 10] }
                LogicalJoin { type: Inner, on: ($0 = $8), output_indices: [0, 1, 2, 3, 4, 5, 6, 7] }
                  LogicalScan { table: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment] }
                  LogicalScan { table: orders, output_columns: [o_orderkey, o_custkey], required_columns: [$1:o_orderkey, $2:o_custkey, $5:o_orderdate], predicate: ($5 >= '1994-01-01':Varchar::Date) AND ($5 < ('1994-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                LogicalScan { table: lineitem, output_columns: [l_orderkey, l_extendedprice, l_discount], required_columns: [$1:l_orderkey, $6:l_extendedprice, $7:l_discount, $9:l_returnflag], predicate: ($9 = 'R':Varchar) }
              LogicalScan { table: nation, columns: [n_nationkey, n_name] }
  batch_plan: |
    BatchTopN { order: [$2 DESC], limit: 20, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchTopN { order: [$2 DESC], limit: 20, offset: 0 }
          BatchProject { exprs: [$0, $1, $7, $2, $4, $5, $3, $6] }
            BatchHashAgg { group_key: [$0, $1, $2, $3, $4, $5, $6], aggs: [sum($7)] }
              BatchExchange { order: [], dist: HashShard([0, 1, 2, 3, 4, 5, 6]) }
                BatchProject { exprs: [$0, $1, $4, $3, $8, $2, $5, ($6 * (1.00:Decimal - $7))] }
                  BatchHashJoin { type: Inner, predicate: $3 = $9, output_indices: [0, 1, 2, 4, 5, 6, 7, 8, 10] }
                    BatchExchange { order: [], dist: HashShard([3]) }
                      BatchHashJoin { type: Inner, predicate: $7 = $8, output_indices: [0, 1, 2, 3, 4, 5, 6, 9, 10] }
                        BatchExchange { order: [], dist: HashShard([7]) }
                          BatchHashJoin { type: Inner, predicate: $0 = $8, output_indices: [0, 1, 2, 3, 4, 5, 6, 7] }
                            BatchExchange { order: [], dist: HashShard([0]) }
                              BatchScan { table: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment] }
                            BatchExchange { order: [], dist: HashShard([1]) }
                              BatchProject { exprs: [$0, $1] }
                                BatchFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                                  BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchProject { exprs: [$0, $1, $2] }
                            BatchFilter { predicate: ($3 = 'R':Varchar) }
                              BatchScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_returnflag] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchScan { table: nation, columns: [n_nationkey, n_name] }
  stream_plan: |
    StreamMaterialize { columns: [c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment], pk_columns: [c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment], order_descs: [revenue, c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment] }
      StreamTopN { order: [$2 DESC], limit: 20, offset: 0 }
        StreamExchange { dist: Single }
          StreamProject { exprs: [$0, $1, $8, $2, $4, $5, $3, $6] }
            StreamHashAgg { group_key: [$0, $1, $2, $3, $4, $5, $6], aggs: [count, sum($7)] }
              StreamExchange { dist: HashShard([0, 1, 2, 3, 4, 5, 6]) }
                StreamProject { exprs: [$0, $1, $4, $3, $8, $2, $5, ($6 * (1.00:Decimal - $7)), $9, $10, $11, $12] }
                  StreamHashJoin { type: Inner, predicate: $3 = $12, output_indices: [0, 1, 2, 4, 5, 6, 7, 8, 13, 9, 10, 11, 14] }
                    StreamExchange { dist: HashShard([3]) }
                      StreamHashJoin { type: Inner, predicate: $7 = $10, output_indices: [0, 1, 2, 3, 4, 5, 6, 11, 12, 8, 9, 13] }
                        StreamExchange { dist: HashShard([7]) }
                          StreamHashJoin { type: Inner, predicate: $0 = $9, output_indices: [0, 1, 2, 3, 4, 5, 6, 8, 7, 10] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamTableScan { table: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, _row_id], pk_indices: [7] }
                            StreamExchange { dist: HashShard([1]) }
                              StreamProject { exprs: [$0, $1, $2] }
                                StreamFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                                  StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, _row_id, o_orderdate], pk_indices: [2] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamProject { exprs: [$0, $1, $2, $3] }
                            StreamFilter { predicate: ($4 = 'R':Varchar) }
                              StreamTableScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, _row_id, l_returnflag], pk_indices: [3] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
- id: tpch_q11
  before:
    - create_tables
  sql: |
    select
      ps_partkey,
      sum(ps_supplycost * ps_availqty) as value
    from
      partsupp,
      supplier,
      nation
    where
      ps_suppkey = s_suppkey
      and s_nationkey = n_nationkey
      and n_name = 'ARGENTINA'
    group by
      ps_partkey
    having
      sum(ps_supplycost * ps_availqty) > (
        select
          sum(ps_supplycost * ps_availqty) * 0.0001000000
        from
          partsupp,
          supplier,
          nation
        where
          ps_suppkey = s_suppkey
          and s_nationkey = n_nationkey
          and n_name = 'ARGENTINA'
      )
    order by
      value desc;
  logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalFilter { predicate: ($2 > $3) }
        LogicalJoin { type: LeftOuter, on: true, output_indices: all }
          LogicalAgg { group_key: [0], agg_calls: [sum($1), sum($1)] }
            LogicalProject { exprs: [$1, ($4 * $3)] }
              LogicalFilter { predicate: ($2 = $7) AND ($10 = $15) AND ($16 = 'ARGENTINA':Varchar) }
                LogicalJoin { type: Inner, on: true, output_indices: all }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                    LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                  LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
          LogicalProject { exprs: [($0 * 0.0001000000:Decimal)] }
            LogicalAgg { group_key: [], agg_calls: [sum($0)] }
              LogicalProject { exprs: [($4 * $3)] }
                LogicalFilter { predicate: ($2 = $7) AND ($10 = $15) AND ($16 = 'ARGENTINA':Varchar) }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalJoin { type: Inner, on: true, output_indices: all }
                      LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                      LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                    LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ($2 > $3), output_indices: [0, 1] }
      LogicalAgg { group_key: [0], agg_calls: [sum($1), sum($1)] }
        LogicalProject { exprs: [$0, ($2 * $1)] }
          LogicalJoin { type: Inner, on: ($3 = $4), output_indices: [0, 1, 2] }
            LogicalJoin { type: Inner, on: ($1 = $4), output_indices: [0, 2, 3, 5] }
              LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost] }
              LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
            LogicalScan { table: nation, output_columns: [n_nationkey], required_columns: [$1:n_nationkey, $2:n_name], predicate: ($2 = 'ARGENTINA':Varchar) }
      LogicalProject { exprs: [($0 * 0.0001000000:Decimal)] }
        LogicalAgg { group_key: [], agg_calls: [sum($0)] }
          LogicalProject { exprs: [($1 * $0)] }
            LogicalJoin { type: Inner, on: ($2 = $3), output_indices: [0, 1] }
              LogicalJoin { type: Inner, on: ($0 = $3), output_indices: [1, 2, 4] }
                LogicalScan { table: partsupp, columns: [ps_suppkey, ps_availqty, ps_supplycost] }
                LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
              LogicalScan { table: nation, output_columns: [n_nationkey], required_columns: [$1:n_nationkey, $2:n_name], predicate: ($2 = 'ARGENTINA':Varchar) }
  batch_plan: |
    BatchSort { order: [$1 DESC] }
      BatchNestedLoopJoin { type: Inner, predicate: ($2 > $3), output_indices: [0, 1] }
        BatchExchange { order: [], dist: Single }
          BatchHashAgg { group_key: [$0], aggs: [sum($1), sum($1)] }
            BatchExchange { order: [], dist: HashShard([0]) }
              BatchProject { exprs: [$0, ($2 * $1)] }
                BatchHashJoin { type: Inner, predicate: $3 = $4, output_indices: [0, 1, 2] }
                  BatchExchange { order: [], dist: HashShard([3]) }
                    BatchHashJoin { type: Inner, predicate: $1 = $4, output_indices: [0, 2, 3, 5] }
                      BatchExchange { order: [], dist: HashShard([1]) }
                        BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchProject { exprs: [$0] }
                      BatchFilter { predicate: ($1 = 'ARGENTINA':Varchar) }
                        BatchScan { table: nation, columns: [n_nationkey, n_name] }
        BatchProject { exprs: [($0 * 0.0001000000:Decimal)] }
          BatchSimpleAgg { aggs: [sum($0)] }
            BatchExchange { order: [], dist: Single }
              BatchSimpleAgg { aggs: [sum($0)] }
                BatchProject { exprs: [($1 * $0)] }
                  BatchHashJoin { type: Inner, predicate: $2 = $3, output_indices: [0, 1] }
                    BatchExchange { order: [], dist: HashShard([2]) }
                      BatchHashJoin { type: Inner, predicate: $0 = $3, output_indices: [1, 2, 4] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: partsupp, columns: [ps_suppkey, ps_availqty, ps_supplycost] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchProject { exprs: [$0] }
                        BatchFilter { predicate: ($1 = 'ARGENTINA':Varchar) }
                          BatchScan { table: nation, columns: [n_nationkey, n_name] }
  stream_plan: |
    StreamMaterialize { columns: [ps_partkey, value], pk_columns: [ps_partkey], order_descs: [value, ps_partkey] }
      StreamExchange { dist: HashShard([0]) }
        StreamProject { exprs: [$0, $2] }
          StreamDynamicFilter { predicate: ($3 > $4) }
            StreamExchange { dist: HashShard([3]) }
              StreamHashAgg { group_key: [$0], aggs: [count, sum($1), sum($1)] }
                StreamExchange { dist: HashShard([0]) }
                  StreamProject { exprs: [$0, ($2 * $1), $3, $4, $5] }
                    StreamHashJoin { type: Inner, predicate: $3 = $6, output_indices: [0, 1, 2, 4, 5, 7] }
                      StreamExchange { dist: HashShard([3]) }
                        StreamHashJoin { type: Inner, predicate: $1 = $5, output_indices: [0, 2, 3, 6, 4, 7] }
                          StreamExchange { dist: HashShard([1]) }
                            StreamTableScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, _row_id], pk_indices: [4] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamProject { exprs: [$0, $1] }
                          StreamFilter { predicate: ($2 = 'ARGENTINA':Varchar) }
                            StreamTableScan { table: nation, columns: [n_nationkey, _row_id, n_name], pk_indices: [1] }
            StreamExchange { dist: Broadcast }
              StreamProject { exprs: [($1 * 0.0001000000:Decimal)] }
                StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
                  StreamExchange { dist: Single }
                    StreamLocalSimpleAgg { aggs: [count, sum($0)] }
                      StreamProject { exprs: [($1 * $0), $2, $3, $4] }
                        StreamHashJoin { type: Inner, predicate: $2 = $5, output_indices: [0, 1, 3, 4, 6] }
                          StreamExchange { dist: HashShard([2]) }
                            StreamHashJoin { type: Inner, predicate: $0 = $4, output_indices: [1, 2, 5, 3, 6] }
                              StreamExchange { dist: HashShard([0]) }
                                StreamTableScan { table: partsupp, columns: [ps_suppkey, ps_availqty, ps_supplycost, _row_id], pk_indices: [3] }
                              StreamExchange { dist: HashShard([0]) }
                                StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamProject { exprs: [$0, $1] }
                              StreamFilter { predicate: ($2 = 'ARGENTINA':Varchar) }
                                StreamTableScan { table: nation, columns: [n_nationkey, _row_id, n_name], pk_indices: [1] }
- id: tpch_q12
  before:
    - create_tables
  sql: |
    select
        l_shipmode,
        sum(case
            when o_orderpriority = '1-URGENT'
                or o_orderpriority = '2-HIGH'
                then 1
            else 0
        end) as high_line_count,
        sum(case
            when o_orderpriority <> '1-URGENT'
                and o_orderpriority <> '2-HIGH'
                then 1
            else 0
        end) as low_line_count
    from
        orders,
        lineitem
    where
        o_orderkey = l_orderkey
        and l_shipmode in ('FOB', 'SHIP')
        and l_commitdate < l_receiptdate
        and l_shipdate < l_commitdate
        and l_receiptdate >= date '1994-01-01'
        and l_receiptdate < date '1994-01-01' + interval '1' year
    group by
        l_shipmode
    order by
        l_shipmode;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $2] }
      LogicalAgg { group_key: [0], agg_calls: [sum($1), sum($2)] }
        LogicalProject { exprs: [$25, Case((($6 = '1-URGENT':Varchar) OR ($6 = '2-HIGH':Varchar)), 1:Int32, 0:Int32), Case((($6 <> '1-URGENT':Varchar) AND ($6 <> '2-HIGH':Varchar)), 1:Int32, 0:Int32)] }
          LogicalFilter { predicate: ($1 = $11) AND In($25, 'FOB':Varchar, 'SHIP':Varchar) AND ($22 < $23) AND ($21 < $22) AND ($23 >= '1994-01-01':Varchar::Date) AND ($23 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
            LogicalJoin { type: Inner, on: true, output_indices: all }
              LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
              LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [0], agg_calls: [sum($1), sum($2)] }
      LogicalProject { exprs: [$1, Case((($0 = '1-URGENT':Varchar) OR ($0 = '2-HIGH':Varchar)), 1:Int32, 0:Int32), Case((($0 <> '1-URGENT':Varchar) AND ($0 <> '2-HIGH':Varchar)), 1:Int32, 0:Int32)] }
        LogicalJoin { type: Inner, on: ($0 = $2), output_indices: [1, 3] }
          LogicalScan { table: orders, columns: [o_orderkey, o_orderpriority] }
          LogicalScan { table: lineitem, output_columns: [l_orderkey, l_shipmode], required_columns: [$1:l_orderkey, $15:l_shipmode, $11:l_shipdate, $12:l_commitdate, $13:l_receiptdate], predicate: In($15, 'FOB':Varchar, 'SHIP':Varchar) AND ($12 < $13) AND ($11 < $12) AND ($13 >= '1994-01-01':Varchar::Date) AND ($13 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchHashAgg { group_key: [$0], aggs: [sum($1), sum($2)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$1, Case((($0 = '1-URGENT':Varchar) OR ($0 = '2-HIGH':Varchar)), 1:Int32, 0:Int32), Case((($0 <> '1-URGENT':Varchar) AND ($0 <> '2-HIGH':Varchar)), 1:Int32, 0:Int32)] }
              BatchHashJoin { type: Inner, predicate: $0 = $2, output_indices: [1, 3] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchScan { table: orders, columns: [o_orderkey, o_orderpriority] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchProject { exprs: [$0, $1] }
                    BatchFilter { predicate: In($1, 'FOB':Varchar, 'SHIP':Varchar) AND ($3 < $4) AND ($2 < $3) AND ($4 >= '1994-01-01':Varchar::Date) AND ($4 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                      BatchScan { table: lineitem, columns: [l_orderkey, l_shipmode, l_shipdate, l_commitdate, l_receiptdate] }
  stream_plan: |
    StreamMaterialize { columns: [l_shipmode, agg#0(hidden), high_line_count, low_line_count], pk_columns: [l_shipmode] }
      StreamHashAgg { group_key: [$0], aggs: [count, sum($1), sum($2)] }
        StreamExchange { dist: HashShard([0]) }
          StreamProject { exprs: [$1, Case((($0 = '1-URGENT':Varchar) OR ($0 = '2-HIGH':Varchar)), 1:Int32, 0:Int32), Case((($0 <> '1-URGENT':Varchar) AND ($0 <> '2-HIGH':Varchar)), 1:Int32, 0:Int32), $2, $3] }
            StreamHashJoin { type: Inner, predicate: $0 = $3, output_indices: [1, 4, 2, 5] }
              StreamExchange { dist: HashShard([0]) }
                StreamTableScan { table: orders, columns: [o_orderkey, o_orderpriority, _row_id], pk_indices: [2] }
              StreamExchange { dist: HashShard([0]) }
                StreamProject { exprs: [$0, $1, $2] }
                  StreamFilter { predicate: In($1, 'FOB':Varchar, 'SHIP':Varchar) AND ($4 < $5) AND ($3 < $4) AND ($5 >= '1994-01-01':Varchar::Date) AND ($5 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                    StreamTableScan { table: lineitem, columns: [l_orderkey, l_shipmode, _row_id, l_shipdate, l_commitdate, l_receiptdate], pk_indices: [2] }
- id: tpch_q13
  before:
    - create_tables
  sql: |
    select
      c_count,
      count(*) as custdist
    from
      (
        select
          c_custkey,
          count(o_orderkey) as c_count
        from
          customer left outer join orders on
            c_custkey = o_custkey
            and o_comment not like '%:1%:2%'
        group by
          c_custkey
      ) as c_orders (c_custkey, c_count)
    group by
      c_count
    order by
      custdist desc,
      c_count desc;
  logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalAgg { group_key: [0], agg_calls: [count] }
        LogicalProject { exprs: [$1] }
          LogicalProject { exprs: [$0, $1] }
            LogicalAgg { group_key: [0], agg_calls: [count($1)] }
              LogicalProject { exprs: [$1, $10] }
                LogicalJoin { type: LeftOuter, on: ($1 = $11) AND Not(Like($18, '%:1%:2%':Varchar)), output_indices: all }
                  LogicalScan { table: customer, columns: [_row_id, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                  LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [0], agg_calls: [count] }
      LogicalProject { exprs: [$1] }
        LogicalAgg { group_key: [0], agg_calls: [count($1)] }
          LogicalJoin { type: LeftOuter, on: ($0 = $2), output_indices: [0, 1] }
            LogicalScan { table: customer, columns: [c_custkey] }
            LogicalScan { table: orders, output_columns: [o_orderkey, o_custkey], required_columns: [$1:o_orderkey, $2:o_custkey, $9:o_comment], predicate: Not(Like($9, '%:1%:2%':Varchar)) }
  batch_plan: |
    BatchExchange { order: [$1 DESC, $0 DESC], dist: Single }
      BatchSort { order: [$1 DESC, $0 DESC] }
        BatchHashAgg { group_key: [$0], aggs: [count] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$1] }
              BatchHashAgg { group_key: [$0], aggs: [count($1)] }
                BatchHashJoin { type: LeftOuter, predicate: $0 = $2, output_indices: [0, 1] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: customer, columns: [c_custkey] }
                  BatchExchange { order: [], dist: HashShard([1]) }
                    BatchProject { exprs: [$0, $1] }
                      BatchFilter { predicate: Not(Like($2, '%:1%:2%':Varchar)) }
                        BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_comment] }
  stream_plan: |
    StreamMaterialize { columns: [c_count, agg#0(hidden), custdist], pk_columns: [c_count], order_descs: [custdist, c_count] }
      StreamHashAgg { group_key: [$0], aggs: [count, count] }
        StreamExchange { dist: HashShard([0]) }
          StreamProject { exprs: [$2, $0] }
            StreamHashAgg { group_key: [$0], aggs: [count, count($1)] }
              StreamHashJoin { type: LeftOuter, predicate: $0 = $3, output_indices: [0, 2, 1, 4] }
                StreamExchange { dist: HashShard([0]) }
                  StreamTableScan { table: customer, columns: [c_custkey, _row_id], pk_indices: [1] }
                StreamExchange { dist: HashShard([1]) }
                  StreamProject { exprs: [$0, $1, $2] }
                    StreamFilter { predicate: Not(Like($3, '%:1%:2%':Varchar)) }
                      StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, _row_id, o_comment], pk_indices: [2] }
- id: tpch_q14
  before:
    - create_tables
  sql: |
    select
      100.00 * sum(case
        when p_type like 'PROMO%'
          then l_extendedprice * (1 - l_discount)
        else 0
      end) / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
    from
      lineitem,
      part
    where
      l_partkey = p_partkey
      and l_shipdate >= date '1995-09-01'
      and l_shipdate < date '1995-09-01' + interval '1' month;
  logical_plan: |
    LogicalProject { exprs: [((100.00:Decimal * $0) / $1)] }
      LogicalAgg { group_key: [], agg_calls: [sum($0), sum($1)] }
        LogicalProject { exprs: [Case(Like($22, 'PROMO%':Varchar), ($6 * (1:Int32 - $7)), 0:Int32::Decimal), ($6 * (1:Int32 - $7))] }
          LogicalFilter { predicate: ($2 = $18) AND ($11 >= '1995-09-01':Varchar::Date) AND ($11 < ('1995-09-01':Varchar::Date + '1 mon 00:00:00':Interval)) }
            LogicalJoin { type: Inner, on: true, output_indices: all }
              LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
              LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
  optimized_logical_plan: |
    LogicalProject { exprs: [((100.00:Decimal * $0) / $1)] }
      LogicalAgg { group_key: [], agg_calls: [sum($0), sum($1)] }
        LogicalProject { exprs: [Case(Like($2, 'PROMO%':Varchar), ($0 * (1:Int32 - $1)), 0:Int32::Decimal), ($0 * (1:Int32 - $1))] }
          LogicalJoin { type: Inner, on: ($0 = $3), output_indices: [1, 2, 4] }
            LogicalScan { table: lineitem, output_columns: [l_partkey, l_extendedprice, l_discount], required_columns: [$2:l_partkey, $6:l_extendedprice, $7:l_discount, $11:l_shipdate], predicate: ($11 >= '1995-09-01':Varchar::Date) AND ($11 < ('1995-09-01':Varchar::Date + '1 mon 00:00:00':Interval)) }
            LogicalScan { table: part, columns: [p_partkey, p_type] }
  batch_plan: |
    BatchProject { exprs: [((100.00:Decimal * $0) / $1)] }
      BatchSimpleAgg { aggs: [sum($0), sum($1)] }
        BatchExchange { order: [], dist: Single }
          BatchSimpleAgg { aggs: [sum($0), sum($1)] }
            BatchProject { exprs: [Case(Like($2, 'PROMO%':Varchar), ($0 * (1:Int32 - $1)), 0:Int32::Decimal), ($0 * (1:Int32 - $1))] }
              BatchHashJoin { type: Inner, predicate: $0 = $3, output_indices: [1, 2, 4] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchProject { exprs: [$0, $1, $2] }
                    BatchFilter { predicate: ($3 >= '1995-09-01':Varchar::Date) AND ($3 < ('1995-09-01':Varchar::Date + '1 mon 00:00:00':Interval)) }
                      BatchScan { table: lineitem, columns: [l_partkey, l_extendedprice, l_discount, l_shipdate] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchScan { table: part, columns: [p_partkey, p_type] }
  stream_plan: |
    StreamMaterialize { columns: [promo_revenue], pk_columns: [] }
      StreamProject { exprs: [((100.00:Decimal * $1) / $2)] }
        StreamGlobalSimpleAgg { aggs: [sum($0), sum($1), sum($2)] }
          StreamExchange { dist: Single }
            StreamLocalSimpleAgg { aggs: [count, sum($0), sum($1)] }
              StreamProject { exprs: [Case(Like($2, 'PROMO%':Varchar), ($0 * (1:Int32 - $1)), 0:Int32::Decimal), ($0 * (1:Int32 - $1)), $3, $4] }
                StreamHashJoin { type: Inner, predicate: $0 = $4, output_indices: [1, 2, 5, 3, 6] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamProject { exprs: [$0, $1, $2, $3] }
                      StreamFilter { predicate: ($4 >= '1995-09-01':Varchar::Date) AND ($4 < ('1995-09-01':Varchar::Date + '1 mon 00:00:00':Interval)) }
                        StreamTableScan { table: lineitem, columns: [l_partkey, l_extendedprice, l_discount, _row_id, l_shipdate], pk_indices: [3] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamTableScan { table: part, columns: [p_partkey, p_type, _row_id], pk_indices: [2] }
- id: tpch_q15
  before:
    - create_tables
  sql: |
    with revenue0 (supplier_no, total_revenue) as (
      select
        l_suppkey,
        sum(l_extendedprice * (1 - l_discount))
      from
        lineitem
      where
        l_shipdate >= date '1993-01-01'
        and l_shipdate < date '1993-01-01' + interval '3' month
      group by
        l_suppkey
    )
    select
      s_suppkey,
      s_name,
      s_address,
      s_phone,
      total_revenue
    from
      supplier,
      revenue0
    where
      s_suppkey = supplier_no
      and total_revenue = (
        select
          max(total_revenue)
        from
          revenue0
      )
    order by
      s_suppkey;
  logical_plan: |
    LogicalProject { exprs: [$1, $2, $3, $5, $9] }
      LogicalFilter { predicate: ($1 = $8) AND ($9 = $10) }
        LogicalJoin { type: LeftOuter, on: true, output_indices: all }
          LogicalJoin { type: Inner, on: true, output_indices: all }
            LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
            LogicalProject { exprs: [$0, $1] }
              LogicalAgg { group_key: [0], agg_calls: [sum($1)] }
                LogicalProject { exprs: [$3, ($6 * (1:Int32 - $7))] }
                  LogicalFilter { predicate: ($11 >= '1993-01-01':Varchar::Date) AND ($11 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                    LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
          LogicalProject { exprs: [$0] }
            LogicalAgg { group_key: [], agg_calls: [max($0)] }
              LogicalProject { exprs: [$1] }
                LogicalProject { exprs: [$0, $1] }
                  LogicalAgg { group_key: [0], agg_calls: [sum($1)] }
                    LogicalProject { exprs: [$3, ($6 * (1:Int32 - $7))] }
                      LogicalFilter { predicate: ($11 >= '1993-01-01':Varchar::Date) AND ($11 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                        LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ($4 = $5), output_indices: [0, 1, 2, 3, 4] }
      LogicalJoin { type: Inner, on: ($0 = $4), output_indices: [0, 1, 2, 3, 5] }
        LogicalScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_phone] }
        LogicalAgg { group_key: [0], agg_calls: [sum($1)] }
          LogicalProject { exprs: [$0, ($1 * (1:Int32 - $2))] }
            LogicalScan { table: lineitem, output_columns: [l_suppkey, l_extendedprice, l_discount], required_columns: [$3:l_suppkey, $6:l_extendedprice, $7:l_discount, $11:l_shipdate], predicate: ($11 >= '1993-01-01':Varchar::Date) AND ($11 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
      LogicalAgg { group_key: [], agg_calls: [max($0)] }
        LogicalProject { exprs: [$1] }
          LogicalAgg { group_key: [0], agg_calls: [sum($1)] }
            LogicalProject { exprs: [$0, ($1 * (1:Int32 - $2))] }
              LogicalScan { table: lineitem, output_columns: [l_suppkey, l_extendedprice, l_discount], required_columns: [$3:l_suppkey, $6:l_extendedprice, $7:l_discount, $11:l_shipdate], predicate: ($11 >= '1993-01-01':Varchar::Date) AND ($11 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchHashJoin { type: Inner, predicate: $4 = $5, output_indices: [0, 1, 2, 3, 4] }
          BatchExchange { order: [], dist: HashShard([4]) }
            BatchHashJoin { type: Inner, predicate: $0 = $4, output_indices: [0, 1, 2, 3, 5] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_phone] }
              BatchHashAgg { group_key: [$0], aggs: [sum($1)] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchProject { exprs: [$0, ($1 * (1:Int32 - $2))] }
                    BatchFilter { predicate: ($3 >= '1993-01-01':Varchar::Date) AND ($3 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                      BatchScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, l_shipdate] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchSimpleAgg { aggs: [max($0)] }
              BatchExchange { order: [], dist: Single }
                BatchSimpleAgg { aggs: [max($0)] }
                  BatchProject { exprs: [$1] }
                    BatchHashAgg { group_key: [$0], aggs: [sum($1)] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchProject { exprs: [$0, ($1 * (1:Int32 - $2))] }
                          BatchFilter { predicate: ($3 >= '1993-01-01':Varchar::Date) AND ($3 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                            BatchScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [s_suppkey, s_name, s_address, s_phone, total_revenue, _row_id(hidden), l_suppkey(hidden)], pk_columns: [_row_id, l_suppkey], order_descs: [s_suppkey, _row_id, l_suppkey] }
      StreamExchange { dist: HashShard([5, 6]) }
        StreamHashJoin { type: Inner, predicate: $4 = $8, output_indices: [0, 1, 2, 3, 4, 5, 6] }
          StreamExchange { dist: HashShard([4]) }
            StreamHashJoin { type: Inner, predicate: $0 = $5, output_indices: [0, 1, 2, 3, 7, 4, 5] }
              StreamExchange { dist: HashShard([0]) }
                StreamTableScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_phone, _row_id], pk_indices: [4] }
              StreamHashAgg { group_key: [$0], aggs: [count, sum($1)] }
                StreamExchange { dist: HashShard([0]) }
                  StreamProject { exprs: [$0, ($1 * (1:Int32 - $2)), $3] }
                    StreamFilter { predicate: ($4 >= '1993-01-01':Varchar::Date) AND ($4 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                      StreamTableScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, _row_id, l_shipdate], pk_indices: [3] }
          StreamExchange { dist: HashShard([1]) }
            StreamGlobalSimpleAgg { aggs: [count, max($0)] }
              StreamExchange { dist: Single }
                StreamProject { exprs: [$2, $0] }
                  StreamHashAgg { group_key: [$0], aggs: [count, sum($1)] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamProject { exprs: [$0, ($1 * (1:Int32 - $2)), $3] }
                        StreamFilter { predicate: ($4 >= '1993-01-01':Varchar::Date) AND ($4 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                          StreamTableScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, _row_id, l_shipdate], pk_indices: [3] }
- id: tpch_q16
  before:
    - create_tables
  sql: |
    select
      p_brand,
      p_type,
      p_size,
      count(distinct ps_suppkey) as supplier_cnt
    from
      partsupp,
      part
    where
      p_partkey = ps_partkey
      and p_brand <> 'Brand#45'
      and p_type not like 'SMALL PLATED%'
      and p_size in (19, 17, 16, 23, 10, 4, 38, 11)
      and ps_suppkey not in (
        select
          s_suppkey
        from
          supplier
        where
          s_comment like '%Customer%Complaints%'
      )
    group by
      p_brand,
      p_type,
      p_size
    order by
      supplier_cnt desc,
      p_brand,
      p_type,
      p_size;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $2, $3] }
      LogicalAgg { group_key: [0, 1, 2], agg_calls: [count(distinct $3)] }
        LogicalProject { exprs: [$10, $11, $12, $2] }
          LogicalFilter { predicate: ($7 = $1) AND ($10 <> 'Brand#45':Varchar) AND Not(Like($11, 'SMALL PLATED%':Varchar)) AND In($12, 19:Int32, 17:Int32, 16:Int32, 23:Int32, 10:Int32, 4:Int32, 38:Int32, 11:Int32) }
            LogicalJoin { type: LeftAnti, on: ($2 = $16), output_indices: all }
              LogicalJoin { type: Inner, on: true, output_indices: all }
                LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
              LogicalProject { exprs: [$1] }
                LogicalFilter { predicate: Like($7, '%Customer%Complaints%':Varchar) }
                  LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [0, 1, 2], agg_calls: [count($3) filter(($4 = 0:Int64))] }
      LogicalAgg { group_key: [0, 1, 2, 3, 4], agg_calls: [] }
        LogicalExpand { column_subsets: [[0, 1, 2, 3]] }
          LogicalProject { exprs: [$1, $2, $3, $0] }
            LogicalJoin { type: LeftAnti, on: ($0 = $4), output_indices: all }
              LogicalJoin { type: Inner, on: ($2 = $0), output_indices: [1, 3, 4, 5] }
                LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey] }
                LogicalScan { table: part, output_columns: [p_partkey, p_brand, p_type, p_size], required_columns: [$1:p_partkey, $4:p_brand, $5:p_type, $6:p_size], predicate: ($4 <> 'Brand#45':Varchar) AND Not(Like($5, 'SMALL PLATED%':Varchar)) AND In($6, 19:Int32, 17:Int32, 16:Int32, 23:Int32, 10:Int32, 4:Int32, 38:Int32, 11:Int32) }
              LogicalScan { table: supplier, output_columns: [s_suppkey], required_columns: [$1:s_suppkey, $7:s_comment], predicate: Like($7, '%Customer%Complaints%':Varchar) }
  batch_plan: |
    BatchExchange { order: [$3 DESC, $0 ASC, $1 ASC, $2 ASC], dist: Single }
      BatchSort { order: [$3 DESC, $0 ASC, $1 ASC, $2 ASC] }
        BatchHashAgg { group_key: [$0, $1, $2], aggs: [count($3) filter(($4 = 0:Int64))] }
          BatchExchange { order: [], dist: HashShard([0, 1, 2]) }
            BatchHashAgg { group_key: [$0, $1, $2, $3, $4], aggs: [] }
              BatchExchange { order: [], dist: HashShard([0, 1, 2, 3, 4]) }
                BatchExpand { column_subsets: [[0, 1, 2, 3]] }
                  BatchProject { exprs: [$1, $2, $3, $0] }
                    BatchHashJoin { type: LeftAnti, predicate: $0 = $4, output_indices: all }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchHashJoin { type: Inner, predicate: $0 = $2, output_indices: [1, 3, 4, 5] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchFilter { predicate: ($1 <> 'Brand#45':Varchar) AND Not(Like($2, 'SMALL PLATED%':Varchar)) AND In($3, 19:Int32, 17:Int32, 16:Int32, 23:Int32, 10:Int32, 4:Int32, 38:Int32, 11:Int32) }
                              BatchScan { table: part, columns: [p_partkey, p_brand, p_type, p_size] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchProject { exprs: [$0] }
                          BatchFilter { predicate: Like($1, '%Customer%Complaints%':Varchar) }
                            BatchScan { table: supplier, columns: [s_suppkey, s_comment] }
  stream_plan: |
    StreamMaterialize { columns: [p_brand, p_type, p_size, agg#0(hidden), supplier_cnt], pk_columns: [p_brand, p_type, p_size], order_descs: [supplier_cnt, p_brand, p_type, p_size] }
      StreamHashAgg { group_key: [$0, $1, $2], aggs: [count, count($3) filter(($4 = 0:Int64))] }
        StreamExchange { dist: HashShard([0, 1, 2]) }
          StreamHashAgg { group_key: [$0, $1, $2, $3, $6], aggs: [count] }
            StreamExchange { dist: HashShard([0, 1, 2, 3, 6]) }
              StreamExpand { column_subsets: [[0, 1, 2, 3]] }
                StreamProject { exprs: [$1, $2, $3, $0, $4, $5] }
                  StreamHashJoin { type: LeftAnti, predicate: $0 = $6, output_indices: all }
                    StreamExchange { dist: HashShard([0]) }
                      StreamHashJoin { type: Inner, predicate: $0 = $3, output_indices: [1, 4, 5, 6, 2, 7] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamTableScan { table: partsupp, columns: [ps_partkey, ps_suppkey, _row_id], pk_indices: [2] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamFilter { predicate: ($1 <> 'Brand#45':Varchar) AND Not(Like($2, 'SMALL PLATED%':Varchar)) AND In($3, 19:Int32, 17:Int32, 16:Int32, 23:Int32, 10:Int32, 4:Int32, 38:Int32, 11:Int32) }
                            StreamTableScan { table: part, columns: [p_partkey, p_brand, p_type, p_size, _row_id], pk_indices: [4] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamProject { exprs: [$0, $1] }
                        StreamFilter { predicate: Like($2, '%Customer%Complaints%':Varchar) }
                          StreamTableScan { table: supplier, columns: [s_suppkey, _row_id, s_comment], pk_indices: [1] }
- id: tpch_q17
  before:
    - create_tables
  sql: |
    select
      ROUND(sum(l_extendedprice) / 7.0, 16) as avg_yearly
    from
      lineitem,
      part
    where
      p_partkey = l_partkey
      and p_brand = 'Brand#13'
      and p_container = 'JUMBO PKG'
      and l_quantity < (
        select
          0.2 * avg(l_quantity)
        from
          lineitem
        where
          l_partkey = p_partkey
      );
  logical_plan: |
    LogicalProject { exprs: [RoundDigit(($0 / 7.0:Decimal), 16:Int32)] }
      LogicalAgg { group_key: [], agg_calls: [sum($0)] }
        LogicalProject { exprs: [$6] }
          LogicalFilter { predicate: ($18 = $2) AND ($21 = 'Brand#13':Varchar) AND ($24 = 'JUMBO PKG':Varchar) AND ($5 < $27) }
            LogicalApply { type: LeftOuter, on: true }
              LogicalJoin { type: Inner, on: true, output_indices: all }
                LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
              LogicalProject { exprs: [(0.2:Decimal * ($0 / $1))] }
                LogicalAgg { group_key: [], agg_calls: [sum($0), count($0)] }
                  LogicalProject { exprs: [$5] }
                    LogicalFilter { predicate: ($2 = CorrelatedInputRef { index: 18, depth: 1 }) }
                      LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalProject { exprs: [RoundDigit(($0 / 7.0:Decimal), 16:Int32)] }
      LogicalAgg { group_key: [], agg_calls: [sum($0)] }
        LogicalJoin { type: Inner, on: ($2 = $3) AND ($0 < $4), output_indices: [1] }
          LogicalJoin { type: Inner, on: ($3 = $0), output_indices: [1, 2, 3] }
            LogicalScan { table: lineitem, columns: [l_partkey, l_quantity, l_extendedprice] }
            LogicalScan { table: part, output_columns: [p_partkey], required_columns: [$1:p_partkey, $4:p_brand, $7:p_container], predicate: ($4 = 'Brand#13':Varchar) AND ($7 = 'JUMBO PKG':Varchar) }
          LogicalProject { exprs: [$0, (0.2:Decimal * ($1 / $2))] }
            LogicalAgg { group_key: [0], agg_calls: [sum($1), count($1)] }
              LogicalScan { table: lineitem, columns: [l_partkey, l_quantity] }
  batch_plan: |
    BatchProject { exprs: [RoundDigit(($0 / 7.0:Decimal), 16:Int32)] }
      BatchSimpleAgg { aggs: [sum($0)] }
        BatchExchange { order: [], dist: Single }
          BatchSimpleAgg { aggs: [sum($0)] }
            BatchProject { exprs: [$1] }
              BatchFilter { predicate: ($0 < $4) }
                BatchHashJoin { type: Inner, predicate: $2 = $3, output_indices: all }
                  BatchExchange { order: [], dist: HashShard([2]) }
                    BatchHashJoin { type: Inner, predicate: $0 = $3, output_indices: [1, 2, 3] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: lineitem, columns: [l_partkey, l_quantity, l_extendedprice] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchProject { exprs: [$0] }
                          BatchFilter { predicate: ($1 = 'Brand#13':Varchar) AND ($2 = 'JUMBO PKG':Varchar) }
                            BatchScan { table: part, columns: [p_partkey, p_brand, p_container] }
                  BatchProject { exprs: [$0, (0.2:Decimal * ($1 / $2))] }
                    BatchHashAgg { group_key: [$0], aggs: [sum($1), count($1)] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: lineitem, columns: [l_partkey, l_quantity] }
  stream_plan: |
    StreamMaterialize { columns: [avg_yearly], pk_columns: [] }
      StreamProject { exprs: [RoundDigit(($1 / 7.0:Decimal), 16:Int32)] }
        StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
          StreamExchange { dist: Single }
            StreamLocalSimpleAgg { aggs: [count, sum($0)] }
              StreamProject { exprs: [$1, $3, $4, $5] }
                StreamFilter { predicate: ($0 < $6) }
                  StreamHashJoin { type: Inner, predicate: $2 = $5, output_indices: all }
                    StreamExchange { dist: HashShard([2]) }
                      StreamHashJoin { type: Inner, predicate: $0 = $4, output_indices: [1, 2, 4, 3, 5] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamTableScan { table: lineitem, columns: [l_partkey, l_quantity, l_extendedprice, _row_id], pk_indices: [3] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamProject { exprs: [$0, $1] }
                            StreamFilter { predicate: ($2 = 'Brand#13':Varchar) AND ($3 = 'JUMBO PKG':Varchar) }
                              StreamTableScan { table: part, columns: [p_partkey, _row_id, p_brand, p_container], pk_indices: [1] }
                    StreamProject { exprs: [$0, (0.2:Decimal * ($2 / $3))] }
                      StreamHashAgg { group_key: [$0], aggs: [count, sum($1), count($1)] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamTableScan { table: lineitem, columns: [l_partkey, l_quantity, _row_id], pk_indices: [2] }
- id: tpch_q18
  before:
    - create_tables
  sql: |
    select
      c_name,
      c_custkey,
      o_orderkey,
      o_orderdate,
      o_totalprice,
      sum(l_quantity) quantity
    from
      customer,
      orders,
      lineitem
    where
      o_orderkey in (
        select
          l_orderkey
        from
          lineitem
        group by
          l_orderkey
        having
          sum(l_quantity) > 1
      )
      and c_custkey = o_custkey
      and o_orderkey = l_orderkey
    group by
      c_name,
      c_custkey,
      o_orderkey,
      o_orderdate,
      o_totalprice
    order by
      o_totalprice desc,
      o_orderdate
    LIMIT 100;
  logical_plan: |
    LogicalTopN { order: [$4 DESC, $3 ASC], limit: 100, offset: 0 }
      LogicalProject { exprs: [$0, $1, $2, $3, $4, $5] }
        LogicalAgg { group_key: [0, 1, 2, 3, 4], agg_calls: [sum($5)] }
          LogicalProject { exprs: [$2, $1, $10, $14, $13, $24] }
            LogicalFilter { predicate: ($1 = $11) AND ($10 = $20) }
              LogicalJoin { type: LeftSemi, on: ($10 = $36), output_indices: all }
                LogicalJoin { type: Inner, on: true, output_indices: all }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalScan { table: customer, columns: [_row_id, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                    LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                  LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                LogicalProject { exprs: [$0] }
                  LogicalFilter { predicate: ($1 > 1:Int32) }
                    LogicalAgg { group_key: [0], agg_calls: [sum($1)] }
                      LogicalProject { exprs: [$1, $5] }
                        LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalTopN { order: [$4 DESC, $3 ASC], limit: 100, offset: 0 }
      LogicalAgg { group_key: [0, 1, 2, 3, 4], agg_calls: [sum($5)] }
        LogicalProject { exprs: [$1, $0, $2, $4, $3, $5] }
          LogicalJoin { type: LeftSemi, on: ($2 = $6), output_indices: all }
            LogicalJoin { type: Inner, on: ($2 = $5), output_indices: [0, 1, 2, 3, 4, 6] }
              LogicalJoin { type: Inner, on: ($0 = $3), output_indices: [0, 1, 2, 4, 5] }
                LogicalScan { table: customer, columns: [c_custkey, c_name] }
                LogicalScan { table: orders, columns: [o_orderkey, o_custkey, o_totalprice, o_orderdate] }
              LogicalScan { table: lineitem, columns: [l_orderkey, l_quantity] }
            LogicalProject { exprs: [$0] }
              LogicalFilter { predicate: ($1 > 1:Int32) }
                LogicalAgg { group_key: [0], agg_calls: [sum($1)] }
                  LogicalScan { table: lineitem, columns: [l_orderkey, l_quantity] }
  batch_plan: |
    BatchTopN { order: [$4 DESC, $3 ASC], limit: 100, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchTopN { order: [$4 DESC, $3 ASC], limit: 100, offset: 0 }
          BatchHashAgg { group_key: [$0, $1, $2, $3, $4], aggs: [sum($5)] }
            BatchProject { exprs: [$1, $0, $2, $4, $3, $5] }
              BatchHashJoin { type: LeftSemi, predicate: $2 = $6, output_indices: all }
                BatchHashJoin { type: Inner, predicate: $2 = $5, output_indices: [0, 1, 2, 3, 4, 6] }
                  BatchExchange { order: [], dist: HashShard([2]) }
                    BatchHashJoin { type: Inner, predicate: $0 = $3, output_indices: [0, 1, 2, 4, 5] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: customer, columns: [c_custkey, c_name] }
                      BatchExchange { order: [], dist: HashShard([1]) }
                        BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_totalprice, o_orderdate] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: lineitem, columns: [l_orderkey, l_quantity] }
                BatchProject { exprs: [$0] }
                  BatchFilter { predicate: ($1 > 1:Int32) }
                    BatchHashAgg { group_key: [$0], aggs: [sum($1)] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: lineitem, columns: [l_orderkey, l_quantity] }
  stream_plan: |
    StreamMaterialize { columns: [c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice, agg#0(hidden), quantity], pk_columns: [c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice], order_descs: [o_totalprice, o_orderdate, c_name, c_custkey, o_orderkey] }
      StreamTopN { order: [$4 DESC, $3 ASC], limit: 100, offset: 0 }
        StreamExchange { dist: Single }
          StreamHashAgg { group_key: [$0, $1, $2, $3, $4], aggs: [count, sum($5)] }
            StreamProject { exprs: [$1, $0, $2, $4, $3, $5, $6, $7, $8] }
              StreamHashJoin { type: LeftSemi, predicate: $2 = $9, output_indices: all }
                StreamHashJoin { type: Inner, predicate: $2 = $7, output_indices: [0, 1, 2, 3, 4, 8, 5, 6, 9] }
                  StreamExchange { dist: HashShard([2]) }
                    StreamHashJoin { type: Inner, predicate: $0 = $4, output_indices: [0, 1, 3, 5, 6, 2, 7] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: customer, columns: [c_custkey, c_name, _row_id], pk_indices: [2] }
                      StreamExchange { dist: HashShard([1]) }
                        StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_totalprice, o_orderdate, _row_id], pk_indices: [4] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamTableScan { table: lineitem, columns: [l_orderkey, l_quantity, _row_id], pk_indices: [2] }
                StreamProject { exprs: [$0] }
                  StreamFilter { predicate: ($2 > 1:Int32) }
                    StreamHashAgg { group_key: [$0], aggs: [count, sum($1)] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: lineitem, columns: [l_orderkey, l_quantity, _row_id], pk_indices: [2] }
- id: tpch_q19
  before:
    - create_tables
  sql: |
    select
      sum(l_extendedprice* (1 - l_discount)) as revenue
    from
      lineitem,
      part
    where
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#52'
        and p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
        and l_quantity >= 1 and l_quantity <= 11
        and p_size between 1 and 5
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      )
      or
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#24'
        and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
        and l_quantity >= 30 and l_quantity <= 40
        and p_size between 1 and 10
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      )
      or
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#32'
        and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
        and l_quantity >= 10 and l_quantity <= 20
        and p_size between 1 and 15
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      );
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalAgg { group_key: [], agg_calls: [sum($0)] }
        LogicalProject { exprs: [($6 * (1:Int32 - $7))] }
          LogicalFilter { predicate: ($18 = $2) AND ($23 >= 1:Int32) AND In($15, 'AIR':Varchar, 'AIR REG':Varchar) AND ($14 = 'DELIVER IN PERSON':Varchar) AND ((((((($21 = 'Brand#52':Varchar) AND In($24, 'SM CASE':Varchar, 'SM BOX':Varchar, 'SM PACK':Varchar, 'SM PKG':Varchar)) AND ($5 >= 1:Int32)) AND ($5 <= 11:Int32)) AND ($23 <= 5:Int32)) OR ((((($21 = 'Brand#24':Varchar) AND In($24, 'MED BAG':Varchar, 'MED BOX':Varchar, 'MED PKG':Varchar, 'MED PACK':Varchar)) AND ($5 >= 30:Int32)) AND ($5 <= 40:Int32)) AND ($23 <= 10:Int32))) OR ((((($21 = 'Brand#32':Varchar) AND In($24, 'LG CASE':Varchar, 'LG BOX':Varchar, 'LG PACK':Varchar, 'LG PKG':Varchar)) AND ($5 >= 10:Int32)) AND ($5 <= 20:Int32)) AND ($23 <= 15:Int32))) }
            LogicalJoin { type: Inner, on: true, output_indices: all }
              LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
              LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [], agg_calls: [sum($0)] }
      LogicalProject { exprs: [($0 * (1:Int32 - $1))] }
        LogicalJoin { type: Inner, on: ($4 = $0) AND ((((((($5 = 'Brand#52':Varchar) AND In($7, 'SM CASE':Varchar, 'SM BOX':Varchar, 'SM PACK':Varchar, 'SM PKG':Varchar)) AND ($1 >= 1:Int32)) AND ($1 <= 11:Int32)) AND ($6 <= 5:Int32)) OR ((((($5 = 'Brand#24':Varchar) AND In($7, 'MED BAG':Varchar, 'MED BOX':Varchar, 'MED PKG':Varchar, 'MED PACK':Varchar)) AND ($1 >= 30:Int32)) AND ($1 <= 40:Int32)) AND ($6 <= 10:Int32))) OR ((((($5 = 'Brand#32':Varchar) AND In($7, 'LG CASE':Varchar, 'LG BOX':Varchar, 'LG PACK':Varchar, 'LG PKG':Varchar)) AND ($1 >= 10:Int32)) AND ($1 <= 20:Int32)) AND ($6 <= 15:Int32))), output_indices: [2, 3] }
          LogicalScan { table: lineitem, output_columns: [l_partkey, l_quantity, l_extendedprice, l_discount], required_columns: [$2:l_partkey, $5:l_quantity, $6:l_extendedprice, $7:l_discount, $14:l_shipinstruct, $15:l_shipmode], predicate: In($15, 'AIR':Varchar, 'AIR REG':Varchar) AND ($14 = 'DELIVER IN PERSON':Varchar) }
          LogicalScan { table: part, output_columns: [p_partkey, p_brand, p_size, p_container], required_columns: [$1:p_partkey, $4:p_brand, $6:p_size, $7:p_container], predicate: ($6 >= 1:Int32) }
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0)] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [sum($0)] }
          BatchProject { exprs: [($2 * (1:Int32 - $3))] }
            BatchFilter { predicate: ((((((($5 = 'Brand#52':Varchar) AND In($7, 'SM CASE':Varchar, 'SM BOX':Varchar, 'SM PACK':Varchar, 'SM PKG':Varchar)) AND ($1 >= 1:Int32)) AND ($1 <= 11:Int32)) AND ($6 <= 5:Int32)) OR ((((($5 = 'Brand#24':Varchar) AND In($7, 'MED BAG':Varchar, 'MED BOX':Varchar, 'MED PKG':Varchar, 'MED PACK':Varchar)) AND ($1 >= 30:Int32)) AND ($1 <= 40:Int32)) AND ($6 <= 10:Int32))) OR ((((($5 = 'Brand#32':Varchar) AND In($7, 'LG CASE':Varchar, 'LG BOX':Varchar, 'LG PACK':Varchar, 'LG PKG':Varchar)) AND ($1 >= 10:Int32)) AND ($1 <= 20:Int32)) AND ($6 <= 15:Int32))) }
              BatchHashJoin { type: Inner, predicate: $0 = $4, output_indices: all }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchProject { exprs: [$0, $1, $2, $3] }
                    BatchFilter { predicate: In($5, 'AIR':Varchar, 'AIR REG':Varchar) AND ($4 = 'DELIVER IN PERSON':Varchar) }
                      BatchScan { table: lineitem, columns: [l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchFilter { predicate: ($2 >= 1:Int32) }
                    BatchScan { table: part, columns: [p_partkey, p_brand, p_size, p_container] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), revenue], pk_columns: [] }
      StreamGlobalSimpleAgg { aggs: [sum($0), sum($1)] }
        StreamExchange { dist: Single }
          StreamLocalSimpleAgg { aggs: [count, sum($0)] }
            StreamProject { exprs: [($2 * (1:Int32 - $3)), $4, $9] }
              StreamFilter { predicate: ((((((($6 = 'Brand#52':Varchar) AND In($8, 'SM CASE':Varchar, 'SM BOX':Varchar, 'SM PACK':Varchar, 'SM PKG':Varchar)) AND ($1 >= 1:Int32)) AND ($1 <= 11:Int32)) AND ($7 <= 5:Int32)) OR ((((($6 = 'Brand#24':Varchar) AND In($8, 'MED BAG':Varchar, 'MED BOX':Varchar, 'MED PKG':Varchar, 'MED PACK':Varchar)) AND ($1 >= 30:Int32)) AND ($1 <= 40:Int32)) AND ($7 <= 10:Int32))) OR ((((($6 = 'Brand#32':Varchar) AND In($8, 'LG CASE':Varchar, 'LG BOX':Varchar, 'LG PACK':Varchar, 'LG PKG':Varchar)) AND ($1 >= 10:Int32)) AND ($1 <= 20:Int32)) AND ($7 <= 15:Int32))) }
                StreamHashJoin { type: Inner, predicate: $0 = $5, output_indices: all }
                  StreamExchange { dist: HashShard([0]) }
                    StreamProject { exprs: [$0, $1, $2, $3, $4] }
                      StreamFilter { predicate: In($6, 'AIR':Varchar, 'AIR REG':Varchar) AND ($5 = 'DELIVER IN PERSON':Varchar) }
                        StreamTableScan { table: lineitem, columns: [l_partkey, l_quantity, l_extendedprice, l_discount, _row_id, l_shipinstruct, l_shipmode], pk_indices: [4] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($2 >= 1:Int32) }
                      StreamTableScan { table: part, columns: [p_partkey, p_brand, p_size, p_container, _row_id], pk_indices: [4] }
- id: tpch_q20
  before:
    - create_tables
  sql: |
    select
      s_name,
      s_address
    from
      supplier,
      nation
    where
      s_suppkey in (
        select
          ps_suppkey
        from
          partsupp
        where
          ps_partkey in (
            select
              p_partkey
            from
              part
            where
              p_name like 'forest%'
          )
          and ps_availqty > (
            select
              0.5 * sum(l_quantity)
            from
              lineitem
            where
              l_partkey = ps_partkey
              and l_suppkey = ps_suppkey
              and l_shipdate >= date '1994-01-01'
              and l_shipdate < date '1994-01-01' + interval '1' year
          )
      )
      and s_nationkey = n_nationkey
      and n_name = 'KENYA'
    order by
      s_name;
  logical_plan: |
    LogicalProject { exprs: [$2, $3] }
      LogicalFilter { predicate: ($4 = $9) AND ($10 = 'KENYA':Varchar) }
        LogicalJoin { type: LeftSemi, on: ($1 = $13), output_indices: all }
          LogicalJoin { type: Inner, on: true, output_indices: all }
            LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
            LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
          LogicalProject { exprs: [$2] }
            LogicalFilter { predicate: ($3 > $6) }
              LogicalApply { type: LeftOuter, on: true }
                LogicalJoin { type: LeftSemi, on: ($1 = $6), output_indices: all }
                  LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                  LogicalProject { exprs: [$1] }
                    LogicalFilter { predicate: Like($2, 'forest%':Varchar) }
                      LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                LogicalProject { exprs: [(0.5:Decimal * $0)] }
                  LogicalAgg { group_key: [], agg_calls: [sum($0)] }
                    LogicalProject { exprs: [$5] }
                      LogicalFilter { predicate: ($2 = CorrelatedInputRef { index: 1, depth: 1 }) AND ($3 = CorrelatedInputRef { index: 2, depth: 1 }) AND ($11 >= '1994-01-01':Varchar::Date) AND ($11 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                        LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: ($0 = $3), output_indices: [1, 2] }
      LogicalJoin { type: Inner, on: ($3 = $4), output_indices: [0, 1, 2] }
        LogicalScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey] }
        LogicalScan { table: nation, output_columns: [n_nationkey], required_columns: [$1:n_nationkey, $2:n_name], predicate: ($2 = 'KENYA':Varchar) }
      LogicalJoin { type: Inner, on: ($0 = $3) AND ($1 = $4) AND ($2 > $5), output_indices: [1] }
        LogicalJoin { type: LeftSemi, on: ($0 = $3), output_indices: all }
          LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty] }
          LogicalScan { table: part, output_columns: [p_partkey], required_columns: [$1:p_partkey, $2:p_name], predicate: Like($2, 'forest%':Varchar) }
        LogicalProject { exprs: [$0, $1, (0.5:Decimal * $2)] }
          LogicalAgg { group_key: [0, 1], agg_calls: [sum($2)] }
            LogicalScan { table: lineitem, output_columns: [l_partkey, l_suppkey, l_quantity], required_columns: [$2:l_partkey, $3:l_suppkey, $5:l_quantity, $11:l_shipdate], predicate: ($11 >= '1994-01-01':Varchar::Date) AND ($11 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchHashJoin { type: LeftSemi, predicate: $0 = $3, output_indices: [1, 2] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchHashJoin { type: Inner, predicate: $3 = $4, output_indices: [0, 1, 2] }
              BatchExchange { order: [], dist: HashShard([3]) }
                BatchScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchProject { exprs: [$0] }
                  BatchFilter { predicate: ($1 = 'KENYA':Varchar) }
                    BatchScan { table: nation, columns: [n_nationkey, n_name] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$1] }
              BatchFilter { predicate: ($2 > $5) }
                BatchHashJoin { type: Inner, predicate: $0 = $3 AND $1 = $4, output_indices: all }
                  BatchExchange { order: [], dist: HashShard([0, 1]) }
                    BatchHashJoin { type: LeftSemi, predicate: $0 = $3, output_indices: all }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchProject { exprs: [$0] }
                          BatchFilter { predicate: Like($1, 'forest%':Varchar) }
                            BatchScan { table: part, columns: [p_partkey, p_name] }
                  BatchProject { exprs: [$0, $1, (0.5:Decimal * $2)] }
                    BatchHashAgg { group_key: [$0, $1], aggs: [sum($2)] }
                      BatchExchange { order: [], dist: HashShard([0, 1]) }
                        BatchProject { exprs: [$0, $1, $2] }
                          BatchFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                            BatchScan { table: lineitem, columns: [l_partkey, l_suppkey, l_quantity, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden)], pk_columns: [_row_id, _row_id#1], order_descs: [s_name, _row_id, _row_id#1] }
      StreamExchange { dist: HashShard([2, 3]) }
        StreamHashJoin { type: LeftSemi, predicate: $0 = $5, output_indices: [1, 2, 3, 4] }
          StreamExchange { dist: HashShard([0]) }
            StreamHashJoin { type: Inner, predicate: $3 = $5, output_indices: [0, 1, 2, 4, 6] }
              StreamExchange { dist: HashShard([3]) }
                StreamTableScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, _row_id], pk_indices: [4] }
              StreamExchange { dist: HashShard([0]) }
                StreamProject { exprs: [$0, $1] }
                  StreamFilter { predicate: ($2 = 'KENYA':Varchar) }
                    StreamTableScan { table: nation, columns: [n_nationkey, _row_id, n_name], pk_indices: [1] }
          StreamExchange { dist: HashShard([0]) }
            StreamProject { exprs: [$1, $3, $4, $5] }
              StreamFilter { predicate: ($2 > $6) }
                StreamHashJoin { type: Inner, predicate: $0 = $4 AND $1 = $5, output_indices: all }
                  StreamExchange { dist: HashShard([0, 1]) }
                    StreamHashJoin { type: LeftSemi, predicate: $0 = $4, output_indices: all }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, _row_id], pk_indices: [3] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamProject { exprs: [$0, $1] }
                          StreamFilter { predicate: Like($2, 'forest%':Varchar) }
                            StreamTableScan { table: part, columns: [p_partkey, _row_id, p_name], pk_indices: [1] }
                  StreamProject { exprs: [$0, $1, (0.5:Decimal * $3)] }
                    StreamHashAgg { group_key: [$0, $1], aggs: [count, sum($2)] }
                      StreamExchange { dist: HashShard([0, 1]) }
                        StreamProject { exprs: [$0, $1, $2, $3] }
                          StreamFilter { predicate: ($4 >= '1994-01-01':Varchar::Date) AND ($4 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                            StreamTableScan { table: lineitem, columns: [l_partkey, l_suppkey, l_quantity, _row_id, l_shipdate], pk_indices: [3] }
- id: tpch_q21
  before:
    - create_tables
  sql: |
    select
      s_name,
      count(*) as numwait
    from
      supplier,
      lineitem l1,
      orders,
      nation
    where
      s_suppkey = l1.l_suppkey
      and o_orderkey = l1.l_orderkey
      and o_orderstatus = 'F'
      and l1.l_receiptdate > l1.l_commitdate
      and exists (
        select
          *
        from
          lineitem l2
        where
          l2.l_orderkey = l1.l_orderkey
          and l2.l_suppkey <> l1.l_suppkey
      )
      and not exists (
        select
          *
        from
          lineitem l3
        where
          l3.l_orderkey = l1.l_orderkey
          and l3.l_suppkey <> l1.l_suppkey
          and l3.l_receiptdate > l3.l_commitdate
      )
      and s_nationkey = n_nationkey
      and n_name = 'GERMANY'
    group by
      s_name
    order by
      numwait desc,
      s_name
    LIMIT 100;
  logical_plan: |
    LogicalTopN { order: [$1 DESC, $0 ASC], limit: 100, offset: 0 }
      LogicalProject { exprs: [$0, $1] }
        LogicalAgg { group_key: [0], agg_calls: [count] }
          LogicalProject { exprs: [$2] }
            LogicalFilter { predicate: ($1 = $11) AND ($26 = $9) AND ($28 = 'F':Varchar) AND ($21 > $20) AND ($4 = $36) AND ($37 = 'GERMANY':Varchar) }
              LogicalApply { type: LeftAnti, on: true }
                LogicalApply { type: LeftSemi, on: true }
                  LogicalJoin { type: Inner, on: true, output_indices: all }
                    LogicalJoin { type: Inner, on: true, output_indices: all }
                      LogicalJoin { type: Inner, on: true, output_indices: all }
                        LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                        LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                      LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                    LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
                  LogicalProject { exprs: [$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16] }
                    LogicalFilter { predicate: ($1 = CorrelatedInputRef { index: 9, depth: 1 }) AND ($3 <> CorrelatedInputRef { index: 11, depth: 1 }) }
                      LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                LogicalProject { exprs: [$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16] }
                  LogicalFilter { predicate: ($1 = CorrelatedInputRef { index: 9, depth: 1 }) AND ($3 <> CorrelatedInputRef { index: 11, depth: 1 }) AND ($13 > $12) }
                    LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
  optimized_logical_plan: |
    LogicalTopN { order: [$1 DESC, $0 ASC], limit: 100, offset: 0 }
      LogicalAgg { group_key: [0], agg_calls: [count] }
        LogicalJoin { type: LeftAnti, on: ($3 = $1) AND ($4 <> $2), output_indices: [0] }
          LogicalJoin { type: LeftSemi, on: ($3 = $1) AND ($4 <> $2), output_indices: all }
            LogicalJoin { type: Inner, on: ($1 = $4), output_indices: [0, 2, 3] }
              LogicalJoin { type: Inner, on: ($4 = $2), output_indices: [0, 1, 2, 3] }
                LogicalJoin { type: Inner, on: ($0 = $4), output_indices: [1, 2, 3, 4] }
                  LogicalScan { table: supplier, columns: [s_suppkey, s_name, s_nationkey] }
                  LogicalScan { table: lineitem, output_columns: [l_orderkey, l_suppkey], required_columns: [$1:l_orderkey, $3:l_suppkey, $12:l_commitdate, $13:l_receiptdate], predicate: ($13 > $12) }
                LogicalScan { table: orders, output_columns: [o_orderkey], required_columns: [$1:o_orderkey, $3:o_orderstatus], predicate: ($3 = 'F':Varchar) }
              LogicalScan { table: nation, output_columns: [n_nationkey], required_columns: [$1:n_nationkey, $2:n_name], predicate: ($2 = 'GERMANY':Varchar) }
            LogicalScan { table: lineitem, columns: [l_orderkey, l_suppkey] }
          LogicalScan { table: lineitem, output_columns: [l_orderkey, l_suppkey], required_columns: [$1:l_orderkey, $3:l_suppkey, $12:l_commitdate, $13:l_receiptdate], predicate: ($13 > $12) }
  batch_plan: |
    BatchTopN { order: [$1 DESC, $0 ASC], limit: 100, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchTopN { order: [$1 DESC, $0 ASC], limit: 100, offset: 0 }
          BatchHashAgg { group_key: [$0], aggs: [count] }
            BatchExchange { order: [], dist: HashShard([0]) }
              BatchHashJoin { type: LeftAnti, predicate: $1 = $3 AND ($4 <> $2), output_indices: [0] }
                BatchHashJoin { type: LeftSemi, predicate: $1 = $3 AND ($4 <> $2), output_indices: all }
                  BatchExchange { order: [], dist: HashShard([1]) }
                    BatchHashJoin { type: Inner, predicate: $1 = $4, output_indices: [0, 2, 3] }
                      BatchExchange { order: [], dist: HashShard([1]) }
                        BatchHashJoin { type: Inner, predicate: $2 = $4, output_indices: [0, 1, 2, 3] }
                          BatchExchange { order: [], dist: HashShard([2]) }
                            BatchHashJoin { type: Inner, predicate: $0 = $4, output_indices: [1, 2, 3, 4] }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchScan { table: supplier, columns: [s_suppkey, s_name, s_nationkey] }
                              BatchExchange { order: [], dist: HashShard([1]) }
                                BatchProject { exprs: [$0, $1] }
                                  BatchFilter { predicate: ($3 > $2) }
                                    BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchProject { exprs: [$0] }
                              BatchFilter { predicate: ($1 = 'F':Varchar) }
                                BatchScan { table: orders, columns: [o_orderkey, o_orderstatus] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchProject { exprs: [$0] }
                          BatchFilter { predicate: ($1 = 'GERMANY':Varchar) }
                            BatchScan { table: nation, columns: [n_nationkey, n_name] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchProject { exprs: [$0, $1] }
                    BatchFilter { predicate: ($3 > $2) }
                      BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate] }
  stream_plan: |
    StreamMaterialize { columns: [s_name, agg#0(hidden), numwait], pk_columns: [s_name], order_descs: [numwait, s_name] }
      StreamTopN { order: [$2 DESC, $0 ASC], limit: 100, offset: 0 }
        StreamExchange { dist: Single }
          StreamHashAgg { group_key: [$0], aggs: [count, count] }
            StreamExchange { dist: HashShard([0]) }
              StreamHashJoin { type: LeftAnti, predicate: $1 = $7 AND ($8 <> $2), output_indices: [0, 3, 4, 5, 6] }
                StreamHashJoin { type: LeftSemi, predicate: $1 = $7 AND ($8 <> $2), output_indices: all }
                  StreamExchange { dist: HashShard([1]) }
                    StreamHashJoin { type: Inner, predicate: $1 = $7, output_indices: [0, 2, 3, 4, 5, 6, 8] }
                      StreamExchange { dist: HashShard([1]) }
                        StreamHashJoin { type: Inner, predicate: $2 = $6, output_indices: [0, 1, 2, 3, 4, 5, 7] }
                          StreamExchange { dist: HashShard([2]) }
                            StreamHashJoin { type: Inner, predicate: $0 = $5, output_indices: [1, 2, 4, 5, 3, 6] }
                              StreamExchange { dist: HashShard([0]) }
                                StreamTableScan { table: supplier, columns: [s_suppkey, s_name, s_nationkey, _row_id], pk_indices: [3] }
                              StreamExchange { dist: HashShard([1]) }
                                StreamProject { exprs: [$0, $1, $2] }
                                  StreamFilter { predicate: ($4 > $3) }
                                    StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, _row_id, l_commitdate, l_receiptdate], pk_indices: [2] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamProject { exprs: [$0, $1] }
                              StreamFilter { predicate: ($2 = 'F':Varchar) }
                                StreamTableScan { table: orders, columns: [o_orderkey, _row_id, o_orderstatus], pk_indices: [1] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamProject { exprs: [$0, $1] }
                          StreamFilter { predicate: ($2 = 'GERMANY':Varchar) }
                            StreamTableScan { table: nation, columns: [n_nationkey, _row_id, n_name], pk_indices: [1] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, _row_id], pk_indices: [2] }
                StreamExchange { dist: HashShard([0]) }
                  StreamProject { exprs: [$0, $1, $2] }
                    StreamFilter { predicate: ($4 > $3) }
                      StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, _row_id, l_commitdate, l_receiptdate], pk_indices: [2] }
- id: tpch_q22
  before:
    - create_tables
  sql: |
    select
      cntrycode,
      count(*) as numcust,
      sum(c_acctbal) as totacctbal
    from
      (
        select
          substring(c_phone from 1 for 2) as cntrycode,
          c_acctbal
        from
          customer
        where
          substring(c_phone from 1 for 2) in
            ('30', '24', '31', '38', '25', '34', '37')
          and c_acctbal > (
            select
              avg(c_acctbal)
            from
              customer
            where
              c_acctbal > 0.00::numeric
              and substring(c_phone from 1 for 2) in
                ('30', '24', '31', '38', '25', '34', '37')
          )
          and not exists (
            select
              *
            from
              orders
            where
              o_custkey = c_custkey
          )
      ) as custsale
    group by
      cntrycode
    order by
      cntrycode;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $2] }
      LogicalAgg { group_key: [0], agg_calls: [count, sum($1)] }
        LogicalProject { exprs: [$0, $1] }
          LogicalProject { exprs: [Substr($5, 1:Int32, 2:Int32), $6] }
            LogicalFilter { predicate: In(Substr($5, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) AND ($6 > $9) }
              LogicalJoin { type: LeftOuter, on: true, output_indices: all }
                LogicalApply { type: LeftAnti, on: true }
                  LogicalScan { table: customer, columns: [_row_id, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                  LogicalProject { exprs: [$1, $2, $3, $4, $5, $6, $7, $8, $9] }
                    LogicalFilter { predicate: ($2 = CorrelatedInputRef { index: 1, depth: 1 }) }
                      LogicalScan { table: orders, columns: [_row_id, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                LogicalProject { exprs: [($0 / $1)] }
                  LogicalAgg { group_key: [], agg_calls: [sum($0), count($0)] }
                    LogicalProject { exprs: [$6] }
                      LogicalFilter { predicate: ($6 > 0.00:Decimal) AND In(Substr($5, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) }
                        LogicalScan { table: customer, columns: [_row_id, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
  optimized_logical_plan: |
    LogicalAgg { group_key: [0], agg_calls: [count, sum($1)] }
      LogicalProject { exprs: [Substr($0, 1:Int32, 2:Int32), $1] }
        LogicalJoin { type: Inner, on: ($1 > $2), output_indices: [0, 1] }
          LogicalJoin { type: LeftAnti, on: ($3 = $0), output_indices: [1, 2] }
            LogicalScan { table: customer, output_columns: [c_custkey, c_phone, c_acctbal], required_columns: [$1:c_custkey, $5:c_phone, $6:c_acctbal], predicate: In(Substr($5, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) }
            LogicalScan { table: orders, columns: [o_custkey] }
          LogicalProject { exprs: [($0 / $1)] }
            LogicalAgg { group_key: [], agg_calls: [sum($0), count($0)] }
              LogicalScan { table: customer, output_columns: [c_acctbal], required_columns: [$6:c_acctbal, $5:c_phone], predicate: ($6 > 0.00:Decimal) AND In(Substr($5, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) }
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchHashAgg { group_key: [$0], aggs: [count, sum($1)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [Substr($0, 1:Int32, 2:Int32), $1] }
              BatchNestedLoopJoin { type: Inner, predicate: ($1 > $2), output_indices: [0, 1] }
                BatchExchange { order: [], dist: Single }
                  BatchHashJoin { type: LeftAnti, predicate: $0 = $3, output_indices: [1, 2] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: In(Substr($1, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) }
                        BatchScan { table: customer, columns: [c_custkey, c_phone, c_acctbal] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchScan { table: orders, columns: [o_custkey] }
                BatchProject { exprs: [($0 / $1)] }
                  BatchSimpleAgg { aggs: [sum($0), sum($1)] }
                    BatchExchange { order: [], dist: Single }
                      BatchSimpleAgg { aggs: [sum($0), count($0)] }
                        BatchProject { exprs: [$0] }
                          BatchFilter { predicate: ($0 > 0.00:Decimal) AND In(Substr($1, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) }
                            BatchScan { table: customer, columns: [c_acctbal, c_phone] }
  stream_plan: |
    StreamMaterialize { columns: [cntrycode, agg#0(hidden), numcust, totacctbal], pk_columns: [cntrycode] }
      StreamHashAgg { group_key: [$0], aggs: [count, count, sum($1)] }
        StreamExchange { dist: HashShard([0]) }
          StreamProject { exprs: [Substr($0, 1:Int32, 2:Int32), $1, $2] }
            StreamDynamicFilter { predicate: ($1 > $3) }
              StreamExchange { dist: HashShard([1]) }
                StreamHashJoin { type: LeftAnti, predicate: $0 = $4, output_indices: [1, 2, 3] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: In(Substr($1, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) }
                      StreamTableScan { table: customer, columns: [c_custkey, c_phone, c_acctbal, _row_id], pk_indices: [3] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamTableScan { table: orders, columns: [o_custkey, _row_id], pk_indices: [1] }
              StreamExchange { dist: Broadcast }
                StreamProject { exprs: [($1 / $2)] }
                  StreamGlobalSimpleAgg { aggs: [sum($0), sum($1), sum($2)] }
                    StreamExchange { dist: Single }
                      StreamLocalSimpleAgg { aggs: [count, sum($0), count($0)] }
                        StreamProject { exprs: [$0, $1] }
                          StreamFilter { predicate: ($0 > 0.00:Decimal) AND In(Substr($2, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) }
                            StreamTableScan { table: customer, columns: [c_acctbal, _row_id, c_phone], pk_indices: [1] }
