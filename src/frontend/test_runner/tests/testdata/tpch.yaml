- id: create_tables
  sql: |
    CREATE TABLE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR(25),
            s_address VARCHAR(40),
            s_nationkey INTEGER,
            s_phone VARCHAR(15),
            s_acctbal NUMERIC,
            s_comment VARCHAR(101));

    CREATE TABLE part (
            p_partkey INTEGER,
            p_name VARCHAR(55),
            p_mfgr VARCHAR(25),
            p_brand VARCHAR(10),
            p_type VARCHAR(100),
            p_size INTEGER,
            p_container VARCHAR(10),
            p_retailprice NUMERIC,
            p_comment VARCHAR(23));

    CREATE TABLE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR(199));

    CREATE TABLE customer (
            c_custkey INTEGER,
            c_name VARCHAR(25),
            c_address VARCHAR(40),
            c_nationkey INTEGER,
            c_phone VARCHAR(15),
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR(10),
            c_comment VARCHAR(117));

    CREATE TABLE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR(1),
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR(15),
            o_clerk VARCHAR(15),
            o_shippriority INTEGER,
            o_comment VARCHAR(79));

    CREATE TABLE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR(1),
            l_linestatus VARCHAR(1),
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR(25),
            l_shipmode VARCHAR(10),
            l_comment VARCHAR(44));

    CREATE TABLE nation (
            n_nationkey INTEGER,
            n_name VARCHAR(25),
            n_regionkey INTEGER,
            n_comment VARCHAR(152));

    CREATE TABLE region (
            r_regionkey INTEGER,
            r_name VARCHAR(25),
            r_comment VARCHAR(152));
- id: tpch_q1
  before:
    - create_tables
  sql: |
    select
      l_returnflag,
      l_linestatus,
      sum(l_quantity) as sum_qty,
      sum(l_extendedprice) as sum_base_price,
      sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
      sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
      round(avg(l_quantity), 4) as avg_qty,
      round(avg(l_extendedprice), 4) as avg_price,
      round(avg(l_discount), 4) as avg_disc,
      count(*) as count_order
    from
      lineitem
    where
      l_shipdate <= date '1998-12-01' - interval '71' day
    group by
      l_returnflag,
      l_linestatus
    order by
      l_returnflag,
      l_linestatus;
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 ASC], dist: Single }
      BatchSort { order: [$0 ASC, $1 ASC] }
        BatchProject { exprs: [$0, $1, $2, $3, $4, $5, RoundDigit(($6 / $7), 4:Int32), RoundDigit(($8 / $9), 4:Int32), RoundDigit(($10 / $11), 4:Int32), $12], expr_alias: [l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, avg_qty, avg_price, avg_disc, count_order] }
          BatchHashAgg { group_keys: [$0, $1], aggs: [sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
            BatchProject { exprs: [$4, $5, $0, $1, ($1 * (1:Int32 - $2)), (($1 * (1:Int32 - $2)) * (1:Int32 + $3)), $2], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
              BatchExchange { order: [], dist: HashShard([4, 5]) }
                BatchFilter { predicate: ($6 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
                  BatchScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, avg_qty, avg_price, avg_disc, count_order], pk_columns: [l_returnflag, l_linestatus] }
      StreamProject { exprs: [$0, $1, $3, $4, $5, $6, RoundDigit(($7 / $8), 4:Int32), RoundDigit(($9 / $10), 4:Int32), RoundDigit(($11 / $12), 4:Int32), $13], expr_alias: [l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, avg_qty, avg_price, avg_disc, count_order] }
        StreamHashAgg { group_keys: [$0, $1], aggs: [count, sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
          StreamProject { exprs: [$4, $5, $0, $1, ($1 * (1:Int32 - $2)), (($1 * (1:Int32 - $2)) * (1:Int32 + $3)), $2, $7], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ] }
            StreamExchange { dist: HashShard([4, 5]) }
              StreamFilter { predicate: ($6 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
                StreamTableScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, _row_id#0], pk_indices: [7] }
- id: tpch_q2
  before:
    - create_tables
  sql: |
    select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
    from
            part,
            supplier,
            partsupp,
            nation,
            region
    where
            p_partkey = ps_partkey
            and s_suppkey = ps_suppkey
      and p_size = 4
      and p_type like '%TIN'
            and s_nationkey = n_nationkey
            and n_regionkey = r_regionkey
            and r_name = 'AFRICA'
            and ps_supplycost = (
                    select
                            min(ps_supplycost)
                    from
                            partsupp,
                            supplier,
                            nation,
                            region
                    where
                            p_partkey = ps_partkey
                            and s_suppkey = ps_suppkey
                            and s_nationkey = n_nationkey
                            and n_regionkey = r_regionkey
                            and r_name = 'AFRICA'
            )
    order by
          s_acctbal desc,
          n_name,
          s_name,
          p_partkey
    limit 100;
  logical_plan: |
    LogicalLimit { limit: 100, offset: 0 }
      LogicalProject { exprs: [$16, $12, $26, $1, $3, $13, $15, $17], expr_alias: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
        LogicalFilter { predicate: ($1 = $19) AND ($11 = $20) AND ($6 = 4:Int32) AND Like($5, '%TIN':Varchar) AND ($14 = $25) AND ($27 = $30) AND ($31 = 'AFRICA':Varchar) AND ($22 = $33) }
          LogicalApply { type: LeftOuter }
            LogicalJoin { type: Inner, on: always }
              LogicalJoin { type: Inner, on: always }
                LogicalJoin { type: Inner, on: always }
                  LogicalJoin { type: Inner, on: always }
                    LogicalScan { table: part, columns: [_row_id#0, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                    LogicalScan { table: supplier, columns: [_row_id#0, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                  LogicalScan { table: partsupp, columns: [_row_id#0, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
              LogicalScan { table: region, columns: [_row_id#0, r_regionkey, r_name, r_comment] }
            LogicalProject { exprs: [$0], expr_alias: [ ] }
              LogicalAgg { group_keys: [], agg_calls: [min($0)] }
                LogicalProject { exprs: [$4], expr_alias: [ ] }
                  LogicalFilter { predicate: (CorrelatedInputRef { index: 1, depth: 1 } = $1) AND ($7 = $2) AND ($10 = $15) AND ($17 = $20) AND ($21 = 'AFRICA':Varchar) }
                    LogicalJoin { type: Inner, on: always }
                      LogicalJoin { type: Inner, on: always }
                        LogicalJoin { type: Inner, on: always }
                          LogicalScan { table: partsupp, columns: [_row_id#0, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                          LogicalScan { table: supplier, columns: [_row_id#0, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                        LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
                      LogicalScan { table: region, columns: [_row_id#0, r_regionkey, r_name, r_comment] }
- id: tpch_q3
  before:
    - create_tables
  sql: |
    select
      l_orderkey,
      sum(l_extendedprice * (1 - l_discount)) as revenue,
      o_orderdate,
      o_shippriority
    from
      customer,
      orders,
      lineitem
    where
      c_mktsegment = 'FURNITURE'
      and c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and o_orderdate < date '1995-03-29'
      and l_shipdate > date '1995-03-29'
    group by
      l_orderkey,
      o_orderdate,
      o_shippriority
    order by
      revenue desc,
      o_orderdate
    /* TODO: support order + limit */
    /* LIMIT 10; */
  batch_plan: |
    BatchExchange { order: [$1 DESC, $2 ASC], dist: Single }
      BatchSort { order: [$1 DESC, $2 ASC] }
        BatchProject { exprs: [$0, $3, $1, $2], expr_alias: [l_orderkey, revenue, o_orderdate, o_shippriority] }
          BatchHashAgg { group_keys: [$0, $1, $2], aggs: [sum($3)] }
            BatchProject { exprs: [$3, $1, $2, ($4 * (1:Int32 - $5))], expr_alias: [ ,  ,  ,  ] }
              BatchExchange { order: [], dist: HashShard([3, 1, 2]) }
                BatchHashJoin { type: Inner, predicate: $0 = $3 }
                  BatchProject { exprs: [$1, $3, $4], expr_alias: [ ,  ,  ] }
                    BatchExchange { order: [], dist: HashShard([1]) }
                      BatchHashJoin { type: Inner, predicate: $0 = $2 }
                        BatchProject { exprs: [$0], expr_alias: [ ] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchFilter { predicate: ($1 = 'FURNITURE':Varchar) }
                              BatchScan { table: customer, columns: [c_custkey, c_mktsegment] }
                        BatchExchange { order: [], dist: HashShard([1]) }
                          BatchFilter { predicate: ($2 < '1995-03-29':Varchar::Date) }
                            BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, o_shippriority] }
                  BatchProject { exprs: [$0, $1, $2], expr_alias: [ ,  ,  ] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($3 > '1995-03-29':Varchar::Date) }
                        BatchScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [l_orderkey, revenue, o_orderdate, o_shippriority], pk_columns: [revenue, o_orderdate, l_orderkey, o_shippriority] }
      StreamProject { exprs: [$0, $4, $1, $2], expr_alias: [l_orderkey, revenue, o_orderdate, o_shippriority] }
        StreamHashAgg { group_keys: [$0, $1, $2], aggs: [count, sum($3)] }
          StreamProject { exprs: [$5, $1, $2, ($6 * (1:Int32 - $7)), $3, $4, $8], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
            StreamExchange { dist: HashShard([5, 1, 2]) }
              StreamHashJoin { type: Inner, predicate: $0 = $5 }
                StreamProject { exprs: [$2, $4, $5, $1, $6], expr_alias: [ ,  ,  ,  ,  ] }
                  StreamExchange { dist: HashShard([2]) }
                    StreamHashJoin { type: Inner, predicate: $0 = $3 }
                      StreamProject { exprs: [$0, $2], expr_alias: [ ,  ] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamFilter { predicate: ($1 = 'FURNITURE':Varchar) }
                            StreamTableScan { table: customer, columns: [c_custkey, c_mktsegment, _row_id#0], pk_indices: [2] }
                      StreamExchange { dist: HashShard([1]) }
                        StreamFilter { predicate: ($2 < '1995-03-29':Varchar::Date) }
                          StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, o_shippriority, _row_id#0], pk_indices: [4] }
                StreamProject { exprs: [$0, $1, $2, $4], expr_alias: [ ,  ,  ,  ] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($3 > '1995-03-29':Varchar::Date) }
                      StreamTableScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id#0], pk_indices: [4] }
- id: tpch_q4
  before:
    - create_tables
  sql: |
    select
      o_orderpriority,
      count(*) as order_count
    from
      orders
    where
      o_orderdate >= date '1997-07-01'
      and o_orderdate < date '1997-07-01' + interval '3' month
      and exists (
        select
          *
        from
          lineitem
        where
          l_orderkey = o_orderkey
          and l_commitdate < l_receiptdate
      )
    group by
      o_orderpriority
    order by
      o_orderpriority;
  logical_plan: |
    LogicalProject { exprs: [$0, $1], expr_alias: [o_orderpriority, order_count] }
      LogicalAgg { group_keys: [0], agg_calls: [count] }
        LogicalProject { exprs: [$6], expr_alias: [ ] }
          LogicalFilter { predicate: ($5 >= '1997-07-01':Varchar::Date) AND ($5 < ('1997-07-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
            LogicalApply { type: LeftSemi }
              LogicalScan { table: orders, columns: [_row_id#0, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
              LogicalProject { exprs: [$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16], expr_alias: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                LogicalFilter { predicate: ($1 = CorrelatedInputRef { index: 1, depth: 1 }) AND ($12 < $13) }
                  LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
- id: tpch_q5
  before:
    - create_tables
  sql: |
    select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
      and r_name = 'MIDDLE EAST'
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '1' year
    group by
      n_name
    order by
      revenue desc;
  logical_plan: |
    LogicalProject { exprs: [$0, $1], expr_alias: [n_name, revenue] }
      LogicalAgg { group_keys: [0], agg_calls: [sum($1)] }
        LogicalProject { exprs: [$46, ($25 * (1:Int32 - $26))], expr_alias: [ ,  ] }
          LogicalFilter { predicate: ($1 = $11) AND ($20 = $10) AND ($22 = $37) AND ($4 = $40) AND ($40 = $45) AND ($47 = $50) AND ($51 = 'MIDDLE EAST':Varchar) AND ($14 >= '1994-01-01':Varchar::Date) AND ($14 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
            LogicalJoin { type: Inner, on: always }
              LogicalJoin { type: Inner, on: always }
                LogicalJoin { type: Inner, on: always }
                  LogicalJoin { type: Inner, on: always }
                    LogicalJoin { type: Inner, on: always }
                      LogicalScan { table: customer, columns: [_row_id#0, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                      LogicalScan { table: orders, columns: [_row_id#0, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                    LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                  LogicalScan { table: supplier, columns: [_row_id#0, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
              LogicalScan { table: region, columns: [_row_id#0, r_regionkey, r_name, r_comment] }
  batch_plan: |
    BatchExchange { order: [$1 DESC], dist: Single }
      BatchSort { order: [$1 DESC] }
        BatchProject { exprs: [$0, $1], expr_alias: [n_name, revenue] }
          BatchHashAgg { group_keys: [$0], aggs: [sum($1)] }
            BatchProject { exprs: [$2, ($0 * (1:Int32 - $1))], expr_alias: [ ,  ] }
              BatchExchange { order: [], dist: HashShard([2]) }
                BatchHashJoin { type: Inner, predicate: $3 = $4 }
                  BatchProject { exprs: [$0, $1, $4, $5], expr_alias: [ ,  ,  ,  ] }
                    BatchExchange { order: [], dist: HashShard([5]) }
                      BatchHashJoin { type: Inner, predicate: $2 = $3 }
                        BatchProject { exprs: [$2, $3, $5], expr_alias: [ ,  ,  ] }
                          BatchExchange { order: [], dist: HashShard([5]) }
                            BatchHashJoin { type: Inner, predicate: $1 = $4AND $0 = $5 }
                              BatchProject { exprs: [$0, $3, $4, $5], expr_alias: [ ,  ,  ,  ] }
                                BatchExchange { order: [], dist: HashShard([3, 0]) }
                                  BatchHashJoin { type: Inner, predicate: $1 = $2 }
                                    BatchProject { exprs: [$1, $2], expr_alias: [ ,  ] }
                                      BatchExchange { order: [], dist: HashShard([2]) }
                                        BatchHashJoin { type: Inner, predicate: $0 = $3 }
                                          BatchExchange { order: [], dist: HashShard([0]) }
                                            BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                                          BatchProject { exprs: [$0, $1], expr_alias: [ ,  ] }
                                            BatchExchange { order: [], dist: HashShard([1]) }
                                              BatchFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                                BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                                    BatchExchange { order: [], dist: HashShard([0]) }
                                      BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
                              BatchExchange { order: [], dist: HashShard([0, 1]) }
                                BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: nation, columns: [n_nationkey, n_name, n_regionkey] }
                  BatchProject { exprs: [$0], expr_alias: [ ] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($1 = 'MIDDLE EAST':Varchar) }
                        BatchScan { table: region, columns: [r_regionkey, r_name] }
  stream_plan: |
    StreamMaterialize { columns: [n_name, revenue], pk_columns: [revenue, n_name] }
      StreamProject { exprs: [$0, $2], expr_alias: [n_name, revenue] }
        StreamHashAgg { group_keys: [$0], aggs: [count, sum($1)] }
          StreamProject { exprs: [$2, ($0 * (1:Int32 - $1)), $4, $5, $6, $7, $8, $10], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ] }
            StreamExchange { dist: HashShard([2]) }
              StreamHashJoin { type: Inner, predicate: $3 = $9 }
                StreamProject { exprs: [$0, $1, $8, $9, $3, $4, $5, $6, $10], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ] }
                  StreamExchange { dist: HashShard([9]) }
                    StreamHashJoin { type: Inner, predicate: $2 = $7 }
                      StreamProject { exprs: [$2, $3, $8, $4, $5, $6, $9], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
                        StreamExchange { dist: HashShard([8]) }
                          StreamHashJoin { type: Inner, predicate: $1 = $7AND $0 = $8 }
                            StreamProject { exprs: [$0, $5, $6, $7, $2, $3, $8], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
                              StreamExchange { dist: HashShard([5, 0]) }
                                StreamHashJoin { type: Inner, predicate: $1 = $4 }
                                  StreamProject { exprs: [$1, $3, $2, $5], expr_alias: [ ,  ,  ,  ] }
                                    StreamExchange { dist: HashShard([3]) }
                                      StreamHashJoin { type: Inner, predicate: $0 = $4 }
                                        StreamExchange { dist: HashShard([0]) }
                                          StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id#0], pk_indices: [2] }
                                        StreamProject { exprs: [$0, $1, $3], expr_alias: [ ,  ,  ] }
                                          StreamExchange { dist: HashShard([1]) }
                                            StreamFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                              StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, _row_id#0], pk_indices: [3] }
                                  StreamExchange { dist: HashShard([0]) }
                                    StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id#0], pk_indices: [4] }
                            StreamExchange { dist: HashShard([0, 1]) }
                              StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id#0], pk_indices: [2] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: nation, columns: [n_nationkey, n_name, n_regionkey, _row_id#0], pk_indices: [3] }
                StreamProject { exprs: [$0, $2], expr_alias: [ ,  ] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($1 = 'MIDDLE EAST':Varchar) }
                      StreamTableScan { table: region, columns: [r_regionkey, r_name, _row_id#0], pk_indices: [2] }
- id: tpch_q6
  before:
    - create_tables
  sql: |
    select
      sum(l_extendedprice * l_discount) as revenue
    from
      lineitem
    where
      l_shipdate >= date '1994-01-01'
      and l_shipdate < date '1994-01-01' + interval '1' year
      and l_discount between 0.08 - 0.01 and 0.08 + 0.01
      and l_quantity < 24;
  batch_plan: |
    BatchProject { exprs: [$0], expr_alias: [revenue] }
      BatchSimpleAgg { aggs: [sum($0)] }
        BatchExchange { order: [], dist: Single }
          BatchProject { exprs: [($1 * $2)], expr_alias: [ ] }
            BatchFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($2 >= (0.08:Decimal - 0.01:Decimal)) AND ($2 <= (0.08:Decimal + 0.01:Decimal)) AND ($0 < 24:Int32) }
              BatchScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [revenue, agg#0(hidden)], pk_columns: [agg#0, revenue] }
      StreamProject { exprs: [$1, $0], expr_alias: [revenue,  ] }
        StreamSimpleAgg { aggs: [count, sum($0)] }
          StreamProject { exprs: [($1 * $2), $4], expr_alias: [ ,  ] }
            StreamFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($2 >= (0.08:Decimal - 0.01:Decimal)) AND ($2 <= (0.08:Decimal + 0.01:Decimal)) AND ($0 < 24:Int32) }
              StreamTableScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_shipdate, _row_id#0], pk_indices: [4] }
- id: tpch_q7
  before:
    - create_tables
  sql: |
    select
      supp_nation,
      cust_nation,
      l_year,
      sum(volume) as revenue
    from
      (
        select
          n1.n_name as supp_nation,
          n2.n_name as cust_nation,
          extract(year from l_shipdate) as l_year,
          l_extendedprice * (1 - l_discount) as volume
        from
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2
        where
          s_suppkey = l_suppkey
          and o_orderkey = l_orderkey
          and c_custkey = o_custkey
          and s_nationkey = n1.n_nationkey
          and c_nationkey = n2.n_nationkey
          and (
            (n1.n_name = 'ROMANIA' and n2.n_name = 'IRAN')
            or (n1.n_name = 'IRAN' and n2.n_name = 'ROMANIA')
          )
          and l_shipdate between date '1983-01-01' and date '2000-12-31'
      ) as shipping
    group by
      supp_nation,
      cust_nation,
      l_year
    order by
      supp_nation,
      cust_nation,
      l_year;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $2, $3], expr_alias: [supp_nation, cust_nation, l_year, revenue] }
      LogicalAgg { group_keys: [0, 1, 2], agg_calls: [sum($3)] }
        LogicalProject { exprs: [$0, $1, $2, $3], expr_alias: [ ,  ,  ,  ] }
          LogicalProject { exprs: [$46, $51, Extract('YEAR':Varchar, $19), ($14 * (1:Int32 - $15))], expr_alias: [supp_nation, cust_nation, l_year, volume] }
            LogicalFilter { predicate: ($1 = $11) AND ($26 = $9) AND ($36 = $27) AND ($4 = $45) AND ($39 = $50) AND ((($46 = 'ROMANIA':Varchar) AND ($51 = 'IRAN':Varchar)) OR (($46 = 'IRAN':Varchar) AND ($51 = 'ROMANIA':Varchar))) AND ($19 >= '1983-01-01':Varchar::Date) AND ($19 <= '2000-12-31':Varchar::Date) }
              LogicalJoin { type: Inner, on: always }
                LogicalJoin { type: Inner, on: always }
                  LogicalJoin { type: Inner, on: always }
                    LogicalJoin { type: Inner, on: always }
                      LogicalJoin { type: Inner, on: always }
                        LogicalScan { table: supplier, columns: [_row_id#0, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                        LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                      LogicalScan { table: orders, columns: [_row_id#0, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                    LogicalScan { table: customer, columns: [_row_id#0, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                  LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
                LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 ASC, $2 ASC], dist: Single }
      BatchSort { order: [$0 ASC, $1 ASC, $2 ASC] }
        BatchProject { exprs: [$0, $1, $2, $3], expr_alias: [supp_nation, cust_nation, l_year, revenue] }
          BatchHashAgg { group_keys: [$0, $1, $2], aggs: [sum($3)] }
            BatchExchange { order: [], dist: HashShard([0, 1, 2]) }
              BatchProject { exprs: [$4, $6, Extract('YEAR':Varchar, $2), ($0 * (1:Int32 - $1))], expr_alias: [ ,  ,  ,  ] }
                BatchFilter { predicate: ((($4 = 'ROMANIA':Varchar) AND ($6 = 'IRAN':Varchar)) OR (($4 = 'IRAN':Varchar) AND ($6 = 'ROMANIA':Varchar))) }
                  BatchHashJoin { type: Inner, predicate: $3 = $5 }
                    BatchProject { exprs: [$1, $2, $3, $4, $6], expr_alias: [ ,  ,  ,  ,  ] }
                      BatchExchange { order: [], dist: HashShard([4]) }
                        BatchHashJoin { type: Inner, predicate: $0 = $5 }
                          BatchProject { exprs: [$0, $1, $2, $3, $6], expr_alias: [ ,  ,  ,  ,  ] }
                            BatchExchange { order: [], dist: HashShard([0]) }
                              BatchHashJoin { type: Inner, predicate: $4 = $5 }
                                BatchProject { exprs: [$0, $2, $3, $4, $6], expr_alias: [ ,  ,  ,  ,  ] }
                                  BatchExchange { order: [], dist: HashShard([6]) }
                                    BatchHashJoin { type: Inner, predicate: $1 = $5 }
                                      BatchProject { exprs: [$1, $2, $4, $5, $6], expr_alias: [ ,  ,  ,  ,  ] }
                                        BatchExchange { order: [], dist: HashShard([2]) }
                                          BatchHashJoin { type: Inner, predicate: $0 = $3 }
                                            BatchExchange { order: [], dist: HashShard([0]) }
                                              BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                                            BatchExchange { order: [], dist: HashShard([1]) }
                                              BatchFilter { predicate: ($4 >= '1983-01-01':Varchar::Date) AND ($4 <= '2000-12-31':Varchar::Date) }
                                                BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate] }
                                      BatchExchange { order: [], dist: HashShard([0]) }
                                        BatchScan { table: orders, columns: [o_orderkey, o_custkey] }
                                BatchExchange { order: [], dist: HashShard([0]) }
                                  BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: nation, columns: [n_nationkey, n_name] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchScan { table: nation, columns: [n_nationkey, n_name] }
  stream_plan: |
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], pk_columns: [supp_nation, cust_nation, l_year] }
      StreamProject { exprs: [$0, $1, $2, $4], expr_alias: [supp_nation, cust_nation, l_year, revenue] }
        StreamHashAgg { group_keys: [$0, $1, $2], aggs: [count, sum($3)] }
          StreamExchange { dist: HashShard([0, 1, 2]) }
            StreamProject { exprs: [$4, $11, Extract('YEAR':Varchar, $2), ($0 * (1:Int32 - $1)), $5, $6, $7, $8, $9, $12], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
              StreamFilter { predicate: ((($4 = 'ROMANIA':Varchar) AND ($11 = 'IRAN':Varchar)) OR (($4 = 'IRAN':Varchar) AND ($11 = 'ROMANIA':Varchar))) }
                StreamHashJoin { type: Inner, predicate: $3 = $10 }
                  StreamProject { exprs: [$1, $2, $3, $4, $10, $5, $6, $7, $8, $11], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
                    StreamExchange { dist: HashShard([4]) }
                      StreamHashJoin { type: Inner, predicate: $0 = $9 }
                        StreamProject { exprs: [$0, $1, $2, $3, $9, $5, $6, $7, $10], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamHashJoin { type: Inner, predicate: $4 = $8 }
                              StreamProject { exprs: [$0, $2, $3, $4, $8, $5, $6, $9], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ] }
                                StreamExchange { dist: HashShard([8]) }
                                  StreamHashJoin { type: Inner, predicate: $1 = $7 }
                                    StreamProject { exprs: [$1, $3, $5, $6, $7, $2, $8], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
                                      StreamExchange { dist: HashShard([3]) }
                                        StreamHashJoin { type: Inner, predicate: $0 = $4 }
                                          StreamExchange { dist: HashShard([0]) }
                                            StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id#0], pk_indices: [2] }
                                          StreamExchange { dist: HashShard([1]) }
                                            StreamFilter { predicate: ($4 >= '1983-01-01':Varchar::Date) AND ($4 <= '2000-12-31':Varchar::Date) }
                                              StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate, _row_id#0], pk_indices: [5] }
                                    StreamExchange { dist: HashShard([0]) }
                                      StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, _row_id#0], pk_indices: [2] }
                              StreamExchange { dist: HashShard([0]) }
                                StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id#0], pk_indices: [2] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id#0], pk_indices: [2] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id#0], pk_indices: [2] }
- id: tpch_q8
  before:
    - create_tables
  sql: |
    select
      o_year,
      round(sum(case
        when nation = 'IRAN' then volume
        else 0
      end) / sum(volume), 6) as mkt_share
    from
      (
        select
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) as volume,
          n2.n_name as nation
        from
          part,
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2,
          region
        where
          p_partkey = l_partkey
          and s_suppkey = l_suppkey
          and l_orderkey = o_orderkey
          and o_custkey = c_custkey
          and c_nationkey = n1.n_nationkey
          and n1.n_regionkey = r_regionkey
          and r_name = 'ASIA'
          and s_nationkey = n2.n_nationkey
          and o_orderdate between date '1995-01-01' and date '1996-12-31'
          and p_type = 'PROMO ANODIZED STEEL'
      ) as all_nations
    group by
      o_year
    order by
      o_year;
  logical_plan: |
    LogicalProject { exprs: [$0, RoundDigit(($1 / $2), 6:Int32)], expr_alias: [o_year, mkt_share] }
      LogicalAgg { group_keys: [0], agg_calls: [sum($1), sum($2)] }
        LogicalProject { exprs: [$0, Case(($2 = 'IRAN':Varchar), $1, 0:Int32::Decimal), $1], expr_alias: [ ,  ,  ] }
          LogicalProject { exprs: [Extract('YEAR':Varchar, $40), ($24 * (1:Int32 - $25)), $61], expr_alias: [o_year, volume, nation] }
            LogicalFilter { predicate: ($1 = $20) AND ($11 = $21) AND ($19 = $36) AND ($37 = $46) AND ($49 = $55) AND ($57 = $65) AND ($66 = 'ASIA':Varchar) AND ($14 = $60) AND ($40 >= '1995-01-01':Varchar::Date) AND ($40 <= '1996-12-31':Varchar::Date) AND ($5 = 'PROMO ANODIZED STEEL':Varchar) }
              LogicalJoin { type: Inner, on: always }
                LogicalJoin { type: Inner, on: always }
                  LogicalJoin { type: Inner, on: always }
                    LogicalJoin { type: Inner, on: always }
                      LogicalJoin { type: Inner, on: always }
                        LogicalJoin { type: Inner, on: always }
                          LogicalJoin { type: Inner, on: always }
                            LogicalScan { table: part, columns: [_row_id#0, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                            LogicalScan { table: supplier, columns: [_row_id#0, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                          LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                        LogicalScan { table: orders, columns: [_row_id#0, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                      LogicalScan { table: customer, columns: [_row_id#0, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                    LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
                  LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
                LogicalScan { table: region, columns: [_row_id#0, r_regionkey, r_name, r_comment] }
- id: tpch_q9
  before:
    - create_tables
  sql: |
    select
      nation,
      o_year,
      round(sum(amount), 2) as sum_profit
    from
      (
        select
          n_name as nation,
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
          part,
          supplier,
          lineitem,
          partsupp,
          orders,
          nation
        where
          s_suppkey = l_suppkey
          and ps_suppkey = l_suppkey
          and ps_partkey = l_partkey
          and p_partkey = l_partkey
          and o_orderkey = l_orderkey
          and s_nationkey = n_nationkey
          and p_name like '%yellow%'
      ) as profit
    group by
      nation,
      o_year
    order by
      nation,
      o_year desc;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, RoundDigit($2, 2:Int32)], expr_alias: [nation, o_year, sum_profit] }
      LogicalAgg { group_keys: [0, 1], agg_calls: [sum($2)] }
        LogicalProject { exprs: [$0, $1, $2], expr_alias: [ ,  ,  ] }
          LogicalProject { exprs: [$53, Extract('YEAR':Varchar, $46), (($24 * (1:Int32 - $25)) - ($39 * $23))], expr_alias: [nation, o_year, amount] }
            LogicalFilter { predicate: ($11 = $21) AND ($37 = $21) AND ($36 = $20) AND ($1 = $20) AND ($42 = $19) AND ($14 = $52) AND Like($2, '%yellow%':Varchar) }
              LogicalJoin { type: Inner, on: always }
                LogicalJoin { type: Inner, on: always }
                  LogicalJoin { type: Inner, on: always }
                    LogicalJoin { type: Inner, on: always }
                      LogicalJoin { type: Inner, on: always }
                        LogicalScan { table: part, columns: [_row_id#0, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                        LogicalScan { table: supplier, columns: [_row_id#0, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                      LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                    LogicalScan { table: partsupp, columns: [_row_id#0, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                  LogicalScan { table: orders, columns: [_row_id#0, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
- id: tpch_q10
  before:
    - create_tables
  sql: |
    select
      c_custkey,
      c_name,
      sum(l_extendedprice * (1.00 - l_discount)) as revenue,
      c_acctbal,
      n_name,
      c_address,
      c_phone,
      c_comment
    from
      customer,
      orders,
      lineitem,
      nation
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '3' month
      and l_returnflag = 'R'
      and c_nationkey = n_nationkey
    group by
      c_custkey,
      c_name,
      c_acctbal,
      c_phone,
      n_name,
      c_address,
      c_comment
    order by
      revenue desc
    limit 20;
  logical_plan: |
    LogicalLimit { limit: 20, offset: 0 }
      LogicalProject { exprs: [$0, $1, $7, $2, $4, $5, $3, $6], expr_alias: [c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment] }
        LogicalAgg { group_keys: [0, 1, 2, 3, 4, 5, 6], agg_calls: [sum($7)] }
          LogicalProject { exprs: [$1, $2, $6, $5, $38, $3, $8, ($25 * (1.00:Decimal - $26))], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ] }
            LogicalFilter { predicate: ($1 = $11) AND ($20 = $10) AND ($14 >= '1994-01-01':Varchar::Date) AND ($14 < ('1994-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) AND ($28 = 'R':Varchar) AND ($4 = $37) }
              LogicalJoin { type: Inner, on: always }
                LogicalJoin { type: Inner, on: always }
                  LogicalJoin { type: Inner, on: always }
                    LogicalScan { table: customer, columns: [_row_id#0, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                    LogicalScan { table: orders, columns: [_row_id#0, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
                  LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
- id: tpch_q12
  before:
    - create_tables
  sql: |
    select
        l_shipmode,
        sum(case
            when o_orderpriority = '1-URGENT'
                or o_orderpriority = '2-HIGH'
                then 1
            else 0
        end) as high_line_count,
        sum(case
            when o_orderpriority <> '1-URGENT'
                and o_orderpriority <> '2-HIGH'
                then 1
            else 0
        end) as low_line_count
    from
        orders,
        lineitem
    where
        o_orderkey = l_orderkey
        and l_shipmode in ('FOB', 'SHIP')
        and l_commitdate < l_receiptdate
        and l_shipdate < l_commitdate
        and l_receiptdate >= date '1994-01-01'
        and l_receiptdate < date '1994-01-01' + interval '1' year
    group by
        l_shipmode
    order by
        l_shipmode;
  binder_error: 'Feature is not yet implemented: unsupported expression InList { expr: Identifier(Ident { value: "l_shipmode", quote_style: None }), list: [Value(SingleQuotedString("FOB")), Value(SingleQuotedString("SHIP"))], negated: false }, Tracking issue: https://github.com/singularity-data/risingwave/issues/112'
- id: tpch_q13
  before:
    - create_tables
  sql: |
    select
      c_count,
      count(*) as custdist
    from
      (
        select
          c_custkey,
          count(o_orderkey) as c_count
        from
          customer left outer join orders on
            c_custkey = o_custkey
            and o_comment not like '%:1%:2%'
        group by
          c_custkey
      ) as c_orders (c_custkey, c_count)
    group by
      c_count
    order by
      custdist desc,
      c_count desc;
  logical_plan: |
    LogicalProject { exprs: [$0, $1], expr_alias: [c_count, custdist] }
      LogicalAgg { group_keys: [0], agg_calls: [count] }
        LogicalProject { exprs: [$1], expr_alias: [ ] }
          LogicalProject { exprs: [$0, $1], expr_alias: [c_custkey, c_count] }
            LogicalAgg { group_keys: [0], agg_calls: [count($1)] }
              LogicalProject { exprs: [$1, $10], expr_alias: [ ,  ] }
                LogicalJoin { type: LeftOuter, on: ($1 = $11) AND Not(Like($18, '%:1%:2%':Varchar)) }
                  LogicalScan { table: customer, columns: [_row_id#0, c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment] }
                  LogicalScan { table: orders, columns: [_row_id#0, o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment] }
  batch_plan: |
    BatchExchange { order: [$1 DESC, $0 DESC], dist: Single }
      BatchSort { order: [$1 DESC, $0 DESC] }
        BatchProject { exprs: [$0, $1], expr_alias: [c_count, custdist] }
          BatchHashAgg { group_keys: [$0], aggs: [count] }
            BatchProject { exprs: [$1], expr_alias: [ ] }
              BatchExchange { order: [], dist: HashShard([1]) }
                BatchHashAgg { group_keys: [$0], aggs: [count($1)] }
                  BatchProject { exprs: [$0, $1], expr_alias: [ ,  ] }
                    BatchHashJoin { type: LeftOuter, predicate: $0 = $2AND Not(Like($3, '%:1%:2%':Varchar)) }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: customer, columns: [c_custkey] }
                      BatchExchange { order: [], dist: HashShard([1]) }
                        BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_comment] }
  stream_plan: |
    StreamMaterialize { columns: [c_count, custdist], pk_columns: [custdist, c_count] }
      StreamProject { exprs: [$0, $2], expr_alias: [c_count, custdist] }
        StreamHashAgg { group_keys: [$0], aggs: [count, count] }
          StreamProject { exprs: [$2, $0], expr_alias: [ ,  ] }
            StreamExchange { dist: HashShard([2]) }
              StreamHashAgg { group_keys: [$0], aggs: [count, count($1)] }
                StreamProject { exprs: [$0, $2, $1, $5], expr_alias: [ ,  ,  ,  ] }
                  StreamHashJoin { type: LeftOuter, predicate: $0 = $3AND Not(Like($4, '%:1%:2%':Varchar)) }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: customer, columns: [c_custkey, _row_id#0], pk_indices: [1] }
                    StreamExchange { dist: HashShard([1]) }
                      StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_comment, _row_id#0], pk_indices: [3] }
- id: tpch_q14
  before:
    - create_tables
  sql: |
    select
      100.00 * sum(case
        when p_type like 'PROMO%'
          then l_extendedprice * (1 - l_discount)
        else 0
      end) / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
    from
      lineitem,
      part
    where
      l_partkey = p_partkey
      and l_shipdate >= date '1995-09-01'
      and l_shipdate < date '1995-09-01' + interval '1' month;
  logical_plan: |
    LogicalProject { exprs: [((100.00:Decimal * $0) / $1)], expr_alias: [promo_revenue] }
      LogicalAgg { group_keys: [], agg_calls: [sum($0), sum($1)] }
        LogicalProject { exprs: [Case(Like($22, 'PROMO%':Varchar), ($6 * (1:Int32 - $7)), 0:Int32::Decimal), ($6 * (1:Int32 - $7))], expr_alias: [ ,  ] }
          LogicalFilter { predicate: ($2 = $18) AND ($11 >= '1995-09-01':Varchar::Date) AND ($11 < ('1995-09-01':Varchar::Date + '1 mon 00:00:00':Interval)) }
            LogicalJoin { type: Inner, on: always }
              LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
              LogicalScan { table: part, columns: [_row_id#0, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
- id: tpch_q15
  before:
    - create_tables
  sql: |
    select
      s_suppkey,
      s_name,
      s_address,
      s_phone,
      total_revenue
    from
      supplier,
      (
        select
        l_suppkey,
        sum(l_extendedprice * (1 - l_discount)) as total_revenue
      from
        lineitem
      where
        l_shipdate >= date '1993-01-01'
        and l_shipdate < date '1993-01-01' + interval '3' month
      group by
        l_suppkey
      ) as revenue0 (supplier_no, total_revenue)
    where
      s_suppkey = supplier_no
      and total_revenue = (
        select
          max(total_revenue) as max_revenue
        from
          (
            select
            l_suppkey,
            sum(l_extendedprice * (1 - l_discount)) as total_revenue
          from
            lineitem
          where
            l_shipdate >= date '1993-01-01'
            and l_shipdate < date '1993-01-01' + interval '3' month
          group by
            l_suppkey
          ) as revenue0 (supplier_no, total_revenue)
      )
    order by
      s_suppkey;
  logical_plan: |
    LogicalProject { exprs: [$1, $2, $3, $5, $9], expr_alias: [s_suppkey, s_name, s_address, s_phone, total_revenue] }
      LogicalFilter { predicate: ($1 = $8) AND ($9 = $10) }
        LogicalJoin { type: LeftOuter, on: always }
          LogicalJoin { type: Inner, on: always }
            LogicalScan { table: supplier, columns: [_row_id#0, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
            LogicalProject { exprs: [$0, $1], expr_alias: [l_suppkey, total_revenue] }
              LogicalAgg { group_keys: [0], agg_calls: [sum($1)] }
                LogicalProject { exprs: [$3, ($6 * (1:Int32 - $7))], expr_alias: [ ,  ] }
                  LogicalFilter { predicate: ($11 >= '1993-01-01':Varchar::Date) AND ($11 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                    LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
          LogicalProject { exprs: [$0], expr_alias: [max_revenue] }
            LogicalAgg { group_keys: [], agg_calls: [max($0)] }
              LogicalProject { exprs: [$1], expr_alias: [ ] }
                LogicalProject { exprs: [$0, $1], expr_alias: [l_suppkey, total_revenue] }
                  LogicalAgg { group_keys: [0], agg_calls: [sum($1)] }
                    LogicalProject { exprs: [$3, ($6 * (1:Int32 - $7))], expr_alias: [ ,  ] }
                      LogicalFilter { predicate: ($11 >= '1993-01-01':Varchar::Date) AND ($11 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                        LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
- id: tpch_q17
  before:
    - create_tables
  sql: |
    select
      ROUND(sum(l_extendedprice) / 7.0, 16) as avg_yearly
    from
      lineitem,
      part
    where
      p_partkey = l_partkey
      and p_brand = 'Brand#13'
      and p_container = 'JUMBO PKG'
      and l_quantity < (
        select
          0.2 * avg(l_quantity)
        from
          lineitem
        where
          l_partkey = p_partkey
      );
  logical_plan: |
    LogicalProject { exprs: [RoundDigit(($0 / 7.0:Decimal), 16:Int32)], expr_alias: [avg_yearly] }
      LogicalAgg { group_keys: [], agg_calls: [sum($0)] }
        LogicalProject { exprs: [$6], expr_alias: [ ] }
          LogicalFilter { predicate: ($18 = $2) AND ($21 = 'Brand#13':Varchar) AND ($24 = 'JUMBO PKG':Varchar) AND ($5 < $27) }
            LogicalApply { type: LeftOuter }
              LogicalJoin { type: Inner, on: always }
                LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                LogicalScan { table: part, columns: [_row_id#0, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
              LogicalProject { exprs: [(0.2:Decimal * ($0 / $1))], expr_alias: [ ] }
                LogicalAgg { group_keys: [], agg_calls: [sum($0), count($0)] }
                  LogicalProject { exprs: [$5], expr_alias: [ ] }
                    LogicalFilter { predicate: ($2 = CorrelatedInputRef { index: 18, depth: 1 }) }
                      LogicalScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
- id: tpch_q18
  before:
    - create_tables
  sql: |
    select
      c_name,
      c_custkey,
      o_orderkey,
      o_orderdate,
      o_totalprice,
      sum(l_quantity) quantity
    from
      customer,
      orders,
      lineitem
    where
      o_orderkey in (
        select
          l_orderkey
        from
          lineitem
        group by
          l_orderkey having
            sum(l_quantity) > 1
      )
      and c_custkey = o_custkey
      and o_orderkey = l_orderkey
    group by
      c_name,
      c_custkey,
      o_orderkey,
      o_orderdate,
      o_totalprice
    order by
      o_totalprice desc,
      o_orderdate
    LIMIT 100;
  binder_error: 'Feature is not yet implemented: unsupported expression InSubquery { expr: Identifier(Ident { value: "o_orderkey", quote_style: None }), subquery: Query { with: None, body: Select(Select { distinct: false, projection: [UnnamedExpr(Identifier(Ident { value: "l_orderkey", quote_style: None }))], from: [TableWithJoins { relation: Table { name: ObjectName([Ident { value: "lineitem", quote_style: None }]), alias: None, args: [] }, joins: [] }], lateral_views: [], selection: None, group_by: [Identifier(Ident { value: "l_orderkey", quote_style: None })], having: Some(BinaryOp { left: Function(Function { name: ObjectName([Ident { value: "sum", quote_style: None }]), args: [Unnamed(Expr(Identifier(Ident { value: "l_quantity", quote_style: None })))], over: None, distinct: false }), op: Gt, right: Value(Number("1", false)) }) }), order_by: [], limit: None, offset: None, fetch: None }, negated: false }, Tracking issue: https://github.com/singularity-data/risingwave/issues/112'
- id: tpch_q19
  before:
    - create_tables
  sql: |
    select
      sum(l_extendedprice* (1 - l_discount)) as revenue
    from
      lineitem,
      part
    where
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#52'
        and p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
        and l_quantity >= 1 and l_quantity <= 11
        and p_size between 1 and 5
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      )
      or
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#24'
        and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
        and l_quantity >= 30 and l_quantity <= 40
        and p_size between 1 and 10
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      )
      or
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#32'
        and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
        and l_quantity >= 10 and l_quantity <= 20
        and p_size between 1 and 15
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      );
  binder_error: 'Feature is not yet implemented: unsupported expression InList { expr: Identifier(Ident { value: "p_container", quote_style: None }), list: [Value(SingleQuotedString("SM CASE")), Value(SingleQuotedString("SM BOX")), Value(SingleQuotedString("SM PACK")), Value(SingleQuotedString("SM PKG"))], negated: false }, Tracking issue: https://github.com/singularity-data/risingwave/issues/112'
- id: tpch_q20
  before:
    - create_tables
  sql: |
    select
      s_name,
      s_address
    from
      supplier,
      nation
    where
      s_suppkey in (
        select
          ps_suppkey
        from
          partsupp
        where
          ps_partkey in (
            select
              p_partkey
            from
              part
            where
              p_name like 'forest%'
          )
          and ps_availqty > (
            select
              0.5 * sum(l_quantity)
            from
              lineitem
            where
              l_partkey = ps_partkey
              and l_suppkey = ps_suppkey
              and l_shipdate >= date '1994-01-01'
              and l_shipdate < date '1994-01-01' + interval '1' year
          )
      )
      and s_nationkey = n_nationkey
      and n_name = 'KENYA'
    order by
      s_name;
  binder_error: 'Feature is not yet implemented: unsupported expression InSubquery { expr: Identifier(Ident { value: "s_suppkey", quote_style: None }), subquery: Query { with: None, body: Select(Select { distinct: false, projection: [UnnamedExpr(Identifier(Ident { value: "ps_suppkey", quote_style: None }))], from: [TableWithJoins { relation: Table { name: ObjectName([Ident { value: "partsupp", quote_style: None }]), alias: None, args: [] }, joins: [] }], lateral_views: [], selection: Some(BinaryOp { left: InSubquery { expr: Identifier(Ident { value: "ps_partkey", quote_style: None }), subquery: Query { with: None, body: Select(Select { distinct: false, projection: [UnnamedExpr(Identifier(Ident { value: "p_partkey", quote_style: None }))], from: [TableWithJoins { relation: Table { name: ObjectName([Ident { value: "part", quote_style: None }]), alias: None, args: [] }, joins: [] }], lateral_views: [], selection: Some(BinaryOp { left: Identifier(Ident { value: "p_name", quote_style: None }), op: Like, right: Value(SingleQuotedString("forest%")) }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, negated: false }, op: And, right: BinaryOp { left: Identifier(Ident { value: "ps_availqty", quote_style: None }), op: Gt, right: Subquery(Query { with: None, body: Select(Select { distinct: false, projection: [UnnamedExpr(BinaryOp { left: Value(Number("0.5", false)), op: Multiply, right: Function(Function { name: ObjectName([Ident { value: "sum", quote_style: None }]), args: [Unnamed(Expr(Identifier(Ident { value: "l_quantity", quote_style: None })))], over: None, distinct: false }) })], from: [TableWithJoins { relation: Table { name: ObjectName([Ident { value: "lineitem", quote_style: None }]), alias: None, args: [] }, joins: [] }], lateral_views: [], selection: Some(BinaryOp { left: BinaryOp { left: BinaryOp { left: BinaryOp { left: Identifier(Ident { value: "l_partkey", quote_style: None }), op: Eq, right: Identifier(Ident { value: "ps_partkey", quote_style: None }) }, op: And, right: BinaryOp { left: Identifier(Ident { value: "l_suppkey", quote_style: None }), op: Eq, right: Identifier(Ident { value: "ps_suppkey", quote_style: None }) } }, op: And, right: BinaryOp { left: Identifier(Ident { value: "l_shipdate", quote_style: None }), op: GtEq, right: TypedString { data_type: Date, value: "1994-01-01" } } }, op: And, right: BinaryOp { left: Identifier(Ident { value: "l_shipdate", quote_style: None }), op: Lt, right: BinaryOp { left: TypedString { data_type: Date, value: "1994-01-01" }, op: Plus, right: Value(Interval { value: "1", leading_field: Some(Year), leading_precision: None, last_field: None, fractional_seconds_precision: None }) } } }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }) } }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, negated: false }, Tracking issue: https://github.com/singularity-data/risingwave/issues/112'
