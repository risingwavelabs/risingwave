- id: create_tables
  sql: |
    CREATE TABLE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR(25),
            s_address VARCHAR(40),
            s_nationkey INTEGER,
            s_phone VARCHAR(15),
            s_acctbal NUMERIC,
            s_comment VARCHAR(101));

    CREATE TABLE part (
            p_partkey INTEGER,
            p_name VARCHAR(55),
            p_mfgr VARCHAR(25),
            p_brand VARCHAR(10),
            p_type VARCHAR(100),
            p_size INTEGER,
            p_container VARCHAR(10),
            p_retailprice NUMERIC,
            p_comment VARCHAR(23));

    CREATE TABLE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR(199));

    CREATE TABLE customer (
            c_custkey INTEGER,
            c_name VARCHAR(25),
            c_address VARCHAR(40),
            c_nationkey INTEGER,
            c_phone VARCHAR(15),
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR(10),
            c_comment VARCHAR(117));

    CREATE TABLE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR(1),
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR(15),
            o_clerk VARCHAR(15),
            o_shippriority INTEGER,
            o_comment VARCHAR(79));

    CREATE TABLE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR(1),
            l_linestatus VARCHAR(1),
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR(25),
            l_shipmode VARCHAR(10),
            l_comment VARCHAR(44));

    CREATE TABLE nation (
            n_nationkey INTEGER,
            n_name VARCHAR(25),
            n_regionkey INTEGER,
            n_comment VARCHAR(152));

    CREATE TABLE region (
            r_regionkey INTEGER,
            r_name VARCHAR(25),
            r_comment VARCHAR(152));
- id: tpch_q1
  before:
    - create_tables
  sql: |
    select
      l_returnflag,
      l_linestatus,
      sum(l_quantity) as sum_qty,
      sum(l_extendedprice) as sum_base_price,
      sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
      sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
      round(avg(l_quantity), 4) as avg_qty,
      round(avg(l_extendedprice), 4) as avg_price,
      round(avg(l_discount), 4) as avg_disc,
      count(*) as count_order
    from
      lineitem
    where
      l_shipdate <= date '1998-12-01' - interval '71' day
    group by
      l_returnflag,
      l_linestatus
    order by
      l_returnflag,
      l_linestatus;
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 ASC], dist: Single }
      BatchSort { order: [$0 ASC, $1 ASC] }
        BatchProject { exprs: [$0, $1, $2, $3, $4, $5, RoundDigit(($6 / $7), 4:Int32), RoundDigit(($8 / $9), 4:Int32), RoundDigit(($10 / $11), 4:Int32), $12], expr_alias: [l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, avg_qty, avg_price, avg_disc, count_order] }
          BatchHashAgg { group_keys: [$0, $1], aggs: [sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
            BatchProject { exprs: [$4, $5, $0, $1, ($1 * (1:Int32 - $2)), (($1 * (1:Int32 - $2)) * (1:Int32 + $3)), $2], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
              BatchExchange { order: [], dist: HashShard([4, 5]) }
                BatchFilter { predicate: ($6 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
                  BatchScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, avg_qty, avg_price, avg_disc, count_order], pk_columns: [l_returnflag, l_linestatus] }
      StreamProject { exprs: [$0, $1, $3, $4, $5, $6, RoundDigit(($7 / $8), 4:Int32), RoundDigit(($9 / $10), 4:Int32), RoundDigit(($11 / $12), 4:Int32), $13], expr_alias: [l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, avg_qty, avg_price, avg_disc, count_order] }
        StreamHashAgg { group_keys: [$0, $1], aggs: [count, sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
          StreamProject { exprs: [$4, $5, $0, $1, ($1 * (1:Int32 - $2)), (($1 * (1:Int32 - $2)) * (1:Int32 + $3)), $2, $7], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ] }
            StreamExchange { dist: HashShard([4, 5]) }
              StreamFilter { predicate: ($6 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
                StreamTableScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, _row_id#0], pk_indices: [7] }
- id: tpch_q2
  before:
    - create_tables
  sql: |
    select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
    from
            part,
            supplier,
            partsupp,
            nation,
            region
    where
            p_partkey = ps_partkey
            and s_suppkey = ps_suppkey
      and p_size = 4
      and p_type like '%TIN'
            and s_nationkey = n_nationkey
            and n_regionkey = r_regionkey
            and r_name = 'AFRICA'
            and ps_supplycost = (
                    select
                            min(ps_supplycost)
                    from
                            partsupp,
                            supplier,
                            nation,
                            region
                    where
                            p_partkey = ps_partkey
                            and s_suppkey = ps_suppkey
                            and s_nationkey = n_nationkey
                            and n_regionkey = r_regionkey
                            and r_name = 'AFRICA'
            )
    order by
          s_acctbal desc,
          n_name,
          s_name,
          p_partkey
    limit 100;
  optimized_logical_plan: |
    LogicalTopN { order: [$0 DESC, $2 ASC, $1 ASC, $3 ASC], limit: 100, offset: 0 }
      LogicalProject { exprs: [$5, $2, $8, $0, $1, $3, $4, $6], expr_alias: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
        LogicalFilter { predicate: ($7 = $9) }
          LogicalProject { exprs: [$1, $3, $12, $13, $15, $16, $17, $22, $26, $33], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
            LogicalAgg { group_keys: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], agg_calls: [min($33)] }
              LogicalProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
                LogicalJoin { type: LeftOuter, on: ($1 = $34) }
                  LogicalJoin { type: Inner, on: ($27 = $30) }
                    LogicalJoin { type: Inner, on: ($14 = $25) }
                      LogicalJoin { type: Inner, on: ($1 = $19) AND ($11 = $20) }
                        LogicalJoin { type: Inner, on: always }
                          LogicalFilter { predicate: ($6 = 4:Int32) AND Like($5, '%TIN':Varchar) }
                            LogicalScan { table: part, columns: [_row_id#0, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                          LogicalScan { table: supplier, columns: [_row_id#0, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                        LogicalScan { table: partsupp, columns: [_row_id#0, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                      LogicalScan { table: nation, columns: [_row_id#0, n_nationkey, n_name, n_regionkey, n_comment] }
                    LogicalFilter { predicate: ($2 = 'AFRICA':Varchar) }
                      LogicalScan { table: region, columns: [_row_id#0, r_regionkey, r_name, r_comment] }
                  LogicalProject { exprs: [$1, $0], expr_alias: [ ,  ] }
                    LogicalJoin { type: Inner, on: ($2 = $3) }
                      LogicalProject { exprs: [$0, $1, $4], expr_alias: [ ,  ,  ] }
                        LogicalJoin { type: Inner, on: ($2 = $3) }
                          LogicalProject { exprs: [$0, $2, $4], expr_alias: [ ,  ,  ] }
                            LogicalJoin { type: Inner, on: ($3 = $1) }
                              LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
                              LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                          LogicalScan { table: nation, columns: [n_nationkey, n_regionkey] }
                      LogicalProject { exprs: [$0], expr_alias: [ ] }
                        LogicalFilter { predicate: ($1 = 'AFRICA':Varchar) }
                          LogicalScan { table: region, columns: [r_regionkey, r_name] }
- id: tpch_q3
  before:
    - create_tables
  sql: |
    select
      l_orderkey,
      sum(l_extendedprice * (1 - l_discount)) as revenue,
      o_orderdate,
      o_shippriority
    from
      customer,
      orders,
      lineitem
    where
      c_mktsegment = 'FURNITURE'
      and c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and o_orderdate < date '1995-03-29'
      and l_shipdate > date '1995-03-29'
    group by
      l_orderkey,
      o_orderdate,
      o_shippriority
    order by
      revenue desc,
      o_orderdate
    /* TODO: support order + limit */
    /* LIMIT 10; */
  batch_plan: |
    BatchExchange { order: [$1 DESC, $2 ASC], dist: Single }
      BatchSort { order: [$1 DESC, $2 ASC] }
        BatchProject { exprs: [$0, $3, $1, $2], expr_alias: [l_orderkey, revenue, o_orderdate, o_shippriority] }
          BatchHashAgg { group_keys: [$0, $1, $2], aggs: [sum($3)] }
            BatchProject { exprs: [$3, $1, $2, ($4 * (1:Int32 - $5))], expr_alias: [ ,  ,  ,  ] }
              BatchExchange { order: [], dist: HashShard([3, 1, 2]) }
                BatchHashJoin { type: Inner, predicate: $0 = $3 }
                  BatchProject { exprs: [$1, $3, $4], expr_alias: [ ,  ,  ] }
                    BatchExchange { order: [], dist: HashShard([1]) }
                      BatchHashJoin { type: Inner, predicate: $0 = $2 }
                        BatchProject { exprs: [$0], expr_alias: [ ] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchFilter { predicate: ($1 = 'FURNITURE':Varchar) }
                              BatchScan { table: customer, columns: [c_custkey, c_mktsegment] }
                        BatchExchange { order: [], dist: HashShard([1]) }
                          BatchFilter { predicate: ($2 < '1995-03-29':Varchar::Date) }
                            BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, o_shippriority] }
                  BatchProject { exprs: [$0, $1, $2], expr_alias: [ ,  ,  ] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($3 > '1995-03-29':Varchar::Date) }
                        BatchScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [l_orderkey, revenue, o_orderdate, o_shippriority], pk_columns: [revenue, o_orderdate, l_orderkey, o_shippriority] }
      StreamProject { exprs: [$0, $4, $1, $2], expr_alias: [l_orderkey, revenue, o_orderdate, o_shippriority] }
        StreamHashAgg { group_keys: [$0, $1, $2], aggs: [count, sum($3)] }
          StreamProject { exprs: [$5, $1, $2, ($6 * (1:Int32 - $7)), $3, $4, $8], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
            StreamExchange { dist: HashShard([5, 1, 2]) }
              StreamHashJoin { type: Inner, predicate: $0 = $5 }
                StreamProject { exprs: [$2, $4, $5, $1, $6], expr_alias: [ ,  ,  ,  ,  ] }
                  StreamExchange { dist: HashShard([2]) }
                    StreamHashJoin { type: Inner, predicate: $0 = $3 }
                      StreamProject { exprs: [$0, $2], expr_alias: [ ,  ] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamFilter { predicate: ($1 = 'FURNITURE':Varchar) }
                            StreamTableScan { table: customer, columns: [c_custkey, c_mktsegment, _row_id#0], pk_indices: [2] }
                      StreamExchange { dist: HashShard([1]) }
                        StreamFilter { predicate: ($2 < '1995-03-29':Varchar::Date) }
                          StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, o_shippriority, _row_id#0], pk_indices: [4] }
                StreamProject { exprs: [$0, $1, $2, $4], expr_alias: [ ,  ,  ,  ] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($3 > '1995-03-29':Varchar::Date) }
                      StreamTableScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id#0], pk_indices: [4] }
- id: tpch_q4
  before:
    - create_tables
  sql: |
    select
      o_orderpriority,
      count(*) as order_count
    from
      orders
    where
      o_orderdate >= date '1997-07-01'
      and o_orderdate < date '1997-07-01' + interval '3' month
      and exists (
        select
          *
        from
          lineitem
        where
          l_orderkey = o_orderkey
          and l_commitdate < l_receiptdate
      )
    group by
      o_orderpriority
    order by
      o_orderpriority;
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchProject { exprs: [$0, $1], expr_alias: [o_orderpriority, order_count] }
          BatchHashAgg { group_keys: [$0], aggs: [count] }
            BatchProject { exprs: [$1], expr_alias: [ ] }
              BatchExchange { order: [], dist: HashShard([1]) }
                BatchHashJoin { type: LeftSemi, predicate: $0 = $2 }
                  BatchProject { exprs: [$0, $2], expr_alias: [ ,  ] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($1 >= '1997-07-01':Varchar::Date) AND ($1 < ('1997-07-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                        BatchScan { table: orders, columns: [o_orderkey, o_orderdate, o_orderpriority] }
                  BatchProject { exprs: [$0], expr_alias: [ ] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($1 < $2) }
                        BatchScan { table: lineitem, columns: [l_orderkey, l_commitdate, l_receiptdate] }
  stream_plan: |
    StreamMaterialize { columns: [o_orderpriority, order_count], pk_columns: [o_orderpriority] }
      StreamProject { exprs: [$0, $2], expr_alias: [o_orderpriority, order_count] }
        StreamHashAgg { group_keys: [$0], aggs: [count, count] }
          StreamProject { exprs: [$1, $2, $4], expr_alias: [ ,  ,  ] }
            StreamExchange { dist: HashShard([1]) }
              StreamHashJoin { type: LeftSemi, predicate: $0 = $3 }
                StreamProject { exprs: [$0, $2, $3], expr_alias: [ ,  ,  ] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($1 >= '1997-07-01':Varchar::Date) AND ($1 < ('1997-07-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                      StreamTableScan { table: orders, columns: [o_orderkey, o_orderdate, o_orderpriority, _row_id#0], pk_indices: [3] }
                StreamProject { exprs: [$0, $3], expr_alias: [ ,  ] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($1 < $2) }
                      StreamTableScan { table: lineitem, columns: [l_orderkey, l_commitdate, l_receiptdate, _row_id#0], pk_indices: [3] }
- id: tpch_q5
  before:
    - create_tables
  sql: |
    select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
      and r_name = 'MIDDLE EAST'
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '1' year
    group by
      n_name
    order by
      revenue desc;
  batch_plan: |
    BatchExchange { order: [$1 DESC], dist: Single }
      BatchSort { order: [$1 DESC] }
        BatchProject { exprs: [$0, $1], expr_alias: [n_name, revenue] }
          BatchHashAgg { group_keys: [$0], aggs: [sum($1)] }
            BatchProject { exprs: [$2, ($0 * (1:Int32 - $1))], expr_alias: [ ,  ] }
              BatchExchange { order: [], dist: HashShard([2]) }
                BatchHashJoin { type: Inner, predicate: $3 = $4 }
                  BatchProject { exprs: [$0, $1, $4, $5], expr_alias: [ ,  ,  ,  ] }
                    BatchExchange { order: [], dist: HashShard([5]) }
                      BatchHashJoin { type: Inner, predicate: $2 = $3 }
                        BatchProject { exprs: [$2, $3, $5], expr_alias: [ ,  ,  ] }
                          BatchExchange { order: [], dist: HashShard([5]) }
                            BatchHashJoin { type: Inner, predicate: $1 = $4AND $0 = $5 }
                              BatchProject { exprs: [$0, $3, $4, $5], expr_alias: [ ,  ,  ,  ] }
                                BatchExchange { order: [], dist: HashShard([3, 0]) }
                                  BatchHashJoin { type: Inner, predicate: $1 = $2 }
                                    BatchProject { exprs: [$1, $2], expr_alias: [ ,  ] }
                                      BatchExchange { order: [], dist: HashShard([2]) }
                                        BatchHashJoin { type: Inner, predicate: $0 = $3 }
                                          BatchExchange { order: [], dist: HashShard([0]) }
                                            BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                                          BatchProject { exprs: [$0, $1], expr_alias: [ ,  ] }
                                            BatchExchange { order: [], dist: HashShard([1]) }
                                              BatchFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                                BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                                    BatchExchange { order: [], dist: HashShard([0]) }
                                      BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
                              BatchExchange { order: [], dist: HashShard([0, 1]) }
                                BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: nation, columns: [n_nationkey, n_name, n_regionkey] }
                  BatchProject { exprs: [$0], expr_alias: [ ] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($1 = 'MIDDLE EAST':Varchar) }
                        BatchScan { table: region, columns: [r_regionkey, r_name] }
  stream_plan: |
    StreamMaterialize { columns: [n_name, revenue], pk_columns: [revenue, n_name] }
      StreamProject { exprs: [$0, $2], expr_alias: [n_name, revenue] }
        StreamHashAgg { group_keys: [$0], aggs: [count, sum($1)] }
          StreamProject { exprs: [$2, ($0 * (1:Int32 - $1)), $4, $5, $6, $7, $8, $10], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ] }
            StreamExchange { dist: HashShard([2]) }
              StreamHashJoin { type: Inner, predicate: $3 = $9 }
                StreamProject { exprs: [$0, $1, $8, $9, $3, $4, $5, $6, $10], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ] }
                  StreamExchange { dist: HashShard([9]) }
                    StreamHashJoin { type: Inner, predicate: $2 = $7 }
                      StreamProject { exprs: [$2, $3, $8, $4, $5, $6, $9], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
                        StreamExchange { dist: HashShard([8]) }
                          StreamHashJoin { type: Inner, predicate: $1 = $7AND $0 = $8 }
                            StreamProject { exprs: [$0, $5, $6, $7, $2, $3, $8], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
                              StreamExchange { dist: HashShard([5, 0]) }
                                StreamHashJoin { type: Inner, predicate: $1 = $4 }
                                  StreamProject { exprs: [$1, $3, $2, $5], expr_alias: [ ,  ,  ,  ] }
                                    StreamExchange { dist: HashShard([3]) }
                                      StreamHashJoin { type: Inner, predicate: $0 = $4 }
                                        StreamExchange { dist: HashShard([0]) }
                                          StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id#0], pk_indices: [2] }
                                        StreamProject { exprs: [$0, $1, $3], expr_alias: [ ,  ,  ] }
                                          StreamExchange { dist: HashShard([1]) }
                                            StreamFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                              StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, _row_id#0], pk_indices: [3] }
                                  StreamExchange { dist: HashShard([0]) }
                                    StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id#0], pk_indices: [4] }
                            StreamExchange { dist: HashShard([0, 1]) }
                              StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id#0], pk_indices: [2] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: nation, columns: [n_nationkey, n_name, n_regionkey, _row_id#0], pk_indices: [3] }
                StreamProject { exprs: [$0, $2], expr_alias: [ ,  ] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($1 = 'MIDDLE EAST':Varchar) }
                      StreamTableScan { table: region, columns: [r_regionkey, r_name, _row_id#0], pk_indices: [2] }
- id: tpch_q6
  before:
    - create_tables
  sql: |
    select
      sum(l_extendedprice * l_discount) as revenue
    from
      lineitem
    where
      l_shipdate >= date '1994-01-01'
      and l_shipdate < date '1994-01-01' + interval '1' year
      and l_discount between 0.08 - 0.01 and 0.08 + 0.01
      and l_quantity < 24;
  batch_plan: |
    BatchProject { exprs: [$0], expr_alias: [revenue] }
      BatchSimpleAgg { aggs: [sum($0)] }
        BatchExchange { order: [], dist: Single }
          BatchProject { exprs: [($1 * $2)], expr_alias: [ ] }
            BatchFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($2 >= (0.08:Decimal - 0.01:Decimal)) AND ($2 <= (0.08:Decimal + 0.01:Decimal)) AND ($0 < 24:Int32) }
              BatchScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [revenue, agg#0(hidden)], pk_columns: [agg#0, revenue] }
      StreamProject { exprs: [$1, $0], expr_alias: [revenue,  ] }
        StreamSimpleAgg { aggs: [count, sum($0)] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [($1 * $2), $4], expr_alias: [ ,  ] }
              StreamFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($2 >= (0.08:Decimal - 0.01:Decimal)) AND ($2 <= (0.08:Decimal + 0.01:Decimal)) AND ($0 < 24:Int32) }
                StreamTableScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_shipdate, _row_id#0], pk_indices: [4] }
- id: tpch_q7
  before:
    - create_tables
  sql: |
    select
      supp_nation,
      cust_nation,
      l_year,
      sum(volume) as revenue
    from
      (
        select
          n1.n_name as supp_nation,
          n2.n_name as cust_nation,
          extract(year from l_shipdate) as l_year,
          l_extendedprice * (1 - l_discount) as volume
        from
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2
        where
          s_suppkey = l_suppkey
          and o_orderkey = l_orderkey
          and c_custkey = o_custkey
          and s_nationkey = n1.n_nationkey
          and c_nationkey = n2.n_nationkey
          and (
            (n1.n_name = 'ROMANIA' and n2.n_name = 'IRAN')
            or (n1.n_name = 'IRAN' and n2.n_name = 'ROMANIA')
          )
          and l_shipdate between date '1983-01-01' and date '2000-12-31'
      ) as shipping
    group by
      supp_nation,
      cust_nation,
      l_year
    order by
      supp_nation,
      cust_nation,
      l_year;
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 ASC, $2 ASC], dist: Single }
      BatchSort { order: [$0 ASC, $1 ASC, $2 ASC] }
        BatchProject { exprs: [$0, $1, $2, $3], expr_alias: [supp_nation, cust_nation, l_year, revenue] }
          BatchHashAgg { group_keys: [$0, $1, $2], aggs: [sum($3)] }
            BatchExchange { order: [], dist: HashShard([0, 1, 2]) }
              BatchProject { exprs: [$4, $6, Extract('YEAR':Varchar, $2), ($0 * (1:Int32 - $1))], expr_alias: [ ,  ,  ,  ] }
                BatchFilter { predicate: ((($4 = 'ROMANIA':Varchar) AND ($6 = 'IRAN':Varchar)) OR (($4 = 'IRAN':Varchar) AND ($6 = 'ROMANIA':Varchar))) }
                  BatchHashJoin { type: Inner, predicate: $3 = $5 }
                    BatchProject { exprs: [$1, $2, $3, $4, $6], expr_alias: [ ,  ,  ,  ,  ] }
                      BatchExchange { order: [], dist: HashShard([4]) }
                        BatchHashJoin { type: Inner, predicate: $0 = $5 }
                          BatchProject { exprs: [$0, $1, $2, $3, $6], expr_alias: [ ,  ,  ,  ,  ] }
                            BatchExchange { order: [], dist: HashShard([0]) }
                              BatchHashJoin { type: Inner, predicate: $4 = $5 }
                                BatchProject { exprs: [$0, $2, $3, $4, $6], expr_alias: [ ,  ,  ,  ,  ] }
                                  BatchExchange { order: [], dist: HashShard([6]) }
                                    BatchHashJoin { type: Inner, predicate: $1 = $5 }
                                      BatchProject { exprs: [$1, $2, $4, $5, $6], expr_alias: [ ,  ,  ,  ,  ] }
                                        BatchExchange { order: [], dist: HashShard([2]) }
                                          BatchHashJoin { type: Inner, predicate: $0 = $3 }
                                            BatchExchange { order: [], dist: HashShard([0]) }
                                              BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                                            BatchExchange { order: [], dist: HashShard([1]) }
                                              BatchFilter { predicate: ($4 >= '1983-01-01':Varchar::Date) AND ($4 <= '2000-12-31':Varchar::Date) }
                                                BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate] }
                                      BatchExchange { order: [], dist: HashShard([0]) }
                                        BatchScan { table: orders, columns: [o_orderkey, o_custkey] }
                                BatchExchange { order: [], dist: HashShard([0]) }
                                  BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: nation, columns: [n_nationkey, n_name] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchScan { table: nation, columns: [n_nationkey, n_name] }
  stream_plan: |
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], pk_columns: [supp_nation, cust_nation, l_year] }
      StreamProject { exprs: [$0, $1, $2, $4], expr_alias: [supp_nation, cust_nation, l_year, revenue] }
        StreamHashAgg { group_keys: [$0, $1, $2], aggs: [count, sum($3)] }
          StreamExchange { dist: HashShard([0, 1, 2]) }
            StreamProject { exprs: [$4, $11, Extract('YEAR':Varchar, $2), ($0 * (1:Int32 - $1)), $5, $6, $7, $8, $9, $12], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
              StreamFilter { predicate: ((($4 = 'ROMANIA':Varchar) AND ($11 = 'IRAN':Varchar)) OR (($4 = 'IRAN':Varchar) AND ($11 = 'ROMANIA':Varchar))) }
                StreamHashJoin { type: Inner, predicate: $3 = $10 }
                  StreamProject { exprs: [$1, $2, $3, $4, $10, $5, $6, $7, $8, $11], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
                    StreamExchange { dist: HashShard([4]) }
                      StreamHashJoin { type: Inner, predicate: $0 = $9 }
                        StreamProject { exprs: [$0, $1, $2, $3, $9, $5, $6, $7, $10], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamHashJoin { type: Inner, predicate: $4 = $8 }
                              StreamProject { exprs: [$0, $2, $3, $4, $8, $5, $6, $9], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ] }
                                StreamExchange { dist: HashShard([8]) }
                                  StreamHashJoin { type: Inner, predicate: $1 = $7 }
                                    StreamProject { exprs: [$1, $3, $5, $6, $7, $2, $8], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
                                      StreamExchange { dist: HashShard([3]) }
                                        StreamHashJoin { type: Inner, predicate: $0 = $4 }
                                          StreamExchange { dist: HashShard([0]) }
                                            StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id#0], pk_indices: [2] }
                                          StreamExchange { dist: HashShard([1]) }
                                            StreamFilter { predicate: ($4 >= '1983-01-01':Varchar::Date) AND ($4 <= '2000-12-31':Varchar::Date) }
                                              StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate, _row_id#0], pk_indices: [5] }
                                    StreamExchange { dist: HashShard([0]) }
                                      StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, _row_id#0], pk_indices: [2] }
                              StreamExchange { dist: HashShard([0]) }
                                StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id#0], pk_indices: [2] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id#0], pk_indices: [2] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id#0], pk_indices: [2] }
- id: tpch_q8
  before:
    - create_tables
  sql: |
    select
      o_year,
      round(sum(case
        when nation = 'IRAN' then volume
        else 0
      end) / sum(volume), 6) as mkt_share
    from
      (
        select
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) as volume,
          n2.n_name as nation
        from
          part,
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2,
          region
        where
          p_partkey = l_partkey
          and s_suppkey = l_suppkey
          and l_orderkey = o_orderkey
          and o_custkey = c_custkey
          and c_nationkey = n1.n_nationkey
          and n1.n_regionkey = r_regionkey
          and r_name = 'ASIA'
          and s_nationkey = n2.n_nationkey
          and o_orderdate between date '1995-01-01' and date '1996-12-31'
          and p_type = 'PROMO ANODIZED STEEL'
      ) as all_nations
    group by
      o_year
    order by
      o_year;
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, RoundDigit(($1 / $2), 6:Int32)], expr_alias: [o_year, mkt_share] }
      LogicalAgg { group_keys: [0], agg_calls: [sum($1), sum($2)] }
        LogicalProject { exprs: [Extract('YEAR':Varchar, $2), Case(($4 = 'IRAN':Varchar), ($0 * (1:Int32 - $1)), 0:Int32::Decimal), ($0 * (1:Int32 - $1))], expr_alias: [ ,  ,  ] }
          LogicalJoin { type: Inner, on: ($3 = $5) }
            LogicalProject { exprs: [$1, $2, $3, $4, $6], expr_alias: [ ,  ,  ,  ,  ] }
              LogicalJoin { type: Inner, on: ($0 = $5) }
                LogicalProject { exprs: [$0, $1, $2, $3, $6], expr_alias: [ ,  ,  ,  ,  ] }
                  LogicalJoin { type: Inner, on: ($4 = $5) }
                    LogicalProject { exprs: [$0, $1, $2, $4, $6], expr_alias: [ ,  ,  ,  ,  ] }
                      LogicalJoin { type: Inner, on: ($3 = $5) }
                        LogicalProject { exprs: [$0, $2, $3, $5, $6], expr_alias: [ ,  ,  ,  ,  ] }
                          LogicalJoin { type: Inner, on: ($1 = $4) }
                            LogicalProject { exprs: [$2, $3, $6, $7], expr_alias: [ ,  ,  ,  ] }
                              LogicalJoin { type: Inner, on: ($0 = $4) AND ($1 = $5) }
                                LogicalJoin { type: Inner, on: always }
                                  LogicalProject { exprs: [$0], expr_alias: [ ] }
                                    LogicalFilter { predicate: ($1 = 'PROMO ANODIZED STEEL':Varchar) }
                                      LogicalScan { table: part, columns: [p_partkey, p_type] }
                                  LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                                LogicalScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount] }
                            LogicalFilter { predicate: ($2 >= '1995-01-01':Varchar::Date) AND ($2 <= '1996-12-31':Varchar::Date) }
                              LogicalScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                        LogicalScan { table: customer, columns: [c_custkey, c_nationkey] }
                    LogicalScan { table: nation, columns: [n_nationkey, n_regionkey] }
                LogicalScan { table: nation, columns: [n_nationkey, n_name] }
            LogicalProject { exprs: [$0], expr_alias: [ ] }
              LogicalFilter { predicate: ($1 = 'ASIA':Varchar) }
                LogicalScan { table: region, columns: [r_regionkey, r_name] }
- id: tpch_q9
  before:
    - create_tables
  sql: |
    select
      nation,
      o_year,
      round(sum(amount), 2) as sum_profit
    from
      (
        select
          n_name as nation,
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
          part,
          supplier,
          lineitem,
          partsupp,
          orders,
          nation
        where
          s_suppkey = l_suppkey
          and ps_suppkey = l_suppkey
          and ps_partkey = l_partkey
          and p_partkey = l_partkey
          and o_orderkey = l_orderkey
          and s_nationkey = n_nationkey
          and p_name like '%yellow%'
      ) as profit
    group by
      nation,
      o_year
    order by
      nation,
      o_year desc;
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, $1, RoundDigit($2, 2:Int32)], expr_alias: [nation, o_year, sum_profit] }
      LogicalAgg { group_keys: [0, 1], agg_calls: [sum($2)] }
        LogicalProject { exprs: [$7, Extract('YEAR':Varchar, $5), (($2 * (1:Int32 - $3)) - ($4 * $1))], expr_alias: [ ,  ,  ] }
          LogicalJoin { type: Inner, on: ($0 = $6) }
            LogicalProject { exprs: [$0, $2, $3, $4, $5, $7], expr_alias: [ ,  ,  ,  ,  ,  ] }
              LogicalJoin { type: Inner, on: ($6 = $1) }
                LogicalProject { exprs: [$0, $1, $4, $5, $6, $9], expr_alias: [ ,  ,  ,  ,  ,  ] }
                  LogicalJoin { type: Inner, on: ($8 = $3) AND ($7 = $2) }
                    LogicalProject { exprs: [$2, $3, $4, $5, $6, $7, $8], expr_alias: [ ,  ,  ,  ,  ,  ,  ] }
                      LogicalJoin { type: Inner, on: ($1 = $5) AND ($0 = $4) }
                        LogicalJoin { type: Inner, on: always }
                          LogicalProject { exprs: [$0], expr_alias: [ ] }
                            LogicalFilter { predicate: Like($1, '%yellow%':Varchar) }
                              LogicalScan { table: part, columns: [p_partkey, p_name] }
                          LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                        LogicalScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
                    LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
                LogicalScan { table: orders, columns: [o_orderkey, o_orderdate] }
            LogicalScan { table: nation, columns: [n_nationkey, n_name] }
- id: tpch_q10
  before:
    - create_tables
  sql: |
    select
      c_custkey,
      c_name,
      sum(l_extendedprice * (1.00 - l_discount)) as revenue,
      c_acctbal,
      n_name,
      c_address,
      c_phone,
      c_comment
    from
      customer,
      orders,
      lineitem,
      nation
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '3' month
      and l_returnflag = 'R'
      and c_nationkey = n_nationkey
    group by
      c_custkey,
      c_name,
      c_acctbal,
      c_phone,
      n_name,
      c_address,
      c_comment
    order by
      revenue desc
    limit 20;
  batch_plan: |
    BatchTopN { order: [$2 DESC], limit: 20, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [$0, $1, $7, $2, $4, $5, $3, $6], expr_alias: [c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment] }
          BatchHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6], aggs: [sum($7)] }
            BatchProject { exprs: [$0, $1, $5, $4, $10, $2, $6, ($7 * (1.00:Decimal - $8))], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ] }
              BatchExchange { order: [], dist: HashShard([0, 1, 5, 4, 10, 2, 6]) }
                BatchHashJoin { type: Inner, predicate: $3 = $9 }
                  BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $9, $10], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ] }
                    BatchExchange { order: [], dist: HashShard([3]) }
                      BatchHashJoin { type: Inner, predicate: $7 = $8 }
                        BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ] }
                          BatchExchange { order: [], dist: HashShard([7]) }
                            BatchHashJoin { type: Inner, predicate: $0 = $8 }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchScan { table: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment] }
                              BatchProject { exprs: [$0, $1], expr_alias: [ ,  ] }
                                BatchExchange { order: [], dist: HashShard([1]) }
                                  BatchFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                                    BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                        BatchProject { exprs: [$0, $1, $2], expr_alias: [ ,  ,  ] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchFilter { predicate: ($3 = 'R':Varchar) }
                              BatchScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_returnflag] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: nation, columns: [n_nationkey, n_name] }
  stream_plan: |
    StreamMaterialize { columns: [c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment], pk_columns: [revenue, c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment] }
      StreamTopN { order: [$2 DESC, $0 ASC, $1 ASC, $3 ASC, $6 ASC, $4 ASC, $5 ASC, $7 ASC], limit: 20, offset: 0 }
        StreamExchange { dist: Single }
          StreamProject { exprs: [$0, $1, $8, $2, $4, $5, $3, $6], expr_alias: [c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment] }
            StreamHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6], aggs: [count, sum($7)] }
              StreamProject { exprs: [$0, $1, $5, $4, $13, $2, $6, ($7 * (1.00:Decimal - $8)), $9, $10, $11, $14], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
                StreamExchange { dist: HashShard([0, 1, 5, 4, 13, 2, 6]) }
                  StreamHashJoin { type: Inner, predicate: $3 = $12 }
                    StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $11, $12, $8, $9, $13], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
                      StreamExchange { dist: HashShard([3]) }
                        StreamHashJoin { type: Inner, predicate: $7 = $10 }
                          StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $8, $7, $10], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
                            StreamExchange { dist: HashShard([8]) }
                              StreamHashJoin { type: Inner, predicate: $0 = $9 }
                                StreamExchange { dist: HashShard([0]) }
                                  StreamTableScan { table: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, _row_id#0], pk_indices: [7] }
                                StreamProject { exprs: [$0, $1, $3], expr_alias: [ ,  ,  ] }
                                  StreamExchange { dist: HashShard([1]) }
                                    StreamFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                                      StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, _row_id#0], pk_indices: [3] }
                          StreamProject { exprs: [$0, $1, $2, $4], expr_alias: [ ,  ,  ,  ] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamFilter { predicate: ($3 = 'R':Varchar) }
                                StreamTableScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_returnflag, _row_id#0], pk_indices: [4] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id#0], pk_indices: [2] }
- id: tpch_q12
  before:
    - create_tables
  sql: |
    select
        l_shipmode,
        sum(case
            when o_orderpriority = '1-URGENT'
                or o_orderpriority = '2-HIGH'
                then 1
            else 0
        end) as high_line_count,
        sum(case
            when o_orderpriority <> '1-URGENT'
                and o_orderpriority <> '2-HIGH'
                then 1
            else 0
        end) as low_line_count
    from
        orders,
        lineitem
    where
        o_orderkey = l_orderkey
        and l_shipmode in ('FOB', 'SHIP')
        and l_commitdate < l_receiptdate
        and l_shipdate < l_commitdate
        and l_receiptdate >= date '1994-01-01'
        and l_receiptdate < date '1994-01-01' + interval '1' year
    group by
        l_shipmode
    order by
        l_shipmode;
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchProject { exprs: [$0, $1, $2], expr_alias: [l_shipmode, high_line_count, low_line_count] }
          BatchHashAgg { group_keys: [$0], aggs: [sum($1), sum($2)] }
            BatchProject { exprs: [$3, Case((($1 = '1-URGENT':Varchar) OR ($1 = '2-HIGH':Varchar)), 1:Int32, 0:Int32), Case((($1 <> '1-URGENT':Varchar) AND ($1 <> '2-HIGH':Varchar)), 1:Int32, 0:Int32)], expr_alias: [ ,  ,  ] }
              BatchExchange { order: [], dist: HashShard([3]) }
                BatchHashJoin { type: Inner, predicate: $0 = $2 }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: orders, columns: [o_orderkey, o_orderpriority] }
                  BatchProject { exprs: [$0, $4], expr_alias: [ ,  ] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: In($4, 'FOB':Varchar, 'SHIP':Varchar) AND ($2 < $3) AND ($1 < $2) AND ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                        BatchScan { table: lineitem, columns: [l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode] }
  stream_plan: |
    StreamMaterialize { columns: [l_shipmode, high_line_count, low_line_count], pk_columns: [l_shipmode] }
      StreamProject { exprs: [$0, $2, $3], expr_alias: [l_shipmode, high_line_count, low_line_count] }
        StreamHashAgg { group_keys: [$0], aggs: [count, sum($1), sum($2)] }
          StreamProject { exprs: [$4, Case((($1 = '1-URGENT':Varchar) OR ($1 = '2-HIGH':Varchar)), 1:Int32, 0:Int32), Case((($1 <> '1-URGENT':Varchar) AND ($1 <> '2-HIGH':Varchar)), 1:Int32, 0:Int32), $2, $5], expr_alias: [ ,  ,  ,  ,  ] }
            StreamExchange { dist: HashShard([4]) }
              StreamHashJoin { type: Inner, predicate: $0 = $3 }
                StreamExchange { dist: HashShard([0]) }
                  StreamTableScan { table: orders, columns: [o_orderkey, o_orderpriority, _row_id#0], pk_indices: [2] }
                StreamProject { exprs: [$0, $4, $5], expr_alias: [ ,  ,  ] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: In($4, 'FOB':Varchar, 'SHIP':Varchar) AND ($2 < $3) AND ($1 < $2) AND ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                      StreamTableScan { table: lineitem, columns: [l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode, _row_id#0], pk_indices: [5] }
- id: tpch_q13
  before:
    - create_tables
  sql: |
    select
      c_count,
      count(*) as custdist
    from
      (
        select
          c_custkey,
          count(o_orderkey) as c_count
        from
          customer left outer join orders on
            c_custkey = o_custkey
            and o_comment not like '%:1%:2%'
        group by
          c_custkey
      ) as c_orders (c_custkey, c_count)
    group by
      c_count
    order by
      custdist desc,
      c_count desc;
  batch_plan: |
    BatchExchange { order: [$1 DESC, $0 DESC], dist: Single }
      BatchSort { order: [$1 DESC, $0 DESC] }
        BatchProject { exprs: [$0, $1], expr_alias: [c_count, custdist] }
          BatchHashAgg { group_keys: [$0], aggs: [count] }
            BatchProject { exprs: [$1], expr_alias: [ ] }
              BatchExchange { order: [], dist: HashShard([1]) }
                BatchHashAgg { group_keys: [$0], aggs: [count($1)] }
                  BatchProject { exprs: [$0, $1], expr_alias: [ ,  ] }
                    BatchHashJoin { type: LeftOuter, predicate: $0 = $2AND Not(Like($3, '%:1%:2%':Varchar)) }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: customer, columns: [c_custkey] }
                      BatchExchange { order: [], dist: HashShard([1]) }
                        BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_comment] }
  stream_plan: |
    StreamMaterialize { columns: [c_count, custdist], pk_columns: [custdist, c_count] }
      StreamProject { exprs: [$0, $2], expr_alias: [c_count, custdist] }
        StreamHashAgg { group_keys: [$0], aggs: [count, count] }
          StreamProject { exprs: [$2, $0], expr_alias: [ ,  ] }
            StreamExchange { dist: HashShard([2]) }
              StreamHashAgg { group_keys: [$0], aggs: [count, count($1)] }
                StreamProject { exprs: [$0, $2, $1, $5], expr_alias: [ ,  ,  ,  ] }
                  StreamHashJoin { type: LeftOuter, predicate: $0 = $3AND Not(Like($4, '%:1%:2%':Varchar)) }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: customer, columns: [c_custkey, _row_id#0], pk_indices: [1] }
                    StreamExchange { dist: HashShard([1]) }
                      StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_comment, _row_id#0], pk_indices: [3] }
- id: tpch_q14
  before:
    - create_tables
  sql: |
    select
      100.00 * sum(case
        when p_type like 'PROMO%'
          then l_extendedprice * (1 - l_discount)
        else 0
      end) / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
    from
      lineitem,
      part
    where
      l_partkey = p_partkey
      and l_shipdate >= date '1995-09-01'
      and l_shipdate < date '1995-09-01' + interval '1' month;
  batch_plan: |
    BatchProject { exprs: [((100.00:Decimal * $0) / $1)], expr_alias: [promo_revenue] }
      BatchSimpleAgg { aggs: [sum($0), sum($1)] }
        BatchExchange { order: [], dist: Single }
          BatchProject { exprs: [Case(Like($4, 'PROMO%':Varchar), ($1 * (1:Int32 - $2)), 0:Int32::Decimal), ($1 * (1:Int32 - $2))], expr_alias: [ ,  ] }
            BatchHashJoin { type: Inner, predicate: $0 = $3 }
              BatchProject { exprs: [$0, $1, $2], expr_alias: [ ,  ,  ] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchFilter { predicate: ($3 >= '1995-09-01':Varchar::Date) AND ($3 < ('1995-09-01':Varchar::Date + '1 mon 00:00:00':Interval)) }
                    BatchScan { table: lineitem, columns: [l_partkey, l_extendedprice, l_discount, l_shipdate] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchScan { table: part, columns: [p_partkey, p_type] }
  stream_plan: |
    StreamMaterialize { columns: [promo_revenue, agg#0(hidden), agg#1(hidden), agg#2(hidden)], pk_columns: [agg#0, agg#1, agg#2] }
      StreamProject { exprs: [((100.00:Decimal * $1) / $2), $0, $1, $2], expr_alias: [promo_revenue,  ,  ,  ] }
        StreamSimpleAgg { aggs: [count, sum($0), sum($1)] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [Case(Like($5, 'PROMO%':Varchar), ($1 * (1:Int32 - $2)), 0:Int32::Decimal), ($1 * (1:Int32 - $2)), $3, $6], expr_alias: [ ,  ,  ,  ] }
              StreamHashJoin { type: Inner, predicate: $0 = $4 }
                StreamProject { exprs: [$0, $1, $2, $4], expr_alias: [ ,  ,  ,  ] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($3 >= '1995-09-01':Varchar::Date) AND ($3 < ('1995-09-01':Varchar::Date + '1 mon 00:00:00':Interval)) }
                      StreamTableScan { table: lineitem, columns: [l_partkey, l_extendedprice, l_discount, l_shipdate, _row_id#0], pk_indices: [4] }
                StreamExchange { dist: HashShard([0]) }
                  StreamTableScan { table: part, columns: [p_partkey, p_type, _row_id#0], pk_indices: [2] }
- id: tpch_q15
  before:
    - create_tables
  sql: |
    select
      s_suppkey,
      s_name,
      s_address,
      s_phone,
      total_revenue
    from
      supplier,
      (
        select
        l_suppkey,
        sum(l_extendedprice * (1 - l_discount)) as total_revenue
      from
        lineitem
      where
        l_shipdate >= date '1993-01-01'
        and l_shipdate < date '1993-01-01' + interval '3' month
      group by
        l_suppkey
      ) as revenue0 (supplier_no, total_revenue)
    where
      s_suppkey = supplier_no
      and total_revenue = (
        select
          max(total_revenue) as max_revenue
        from
          (
            select
            l_suppkey,
            sum(l_extendedprice * (1 - l_discount)) as total_revenue
          from
            lineitem
          where
            l_shipdate >= date '1993-01-01'
            and l_shipdate < date '1993-01-01' + interval '3' month
          group by
            l_suppkey
          ) as revenue0 (supplier_no, total_revenue)
      )
    order by
      s_suppkey;
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, $1, $2, $3, $4], expr_alias: [s_suppkey, s_name, s_address, s_phone, total_revenue] }
      LogicalFilter { predicate: ($4 = $5) }
        LogicalJoin { type: LeftOuter, on: always }
          LogicalProject { exprs: [$0, $1, $2, $3, $5], expr_alias: [ ,  ,  ,  ,  ] }
            LogicalJoin { type: Inner, on: ($0 = $4) }
              LogicalScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_phone] }
              LogicalProject { exprs: [$0, $1], expr_alias: [l_suppkey, total_revenue] }
                LogicalAgg { group_keys: [0], agg_calls: [sum($1)] }
                  LogicalProject { exprs: [$0, ($1 * (1:Int32 - $2))], expr_alias: [ ,  ] }
                    LogicalFilter { predicate: ($3 >= '1993-01-01':Varchar::Date) AND ($3 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                      LogicalScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, l_shipdate] }
          LogicalProject { exprs: [$0], expr_alias: [max_revenue] }
            LogicalAgg { group_keys: [], agg_calls: [max($0)] }
              LogicalProject { exprs: [$1], expr_alias: [ ] }
                LogicalAgg { group_keys: [0], agg_calls: [sum($1)] }
                  LogicalProject { exprs: [$0, ($1 * (1:Int32 - $2))], expr_alias: [ ,  ] }
                    LogicalFilter { predicate: ($3 >= '1993-01-01':Varchar::Date) AND ($3 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                      LogicalScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, l_shipdate] }
- id: tpch_q17
  before:
    - create_tables
  sql: |
    select
      ROUND(sum(l_extendedprice) / 7.0, 16) as avg_yearly
    from
      lineitem,
      part
    where
      p_partkey = l_partkey
      and p_brand = 'Brand#13'
      and p_container = 'JUMBO PKG'
      and l_quantity < (
        select
          0.2 * avg(l_quantity)
        from
          lineitem
        where
          l_partkey = p_partkey
      );
  batch_plan: |
    BatchProject { exprs: [RoundDigit(($0 / 7.0:Decimal), 16:Int32)], expr_alias: [avg_yearly] }
      BatchSimpleAgg { aggs: [sum($0)] }
        BatchExchange { order: [], dist: Single }
          BatchProject { exprs: [$1], expr_alias: [ ] }
            BatchFilter { predicate: ($0 < (0.2:Decimal * ($2 / $3))) }
              BatchProject { exprs: [$5, $6, $27, $28], expr_alias: [ ,  ,  ,  ] }
                BatchHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26], aggs: [sum($27), count($27)] }
                  BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
                    BatchExchange { order: [], dist: HashShard([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]) }
                      BatchHashJoin { type: LeftOuter, predicate: $18 = $28 }
                        BatchExchange { order: [], dist: HashShard([18]) }
                          BatchHashJoin { type: Inner, predicate: $2 = $18 }
                            BatchExchange { order: [], dist: HashShard([2]) }
                              BatchScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                            BatchExchange { order: [], dist: HashShard([1]) }
                              BatchFilter { predicate: ($4 = 'Brand#13':Varchar) AND ($7 = 'JUMBO PKG':Varchar) }
                                BatchScan { table: part, columns: [_row_id#0, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                        BatchProject { exprs: [$1, $0], expr_alias: [ ,  ] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: lineitem, columns: [l_partkey, l_quantity] }
  stream_plan: |
    StreamMaterialize { columns: [avg_yearly, agg#0(hidden), agg#1(hidden)], pk_columns: [agg#0, agg#1] }
      StreamProject { exprs: [RoundDigit(($1 / 7.0:Decimal), 16:Int32), $0, $1], expr_alias: [avg_yearly,  ,  ] }
        StreamSimpleAgg { aggs: [count, sum($0)] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [$1, $4, $5, $6, $7, $8, $0, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
              StreamFilter { predicate: ($0 < (0.2:Decimal * ($2 / $3))) }
                StreamProject { exprs: [$5, $6, $28, $29, $0, $1, $2, $3, $4, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
                  StreamHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26], aggs: [count, sum($27), count($27)] }
                    StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $29], expr_alias: [ ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ] }
                      StreamExchange { dist: HashShard([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]) }
                        StreamHashJoin { type: LeftOuter, predicate: $18 = $28 }
                          StreamExchange { dist: HashShard([18]) }
                            StreamHashJoin { type: Inner, predicate: $2 = $18 }
                              StreamExchange { dist: HashShard([2]) }
                                StreamTableScan { table: lineitem, columns: [_row_id#0, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment], pk_indices: [0] }
                              StreamExchange { dist: HashShard([1]) }
                                StreamFilter { predicate: ($4 = 'Brand#13':Varchar) AND ($7 = 'JUMBO PKG':Varchar) }
                                  StreamTableScan { table: part, columns: [_row_id#0, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment], pk_indices: [0] }
                          StreamProject { exprs: [$1, $0, $2], expr_alias: [ ,  ,  ] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamTableScan { table: lineitem, columns: [l_partkey, l_quantity, _row_id#0], pk_indices: [2] }
- id: tpch_q18
  before:
    - create_tables
  sql: |
    select
      c_name,
      c_custkey,
      o_orderkey,
      o_orderdate,
      o_totalprice,
      sum(l_quantity) quantity
    from
      customer,
      orders,
      lineitem
    where
      o_orderkey in (
        select
          l_orderkey
        from
          lineitem
        group by
          l_orderkey having
            sum(l_quantity) > 1
      )
      and c_custkey = o_custkey
      and o_orderkey = l_orderkey
    group by
      c_name,
      c_custkey,
      o_orderkey,
      o_orderdate,
      o_totalprice
    order by
      o_totalprice desc,
      o_orderdate
    LIMIT 100;
  binder_error: 'Feature is not yet implemented: unsupported expression InSubquery { expr: Identifier(Ident { value: "o_orderkey", quote_style: None }), subquery: Query { with: None, body: Select(Select { distinct: false, projection: [UnnamedExpr(Identifier(Ident { value: "l_orderkey", quote_style: None }))], from: [TableWithJoins { relation: Table { name: ObjectName([Ident { value: "lineitem", quote_style: None }]), alias: None, args: [] }, joins: [] }], lateral_views: [], selection: None, group_by: [Identifier(Ident { value: "l_orderkey", quote_style: None })], having: Some(BinaryOp { left: Function(Function { name: ObjectName([Ident { value: "sum", quote_style: None }]), args: [Unnamed(Expr(Identifier(Ident { value: "l_quantity", quote_style: None })))], over: None, distinct: false }), op: Gt, right: Value(Number("1", false)) }) }), order_by: [], limit: None, offset: None, fetch: None }, negated: false }, Tracking issue: https://github.com/singularity-data/risingwave/issues/112'
- id: tpch_q19
  before:
    - create_tables
  sql: |
    select
      sum(l_extendedprice* (1 - l_discount)) as revenue
    from
      lineitem,
      part
    where
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#52'
        and p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
        and l_quantity >= 1 and l_quantity <= 11
        and p_size between 1 and 5
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      )
      or
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#24'
        and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
        and l_quantity >= 30 and l_quantity <= 40
        and p_size between 1 and 10
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      )
      or
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#32'
        and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
        and l_quantity >= 10 and l_quantity <= 20
        and p_size between 1 and 15
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      );
  batch_plan: |
    BatchProject { exprs: [$0], expr_alias: [revenue] }
      BatchSimpleAgg { aggs: [sum($0)] }
        BatchExchange { order: [], dist: Single }
          BatchProject { exprs: [($2 * (1:Int32 - $3))], expr_alias: [ ] }
            BatchFilter { predicate: ((((((($5 = 'Brand#52':Varchar) AND In($7, 'SM CASE':Varchar, 'SM BOX':Varchar, 'SM PACK':Varchar, 'SM PKG':Varchar)) AND ($1 >= 1:Int32)) AND ($1 <= 11:Int32)) AND ($6 <= 5:Int32)) OR ((((($5 = 'Brand#24':Varchar) AND In($7, 'MED BAG':Varchar, 'MED BOX':Varchar, 'MED PKG':Varchar, 'MED PACK':Varchar)) AND ($1 >= 30:Int32)) AND ($1 <= 40:Int32)) AND ($6 <= 10:Int32))) OR ((((($5 = 'Brand#32':Varchar) AND In($7, 'LG CASE':Varchar, 'LG BOX':Varchar, 'LG PACK':Varchar, 'LG PKG':Varchar)) AND ($1 >= 10:Int32)) AND ($1 <= 20:Int32)) AND ($6 <= 15:Int32))) }
              BatchHashJoin { type: Inner, predicate: $0 = $4 }
                BatchProject { exprs: [$0, $1, $2, $3], expr_alias: [ ,  ,  ,  ] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchFilter { predicate: In($5, 'AIR':Varchar, 'AIR REG':Varchar) AND ($4 = 'DELIVER IN PERSON':Varchar) }
                      BatchScan { table: lineitem, columns: [l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchFilter { predicate: ($2 >= 1:Int32) }
                    BatchScan { table: part, columns: [p_partkey, p_brand, p_size, p_container] }
  stream_plan: |
    StreamMaterialize { columns: [revenue, agg#0(hidden)], pk_columns: [agg#0, revenue] }
      StreamProject { exprs: [$1, $0], expr_alias: [revenue,  ] }
        StreamSimpleAgg { aggs: [count, sum($0)] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [($2 * (1:Int32 - $3)), $4, $9], expr_alias: [ ,  ,  ] }
              StreamFilter { predicate: ((((((($6 = 'Brand#52':Varchar) AND In($8, 'SM CASE':Varchar, 'SM BOX':Varchar, 'SM PACK':Varchar, 'SM PKG':Varchar)) AND ($1 >= 1:Int32)) AND ($1 <= 11:Int32)) AND ($7 <= 5:Int32)) OR ((((($6 = 'Brand#24':Varchar) AND In($8, 'MED BAG':Varchar, 'MED BOX':Varchar, 'MED PKG':Varchar, 'MED PACK':Varchar)) AND ($1 >= 30:Int32)) AND ($1 <= 40:Int32)) AND ($7 <= 10:Int32))) OR ((((($6 = 'Brand#32':Varchar) AND In($8, 'LG CASE':Varchar, 'LG BOX':Varchar, 'LG PACK':Varchar, 'LG PKG':Varchar)) AND ($1 >= 10:Int32)) AND ($1 <= 20:Int32)) AND ($7 <= 15:Int32))) }
                StreamHashJoin { type: Inner, predicate: $0 = $5 }
                  StreamProject { exprs: [$0, $1, $2, $3, $6], expr_alias: [ ,  ,  ,  ,  ] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamFilter { predicate: In($5, 'AIR':Varchar, 'AIR REG':Varchar) AND ($4 = 'DELIVER IN PERSON':Varchar) }
                        StreamTableScan { table: lineitem, columns: [l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode, _row_id#0], pk_indices: [6] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($2 >= 1:Int32) }
                      StreamTableScan { table: part, columns: [p_partkey, p_brand, p_size, p_container, _row_id#0], pk_indices: [4] }
- id: tpch_q20
  before:
    - create_tables
  sql: |
    select
      s_name,
      s_address
    from
      supplier,
      nation
    where
      s_suppkey in (
        select
          ps_suppkey
        from
          partsupp
        where
          ps_partkey in (
            select
              p_partkey
            from
              part
            where
              p_name like 'forest%'
          )
          and ps_availqty > (
            select
              0.5 * sum(l_quantity)
            from
              lineitem
            where
              l_partkey = ps_partkey
              and l_suppkey = ps_suppkey
              and l_shipdate >= date '1994-01-01'
              and l_shipdate < date '1994-01-01' + interval '1' year
          )
      )
      and s_nationkey = n_nationkey
      and n_name = 'KENYA'
    order by
      s_name;
  binder_error: 'Feature is not yet implemented: unsupported expression InSubquery { expr: Identifier(Ident { value: "s_suppkey", quote_style: None }), subquery: Query { with: None, body: Select(Select { distinct: false, projection: [UnnamedExpr(Identifier(Ident { value: "ps_suppkey", quote_style: None }))], from: [TableWithJoins { relation: Table { name: ObjectName([Ident { value: "partsupp", quote_style: None }]), alias: None, args: [] }, joins: [] }], lateral_views: [], selection: Some(BinaryOp { left: InSubquery { expr: Identifier(Ident { value: "ps_partkey", quote_style: None }), subquery: Query { with: None, body: Select(Select { distinct: false, projection: [UnnamedExpr(Identifier(Ident { value: "p_partkey", quote_style: None }))], from: [TableWithJoins { relation: Table { name: ObjectName([Ident { value: "part", quote_style: None }]), alias: None, args: [] }, joins: [] }], lateral_views: [], selection: Some(BinaryOp { left: Identifier(Ident { value: "p_name", quote_style: None }), op: Like, right: Value(SingleQuotedString("forest%")) }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, negated: false }, op: And, right: BinaryOp { left: Identifier(Ident { value: "ps_availqty", quote_style: None }), op: Gt, right: Subquery(Query { with: None, body: Select(Select { distinct: false, projection: [UnnamedExpr(BinaryOp { left: Value(Number("0.5", false)), op: Multiply, right: Function(Function { name: ObjectName([Ident { value: "sum", quote_style: None }]), args: [Unnamed(Expr(Identifier(Ident { value: "l_quantity", quote_style: None })))], over: None, distinct: false }) })], from: [TableWithJoins { relation: Table { name: ObjectName([Ident { value: "lineitem", quote_style: None }]), alias: None, args: [] }, joins: [] }], lateral_views: [], selection: Some(BinaryOp { left: BinaryOp { left: BinaryOp { left: BinaryOp { left: Identifier(Ident { value: "l_partkey", quote_style: None }), op: Eq, right: Identifier(Ident { value: "ps_partkey", quote_style: None }) }, op: And, right: BinaryOp { left: Identifier(Ident { value: "l_suppkey", quote_style: None }), op: Eq, right: Identifier(Ident { value: "ps_suppkey", quote_style: None }) } }, op: And, right: BinaryOp { left: Identifier(Ident { value: "l_shipdate", quote_style: None }), op: GtEq, right: TypedString { data_type: Date, value: "1994-01-01" } } }, op: And, right: BinaryOp { left: Identifier(Ident { value: "l_shipdate", quote_style: None }), op: Lt, right: BinaryOp { left: TypedString { data_type: Date, value: "1994-01-01" }, op: Plus, right: Value(Interval { value: "1", leading_field: Some(Year), leading_precision: None, last_field: None, fractional_seconds_precision: None }) } } }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }) } }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, negated: false }, Tracking issue: https://github.com/singularity-data/risingwave/issues/112'
